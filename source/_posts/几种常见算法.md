---
title: 几种常见算法
date: 2017-06-09 11:02:24
categories: 学习
tags: [排序,算法]
comments: true
---

## 排序
1、插入排序
在要排序的一组数中，假设前面(n-1) [n>=2] 个数已经是排好顺序的，现在要把第n个数插到前面的有序数中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。
<!--more-->
```
if(arr == null || arr.length < 2){
    return arr;
}
for(int i=1;i<arr.length;i++){
    for(intj=i;j>0;j--){
        if(arr[j]<arr[j-1]){
            int temp=arr[j];
            arr[j]=arr[j-1];
            arr[j-1]=temp;
        }else{
            //接下来是无用功
            break;
        }
    }
}
return arr;
```

2、冒泡排序
在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。
```
int temp = 0;
for (int i = a.length - 1; i > 0; --i)
{
    for (int j = 0; j < i; ++j)
    {
        if (a[j + 1] < a[j])
        {
            temp = a[j];
            a[j] = a[j + 1];
            a[j + 1] = temp;
        }
    }
}
```

3、快速排序
快速排序是对冒泡排序的一种本质改进。它的基本思想是通过一趟扫描后，使得排序序列的长度能大幅度地减少。在冒泡排序中，一次扫描只能确保最大数值的数移到正确位置，而待排序序列的长度可能只减少1。快速排序通过一趟扫描，就能确保以某个数为基准点的左边各数都比它小，右边各数都比它大。然后又用同样的方法处理它左右两边的数，直到基准点的左右只有一个元素为止。
```
main()
{
    if(left >= right)/*如果左边索引大于或者等于右边的索引就代表已经整理完成一个组了*/
    {
        return ;
    }
    int i = left;
    int j = right;
    int key = a[left];

    while(i < j)                               /*控制在当组内寻找一遍*/
    {
        while(i < j && key <= a[j])
        /*而寻找结束的条件就是，1，找到一个小于或者大于key的数（大于或小于取决于你想升
        序还是降序）2，没有符合条件1的，并且i与j的大小没有反转*/ 
        {
            j--;/*向前寻找*/
        }

        a[i] = a[j];
        /*找到一个这样的数后就把它赋给前面的被拿走的i的值（如果第一次循环且key是
        a[left]，那么就是给key）*/

        while(i < j && key >= a[i])
        /*这是i在当组内向前寻找，同上，不过注意与key的大小关系停止循环和上面相反，
        因为排序思想是把数往两边扔，所以左右两边的数大小与key的关系相反*/
        {
            i++;
        }

        a[j] = a[i];        
    }

    a[i] = key;/*当在当组内找完一遍以后就把中间数key回归*/
    sort(a, left, i - 1);/*最后用同样的方式对分出来的左边的小组进行同上的做法*/
    sort(a, i + 1, right);/*用同样的方式对分出来的右边的小组进行同上的做法*/
    /*当然最后可能会出现很多分左右，直到每一组的i = j 为止*/
}
```

4、选择排序
在要排序的一组数中，选出最小的一个数与第一个位置的数交换；然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。
```
main()
{
int i,j,min,t;
for(i=0;i<n-1;i++)
{
    min=i;//查找最小值
    for(j=i+1;j<n;j++)
        if(a[min]>a[j])
        min=j;//交换

        if(min!=i)
        {
            t=a[min];
            a[min]=a[i];
            a[i]=t;
        }
    }
}
```

## 二分法
二分法查找只适用与已排序的数列。
思路：首先将值 x 与数组 v 的中间元素比较，如果 x 小于中间的元素，则将 end 值设为 中间元素-1，同理，若 x 大于中间元素，则将中间元素 + 1作为 start，再在 start 与 end 之间进行查找。
```
int start = 0;
int end = data.length-1;
int mid = (start+end)/2;//a
while(data[mid]!=aim&&end>start){
    if(data[mid]>aim){
        end = mid-1;
    }else if(data[mid]<aim){
        start = mid+1;
    }
    mid = (start+end)/2;
}
return (data[mid]!=aim)?-1:mid;
```

## 斐波那契数列
数列：1,1,2,3,5,8,13,21...  求第n项的值
```
int f1,f2,f,i,n;    
f1=f2=1;
if(n<=2)    
    printf("%d",1);    
else 
{                        //加上括号
    for(i=3;i<=n;i++)      
{   
f=f1+f2;         
f1=f2;   
f2=f;             
```



