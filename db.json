{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/yilia/source/main.b3331d.css","path":"main.b3331d.css","modified":1,"renderable":1},{"_id":"themes/yilia/source/slider.445162.js","path":"slider.445162.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/main.b3331d.js","path":"main.b3331d.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/mobile.8d90af.js","path":"mobile.8d90af.js","modified":1,"renderable":1},{"_id":"source/assets/blogImg/avatar.jpg","path":"assets/blogImg/avatar.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogImg/avatar1.jpg","path":"assets/blogImg/avatar1.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogImg/favicon.jpg","path":"assets/blogImg/favicon.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogImg/zhifubao.png","path":"assets/blogImg/zhifubao.png","modified":1,"renderable":0},{"_id":"source/assets/demo/bengji01.jpeg","path":"assets/demo/bengji01.jpeg","modified":1,"renderable":0},{"_id":"source/assets/demo/branch.png","path":"assets/demo/branch.png","modified":1,"renderable":0},{"_id":"source/assets/demo/braveGirl.jpeg","path":"assets/demo/braveGirl.jpeg","modified":1,"renderable":0},{"_id":"source/assets/demo/feilada01.jpeg","path":"assets/demo/feilada01.jpeg","modified":1,"renderable":0},{"_id":"source/assets/demo/head_icon.jpg","path":"assets/demo/head_icon.jpg","modified":1,"renderable":0},{"_id":"source/assets/demo/java_config.png","path":"assets/demo/java_config.png","modified":1,"renderable":0},{"_id":"source/assets/demo/qingxin1.jpg","path":"assets/demo/qingxin1.jpg","modified":1,"renderable":0},{"_id":"source/assets/demo/qingxin2.jpg","path":"assets/demo/qingxin2.jpg","modified":1,"renderable":0},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.3a9902.eot","path":"fonts/iconfont.3a9902.eot","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.6e162c.woff","path":"fonts/iconfont.6e162c.woff","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.9abe9f.svg","path":"fonts/iconfont.9abe9f.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.d0da7e.ttf","path":"fonts/iconfont.d0da7e.ttf","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/js/gitment-theme-default.css","path":"js/gitment-theme-default.css","modified":1,"renderable":1},{"_id":"themes/yilia/source/js/photo.js","path":"js/photo.js","modified":1,"renderable":1},{"_id":"source/assets/blogImg/weixin.png","path":"assets/blogImg/weixin.png","modified":1,"renderable":0},{"_id":"source/assets/demo/0418玉渊潭/yuyuantan01.JPG","path":"assets/demo/0418玉渊潭/yuyuantan01.JPG","modified":1,"renderable":0},{"_id":"source/assets/demo/0418玉渊潭/yuyuantan02.JPG","path":"assets/demo/0418玉渊潭/yuyuantan02.JPG","modified":1,"renderable":0},{"_id":"source/assets/demo/background.jpg","path":"assets/demo/background.jpg","modified":1,"renderable":0},{"_id":"source/assets/demo/0418玉渊潭/yuyuantan03.JPG","path":"assets/demo/0418玉渊潭/yuyuantan03.JPG","modified":1,"renderable":0},{"_id":"themes/yilia/source/js/gitment.browser.js","path":"js/gitment.browser.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/js/gitment.browser.js.map","path":"js/gitment.browser.js.map","modified":1,"renderable":1}],"Cache":[{"_id":"source/404.md","hash":"c8abd5faf4352795d8e53aaea4f1fdf2fde258c0","modified":1500004626000},{"_id":"themes/yilia/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1500004626000},{"_id":"themes/yilia/README.md","hash":"8444a63c50d8a7e40bb3f1f10e549a60da94a21f","modified":1500004626000},{"_id":"themes/yilia/_config.yml","hash":"94210a61e2a59d4fb915e7b1e2945c48cfbc83c0","modified":1500004626000},{"_id":"themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1500004626000},{"_id":"themes/yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1500004626000},{"_id":"source/photos/index.md","hash":"5388dcf6be0793008de18492042c11f0bbb00ce7","modified":1500004626000},{"_id":"source/_posts/2017玉渊潭樱花节.md","hash":"3a9b8a4ceaca1ae6b0fa558bfe920b2feee6f457","modified":1500004626000},{"_id":"source/_posts/798艺术区.md","hash":"7123894185a1639d33f608da54c62d52b8a586db","modified":1500004626000},{"_id":"source/_posts/Apple-Pay学习笔记.md","hash":"65ac1a2314e42108ee679ce94bf833edd5a8284e","modified":1500004626000},{"_id":"source/_posts/JSP学习笔记.md","hash":"ef7d672968d9ef5ca7200d662efcf029ae8db54e","modified":1500004626000},{"_id":"source/_posts/Java搭建springMVC项目笔记.md","hash":"8de47e94053248891fd43dd918426c7b81944edb","modified":1500004626000},{"_id":"source/_posts/Java语言学习笔记.md","hash":"beaa3dac20592226cd7aa40c8ec4397a4ea23d7f","modified":1500004626000},{"_id":"source/_posts/MVVM学习笔记.md","hash":"d743cc54bb4db3b24e9bd99b485c792a76688952","modified":1500004626000},{"_id":"source/_posts/Markdown学习笔记.md","hash":"52b32bf826e133fb97a34e82d802a23654d02fcb","modified":1500004626000},{"_id":"source/_posts/MyEclipse快捷键.md","hash":"854d2658082efe79a9e3626863c5395f7115cebd","modified":1500004626000},{"_id":"source/_posts/OC与JS交互的几种方法.md","hash":"167f7f9c81253579cc5aa404ab9fb61517e796c9","modified":1500004626000},{"_id":"source/_posts/OC中的block.md","hash":"b4249ee8b0142260e951deee5f0627117005adc7","modified":1500004626000},{"_id":"source/_posts/RAC与Target-Action、通知、代理、KVO.md","hash":"7f4cae03c2f8fc5871645b706d7f0a9b91fd28c7","modified":1500004626000},{"_id":"source/_posts/OpenGL学习笔记.md","hash":"42e0c330a170a2d02302071b7f806bc88a9b8d1d","modified":1500004626000},{"_id":"source/_posts/RAC学习笔记.md","hash":"76b45b9a07207a1a4cf30bafda2cef0ec534019e","modified":1500004626000},{"_id":"source/_posts/ReactNative学习笔记.md","hash":"a54a33ef8816221aec54da906a698a781eecfc64","modified":1500004626000},{"_id":"source/_posts/Swift学习笔记.md","hash":"d5bd6005ac34090bfccd3335885708d47e29b5a8","modified":1500004626000},{"_id":"source/_posts/github上使用SSH和gitignore.md","hash":"4957a680a688400b4267670218cb238ac119ae6e","modified":1500004626000},{"_id":"source/_posts/git学习笔记.md","hash":"b501f6464629c218f8a653faaf9b722148f3a00f","modified":1500004626000},{"_id":"source/_posts/hexo创建个人博客记录.md","hash":"acfb0293c730fa3a502445d8caaeceb75d16affb","modified":1500004626000},{"_id":"source/_posts/iBeacon学习笔记.md","hash":"658ac56362f48ffc24823410d775b7a022bf1953","modified":1500004626000},{"_id":"source/_posts/iOS-IM学习笔记.md","hash":"c1839198ac0abdda34337e24e59279029d7f7caa","modified":1500004626000},{"_id":"source/_posts/iOS-runtime学习笔记.md","hash":"bec77d558b6f90263bebffd6a81b1385f28409db","modified":1500004626000},{"_id":"source/_posts/iOS使定时器NSTimer在程序进入后台仍然运行的方法.md","hash":"c25f2518466b956cdcff8600c7401fad0d9a9c0b","modified":1500004626000},{"_id":"source/_posts/iOS动画笔记.md","hash":"03e1998ef90d2bb7cb35a15257398661072f7dfb","modified":1500004626000},{"_id":"source/_posts/iOS单元测试学习笔记.md","hash":"b789426f88fbd7750fec1f34f2c9f69a81deccd6","modified":1500004626000},{"_id":"source/_posts/iOS国际化学习笔记.md","hash":"92dca8cb9bb2ec9353d15ce59619006eac71c191","modified":1500004626000},{"_id":"source/_posts/iOS多媒体学习笔记.md","hash":"da6a295536b822088a6265e7aa1c1165e7c22444","modified":1500004626000},{"_id":"source/_posts/iOS多线程学习笔记.md","hash":"895b4d08a0a4b0e85c3d1aeca8587caf74bf9d46","modified":1500004626000},{"_id":"source/_posts/iOS打包提交APP-Store注意事项.md","hash":"6e67bc28399d41340fdda3a16bee41ea6f50de6c","modified":1500004626000},{"_id":"source/_posts/iOS直播学习笔记.md","hash":"8038f8e1f9eac82343c2df960f678b2ea60dfb5f","modified":1500004626000},{"_id":"source/_posts/iOS调试与性能优化学习笔记.md","hash":"1ad4653b0df9a551d8ffb6d189273ad9bb6a737e","modified":1500004626000},{"_id":"source/_posts/iOS面试知识点总结.md","hash":"20a58e8a225e34c54a174d5dbdcb6bed104e9fa3","modified":1500004626000},{"_id":"source/_posts/java开发环境配置.md","hash":"8775b6a7fe773c6469bc792ebdc318c9c35fafe9","modified":1500004626000},{"_id":"source/_posts/mac显示隐藏文件.md","hash":"6080c841bee5a3de06407210cb6cb87c9f3e7cdd","modified":1500004626000},{"_id":"source/_posts/mysql学习笔记.md","hash":"3ac7bb29f8a84b4063b5823b9b7c8409943f2852","modified":1500004626000},{"_id":"source/_posts/toStudy.md","hash":"02d18cc008bab8e509d87f27ed6d3f656b776f42","modified":1500004626000},{"_id":"source/_posts/几种常见算法.md","hash":"17db6c244dc80fe9598234f1e9f4f922ed8285a5","modified":1500004626000},{"_id":"source/_posts/北京十渡.md","hash":"422548184591756d5fc236713b8488d8a4325f06","modified":1500004626000},{"_id":"source/_posts/将-c文件打包成库文件.md","hash":"00dad4291075b0cdb335c0841fa17d45ab9f018d","modified":1500004626000},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1500004626000},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1500004626000},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1500004626000},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1500004626000},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1500004626000},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1500004626000},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1500004626000},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1500004626000},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1500004626000},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1500004626000},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1500004626000},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1500004626000},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1500004626000},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1500004626000},{"_id":"themes/yilia/source/main.b3331d.css","hash":"28c6279aab4c60c84c70f54a39505efd1a7f145f","modified":1500004626000},{"_id":"themes/yilia/source/slider.445162.js","hash":"e21c3c2cf663d7a4fb0d77f43ae1a148553a7cca","modified":1500004626000},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1500004626000},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1500004626000},{"_id":"themes/yilia/source/main.b3331d.js","hash":"0e98e3674c7687ae4ff7bdcecb05e15434c46e0d","modified":1500004626000},{"_id":"themes/yilia/source/mobile.8d90af.js","hash":"cf2ab659138db5abc70e3e0d7bc64f50d48e834d","modified":1500004626000},{"_id":"source/assets/blogImg/avatar.jpg","hash":"1a13acf5a1bdb99f336f78d5ad9fe8ba301d7454","modified":1500004626000},{"_id":"source/assets/blogImg/avatar1.jpg","hash":"7f6bf05bb06e8fa8d89d3e2528b914b59bfc7c78","modified":1500004626000},{"_id":"source/assets/blogImg/favicon.jpg","hash":"877c56758f59d6008bb681e092d4d4d558dbb941","modified":1500004626000},{"_id":"source/assets/blogImg/zhifubao.png","hash":"eb793f828e3fb4b309f3d0efe8254e8fe34b8664","modified":1500004626000},{"_id":"source/assets/demo/bengji01.jpeg","hash":"63752d31c03844a6cb01f5b501d26e5c817784e4","modified":1500004626000},{"_id":"source/assets/demo/branch.png","hash":"792e0b4c64b5bf60f9ce0562aa600385b259e006","modified":1500004626000},{"_id":"source/assets/demo/braveGirl.jpeg","hash":"a80ada29ff0b8e09df7eeeee8883c6918a041480","modified":1500004626000},{"_id":"source/assets/demo/feilada01.jpeg","hash":"f9b5ef8cf9e27794109e6eb95e529d29cf29bba1","modified":1500004626000},{"_id":"source/assets/demo/head_icon.jpg","hash":"be2553a26f2643e7cfb5009d4b8ae4bbe340319e","modified":1500004626000},{"_id":"source/assets/demo/java_config.png","hash":"0bca35024642d37782779e92d2a5611d13061e41","modified":1500004626000},{"_id":"source/assets/demo/qingxin1.jpg","hash":"1eb01b9ad7839ad83c6a93d58243a424f7039a9c","modified":1500004626000},{"_id":"source/assets/demo/qingxin2.jpg","hash":"bcbc03d7f94d0fbc73d314d69f8b4a775ff99a26","modified":1500004626000},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"2381952dd591bedcad4a8e33c144fec539ca4a43","modified":1500004626000},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1500004626000},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1500004626000},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"d066323b9764b0c08b2914c65d3e4d44a1dc9b13","modified":1500004626000},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"5ff39575c4448eadb338b487f7a0db8aac7db367","modified":1500004626000},{"_id":"themes/yilia/layout/_partial/baidu_tongji.ejs","hash":"b786202f03151acb19ae0d05e81b5859fa910ec0","modified":1500004626000},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"f8a42263edeeb3ccf6115cea5f96f551ed1e76e5","modified":1500004626000},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"d324d28ddc685b3472fd65017bb4f5082c19092e","modified":1500004626000},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1500004626000},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1500004626000},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"490a05585c6278c56fe12277405dc4be8c17eeab","modified":1500004626000},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"2387d91cf94b0b36e8a36841992a5fce63ebd069","modified":1500004626000},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1500004626000},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1500004626000},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1500004626000},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1500004626000},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1500004626000},{"_id":"themes/yilia/source/fonts/iconfont.3a9902.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1500004626000},{"_id":"themes/yilia/source/fonts/iconfont.6e162c.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1500004626000},{"_id":"themes/yilia/source/fonts/iconfont.9abe9f.svg","hash":"772383b62548e2a4fa560d589e05929b9f6f7f7b","modified":1500004626000},{"_id":"themes/yilia/source/fonts/iconfont.d0da7e.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1500004626000},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1500004626000},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1500004626000},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1500004626000},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1500004626000},{"_id":"themes/yilia/source/js/gitment-theme-default.css","hash":"f05cb06e3a8e1caaa07fdf159338090ddf35fd12","modified":1500004626000},{"_id":"themes/yilia/source/js/photo.js","hash":"df4c6a195e1c4465e472ff2544148a3e88e0c10d","modified":1500004626000},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1500004626000},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1500004626000},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1500004626000},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1500004626000},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1500004626000},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1500004626000},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1500004626000},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"e6e83d4863afcc589d4dd2f327e9f396f7d7b343","modified":1500004626000},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"3f5808a49a7365e3f813f78ba96b692f7ca27886","modified":1500004626000},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1500004626000},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1500004626000},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1500004626000},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1500004626000},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1500004626000},{"_id":"themes/yilia/source-src/css/main.scss","hash":"ac8c3312182519e33d0f729d157deb36e5f42894","modified":1500004626000},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1500004626000},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"a40400734c6509b9ac6e393a6681ccd8bafed5eb","modified":1500004626000},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1500004626000},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1500004626000},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1500004626000},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1500004626000},{"_id":"themes/yilia/source-src/css/social.scss","hash":"b5324302815491d0a5e63142f1ead2048ad3f72f","modified":1500004626000},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1500004626000},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1500004626000},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"17a97f7c38f5dfacc3eadf354b5826d77f1c2bdb","modified":1500004626000},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1500004626000},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1500004626000},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1500004626000},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1500004626000},{"_id":"themes/yilia/source-src/js/fix.js","hash":"9591a0f61236a56b2a15a541f572bcfd93823a0f","modified":1500004626000},{"_id":"themes/yilia/source-src/js/main.js","hash":"d665f4cf30450984591bc8ad2348a1baf720d04b","modified":1500004626000},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1500004626000},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1500004626000},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1500004626000},{"_id":"themes/yilia/source-src/js/slider.js","hash":"3bf0d70ae171404a0dc73c33ec48927fc2521a54","modified":1500004626000},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1500004626000},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"808a2e1ed407984cfdc929b827d3638f70ec9a2a","modified":1500004626000},{"_id":"source/assets/blogImg/weixin.png","hash":"64c74e9cf5102df050704a0b8bf13be8d504d2e0","modified":1500004626000},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"6160c13783a7f31dab4fdcc6b752b3a368586d67","modified":1500004626000},{"_id":"source/assets/demo/0418玉渊潭/yuyuantan01.JPG","hash":"6ff0815ed347b14e943a95ed8adcb966d1a6a3ab","modified":1500004626000},{"_id":"source/assets/demo/0418玉渊潭/yuyuantan02.JPG","hash":"f11a7d27b937c0dda10dca3f96d7ae377ead4aa3","modified":1500004626000},{"_id":"source/assets/demo/background.jpg","hash":"f98714e71d7c4dd3bee04c75f0a796ee3314cd8f","modified":1500004626000},{"_id":"source/assets/demo/0418玉渊潭/yuyuantan03.JPG","hash":"fe8c1790be60ea2900f8a4d266b499f55bc8cd5e","modified":1500004626000},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1500004626000},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"9f9fa4f8b0de5f87a9494fd0cb5064502a5d5ef5","modified":1500004626000},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1500004626000},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1500004626000},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1500004626000},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"341103df70d0b476e3acd0afbc507a4a120d8f5f","modified":1500004626000},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1500004626000},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1500004626000},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"ea41c462168d9697caef9485862e9cac718a12c1","modified":1500004626000},{"_id":"themes/yilia/source/js/gitment.browser.js","hash":"e48361946f3a78b33a47250248b279508a5cc1ba","modified":1500004626000},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1500004626000},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1500004626000},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1500004626000},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1500004626000},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1500004626000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1500004626000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"772383b62548e2a4fa560d589e05929b9f6f7f7b","modified":1500004626000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1500004626000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1500004626000},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1500004626000},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1500004626000},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1500004626000},{"_id":"themes/yilia/source/js/gitment.browser.js.map","hash":"72dc603fb7be8b623d1a402419b42c36723367bb","modified":1500004626000},{"_id":"public/content.json","hash":"678f0b32978ec09e2786b9c31cd5d60c3a3ad79a","modified":1500004649730},{"_id":"public/404.html","hash":"58798b416a010e0d39603f9816b9cbc107ff4b38","modified":1500004650603},{"_id":"public/photos/index.html","hash":"eec5c13a2dc2d5754e66c067e8683bd255288a1c","modified":1500004650603},{"_id":"public/2017/07/05/iOS使定时器NSTimer在程序进入后台仍然运行的方法/index.html","hash":"75200f26e02d5ac3d2a33b4881642da818a16299","modified":1500004650603},{"_id":"public/2017/07/05/iOS动画笔记/index.html","hash":"269d416f1a7116137247b12a1e22cfb1906040c8","modified":1500004650604},{"_id":"public/2017/07/04/OC与JS交互的几种方法/index.html","hash":"020049635b2908379cc39d100378069656ce7792","modified":1500004650604},{"_id":"public/2017/07/03/OpenGL学习笔记/index.html","hash":"1f8f6c996ddd2c0b9ed41016f1a886d27586261e","modified":1500004650604},{"_id":"public/2017/07/03/iBeacon学习笔记/index.html","hash":"30d3fc1c56f0f5f5feaea591702b750b83e15ffc","modified":1500004650604},{"_id":"public/2017/07/01/OC中的block/index.html","hash":"8632801e9f657aabaaa88f6184129488e8eafb6a","modified":1500004650604},{"_id":"public/2017/06/30/iOS多线程学习笔记/index.html","hash":"f11f9182e3a3b6f83a0f621d52ebd52e9ffbb7b6","modified":1500004650604},{"_id":"public/2017/06/30/iOS面试知识点总结/index.html","hash":"f4d30976d9a022c25a84813ddd633a5d29fe981e","modified":1500004650604},{"_id":"public/2017/06/29/iOS直播学习笔记/index.html","hash":"a95745d2bfb89168c6b86269e5e15433edcdd5c8","modified":1500004650604},{"_id":"public/2017/06/12/JSP学习笔记/index.html","hash":"ce8be7692cdc419463b4a4cd183478df84f23f3d","modified":1500004650604},{"_id":"public/2017/06/09/几种常见算法/index.html","hash":"d791b32ad8d15b3c8f9e2ff9eb12781f940ad3f7","modified":1500004650605},{"_id":"public/2017/06/09/Java语言学习笔记/index.html","hash":"e6d36fc42a84d2319344620c7f1523fcdda5ddb8","modified":1500004650605},{"_id":"public/2017/06/09/MyEclipse快捷键/index.html","hash":"761e02eb30492e183681df1a7ff8e7148872777e","modified":1500004650605},{"_id":"public/2017/06/08/mysql学习笔记/index.html","hash":"3e0c6560de1ed4e6937d384f92f5ae46ae3f5c9b","modified":1500004650605},{"_id":"public/2017/06/08/Java搭建springMVC项目笔记/index.html","hash":"910cdbc6e15dd2a50e163e02c88630379f52420a","modified":1500004650605},{"_id":"public/2017/06/06/java开发环境配置/index.html","hash":"4bd8b7a4edd3c3438f4021f79b15fdd844422e0f","modified":1500004650605},{"_id":"public/2017/06/05/iOS调试与性能优化学习笔记/index.html","hash":"9b281056f719284a461e4f57be7f953ad0e092e7","modified":1500004650605},{"_id":"public/2017/06/04/798艺术区/index.html","hash":"df3a8033d95db9014cc6b686c7d5ff793497ca5c","modified":1500004650606},{"_id":"public/2017/05/21/ReactNative学习笔记/index.html","hash":"b62ae2d0f7cc4d5cb7e5bb33144fa9b38d9714b3","modified":1500004650606},{"_id":"public/2017/05/20/MVVM学习笔记/index.html","hash":"b9a982171c0c3fd372812470fd7e173a7977daa9","modified":1500004650606},{"_id":"public/2017/05/20/RAC学习笔记/index.html","hash":"898c9b41fae043a608ec85b5baeb78990b89f8f6","modified":1500004650606},{"_id":"public/2017/05/06/iOS多媒体学习笔记/index.html","hash":"7af0b7d333c6026a9149968c99510c35056cc321","modified":1500004650606},{"_id":"public/2017/04/23/RAC与Target-Action、通知、代理、KVO/index.html","hash":"f0719b885c081cc13a2d9d7484f78556d8d84ffb","modified":1500004650606},{"_id":"public/2017/04/22/iOS-IM学习笔记/index.html","hash":"cad2aa928dbcdf58d720d195dfadb4eb1f247191","modified":1500004650606},{"_id":"public/2017/04/16/北京十渡/index.html","hash":"2347d5bf3405a7c12211a963aa1a626c6edf3587","modified":1500004650606},{"_id":"public/2017/04/13/iOS打包提交APP-Store注意事项/index.html","hash":"35466f71fa22578f1bb1796ef32fdbc61603efb7","modified":1500004650607},{"_id":"public/2017/04/09/iOS单元测试学习笔记/index.html","hash":"a20c6b0f032efae9a959cc2e4cda3154482ad0f7","modified":1500004650607},{"_id":"public/2017/04/08/2017玉渊潭樱花节/index.html","hash":"d25d0cb63973ff0ce01b560242b29e91ac2d5c62","modified":1500004650607},{"_id":"public/2017/03/22/iOS-runtime学习笔记/index.html","hash":"6d7e756bc6583b917e240623d09a5f2c81ba0fc1","modified":1500004650607},{"_id":"public/2017/03/21/mac显示隐藏文件/index.html","hash":"0135504f8f1b428dbd66edca13f0289209e036ed","modified":1500004650607},{"_id":"public/2017/03/15/Apple-Pay学习笔记/index.html","hash":"9a0943259deea1bf07a56ed23cdbb0a47379e9ec","modified":1500004650607},{"_id":"public/2017/03/06/将-c文件打包成库文件/index.html","hash":"281e06b941cbd6c8f714126f2ece23fdfae586d3","modified":1500004650607},{"_id":"public/2017/03/03/github上使用SSH和gitignore/index.html","hash":"38fd67d7182c660cd5f120dba1901bf74abd898a","modified":1500004650608},{"_id":"public/2017/03/03/git学习笔记/index.html","hash":"3dd69470f3a8218123c9246b196546b1b309617c","modified":1500004650608},{"_id":"public/2017/02/19/Markdown学习笔记/index.html","hash":"8450c279dcb8895b1587b7df16106ebbb50164ec","modified":1500004650608},{"_id":"public/2017/02/18/hexo创建个人博客记录/index.html","hash":"700c964dc6f0eaf9edd568c479da4d37de347a43","modified":1500004650608},{"_id":"public/2017/01/01/Swift学习笔记/index.html","hash":"736d38b4dc421c633664245a9a7e22878bb4bcac","modified":1500004650608},{"_id":"public/2017/01/01/iOS国际化学习笔记/index.html","hash":"3e4ec06100050bebb977d33cc87b4db1820be0f8","modified":1500004650608},{"_id":"public/2017/01/01/toStudy/index.html","hash":"9404ef761752c7afdf7a25d6d78a7d028f911ca2","modified":1500004650608},{"_id":"public/archives/index.html","hash":"95262c29eff2f498754c6ef06558cedc8948b147","modified":1500004650609},{"_id":"public/archives/page/2/index.html","hash":"badadf85c1ee7b3928c1f5c496c5454b4820dacb","modified":1500004650609},{"_id":"public/archives/page/3/index.html","hash":"638bfb559a30fe0b96a613c87e6a163822b58aad","modified":1500004650609},{"_id":"public/archives/page/4/index.html","hash":"64c6b3c915ffba3415a27aa00daae368b7b0d84a","modified":1500004650609},{"_id":"public/archives/2017/index.html","hash":"0560d1f33d975de561b14aced0aab0d793a6aedf","modified":1500004650609},{"_id":"public/archives/2017/page/2/index.html","hash":"eda60f843b5483626531d7be9fafc1dba43eaf67","modified":1500004650610},{"_id":"public/archives/2017/page/3/index.html","hash":"621623402fbbea2064337610011f16c3ae312b06","modified":1500004650610},{"_id":"public/archives/2017/page/4/index.html","hash":"331ed49e38cc28272f1bfd6d6497182f330c87a6","modified":1500004650610},{"_id":"public/archives/2017/01/index.html","hash":"cda200743221b6b823584e9a55fd06ef8f40697b","modified":1500004650610},{"_id":"public/archives/2017/02/index.html","hash":"d9784af3d3822fefea82bba0a4e0a871aca152ce","modified":1500004650611},{"_id":"public/archives/2017/03/index.html","hash":"68323e8b33cc33ca398ca06f139f48714a218cf3","modified":1500004650611},{"_id":"public/archives/2017/04/index.html","hash":"5cc4e8fb1faf081af09f85a8ba1bba307e9e0e27","modified":1500004650611},{"_id":"public/archives/2017/05/index.html","hash":"85718308a0360c50c93f05bd501e7576278433dc","modified":1500004650611},{"_id":"public/archives/2017/06/index.html","hash":"a982ecd2e8819ab94713cc68087a8fab22edce7a","modified":1500004650611},{"_id":"public/archives/2017/06/page/2/index.html","hash":"653c3df116910367b36721f9938a312d313ff3fd","modified":1500004650611},{"_id":"public/archives/2017/07/index.html","hash":"9a919e6c42becdaff2453664e3ca15b29061b0c9","modified":1500004650612},{"_id":"public/categories/other/index.html","hash":"f94d1e01b01259326f898a193b6b4f320b095f29","modified":1500004650612},{"_id":"public/categories/note/index.html","hash":"ba231b2e09eac28b7a11e98153ae8042b294a3d3","modified":1500004650612},{"_id":"public/categories/note/page/2/index.html","hash":"bf0144854096bf115a500f079d33e0839f06dadb","modified":1500004650612},{"_id":"public/categories/note/page/3/index.html","hash":"65d3dba1a15847abbcee872a03ae106e79f79344","modified":1500004650612},{"_id":"public/categories/note/page/4/index.html","hash":"0bce95e6ed60a686b22410462739870945c81e41","modified":1500004650613},{"_id":"public/index.html","hash":"bc8660b8bab503978bbf613be35dc5e769813834","modified":1500004650613},{"_id":"public/page/2/index.html","hash":"94a8028b99b1914487fcb40ee705f2fb570628b7","modified":1500004650613},{"_id":"public/page/3/index.html","hash":"167b2eb13dc95f05f5f238f3f7bb256479b74b08","modified":1500004650613},{"_id":"public/page/4/index.html","hash":"79d057e17fcad66271d282d15c98248e28a90864","modified":1500004650613},{"_id":"public/tags/玉渊潭/index.html","hash":"71c89b4cde56d32daec975039e8234283bcc88de","modified":1500004650613},{"_id":"public/tags/樱花节/index.html","hash":"90e210cd7f5987b93a332daf2766e6638619912f","modified":1500004650614},{"_id":"public/tags/798/index.html","hash":"8870ebef1dd5ef0f3acc48cbb3a12f7ca3f0dd4c","modified":1500004650614},{"_id":"public/tags/iOS/index.html","hash":"e641fa81afb74a63e86578e45574ad395cfd658d","modified":1500004650614},{"_id":"public/tags/iOS/page/2/index.html","hash":"8bb664c98aabd2e0503e2013c3475e340fcd6bc2","modified":1500004650614},{"_id":"public/tags/Apple-Pay/index.html","hash":"3beb0adefa939e2903b86ba419140ab2801abfae","modified":1500004650614},{"_id":"public/tags/Java/index.html","hash":"178db16a363a4ea7255c043bd60ccbedeb898929","modified":1500004650614},{"_id":"public/tags/JSP/index.html","hash":"4042d0e0e8b6d21c245fcedbf41d43bd60f2f2fa","modified":1500004650614},{"_id":"public/tags/springMVC/index.html","hash":"e2865787190d37123e984bee94a9bdf41e8a8bcc","modified":1500004650615},{"_id":"public/tags/项目/index.html","hash":"66c0ac67f333c4c06855d1547e855c98b76efa15","modified":1500004650615},{"_id":"public/tags/语法/index.html","hash":"0fecdb86ecb9d7ca7e6387ffcdbf571d75510db4","modified":1500004650615},{"_id":"public/tags/MVVM/index.html","hash":"7568d5ffc931cb12245dc0ff95da5871d5c38b74","modified":1500004650615},{"_id":"public/tags/markdown/index.html","hash":"2cd7d920cf325e48327c346f46ee12ab74c1f1b7","modified":1500004650615},{"_id":"public/tags/快捷键/index.html","hash":"f3603f5211ef9042feb93cedcc148551aa21cb3e","modified":1500004650615},{"_id":"public/tags/OC/index.html","hash":"f0d6b1689d9ed02350d4b5ce13bb09482bcbf39f","modified":1500004650615},{"_id":"public/tags/JS/index.html","hash":"447815feb0c9084a0c89448c5ed50fedd4818f6d","modified":1500004650615},{"_id":"public/tags/block/index.html","hash":"e70eca866b0f24febb7a462e23fec261595ad78f","modified":1500004650616},{"_id":"public/tags/RAC/index.html","hash":"47536d8356b6a2fc2eecbfff7d48cffca52d91b3","modified":1500004650616},{"_id":"public/tags/OpenGL/index.html","hash":"b2e5103bbba109e8e0d56631ff4a5cac9424a3d2","modified":1500004650616},{"_id":"public/tags/ReactNative/index.html","hash":"2e90cace76298c4791bd29c67d8382322058b4b1","modified":1500004650616},{"_id":"public/tags/Swift/index.html","hash":"068f4e6645fbbb5f929d80ac06d743898b352ccd","modified":1500004650616},{"_id":"public/tags/github/index.html","hash":"142dd4a3bbf0cd64cbb74ffab291d1446a18de61","modified":1500004650616},{"_id":"public/tags/SSH/index.html","hash":"86f2ec76bd22e5322e5c4c85f4bd4693222239d4","modified":1500004650616},{"_id":"public/tags/gitignore/index.html","hash":"140ad194abc08eb999054bbbd37a1cc3331e1a2a","modified":1500004650617},{"_id":"public/tags/Git/index.html","hash":"205fe943c33690fa000541cd3e554005c0db553d","modified":1500004650617},{"_id":"public/tags/hexo/index.html","hash":"d9dccf1898e4dfc04b48e1ffb001ed3b415a7b46","modified":1500004650617},{"_id":"public/tags/个人博客/index.html","hash":"38c4db8ad9c7f8153bc838515062e458f4197486","modified":1500004650618},{"_id":"public/tags/iBeacon/index.html","hash":"fe5b9051e8cf2946eb4d5ee84d7c0b3aa46ed551","modified":1500004650618},{"_id":"public/tags/IM/index.html","hash":"35964e020e8fa4b8d39252f4220d1426e26b6056","modified":1500004650618},{"_id":"public/tags/socket/index.html","hash":"5cf613727ff7a47b97ac345086fd0eb074e3c03a","modified":1500004650618},{"_id":"public/tags/runtime/index.html","hash":"d866102643df73291f2a584d4a9493a325f0f9bc","modified":1500004650619},{"_id":"public/tags/NSTimer/index.html","hash":"95baa9824360f9df89e65d6fbf96ae5e88444e96","modified":1500004650619},{"_id":"public/tags/后台/index.html","hash":"408fa8802939c793d7d304bb901312d73f460d34","modified":1500004650619},{"_id":"public/tags/动画/index.html","hash":"7540684ebc4014c50ce11da3bd6c446c27fc2d42","modified":1500004650619},{"_id":"public/tags/国际化/index.html","hash":"7c6d2d6df1eb2abc5a6154d51c991cd1bb4f71c1","modified":1500004650620},{"_id":"public/tags/test/index.html","hash":"b1b38a7e53c7dfe2a33521be10ab69cabc586a80","modified":1500004650620},{"_id":"public/tags/音频/index.html","hash":"4a3fcbe7bf079ca854c6573df35875affa6ec9a1","modified":1500004650620},{"_id":"public/tags/视频/index.html","hash":"b526c30a47326070115430c1614ea9419ffb2a8c","modified":1500004650620},{"_id":"public/tags/播放/index.html","hash":"5b838db28dece9fcef7ce30ce1cc2728e8b45451","modified":1500004650620},{"_id":"public/tags/录制/index.html","hash":"70b25611aa746d2d8e76d3b9baf7f6e82a76c49c","modified":1500004650621},{"_id":"public/tags/多线程/index.html","hash":"b1325c8276811d369b9b45ec053b3b8901772245","modified":1500004650621},{"_id":"public/tags/app-store/index.html","hash":"764f09a10353a98203e417a0f46f8158200614fc","modified":1500004650621},{"_id":"public/tags/直播/index.html","hash":"1db0d2bc62a5424b9d046220f133b8f4aeb05ebf","modified":1500004650621},{"_id":"public/tags/优化/index.html","hash":"29f6da1d71ad8a27e186d432a262afe228fe0fae","modified":1500004650621},{"_id":"public/tags/面试/index.html","hash":"3ec97c431cc3653d951f5149b3d3ea22f7dd2676","modified":1500004650621},{"_id":"public/tags/web/index.html","hash":"dd5fb945a4bf55893476511d4e1fd022aab37136","modified":1500004650622},{"_id":"public/tags/技巧/index.html","hash":"da1c158a74384ee39632da1060c355127102aaad","modified":1500004650622},{"_id":"public/tags/隐藏文件/index.html","hash":"c3c206a0777da3795d2e4058cb54921c34ddcfb9","modified":1500004650622},{"_id":"public/tags/mysql/index.html","hash":"4cfd11fe55b08010b90ec3f6697bc566187ca2aa","modified":1500004650622},{"_id":"public/tags/排序/index.html","hash":"a8dd4320f1270d6320938b0e7a7c649bb917b188","modified":1500004650622},{"_id":"public/tags/算法/index.html","hash":"08c77374aeb5f6a6c5d00df7ad65bfc73ad41b13","modified":1500004650622},{"_id":"public/tags/十渡/index.html","hash":"84d1661ad5dac1dd1726459ca812f4f3cb5f74cd","modified":1500004650622},{"_id":"public/tags/蹦极/index.html","hash":"a4794203b97365a2b9315d40f2aaed1a611c73d9","modified":1500004650622},{"_id":"public/tags/c/index.html","hash":"c80b11996a2698d8e719a8478b6476c922ede9dd","modified":1500004650623},{"_id":"public/tags/a/index.html","hash":"4e70f1648e2267159cec00e919202030ba7cfd88","modified":1500004650623},{"_id":"public/tags/so/index.html","hash":"03be959b126a89c2e4ff4e03b2f8480ddecdfdbf","modified":1500004650623},{"_id":"public/assets/blogImg/avatar.jpg","hash":"1a13acf5a1bdb99f336f78d5ad9fe8ba301d7454","modified":1500004650636},{"_id":"public/assets/blogImg/avatar1.jpg","hash":"7f6bf05bb06e8fa8d89d3e2528b914b59bfc7c78","modified":1500004650636},{"_id":"public/assets/blogImg/favicon.jpg","hash":"877c56758f59d6008bb681e092d4d4d558dbb941","modified":1500004650636},{"_id":"public/assets/demo/bengji01.jpeg","hash":"63752d31c03844a6cb01f5b501d26e5c817784e4","modified":1500004650637},{"_id":"public/assets/blogImg/zhifubao.png","hash":"eb793f828e3fb4b309f3d0efe8254e8fe34b8664","modified":1500004650637},{"_id":"public/assets/demo/braveGirl.jpeg","hash":"a80ada29ff0b8e09df7eeeee8883c6918a041480","modified":1500004650637},{"_id":"public/assets/demo/branch.png","hash":"792e0b4c64b5bf60f9ce0562aa600385b259e006","modified":1500004650637},{"_id":"public/assets/demo/java_config.png","hash":"0bca35024642d37782779e92d2a5611d13061e41","modified":1500004650637},{"_id":"public/assets/demo/head_icon.jpg","hash":"be2553a26f2643e7cfb5009d4b8ae4bbe340319e","modified":1500004650637},{"_id":"public/assets/demo/feilada01.jpeg","hash":"f9b5ef8cf9e27794109e6eb95e529d29cf29bba1","modified":1500004650637},{"_id":"public/assets/demo/qingxin1.jpg","hash":"1eb01b9ad7839ad83c6a93d58243a424f7039a9c","modified":1500004650638},{"_id":"public/assets/demo/qingxin2.jpg","hash":"bcbc03d7f94d0fbc73d314d69f8b4a775ff99a26","modified":1500004650638},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1500004650638},{"_id":"public/fonts/iconfont.3a9902.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1500004650638},{"_id":"public/fonts/iconfont.6e162c.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1500004650638},{"_id":"public/fonts/iconfont.9abe9f.svg","hash":"772383b62548e2a4fa560d589e05929b9f6f7f7b","modified":1500004650638},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1500004650638},{"_id":"public/fonts/iconfont.d0da7e.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1500004650638},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1500004650639},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1500004650639},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1500004650639},{"_id":"public/assets/demo/0418玉渊潭/yuyuantan01.JPG","hash":"6ff0815ed347b14e943a95ed8adcb966d1a6a3ab","modified":1500004650639},{"_id":"public/assets/demo/0418玉渊潭/yuyuantan02.JPG","hash":"f11a7d27b937c0dda10dca3f96d7ae377ead4aa3","modified":1500004650639},{"_id":"public/assets/demo/0418玉渊潭/yuyuantan03.JPG","hash":"fe8c1790be60ea2900f8a4d266b499f55bc8cd5e","modified":1500004650639},{"_id":"public/assets/blogImg/weixin.png","hash":"64c74e9cf5102df050704a0b8bf13be8d504d2e0","modified":1500004650648},{"_id":"public/js/photo.js","hash":"df4c6a195e1c4465e472ff2544148a3e88e0c10d","modified":1500004650659},{"_id":"public/main.b3331d.css","hash":"28c6279aab4c60c84c70f54a39505efd1a7f145f","modified":1500004650660},{"_id":"public/slider.445162.js","hash":"e21c3c2cf663d7a4fb0d77f43ae1a148553a7cca","modified":1500004650660},{"_id":"public/main.b3331d.js","hash":"0e98e3674c7687ae4ff7bdcecb05e15434c46e0d","modified":1500004650660},{"_id":"public/mobile.8d90af.js","hash":"cf2ab659138db5abc70e3e0d7bc64f50d48e834d","modified":1500004650660},{"_id":"public/js/gitment-theme-default.css","hash":"f05cb06e3a8e1caaa07fdf159338090ddf35fd12","modified":1500004650660},{"_id":"public/js/gitment.browser.js","hash":"e48361946f3a78b33a47250248b279508a5cc1ba","modified":1500004650660},{"_id":"public/assets/demo/background.jpg","hash":"f98714e71d7c4dd3bee04c75f0a796ee3314cd8f","modified":1500004650661},{"_id":"public/js/gitment.browser.js.map","hash":"72dc603fb7be8b623d1a402419b42c36723367bb","modified":1500004650674}],"Category":[{"name":"随笔","_id":"cj53c1duw0004h3jjbmh8aqil"},{"name":"笔记","_id":"cj53c1dvb000eh3jjy8sl7ucr"}],"Data":[],"Page":[{"layout":"default","_content":"<html>\n    <head>\n         <meta charset=\"UTF-8\" />\n         <title>404</title>                                                                                                                                        \n    </head>\n    <body>\n         <script type=\"text/javascript\" src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"https://guchunli.github.io\" homePageName=\"回到我的主页\"></script>\n    </body>\n</html>","source":"404.md","raw":"---\nlayout: default\n---\n<html>\n    <head>\n         <meta charset=\"UTF-8\" />\n         <title>404</title>                                                                                                                                        \n    </head>\n    <body>\n         <script type=\"text/javascript\" src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"https://guchunli.github.io\" homePageName=\"回到我的主页\"></script>\n    </body>\n</html>","date":"2017-07-14T03:57:06.000Z","updated":"2017-07-14T03:57:06.000Z","path":"404.html","title":"","comments":1,"_id":"cj53c1dtc0000h3jj25gqm4v3","content":"<html><br>    <head><br>         <meta charset=\"UTF-8\"><br>         <title>404</title><br>    </head><br>    <body><br>         <script type=\"text/javascript\" src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\" charset=\"utf-8\" homepageurl=\"https://guchunli.github.io\" homepagename=\"回到我的主页\"></script><br>    </body><br></html>","site":{"data":{}},"excerpt":"","more":"<html><br>    <head><br>         <meta charset=\"UTF-8\"><br>         <title>404</title><br>    </head><br>    <body><br>         <script type=\"text/javascript\" src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\" charset=\"utf-8\" homepageurl=\"https://guchunli.github.io\" homepagename=\"回到我的主页\"></script><br>    </body><br></html>"},{"title":"photo","date":"2017-06-01T08:05:00.000Z","_content":"","source":"photos/index.md","raw":"---\ntitle: photo\ndate: 2017-06-01 16:05:00\n---\n","updated":"2017-07-14T03:57:06.000Z","path":"photos/index.html","comments":1,"layout":"page","_id":"cj53c1dur0002h3jjup8v7fmw","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"2017玉渊潭樱花节","date":"2017-04-08T11:54:47.000Z","_content":"\n### 2017-04-08 玉渊潭樱花节\n\n![](http://o8cfktdb3.bkt.clouddn.com/yuyuantan04.JPG)\n\n去年就打算去玉渊潭看花的\n忘了是什么原因错过了花期，没能去成\n心里总觉得遗憾\n<!--more-->\n今年决定不能再错过一定要去看看的\n虽然今天天气不太好，但是花开尤盛，自以为很是不错\n也算是了了一个小小心愿\n\n最重要的是去了，并且看到了\n不是么~~\n\n![](http://o8cfktdb3.bkt.clouddn.com/yuyuantan02.JPG)\n\n![](http://o8cfktdb3.bkt.clouddn.com/yuyuantan03.JPG)\n\n","source":"_posts/2017玉渊潭樱花节.md","raw":"---\ntitle: 2017玉渊潭樱花节\ndate: 2017-04-08 19:54:47\ncategories: 随笔\ntags: [玉渊潭,樱花节]\n---\n\n### 2017-04-08 玉渊潭樱花节\n\n![](http://o8cfktdb3.bkt.clouddn.com/yuyuantan04.JPG)\n\n去年就打算去玉渊潭看花的\n忘了是什么原因错过了花期，没能去成\n心里总觉得遗憾\n<!--more-->\n今年决定不能再错过一定要去看看的\n虽然今天天气不太好，但是花开尤盛，自以为很是不错\n也算是了了一个小小心愿\n\n最重要的是去了，并且看到了\n不是么~~\n\n![](http://o8cfktdb3.bkt.clouddn.com/yuyuantan02.JPG)\n\n![](http://o8cfktdb3.bkt.clouddn.com/yuyuantan03.JPG)\n\n","slug":"2017玉渊潭樱花节","published":1,"updated":"2017-07-14T03:57:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj53c1dua0001h3jjn1w13gmn","content":"<h3 id=\"2017-04-08-玉渊潭樱花节\"><a href=\"#2017-04-08-玉渊潭樱花节\" class=\"headerlink\" title=\"2017-04-08 玉渊潭樱花节\"></a>2017-04-08 玉渊潭樱花节</h3><p><img src=\"http://o8cfktdb3.bkt.clouddn.com/yuyuantan04.JPG\" alt=\"\"></p>\n<p>去年就打算去玉渊潭看花的<br>忘了是什么原因错过了花期，没能去成<br>心里总觉得遗憾<br><a id=\"more\"></a><br>今年决定不能再错过一定要去看看的<br>虽然今天天气不太好，但是花开尤盛，自以为很是不错<br>也算是了了一个小小心愿</p>\n<p>最重要的是去了，并且看到了<br>不是么~~</p>\n<p><img src=\"http://o8cfktdb3.bkt.clouddn.com/yuyuantan02.JPG\" alt=\"\"></p>\n<p><img src=\"http://o8cfktdb3.bkt.clouddn.com/yuyuantan03.JPG\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"2017-04-08-玉渊潭樱花节\"><a href=\"#2017-04-08-玉渊潭樱花节\" class=\"headerlink\" title=\"2017-04-08 玉渊潭樱花节\"></a>2017-04-08 玉渊潭樱花节</h3><p><img src=\"http://o8cfktdb3.bkt.clouddn.com/yuyuantan04.JPG\" alt=\"\"></p>\n<p>去年就打算去玉渊潭看花的<br>忘了是什么原因错过了花期，没能去成<br>心里总觉得遗憾<br>","more":"<br>今年决定不能再错过一定要去看看的<br>虽然今天天气不太好，但是花开尤盛，自以为很是不错<br>也算是了了一个小小心愿</p>\n<p>最重要的是去了，并且看到了<br>不是么~~</p>\n<p><img src=\"http://o8cfktdb3.bkt.clouddn.com/yuyuantan02.JPG\" alt=\"\"></p>\n<p><img src=\"http://o8cfktdb3.bkt.clouddn.com/yuyuantan03.JPG\" alt=\"\"></p>"},{"title":"798艺术区","date":"2017-06-04T07:30:49.000Z","comments":1,"_content":"\n2017-06-04 北京798艺术区\n\n![“抽象画”](http://o8cfktdb3.bkt.clouddn.com/line.jpeg)  \n抽象画\n<!--more-->\n\n![“陶瓷”](http://o8cfktdb3.bkt.clouddn.com/chinese.jpeg)\n各种小陶瓷\n\n![“卡哇伊”](http://o8cfktdb3.bkt.clouddn.com/cat.jpeg) \n猫咪，卡哇伊\n\n![“brain”](http://o8cfktdb3.bkt.clouddn.com/brain.jpeg) \nbrain\n\n![“red people”](http://o8cfktdb3.bkt.clouddn.com/redpeople.jpeg)\nred people\n\n![“未名”](http://o8cfktdb3.bkt.clouddn.com/unknown.jpeg) \n未名\n\n![“孤独的小孩”](http://o8cfktdb3.bkt.clouddn.com/child.jpeg)  \n孤独的小孩\n\n![“恋人”](http://o8cfktdb3.bkt.clouddn.com/lover.jpeg)  \n恋人\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=28476557&auto=1&height=66\"></iframe>\n","source":"_posts/798艺术区.md","raw":"---\ntitle: 798艺术区\ndate: 2017-06-04 15:30:49\ncategories: 随笔\ntags: [798]\ncomments: true\n---\n\n2017-06-04 北京798艺术区\n\n![“抽象画”](http://o8cfktdb3.bkt.clouddn.com/line.jpeg)  \n抽象画\n<!--more-->\n\n![“陶瓷”](http://o8cfktdb3.bkt.clouddn.com/chinese.jpeg)\n各种小陶瓷\n\n![“卡哇伊”](http://o8cfktdb3.bkt.clouddn.com/cat.jpeg) \n猫咪，卡哇伊\n\n![“brain”](http://o8cfktdb3.bkt.clouddn.com/brain.jpeg) \nbrain\n\n![“red people”](http://o8cfktdb3.bkt.clouddn.com/redpeople.jpeg)\nred people\n\n![“未名”](http://o8cfktdb3.bkt.clouddn.com/unknown.jpeg) \n未名\n\n![“孤独的小孩”](http://o8cfktdb3.bkt.clouddn.com/child.jpeg)  \n孤独的小孩\n\n![“恋人”](http://o8cfktdb3.bkt.clouddn.com/lover.jpeg)  \n恋人\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=28476557&auto=1&height=66\"></iframe>\n","slug":"798艺术区","published":1,"updated":"2017-07-14T03:57:06.000Z","layout":"post","photos":[],"link":"","_id":"cj53c1duu0003h3jjthpdgoeo","content":"<p>2017-06-04 北京798艺术区</p>\n<p><img src=\"http://o8cfktdb3.bkt.clouddn.com/line.jpeg\" alt=\"“抽象画”\"><br>抽象画<br><a id=\"more\"></a></p>\n<p><img src=\"http://o8cfktdb3.bkt.clouddn.com/chinese.jpeg\" alt=\"“陶瓷”\"><br>各种小陶瓷</p>\n<p><img src=\"http://o8cfktdb3.bkt.clouddn.com/cat.jpeg\" alt=\"“卡哇伊”\"><br>猫咪，卡哇伊</p>\n<p><img src=\"http://o8cfktdb3.bkt.clouddn.com/brain.jpeg\" alt=\"“brain”\"><br>brain</p>\n<p><img src=\"http://o8cfktdb3.bkt.clouddn.com/redpeople.jpeg\" alt=\"“red people”\"><br>red people</p>\n<p><img src=\"http://o8cfktdb3.bkt.clouddn.com/unknown.jpeg\" alt=\"“未名”\"><br>未名</p>\n<p><img src=\"http://o8cfktdb3.bkt.clouddn.com/child.jpeg\" alt=\"“孤独的小孩”\"><br>孤独的小孩</p>\n<p><img src=\"http://o8cfktdb3.bkt.clouddn.com/lover.jpeg\" alt=\"“恋人”\"><br>恋人</p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=28476557&auto=1&height=66\"></iframe>\n","site":{"data":{}},"excerpt":"<p>2017-06-04 北京798艺术区</p>\n<p><img src=\"http://o8cfktdb3.bkt.clouddn.com/line.jpeg\" alt=\"“抽象画”\"><br>抽象画<br>","more":"</p>\n<p><img src=\"http://o8cfktdb3.bkt.clouddn.com/chinese.jpeg\" alt=\"“陶瓷”\"><br>各种小陶瓷</p>\n<p><img src=\"http://o8cfktdb3.bkt.clouddn.com/cat.jpeg\" alt=\"“卡哇伊”\"><br>猫咪，卡哇伊</p>\n<p><img src=\"http://o8cfktdb3.bkt.clouddn.com/brain.jpeg\" alt=\"“brain”\"><br>brain</p>\n<p><img src=\"http://o8cfktdb3.bkt.clouddn.com/redpeople.jpeg\" alt=\"“red people”\"><br>red people</p>\n<p><img src=\"http://o8cfktdb3.bkt.clouddn.com/unknown.jpeg\" alt=\"“未名”\"><br>未名</p>\n<p><img src=\"http://o8cfktdb3.bkt.clouddn.com/child.jpeg\" alt=\"“孤独的小孩”\"><br>孤独的小孩</p>\n<p><img src=\"http://o8cfktdb3.bkt.clouddn.com/lover.jpeg\" alt=\"“恋人”\"><br>恋人</p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=28476557&auto=1&height=66\"></iframe>"},{"title":"Apple Pay学习笔记","date":"2017-03-15T08:37:17.000Z","_content":"## 概述\n### 1.支付方式：Touch ID/ Passcode\n### 2.设备要求：iPhone6以上（iphone:线上/线下 ipad:线上 watch:线下）\n### 3.系统要求：iOS8.0以上，银联（中国）：9.2\n<!--more-->\n### 4.基于NFC\n### 5.2014年10月20日在美国正式上线，2016年2月18日凌晨5：00， Apple Pay 业务在中国上线。\n### 6.与微信支付以及支付宝等第三方支付平台的区别：\n* 硬件方面\n    + Apple Pay：必须是iOS设备， 而且是按照线上支付和线下支付区分不同的真机设备（具体参考表1）\n    + 微信、支付宝： 基本跟硬件设备无关， 支持大多数的只能手机\n* 网络环境要求\n    + Apple Pay：线上支付需要联网， 线下支付无需联网就可以支付\n    + 微信、支付宝： 无论是线上还是线下支付， 都需要联网使用\n* 使用技术\n    + Apple Pay：线下支付使用的是 基于NFC的近场通讯技术\n    + 微信、支付宝： 线下支付使用的是 扫码支付（条形码、二维码）\n* 主要功能\n    + Apple Pay：线上支付、线下支付、部分升级后的ATM机可以取款\n    + 微信、支付宝： 线上支付、线下支付、转账、理财等  \n* 安全性能\n    + Apple Pay：不保留银行卡信息，并且不会暴漏给外界、不分流银行存款（不需要从银行卡转钱到另外一个平台）、不能充值  安全性较高\n    + 微信、支付宝： 密码保护，身份验证等手段保护账户  安全性相对稍差\n* 支付时长\n    + Apple Pay：无论是线上支付，还是线下支付， 只需要验证指纹即可支付。非常迅速\n    + 微信、支付宝： 需要扫码支付， 流程相对繁琐，所以时长较长\n* 各自弊端\n    + Apple Pay：只适用于苹果设备， 支付场景单一，无转账理财等业务\n    + 微信、支付宝： 安全性较差， 必须联网操作，需要充值到对应平台\n\n## 注册并配置一个商业标示符\n1.添加一个App ID\n2.配置Merchant ID\n3.为Merchant ID 配置证书, 并下载证书安装到钥匙串\n4.检查安装到钥匙串中的证书是否有效\n5.绑定Merchant ID 到 APP ID\n\n证书失效，请到以下地址下载重新安装：https://www.apple.com/certificateauthority/\n![证书](http://o8cfktdb3.bkt.clouddn.com/applepay.png)\n\n## 代码实现\n\n```\n//一.判断当前设备是否支持支付\n\nif (![PKPaymentAuthorizationViewController canMakePayments]) {\n\nNSLog(@\"该设备不支持ApplePay\");\n\nreturn;\n\n\n\n//二.判断Wallet有没有添加该支付网络的储蓄卡/信用卡\n\n}else if ([PKPaymentAuthorizationViewController canMakePaymentsUsingNetworks:@[PKPaymentNetworkChinaUnionPay,PKPaymentNetworkVisa]]){\n\nNSLog(@\"Wallet没有添加该支付网络的储蓄卡/信用卡\");\n\n//创建一个添加卡的按钮\n\nPKPaymentButton *btn = [PKPaymentButton buttonWithType:PKPaymentButtonTypeSetUp style:PKPaymentButtonStyleBlack];\n\n[btn addTarget:self action:@selector(jumpToSetup) forControlEvents:UIControlEventTouchUpInside];\n\n[self.payView addSubview:btn];        \n\n}else{\n\n//创建一个支付按钮\n\nPKPaymentButton *btn = [PKPaymentButton buttonWithType:PKPaymentButtonTypeBuy style:PKPaymentButtonStyleWhiteOutline];\n\n[btn addTarget:self action:@selector(jumpToPay) forControlEvents:UIControlEventTouchUpInside];\n\n[self.payView addSubview:btn];\n\n}\n\n\n\n- (void)jumpToSetup{\n\n\n\nNSLog(@\"跳转到添加银行卡页面\");\n\n\n\nPKPassLibrary * pk = [[PKPassLibrary alloc]init];\n\n[pk openPaymentSetup];\n\n}\n\n\n\n- (void)jumpToPay{\n\n\n\n//三.创建支付请求并配置各项信息\n\n\n\n//1.创建支付请求\n\nPKPaymentRequest *request = [[PKPaymentRequest alloc]init];\n\n\n\n//2.配置参数\n\n//2.1 商店标识\n\nrequest.merchantIdentifier = @\"\";\n\n//2.2 国家代码\n\nrequest.countryCode = @\"CN\";\n\n//2.3 货币代码\n\nrequest.currencyCode = @\"CNY\";\n\n//2.4 支持的支付网络\n\nrequest.supportedNetworks = @[PKPaymentNetworkChinaUnionPay,PKPaymentNetworkVisa];\n\n//2.5 支付请求包含一个支付摘要项目的列表\n\nNSDecimalNumber *price1 = [NSDecimalNumber decimalNumberWithString:@\"10.0\"];\n\nPKPaymentSummaryItem *item1 = [PKPaymentSummaryItem summaryItemWithLabel:@\"iPhone\" amount:price1];\n\n\n\nNSDecimalNumber *price2 = [NSDecimalNumber decimalNumberWithString:@\"20.0\"];\n\nPKPaymentSummaryItem *item2 = [PKPaymentSummaryItem summaryItemWithLabel:@\"iPad\" amount:price2 type:PKPaymentSummaryItemTypePending];\n\n\n\nNSDecimalNumber *totalPrice = [NSDecimalNumber zero];\n\ntotalPrice = [totalPrice decimalNumberByAdding:price1];\n\ntotalPrice = [totalPrice decimalNumberByAdding:price2];\n\nPKPaymentSummaryItem *total = [PKPaymentSummaryItem summaryItemWithLabel:@\"财务中心\" amount:totalPrice type:PKPaymentSummaryItemTypePending];\n\n//注意：数组最后一个是总价格\n\nrequest.paymentSummaryItems = @[item1,item2,total];\n\n//2.6运输方式\n\nNSDecimalNumber *shippingPrice = [NSDecimalNumber decimalNumberWithString:@\"18.0\"];\n\nPKShippingMethod *method = [PKShippingMethod summaryItemWithLabel:@\"顺风快递\" amount:shippingPrice];\n\nmethod.identifier = @\"shunfeng\";\n\nmethod.detail = @\"24小时内送到\";\n\nrequest.shippingMethods = @[method];\n\nrequest.shippingType = PKShippingTypeServicePickup;\n\n//2.7通过指定merchantCapabilities属性来指定你支持的支付处理标准，3DS支付方式是必须支持的，EMV方式是可选的\n\nrequest.merchantCapabilities = PKMerchantCapability3DS | PKMerchantCapabilityEMV | PKMerchantCapabilityCredit | PKMerchantCapabilityDebit;\n\n//2.8需要的配送信息和账单信息\n\nrequest.requiredBillingAddressFields = PKAddressFieldAll;\n\nrequest.requiredShippingAddressFields = PKAddressFieldAll;\n\n\n\n//2.9 存储额外信息\n\nrequest.applicationData = [@\"购物车ID：123456\" dataUsingEncoding:NSUTF8StringEncoding];\n\n\n\n//四.弹出授权控制器，让用户给支付授权\n\n//开始支付\n\nPKPaymentAuthorizationViewController *pkCtrl = [[PKPaymentAuthorizationViewController alloc]initWithPaymentRequest:request];\n\nif (pkCtrl == nil) {\n\nNSLog(@\"授权控制器创建失败\");\n\nreturn;\n\n}\n\npkCtrl.delegate = self;\n\n[self presentViewController:pkCtrl animated:YES completion:nil];\n\n}\n\n\n\n#pragma mark - PKPaymentAuthorizationViewControllerDelegate\n\n//五.处理支付凭证\n\n//授权成功\n\n- (void)paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)controller\n\ndidAuthorizePayment:(PKPayment *)payment\n\ncompletion:(void (^)(PKPaymentAuthorizationStatus status))completion{\n\n\n\n/*\n\n服务器接收到token后的一般处理流程:\n\n1.验证支付数据的哈希表和签名\n\n2.为加密过的支付数据解码\n\n3.向支付处理系统提交支付数据\n\n4.向订单追踪系统提交订单\n\n*/\n\nNSLog(@\"验证授权---%@\",payment.token);\n\n/*\n\n处理支付请求时，你有两个选择:\n\n1.你既可以利用支付平台处理支付请求，\n\n2.也可以自己实现支付请求处理流程。\n\n一个常用的支付平台可以完成上述大部分操作。\n\n*/\n\nNSLog(@\"验证通过后，需要开发中继续完成交易\");\n\nBOOL isSuccess = YES;\n\nif (isSuccess) {\n\ncompletion(PKPaymentAuthorizationStatusSuccess);\n\n}else{\n\ncompletion(PKPaymentAuthorizationStatusFailure);\n\n}\n\n\n\n}\n\n//六.关闭授权控制器\n\n//授权成功或者取消授权之后会调用此方法\n\n- (void)paymentAuthorizationViewControllerDidFinish:(PKPaymentAuthorizationViewController *)controller{\n\n\n\nNSLog(@\"取消或者交易完成\");\n\n[self dismissViewControllerAnimated:YES completion:nil];\n\n}\n```\n\n转自：[Apple Pay--iOS开发](http://www.cnblogs.com/dashunzi/archive/2016/02/23/ApplePay.html#undefined)\n","source":"_posts/Apple-Pay学习笔记.md","raw":"---\ntitle: Apple Pay学习笔记\ndate: 2017-03-15 16:37:17\ncategories: 笔记\ntags: [iOS,Apple Pay]\n---\n## 概述\n### 1.支付方式：Touch ID/ Passcode\n### 2.设备要求：iPhone6以上（iphone:线上/线下 ipad:线上 watch:线下）\n### 3.系统要求：iOS8.0以上，银联（中国）：9.2\n<!--more-->\n### 4.基于NFC\n### 5.2014年10月20日在美国正式上线，2016年2月18日凌晨5：00， Apple Pay 业务在中国上线。\n### 6.与微信支付以及支付宝等第三方支付平台的区别：\n* 硬件方面\n    + Apple Pay：必须是iOS设备， 而且是按照线上支付和线下支付区分不同的真机设备（具体参考表1）\n    + 微信、支付宝： 基本跟硬件设备无关， 支持大多数的只能手机\n* 网络环境要求\n    + Apple Pay：线上支付需要联网， 线下支付无需联网就可以支付\n    + 微信、支付宝： 无论是线上还是线下支付， 都需要联网使用\n* 使用技术\n    + Apple Pay：线下支付使用的是 基于NFC的近场通讯技术\n    + 微信、支付宝： 线下支付使用的是 扫码支付（条形码、二维码）\n* 主要功能\n    + Apple Pay：线上支付、线下支付、部分升级后的ATM机可以取款\n    + 微信、支付宝： 线上支付、线下支付、转账、理财等  \n* 安全性能\n    + Apple Pay：不保留银行卡信息，并且不会暴漏给外界、不分流银行存款（不需要从银行卡转钱到另外一个平台）、不能充值  安全性较高\n    + 微信、支付宝： 密码保护，身份验证等手段保护账户  安全性相对稍差\n* 支付时长\n    + Apple Pay：无论是线上支付，还是线下支付， 只需要验证指纹即可支付。非常迅速\n    + 微信、支付宝： 需要扫码支付， 流程相对繁琐，所以时长较长\n* 各自弊端\n    + Apple Pay：只适用于苹果设备， 支付场景单一，无转账理财等业务\n    + 微信、支付宝： 安全性较差， 必须联网操作，需要充值到对应平台\n\n## 注册并配置一个商业标示符\n1.添加一个App ID\n2.配置Merchant ID\n3.为Merchant ID 配置证书, 并下载证书安装到钥匙串\n4.检查安装到钥匙串中的证书是否有效\n5.绑定Merchant ID 到 APP ID\n\n证书失效，请到以下地址下载重新安装：https://www.apple.com/certificateauthority/\n![证书](http://o8cfktdb3.bkt.clouddn.com/applepay.png)\n\n## 代码实现\n\n```\n//一.判断当前设备是否支持支付\n\nif (![PKPaymentAuthorizationViewController canMakePayments]) {\n\nNSLog(@\"该设备不支持ApplePay\");\n\nreturn;\n\n\n\n//二.判断Wallet有没有添加该支付网络的储蓄卡/信用卡\n\n}else if ([PKPaymentAuthorizationViewController canMakePaymentsUsingNetworks:@[PKPaymentNetworkChinaUnionPay,PKPaymentNetworkVisa]]){\n\nNSLog(@\"Wallet没有添加该支付网络的储蓄卡/信用卡\");\n\n//创建一个添加卡的按钮\n\nPKPaymentButton *btn = [PKPaymentButton buttonWithType:PKPaymentButtonTypeSetUp style:PKPaymentButtonStyleBlack];\n\n[btn addTarget:self action:@selector(jumpToSetup) forControlEvents:UIControlEventTouchUpInside];\n\n[self.payView addSubview:btn];        \n\n}else{\n\n//创建一个支付按钮\n\nPKPaymentButton *btn = [PKPaymentButton buttonWithType:PKPaymentButtonTypeBuy style:PKPaymentButtonStyleWhiteOutline];\n\n[btn addTarget:self action:@selector(jumpToPay) forControlEvents:UIControlEventTouchUpInside];\n\n[self.payView addSubview:btn];\n\n}\n\n\n\n- (void)jumpToSetup{\n\n\n\nNSLog(@\"跳转到添加银行卡页面\");\n\n\n\nPKPassLibrary * pk = [[PKPassLibrary alloc]init];\n\n[pk openPaymentSetup];\n\n}\n\n\n\n- (void)jumpToPay{\n\n\n\n//三.创建支付请求并配置各项信息\n\n\n\n//1.创建支付请求\n\nPKPaymentRequest *request = [[PKPaymentRequest alloc]init];\n\n\n\n//2.配置参数\n\n//2.1 商店标识\n\nrequest.merchantIdentifier = @\"\";\n\n//2.2 国家代码\n\nrequest.countryCode = @\"CN\";\n\n//2.3 货币代码\n\nrequest.currencyCode = @\"CNY\";\n\n//2.4 支持的支付网络\n\nrequest.supportedNetworks = @[PKPaymentNetworkChinaUnionPay,PKPaymentNetworkVisa];\n\n//2.5 支付请求包含一个支付摘要项目的列表\n\nNSDecimalNumber *price1 = [NSDecimalNumber decimalNumberWithString:@\"10.0\"];\n\nPKPaymentSummaryItem *item1 = [PKPaymentSummaryItem summaryItemWithLabel:@\"iPhone\" amount:price1];\n\n\n\nNSDecimalNumber *price2 = [NSDecimalNumber decimalNumberWithString:@\"20.0\"];\n\nPKPaymentSummaryItem *item2 = [PKPaymentSummaryItem summaryItemWithLabel:@\"iPad\" amount:price2 type:PKPaymentSummaryItemTypePending];\n\n\n\nNSDecimalNumber *totalPrice = [NSDecimalNumber zero];\n\ntotalPrice = [totalPrice decimalNumberByAdding:price1];\n\ntotalPrice = [totalPrice decimalNumberByAdding:price2];\n\nPKPaymentSummaryItem *total = [PKPaymentSummaryItem summaryItemWithLabel:@\"财务中心\" amount:totalPrice type:PKPaymentSummaryItemTypePending];\n\n//注意：数组最后一个是总价格\n\nrequest.paymentSummaryItems = @[item1,item2,total];\n\n//2.6运输方式\n\nNSDecimalNumber *shippingPrice = [NSDecimalNumber decimalNumberWithString:@\"18.0\"];\n\nPKShippingMethod *method = [PKShippingMethod summaryItemWithLabel:@\"顺风快递\" amount:shippingPrice];\n\nmethod.identifier = @\"shunfeng\";\n\nmethod.detail = @\"24小时内送到\";\n\nrequest.shippingMethods = @[method];\n\nrequest.shippingType = PKShippingTypeServicePickup;\n\n//2.7通过指定merchantCapabilities属性来指定你支持的支付处理标准，3DS支付方式是必须支持的，EMV方式是可选的\n\nrequest.merchantCapabilities = PKMerchantCapability3DS | PKMerchantCapabilityEMV | PKMerchantCapabilityCredit | PKMerchantCapabilityDebit;\n\n//2.8需要的配送信息和账单信息\n\nrequest.requiredBillingAddressFields = PKAddressFieldAll;\n\nrequest.requiredShippingAddressFields = PKAddressFieldAll;\n\n\n\n//2.9 存储额外信息\n\nrequest.applicationData = [@\"购物车ID：123456\" dataUsingEncoding:NSUTF8StringEncoding];\n\n\n\n//四.弹出授权控制器，让用户给支付授权\n\n//开始支付\n\nPKPaymentAuthorizationViewController *pkCtrl = [[PKPaymentAuthorizationViewController alloc]initWithPaymentRequest:request];\n\nif (pkCtrl == nil) {\n\nNSLog(@\"授权控制器创建失败\");\n\nreturn;\n\n}\n\npkCtrl.delegate = self;\n\n[self presentViewController:pkCtrl animated:YES completion:nil];\n\n}\n\n\n\n#pragma mark - PKPaymentAuthorizationViewControllerDelegate\n\n//五.处理支付凭证\n\n//授权成功\n\n- (void)paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)controller\n\ndidAuthorizePayment:(PKPayment *)payment\n\ncompletion:(void (^)(PKPaymentAuthorizationStatus status))completion{\n\n\n\n/*\n\n服务器接收到token后的一般处理流程:\n\n1.验证支付数据的哈希表和签名\n\n2.为加密过的支付数据解码\n\n3.向支付处理系统提交支付数据\n\n4.向订单追踪系统提交订单\n\n*/\n\nNSLog(@\"验证授权---%@\",payment.token);\n\n/*\n\n处理支付请求时，你有两个选择:\n\n1.你既可以利用支付平台处理支付请求，\n\n2.也可以自己实现支付请求处理流程。\n\n一个常用的支付平台可以完成上述大部分操作。\n\n*/\n\nNSLog(@\"验证通过后，需要开发中继续完成交易\");\n\nBOOL isSuccess = YES;\n\nif (isSuccess) {\n\ncompletion(PKPaymentAuthorizationStatusSuccess);\n\n}else{\n\ncompletion(PKPaymentAuthorizationStatusFailure);\n\n}\n\n\n\n}\n\n//六.关闭授权控制器\n\n//授权成功或者取消授权之后会调用此方法\n\n- (void)paymentAuthorizationViewControllerDidFinish:(PKPaymentAuthorizationViewController *)controller{\n\n\n\nNSLog(@\"取消或者交易完成\");\n\n[self dismissViewControllerAnimated:YES completion:nil];\n\n}\n```\n\n转自：[Apple Pay--iOS开发](http://www.cnblogs.com/dashunzi/archive/2016/02/23/ApplePay.html#undefined)\n","slug":"Apple-Pay学习笔记","published":1,"updated":"2017-07-14T03:57:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj53c1duz0006h3jjrljh1lt6","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"1-支付方式：Touch-ID-Passcode\"><a href=\"#1-支付方式：Touch-ID-Passcode\" class=\"headerlink\" title=\"1.支付方式：Touch ID/ Passcode\"></a>1.支付方式：Touch ID/ Passcode</h3><h3 id=\"2-设备要求：iPhone6以上（iphone-线上-线下-ipad-线上-watch-线下）\"><a href=\"#2-设备要求：iPhone6以上（iphone-线上-线下-ipad-线上-watch-线下）\" class=\"headerlink\" title=\"2.设备要求：iPhone6以上（iphone:线上/线下 ipad:线上 watch:线下）\"></a>2.设备要求：iPhone6以上（iphone:线上/线下 ipad:线上 watch:线下）</h3><h3 id=\"3-系统要求：iOS8-0以上，银联（中国）：9-2\"><a href=\"#3-系统要求：iOS8-0以上，银联（中国）：9-2\" class=\"headerlink\" title=\"3.系统要求：iOS8.0以上，银联（中国）：9.2\"></a>3.系统要求：iOS8.0以上，银联（中国）：9.2</h3><a id=\"more\"></a>\n<h3 id=\"4-基于NFC\"><a href=\"#4-基于NFC\" class=\"headerlink\" title=\"4.基于NFC\"></a>4.基于NFC</h3><h3 id=\"5-2014年10月20日在美国正式上线，2016年2月18日凌晨5：00，-Apple-Pay-业务在中国上线。\"><a href=\"#5-2014年10月20日在美国正式上线，2016年2月18日凌晨5：00，-Apple-Pay-业务在中国上线。\" class=\"headerlink\" title=\"5.2014年10月20日在美国正式上线，2016年2月18日凌晨5：00， Apple Pay 业务在中国上线。\"></a>5.2014年10月20日在美国正式上线，2016年2月18日凌晨5：00， Apple Pay 业务在中国上线。</h3><h3 id=\"6-与微信支付以及支付宝等第三方支付平台的区别：\"><a href=\"#6-与微信支付以及支付宝等第三方支付平台的区别：\" class=\"headerlink\" title=\"6.与微信支付以及支付宝等第三方支付平台的区别：\"></a>6.与微信支付以及支付宝等第三方支付平台的区别：</h3><ul>\n<li>硬件方面<ul>\n<li>Apple Pay：必须是iOS设备， 而且是按照线上支付和线下支付区分不同的真机设备（具体参考表1）</li>\n<li>微信、支付宝： 基本跟硬件设备无关， 支持大多数的只能手机</li>\n</ul>\n</li>\n<li>网络环境要求<ul>\n<li>Apple Pay：线上支付需要联网， 线下支付无需联网就可以支付</li>\n<li>微信、支付宝： 无论是线上还是线下支付， 都需要联网使用</li>\n</ul>\n</li>\n<li>使用技术<ul>\n<li>Apple Pay：线下支付使用的是 基于NFC的近场通讯技术</li>\n<li>微信、支付宝： 线下支付使用的是 扫码支付（条形码、二维码）</li>\n</ul>\n</li>\n<li>主要功能<ul>\n<li>Apple Pay：线上支付、线下支付、部分升级后的ATM机可以取款</li>\n<li>微信、支付宝： 线上支付、线下支付、转账、理财等  </li>\n</ul>\n</li>\n<li>安全性能<ul>\n<li>Apple Pay：不保留银行卡信息，并且不会暴漏给外界、不分流银行存款（不需要从银行卡转钱到另外一个平台）、不能充值  安全性较高</li>\n<li>微信、支付宝： 密码保护，身份验证等手段保护账户  安全性相对稍差</li>\n</ul>\n</li>\n<li>支付时长<ul>\n<li>Apple Pay：无论是线上支付，还是线下支付， 只需要验证指纹即可支付。非常迅速</li>\n<li>微信、支付宝： 需要扫码支付， 流程相对繁琐，所以时长较长</li>\n</ul>\n</li>\n<li>各自弊端<ul>\n<li>Apple Pay：只适用于苹果设备， 支付场景单一，无转账理财等业务</li>\n<li>微信、支付宝： 安全性较差， 必须联网操作，需要充值到对应平台</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"注册并配置一个商业标示符\"><a href=\"#注册并配置一个商业标示符\" class=\"headerlink\" title=\"注册并配置一个商业标示符\"></a>注册并配置一个商业标示符</h2><p>1.添加一个App ID<br>2.配置Merchant ID<br>3.为Merchant ID 配置证书, 并下载证书安装到钥匙串<br>4.检查安装到钥匙串中的证书是否有效<br>5.绑定Merchant ID 到 APP ID</p>\n<p>证书失效，请到以下地址下载重新安装：<a href=\"https://www.apple.com/certificateauthority/\" target=\"_blank\" rel=\"external\">https://www.apple.com/certificateauthority/</a><br><img src=\"http://o8cfktdb3.bkt.clouddn.com/applepay.png\" alt=\"证书\"></p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div></pre></td><td class=\"code\"><pre><div class=\"line\">//一.判断当前设备是否支持支付</div><div class=\"line\"></div><div class=\"line\">if (![PKPaymentAuthorizationViewController canMakePayments]) &#123;</div><div class=\"line\"></div><div class=\"line\">NSLog(@&quot;该设备不支持ApplePay&quot;);</div><div class=\"line\"></div><div class=\"line\">return;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//二.判断Wallet有没有添加该支付网络的储蓄卡/信用卡</div><div class=\"line\"></div><div class=\"line\">&#125;else if ([PKPaymentAuthorizationViewController canMakePaymentsUsingNetworks:@[PKPaymentNetworkChinaUnionPay,PKPaymentNetworkVisa]])&#123;</div><div class=\"line\"></div><div class=\"line\">NSLog(@&quot;Wallet没有添加该支付网络的储蓄卡/信用卡&quot;);</div><div class=\"line\"></div><div class=\"line\">//创建一个添加卡的按钮</div><div class=\"line\"></div><div class=\"line\">PKPaymentButton *btn = [PKPaymentButton buttonWithType:PKPaymentButtonTypeSetUp style:PKPaymentButtonStyleBlack];</div><div class=\"line\"></div><div class=\"line\">[btn addTarget:self action:@selector(jumpToSetup) forControlEvents:UIControlEventTouchUpInside];</div><div class=\"line\"></div><div class=\"line\">[self.payView addSubview:btn];        </div><div class=\"line\"></div><div class=\"line\">&#125;else&#123;</div><div class=\"line\"></div><div class=\"line\">//创建一个支付按钮</div><div class=\"line\"></div><div class=\"line\">PKPaymentButton *btn = [PKPaymentButton buttonWithType:PKPaymentButtonTypeBuy style:PKPaymentButtonStyleWhiteOutline];</div><div class=\"line\"></div><div class=\"line\">[btn addTarget:self action:@selector(jumpToPay) forControlEvents:UIControlEventTouchUpInside];</div><div class=\"line\"></div><div class=\"line\">[self.payView addSubview:btn];</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">- (void)jumpToSetup&#123;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">NSLog(@&quot;跳转到添加银行卡页面&quot;);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">PKPassLibrary * pk = [[PKPassLibrary alloc]init];</div><div class=\"line\"></div><div class=\"line\">[pk openPaymentSetup];</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">- (void)jumpToPay&#123;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//三.创建支付请求并配置各项信息</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//1.创建支付请求</div><div class=\"line\"></div><div class=\"line\">PKPaymentRequest *request = [[PKPaymentRequest alloc]init];</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//2.配置参数</div><div class=\"line\"></div><div class=\"line\">//2.1 商店标识</div><div class=\"line\"></div><div class=\"line\">request.merchantIdentifier = @&quot;&quot;;</div><div class=\"line\"></div><div class=\"line\">//2.2 国家代码</div><div class=\"line\"></div><div class=\"line\">request.countryCode = @&quot;CN&quot;;</div><div class=\"line\"></div><div class=\"line\">//2.3 货币代码</div><div class=\"line\"></div><div class=\"line\">request.currencyCode = @&quot;CNY&quot;;</div><div class=\"line\"></div><div class=\"line\">//2.4 支持的支付网络</div><div class=\"line\"></div><div class=\"line\">request.supportedNetworks = @[PKPaymentNetworkChinaUnionPay,PKPaymentNetworkVisa];</div><div class=\"line\"></div><div class=\"line\">//2.5 支付请求包含一个支付摘要项目的列表</div><div class=\"line\"></div><div class=\"line\">NSDecimalNumber *price1 = [NSDecimalNumber decimalNumberWithString:@&quot;10.0&quot;];</div><div class=\"line\"></div><div class=\"line\">PKPaymentSummaryItem *item1 = [PKPaymentSummaryItem summaryItemWithLabel:@&quot;iPhone&quot; amount:price1];</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">NSDecimalNumber *price2 = [NSDecimalNumber decimalNumberWithString:@&quot;20.0&quot;];</div><div class=\"line\"></div><div class=\"line\">PKPaymentSummaryItem *item2 = [PKPaymentSummaryItem summaryItemWithLabel:@&quot;iPad&quot; amount:price2 type:PKPaymentSummaryItemTypePending];</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">NSDecimalNumber *totalPrice = [NSDecimalNumber zero];</div><div class=\"line\"></div><div class=\"line\">totalPrice = [totalPrice decimalNumberByAdding:price1];</div><div class=\"line\"></div><div class=\"line\">totalPrice = [totalPrice decimalNumberByAdding:price2];</div><div class=\"line\"></div><div class=\"line\">PKPaymentSummaryItem *total = [PKPaymentSummaryItem summaryItemWithLabel:@&quot;财务中心&quot; amount:totalPrice type:PKPaymentSummaryItemTypePending];</div><div class=\"line\"></div><div class=\"line\">//注意：数组最后一个是总价格</div><div class=\"line\"></div><div class=\"line\">request.paymentSummaryItems = @[item1,item2,total];</div><div class=\"line\"></div><div class=\"line\">//2.6运输方式</div><div class=\"line\"></div><div class=\"line\">NSDecimalNumber *shippingPrice = [NSDecimalNumber decimalNumberWithString:@&quot;18.0&quot;];</div><div class=\"line\"></div><div class=\"line\">PKShippingMethod *method = [PKShippingMethod summaryItemWithLabel:@&quot;顺风快递&quot; amount:shippingPrice];</div><div class=\"line\"></div><div class=\"line\">method.identifier = @&quot;shunfeng&quot;;</div><div class=\"line\"></div><div class=\"line\">method.detail = @&quot;24小时内送到&quot;;</div><div class=\"line\"></div><div class=\"line\">request.shippingMethods = @[method];</div><div class=\"line\"></div><div class=\"line\">request.shippingType = PKShippingTypeServicePickup;</div><div class=\"line\"></div><div class=\"line\">//2.7通过指定merchantCapabilities属性来指定你支持的支付处理标准，3DS支付方式是必须支持的，EMV方式是可选的</div><div class=\"line\"></div><div class=\"line\">request.merchantCapabilities = PKMerchantCapability3DS | PKMerchantCapabilityEMV | PKMerchantCapabilityCredit | PKMerchantCapabilityDebit;</div><div class=\"line\"></div><div class=\"line\">//2.8需要的配送信息和账单信息</div><div class=\"line\"></div><div class=\"line\">request.requiredBillingAddressFields = PKAddressFieldAll;</div><div class=\"line\"></div><div class=\"line\">request.requiredShippingAddressFields = PKAddressFieldAll;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//2.9 存储额外信息</div><div class=\"line\"></div><div class=\"line\">request.applicationData = [@&quot;购物车ID：123456&quot; dataUsingEncoding:NSUTF8StringEncoding];</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//四.弹出授权控制器，让用户给支付授权</div><div class=\"line\"></div><div class=\"line\">//开始支付</div><div class=\"line\"></div><div class=\"line\">PKPaymentAuthorizationViewController *pkCtrl = [[PKPaymentAuthorizationViewController alloc]initWithPaymentRequest:request];</div><div class=\"line\"></div><div class=\"line\">if (pkCtrl == nil) &#123;</div><div class=\"line\"></div><div class=\"line\">NSLog(@&quot;授权控制器创建失败&quot;);</div><div class=\"line\"></div><div class=\"line\">return;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">pkCtrl.delegate = self;</div><div class=\"line\"></div><div class=\"line\">[self presentViewController:pkCtrl animated:YES completion:nil];</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#pragma mark - PKPaymentAuthorizationViewControllerDelegate</div><div class=\"line\"></div><div class=\"line\">//五.处理支付凭证</div><div class=\"line\"></div><div class=\"line\">//授权成功</div><div class=\"line\"></div><div class=\"line\">- (void)paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)controller</div><div class=\"line\"></div><div class=\"line\">didAuthorizePayment:(PKPayment *)payment</div><div class=\"line\"></div><div class=\"line\">completion:(void (^)(PKPaymentAuthorizationStatus status))completion&#123;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">/*</div><div class=\"line\"></div><div class=\"line\">服务器接收到token后的一般处理流程:</div><div class=\"line\"></div><div class=\"line\">1.验证支付数据的哈希表和签名</div><div class=\"line\"></div><div class=\"line\">2.为加密过的支付数据解码</div><div class=\"line\"></div><div class=\"line\">3.向支付处理系统提交支付数据</div><div class=\"line\"></div><div class=\"line\">4.向订单追踪系统提交订单</div><div class=\"line\"></div><div class=\"line\">*/</div><div class=\"line\"></div><div class=\"line\">NSLog(@&quot;验证授权---%@&quot;,payment.token);</div><div class=\"line\"></div><div class=\"line\">/*</div><div class=\"line\"></div><div class=\"line\">处理支付请求时，你有两个选择:</div><div class=\"line\"></div><div class=\"line\">1.你既可以利用支付平台处理支付请求，</div><div class=\"line\"></div><div class=\"line\">2.也可以自己实现支付请求处理流程。</div><div class=\"line\"></div><div class=\"line\">一个常用的支付平台可以完成上述大部分操作。</div><div class=\"line\"></div><div class=\"line\">*/</div><div class=\"line\"></div><div class=\"line\">NSLog(@&quot;验证通过后，需要开发中继续完成交易&quot;);</div><div class=\"line\"></div><div class=\"line\">BOOL isSuccess = YES;</div><div class=\"line\"></div><div class=\"line\">if (isSuccess) &#123;</div><div class=\"line\"></div><div class=\"line\">completion(PKPaymentAuthorizationStatusSuccess);</div><div class=\"line\"></div><div class=\"line\">&#125;else&#123;</div><div class=\"line\"></div><div class=\"line\">completion(PKPaymentAuthorizationStatusFailure);</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//六.关闭授权控制器</div><div class=\"line\"></div><div class=\"line\">//授权成功或者取消授权之后会调用此方法</div><div class=\"line\"></div><div class=\"line\">- (void)paymentAuthorizationViewControllerDidFinish:(PKPaymentAuthorizationViewController *)controller&#123;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">NSLog(@&quot;取消或者交易完成&quot;);</div><div class=\"line\"></div><div class=\"line\">[self dismissViewControllerAnimated:YES completion:nil];</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>转自：<a href=\"http://www.cnblogs.com/dashunzi/archive/2016/02/23/ApplePay.html#undefined\" target=\"_blank\" rel=\"external\">Apple Pay–iOS开发</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"1-支付方式：Touch-ID-Passcode\"><a href=\"#1-支付方式：Touch-ID-Passcode\" class=\"headerlink\" title=\"1.支付方式：Touch ID/ Passcode\"></a>1.支付方式：Touch ID/ Passcode</h3><h3 id=\"2-设备要求：iPhone6以上（iphone-线上-线下-ipad-线上-watch-线下）\"><a href=\"#2-设备要求：iPhone6以上（iphone-线上-线下-ipad-线上-watch-线下）\" class=\"headerlink\" title=\"2.设备要求：iPhone6以上（iphone:线上/线下 ipad:线上 watch:线下）\"></a>2.设备要求：iPhone6以上（iphone:线上/线下 ipad:线上 watch:线下）</h3><h3 id=\"3-系统要求：iOS8-0以上，银联（中国）：9-2\"><a href=\"#3-系统要求：iOS8-0以上，银联（中国）：9-2\" class=\"headerlink\" title=\"3.系统要求：iOS8.0以上，银联（中国）：9.2\"></a>3.系统要求：iOS8.0以上，银联（中国）：9.2</h3>","more":"<h3 id=\"4-基于NFC\"><a href=\"#4-基于NFC\" class=\"headerlink\" title=\"4.基于NFC\"></a>4.基于NFC</h3><h3 id=\"5-2014年10月20日在美国正式上线，2016年2月18日凌晨5：00，-Apple-Pay-业务在中国上线。\"><a href=\"#5-2014年10月20日在美国正式上线，2016年2月18日凌晨5：00，-Apple-Pay-业务在中国上线。\" class=\"headerlink\" title=\"5.2014年10月20日在美国正式上线，2016年2月18日凌晨5：00， Apple Pay 业务在中国上线。\"></a>5.2014年10月20日在美国正式上线，2016年2月18日凌晨5：00， Apple Pay 业务在中国上线。</h3><h3 id=\"6-与微信支付以及支付宝等第三方支付平台的区别：\"><a href=\"#6-与微信支付以及支付宝等第三方支付平台的区别：\" class=\"headerlink\" title=\"6.与微信支付以及支付宝等第三方支付平台的区别：\"></a>6.与微信支付以及支付宝等第三方支付平台的区别：</h3><ul>\n<li>硬件方面<ul>\n<li>Apple Pay：必须是iOS设备， 而且是按照线上支付和线下支付区分不同的真机设备（具体参考表1）</li>\n<li>微信、支付宝： 基本跟硬件设备无关， 支持大多数的只能手机</li>\n</ul>\n</li>\n<li>网络环境要求<ul>\n<li>Apple Pay：线上支付需要联网， 线下支付无需联网就可以支付</li>\n<li>微信、支付宝： 无论是线上还是线下支付， 都需要联网使用</li>\n</ul>\n</li>\n<li>使用技术<ul>\n<li>Apple Pay：线下支付使用的是 基于NFC的近场通讯技术</li>\n<li>微信、支付宝： 线下支付使用的是 扫码支付（条形码、二维码）</li>\n</ul>\n</li>\n<li>主要功能<ul>\n<li>Apple Pay：线上支付、线下支付、部分升级后的ATM机可以取款</li>\n<li>微信、支付宝： 线上支付、线下支付、转账、理财等  </li>\n</ul>\n</li>\n<li>安全性能<ul>\n<li>Apple Pay：不保留银行卡信息，并且不会暴漏给外界、不分流银行存款（不需要从银行卡转钱到另外一个平台）、不能充值  安全性较高</li>\n<li>微信、支付宝： 密码保护，身份验证等手段保护账户  安全性相对稍差</li>\n</ul>\n</li>\n<li>支付时长<ul>\n<li>Apple Pay：无论是线上支付，还是线下支付， 只需要验证指纹即可支付。非常迅速</li>\n<li>微信、支付宝： 需要扫码支付， 流程相对繁琐，所以时长较长</li>\n</ul>\n</li>\n<li>各自弊端<ul>\n<li>Apple Pay：只适用于苹果设备， 支付场景单一，无转账理财等业务</li>\n<li>微信、支付宝： 安全性较差， 必须联网操作，需要充值到对应平台</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"注册并配置一个商业标示符\"><a href=\"#注册并配置一个商业标示符\" class=\"headerlink\" title=\"注册并配置一个商业标示符\"></a>注册并配置一个商业标示符</h2><p>1.添加一个App ID<br>2.配置Merchant ID<br>3.为Merchant ID 配置证书, 并下载证书安装到钥匙串<br>4.检查安装到钥匙串中的证书是否有效<br>5.绑定Merchant ID 到 APP ID</p>\n<p>证书失效，请到以下地址下载重新安装：<a href=\"https://www.apple.com/certificateauthority/\" target=\"_blank\" rel=\"external\">https://www.apple.com/certificateauthority/</a><br><img src=\"http://o8cfktdb3.bkt.clouddn.com/applepay.png\" alt=\"证书\"></p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div></pre></td><td class=\"code\"><pre><div class=\"line\">//一.判断当前设备是否支持支付</div><div class=\"line\"></div><div class=\"line\">if (![PKPaymentAuthorizationViewController canMakePayments]) &#123;</div><div class=\"line\"></div><div class=\"line\">NSLog(@&quot;该设备不支持ApplePay&quot;);</div><div class=\"line\"></div><div class=\"line\">return;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//二.判断Wallet有没有添加该支付网络的储蓄卡/信用卡</div><div class=\"line\"></div><div class=\"line\">&#125;else if ([PKPaymentAuthorizationViewController canMakePaymentsUsingNetworks:@[PKPaymentNetworkChinaUnionPay,PKPaymentNetworkVisa]])&#123;</div><div class=\"line\"></div><div class=\"line\">NSLog(@&quot;Wallet没有添加该支付网络的储蓄卡/信用卡&quot;);</div><div class=\"line\"></div><div class=\"line\">//创建一个添加卡的按钮</div><div class=\"line\"></div><div class=\"line\">PKPaymentButton *btn = [PKPaymentButton buttonWithType:PKPaymentButtonTypeSetUp style:PKPaymentButtonStyleBlack];</div><div class=\"line\"></div><div class=\"line\">[btn addTarget:self action:@selector(jumpToSetup) forControlEvents:UIControlEventTouchUpInside];</div><div class=\"line\"></div><div class=\"line\">[self.payView addSubview:btn];        </div><div class=\"line\"></div><div class=\"line\">&#125;else&#123;</div><div class=\"line\"></div><div class=\"line\">//创建一个支付按钮</div><div class=\"line\"></div><div class=\"line\">PKPaymentButton *btn = [PKPaymentButton buttonWithType:PKPaymentButtonTypeBuy style:PKPaymentButtonStyleWhiteOutline];</div><div class=\"line\"></div><div class=\"line\">[btn addTarget:self action:@selector(jumpToPay) forControlEvents:UIControlEventTouchUpInside];</div><div class=\"line\"></div><div class=\"line\">[self.payView addSubview:btn];</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">- (void)jumpToSetup&#123;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">NSLog(@&quot;跳转到添加银行卡页面&quot;);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">PKPassLibrary * pk = [[PKPassLibrary alloc]init];</div><div class=\"line\"></div><div class=\"line\">[pk openPaymentSetup];</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">- (void)jumpToPay&#123;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//三.创建支付请求并配置各项信息</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//1.创建支付请求</div><div class=\"line\"></div><div class=\"line\">PKPaymentRequest *request = [[PKPaymentRequest alloc]init];</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//2.配置参数</div><div class=\"line\"></div><div class=\"line\">//2.1 商店标识</div><div class=\"line\"></div><div class=\"line\">request.merchantIdentifier = @&quot;&quot;;</div><div class=\"line\"></div><div class=\"line\">//2.2 国家代码</div><div class=\"line\"></div><div class=\"line\">request.countryCode = @&quot;CN&quot;;</div><div class=\"line\"></div><div class=\"line\">//2.3 货币代码</div><div class=\"line\"></div><div class=\"line\">request.currencyCode = @&quot;CNY&quot;;</div><div class=\"line\"></div><div class=\"line\">//2.4 支持的支付网络</div><div class=\"line\"></div><div class=\"line\">request.supportedNetworks = @[PKPaymentNetworkChinaUnionPay,PKPaymentNetworkVisa];</div><div class=\"line\"></div><div class=\"line\">//2.5 支付请求包含一个支付摘要项目的列表</div><div class=\"line\"></div><div class=\"line\">NSDecimalNumber *price1 = [NSDecimalNumber decimalNumberWithString:@&quot;10.0&quot;];</div><div class=\"line\"></div><div class=\"line\">PKPaymentSummaryItem *item1 = [PKPaymentSummaryItem summaryItemWithLabel:@&quot;iPhone&quot; amount:price1];</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">NSDecimalNumber *price2 = [NSDecimalNumber decimalNumberWithString:@&quot;20.0&quot;];</div><div class=\"line\"></div><div class=\"line\">PKPaymentSummaryItem *item2 = [PKPaymentSummaryItem summaryItemWithLabel:@&quot;iPad&quot; amount:price2 type:PKPaymentSummaryItemTypePending];</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">NSDecimalNumber *totalPrice = [NSDecimalNumber zero];</div><div class=\"line\"></div><div class=\"line\">totalPrice = [totalPrice decimalNumberByAdding:price1];</div><div class=\"line\"></div><div class=\"line\">totalPrice = [totalPrice decimalNumberByAdding:price2];</div><div class=\"line\"></div><div class=\"line\">PKPaymentSummaryItem *total = [PKPaymentSummaryItem summaryItemWithLabel:@&quot;财务中心&quot; amount:totalPrice type:PKPaymentSummaryItemTypePending];</div><div class=\"line\"></div><div class=\"line\">//注意：数组最后一个是总价格</div><div class=\"line\"></div><div class=\"line\">request.paymentSummaryItems = @[item1,item2,total];</div><div class=\"line\"></div><div class=\"line\">//2.6运输方式</div><div class=\"line\"></div><div class=\"line\">NSDecimalNumber *shippingPrice = [NSDecimalNumber decimalNumberWithString:@&quot;18.0&quot;];</div><div class=\"line\"></div><div class=\"line\">PKShippingMethod *method = [PKShippingMethod summaryItemWithLabel:@&quot;顺风快递&quot; amount:shippingPrice];</div><div class=\"line\"></div><div class=\"line\">method.identifier = @&quot;shunfeng&quot;;</div><div class=\"line\"></div><div class=\"line\">method.detail = @&quot;24小时内送到&quot;;</div><div class=\"line\"></div><div class=\"line\">request.shippingMethods = @[method];</div><div class=\"line\"></div><div class=\"line\">request.shippingType = PKShippingTypeServicePickup;</div><div class=\"line\"></div><div class=\"line\">//2.7通过指定merchantCapabilities属性来指定你支持的支付处理标准，3DS支付方式是必须支持的，EMV方式是可选的</div><div class=\"line\"></div><div class=\"line\">request.merchantCapabilities = PKMerchantCapability3DS | PKMerchantCapabilityEMV | PKMerchantCapabilityCredit | PKMerchantCapabilityDebit;</div><div class=\"line\"></div><div class=\"line\">//2.8需要的配送信息和账单信息</div><div class=\"line\"></div><div class=\"line\">request.requiredBillingAddressFields = PKAddressFieldAll;</div><div class=\"line\"></div><div class=\"line\">request.requiredShippingAddressFields = PKAddressFieldAll;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//2.9 存储额外信息</div><div class=\"line\"></div><div class=\"line\">request.applicationData = [@&quot;购物车ID：123456&quot; dataUsingEncoding:NSUTF8StringEncoding];</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//四.弹出授权控制器，让用户给支付授权</div><div class=\"line\"></div><div class=\"line\">//开始支付</div><div class=\"line\"></div><div class=\"line\">PKPaymentAuthorizationViewController *pkCtrl = [[PKPaymentAuthorizationViewController alloc]initWithPaymentRequest:request];</div><div class=\"line\"></div><div class=\"line\">if (pkCtrl == nil) &#123;</div><div class=\"line\"></div><div class=\"line\">NSLog(@&quot;授权控制器创建失败&quot;);</div><div class=\"line\"></div><div class=\"line\">return;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">pkCtrl.delegate = self;</div><div class=\"line\"></div><div class=\"line\">[self presentViewController:pkCtrl animated:YES completion:nil];</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#pragma mark - PKPaymentAuthorizationViewControllerDelegate</div><div class=\"line\"></div><div class=\"line\">//五.处理支付凭证</div><div class=\"line\"></div><div class=\"line\">//授权成功</div><div class=\"line\"></div><div class=\"line\">- (void)paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)controller</div><div class=\"line\"></div><div class=\"line\">didAuthorizePayment:(PKPayment *)payment</div><div class=\"line\"></div><div class=\"line\">completion:(void (^)(PKPaymentAuthorizationStatus status))completion&#123;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">/*</div><div class=\"line\"></div><div class=\"line\">服务器接收到token后的一般处理流程:</div><div class=\"line\"></div><div class=\"line\">1.验证支付数据的哈希表和签名</div><div class=\"line\"></div><div class=\"line\">2.为加密过的支付数据解码</div><div class=\"line\"></div><div class=\"line\">3.向支付处理系统提交支付数据</div><div class=\"line\"></div><div class=\"line\">4.向订单追踪系统提交订单</div><div class=\"line\"></div><div class=\"line\">*/</div><div class=\"line\"></div><div class=\"line\">NSLog(@&quot;验证授权---%@&quot;,payment.token);</div><div class=\"line\"></div><div class=\"line\">/*</div><div class=\"line\"></div><div class=\"line\">处理支付请求时，你有两个选择:</div><div class=\"line\"></div><div class=\"line\">1.你既可以利用支付平台处理支付请求，</div><div class=\"line\"></div><div class=\"line\">2.也可以自己实现支付请求处理流程。</div><div class=\"line\"></div><div class=\"line\">一个常用的支付平台可以完成上述大部分操作。</div><div class=\"line\"></div><div class=\"line\">*/</div><div class=\"line\"></div><div class=\"line\">NSLog(@&quot;验证通过后，需要开发中继续完成交易&quot;);</div><div class=\"line\"></div><div class=\"line\">BOOL isSuccess = YES;</div><div class=\"line\"></div><div class=\"line\">if (isSuccess) &#123;</div><div class=\"line\"></div><div class=\"line\">completion(PKPaymentAuthorizationStatusSuccess);</div><div class=\"line\"></div><div class=\"line\">&#125;else&#123;</div><div class=\"line\"></div><div class=\"line\">completion(PKPaymentAuthorizationStatusFailure);</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//六.关闭授权控制器</div><div class=\"line\"></div><div class=\"line\">//授权成功或者取消授权之后会调用此方法</div><div class=\"line\"></div><div class=\"line\">- (void)paymentAuthorizationViewControllerDidFinish:(PKPaymentAuthorizationViewController *)controller&#123;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">NSLog(@&quot;取消或者交易完成&quot;);</div><div class=\"line\"></div><div class=\"line\">[self dismissViewControllerAnimated:YES completion:nil];</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>转自：<a href=\"http://www.cnblogs.com/dashunzi/archive/2016/02/23/ApplePay.html#undefined\" target=\"_blank\" rel=\"external\">Apple Pay–iOS开发</a></p>"},{"title":"JSP学习笔记","date":"2017-06-12T01:22:10.000Z","comments":1,"_content":"\ncookies 存储在浏览器。而会话存储在服务器端\n","source":"_posts/JSP学习笔记.md","raw":"---\ntitle: JSP学习笔记\ndate: 2017-06-12 09:22:10\ncategories: 笔记\ntags: [Java,JSP]\ncomments: true\n---\n\ncookies 存储在浏览器。而会话存储在服务器端\n","slug":"JSP学习笔记","published":1,"updated":"2017-07-14T03:57:06.000Z","layout":"post","photos":[],"link":"","_id":"cj53c1dv00007h3jjtnta7sha","content":"<p>cookies 存储在浏览器。而会话存储在服务器端</p>\n","site":{"data":{}},"excerpt":"","more":"<p>cookies 存储在浏览器。而会话存储在服务器端</p>\n"},{"title":"Java搭建springMVC项目笔记","date":"2017-06-08T01:44:19.000Z","_content":"\n# MyEclipse搭建项目\n* 创建命名空间namespace\n* 新建项目 new -> project\n* 添加tomcat,jdk\n* 运行\n* 访问：http://localhost:8080/project_name/\n\n<!--more-->\n\n```\n...\nnested exception is org.springframework.core.NestedIOException: ASM ClassReader failed to parse class file - probably due to a new Java class file version that isn't supported yet\n...\nnested exception is java.lang.IllegalArgumentException\n...\n```\n\n解决方法：\n在项目上右键–properties–java Compile–compiler compliance level\n\n在工程目录下添加config文件夹，下面添加文件：jdbc.properties,spring-mvc.xml,spring-mybatis.xml\n![spring-config](/assets/demo/java_config.png)\n\n* jdbc.properties：mysql配置\n* spring-mvc.xml\n    + context -> base-package: 包的跟路径\n    + bean -> prefix: /WEB-INF/page/下放.jsp文件\n        mvc -> bean: utl 的根路径\n    + spring-mybatis.xml: \n        - context -> base-package: 包的根路径\n        - bean -> base-package: dao的根路径\n        - aop -> expression: service的根路径\n","source":"_posts/Java搭建springMVC项目笔记.md","raw":"---\ntitle: Java搭建springMVC项目笔记\ndate: 2017-06-08 09:44:19\ncategories: 笔记\ntags: [Java,springMVC,项目]\n---\n\n# MyEclipse搭建项目\n* 创建命名空间namespace\n* 新建项目 new -> project\n* 添加tomcat,jdk\n* 运行\n* 访问：http://localhost:8080/project_name/\n\n<!--more-->\n\n```\n...\nnested exception is org.springframework.core.NestedIOException: ASM ClassReader failed to parse class file - probably due to a new Java class file version that isn't supported yet\n...\nnested exception is java.lang.IllegalArgumentException\n...\n```\n\n解决方法：\n在项目上右键–properties–java Compile–compiler compliance level\n\n在工程目录下添加config文件夹，下面添加文件：jdbc.properties,spring-mvc.xml,spring-mybatis.xml\n![spring-config](/assets/demo/java_config.png)\n\n* jdbc.properties：mysql配置\n* spring-mvc.xml\n    + context -> base-package: 包的跟路径\n    + bean -> prefix: /WEB-INF/page/下放.jsp文件\n        mvc -> bean: utl 的根路径\n    + spring-mybatis.xml: \n        - context -> base-package: 包的根路径\n        - bean -> base-package: dao的根路径\n        - aop -> expression: service的根路径\n","slug":"Java搭建springMVC项目笔记","published":1,"updated":"2017-07-14T03:57:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj53c1dv30008h3jj6sdx9gw5","content":"<h1 id=\"MyEclipse搭建项目\"><a href=\"#MyEclipse搭建项目\" class=\"headerlink\" title=\"MyEclipse搭建项目\"></a>MyEclipse搭建项目</h1><ul>\n<li>创建命名空间namespace</li>\n<li>新建项目 new -&gt; project</li>\n<li>添加tomcat,jdk</li>\n<li>运行</li>\n<li>访问：<a href=\"http://localhost:8080/project_name/\" target=\"_blank\" rel=\"external\">http://localhost:8080/project_name/</a></li>\n</ul>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\">nested exception is org.springframework.core.NestedIOException: ASM ClassReader failed to parse class file - probably due to a new Java class file version that isn&apos;t supported yet</div><div class=\"line\">...</div><div class=\"line\">nested exception is java.lang.IllegalArgumentException</div><div class=\"line\">...</div></pre></td></tr></table></figure>\n<p>解决方法：<br>在项目上右键–properties–java Compile–compiler compliance level</p>\n<p>在工程目录下添加config文件夹，下面添加文件：jdbc.properties,spring-mvc.xml,spring-mybatis.xml<br><img src=\"/assets/demo/java_config.png\" alt=\"spring-config\"></p>\n<ul>\n<li>jdbc.properties：mysql配置</li>\n<li>spring-mvc.xml<ul>\n<li>context -&gt; base-package: 包的跟路径</li>\n<li>bean -&gt; prefix: /WEB-INF/page/下放.jsp文件<br>  mvc -&gt; bean: utl 的根路径</li>\n<li>spring-mybatis.xml: <ul>\n<li>context -&gt; base-package: 包的根路径</li>\n<li>bean -&gt; base-package: dao的根路径</li>\n<li>aop -&gt; expression: service的根路径</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"MyEclipse搭建项目\"><a href=\"#MyEclipse搭建项目\" class=\"headerlink\" title=\"MyEclipse搭建项目\"></a>MyEclipse搭建项目</h1><ul>\n<li>创建命名空间namespace</li>\n<li>新建项目 new -&gt; project</li>\n<li>添加tomcat,jdk</li>\n<li>运行</li>\n<li>访问：<a href=\"http://localhost:8080/project_name/\" target=\"_blank\" rel=\"external\">http://localhost:8080/project_name/</a></li>\n</ul>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\">nested exception is org.springframework.core.NestedIOException: ASM ClassReader failed to parse class file - probably due to a new Java class file version that isn&apos;t supported yet</div><div class=\"line\">...</div><div class=\"line\">nested exception is java.lang.IllegalArgumentException</div><div class=\"line\">...</div></pre></td></tr></table></figure>\n<p>解决方法：<br>在项目上右键–properties–java Compile–compiler compliance level</p>\n<p>在工程目录下添加config文件夹，下面添加文件：jdbc.properties,spring-mvc.xml,spring-mybatis.xml<br><img src=\"/assets/demo/java_config.png\" alt=\"spring-config\"></p>\n<ul>\n<li>jdbc.properties：mysql配置</li>\n<li>spring-mvc.xml<ul>\n<li>context -&gt; base-package: 包的跟路径</li>\n<li>bean -&gt; prefix: /WEB-INF/page/下放.jsp文件<br>  mvc -&gt; bean: utl 的根路径</li>\n<li>spring-mybatis.xml: <ul>\n<li>context -&gt; base-package: 包的根路径</li>\n<li>bean -&gt; base-package: dao的根路径</li>\n<li>aop -&gt; expression: service的根路径</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>"},{"title":"Java语言学习笔记","date":"2017-06-09T01:59:09.000Z","toc":true,"_content":"\n##JAVA基础\n### 1.public类\n* 一个源文件中只能有一个public类\n* 一个源文件可以有多个非public类\n\n### 2.package/import\n编译java包：\n> $ javac -d directory javafilename\n```\nE:\\sources> javac -d c:\\classes Simple.java\n//运行\ne:\\sources> set classpath=c:\\classes;.;\ne:\\sources> java mypack.Simple\n```\nOR\n```\ne:\\sources> java -classpath c:\\classes mypack.Simple\n```\n<!--more-->\n加载类文件或jar文件的方式:\n* 加载临时类文件\n    + 通过在命令提示符中设置类路径\n    + 通过 -classpath 开关选项\n* 永久加载类文件\n    + 通过在环境变量中设置类路径\n    + 通过创建jar文件，其中包含所有类文件，并将jar文件复制到JDK安装目录的jre/lib/ext文件夹中。\n\n### 3.引用类型\n对象、数组都是引用数据类型。\n所有引用类型的默认值都是null。\n\n### 4.JAVA常量\n在 Java 中使用 final 关键字来修饰常量，通常使用大写字母表示常量\n\n### 5. 基本数据类型\n* 不能对boolean类型进行类型转换。\n* 在把容量大的类型转换为容量小的类型时必须使用强制类型转换 double->float\n\n6.自动类型转换\n转换前的数据类型的位数要低于转换后的数据类型。Float->double\n\n7. Java语言支持的变量类型\n#### 类变量：独立于方法之外的变量，用 static 修饰。\n+ 在类中以static关键字声明，但必须在方法构造方法和语句块之外\n+ 静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。\n+ 静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。\n+ 为了对类的使用者可见，大多数静态变量声明为public类型\n+ 默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。\n+ 类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。\n+ 静态块在类加载时main之前执行\n#### 实例变量：独立于方法之外的变量，不过没有 static 修饰。\n+ 当一个对象被实例化之后，每个实例变量的值就跟着确定；\n+ 实例变量可以声明在使用前或者使用后；\n+ 一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；\n+ 实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；\n+ 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名\n#### 局部变量：类的方法中的变量。\n+ 访问修饰符不能用于局部变量；\n+ 局部变量是在栈上分配的。\n+ 局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。\n\n#### 实例初始化块\n主要有三个规则。 它们如下：\n* 在创建类的实例时创建实例初始化程序块。\n* 在父类构造函数被调用之后(即在super()构造函数调用之后)调用实例初始化块。\n* 实例初始化程序块按它们显示的顺序排列。\n\n### 8．修饰符：访问修饰符、非访问修饰符\n+ 修饰符用来定义类、方法或者变量，通常放在语句的最前端，默认default\n#### 访问修饰符\n（1） public/protected/default/private\n（2） private: 只能通过类中公共的 getter 方法被外部类访问\n（3） protected: 同一个包中的任何其他类访问，也能够被不同包中的子类访问\n+ public: 如果几个相互访问的 public 类分布在不同的包中，则需要导入相应 public 类所在的包\n+ 注意：父类中声明为 public 的方法在子类中也必须为 public。\n+ 父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。\n+ 父类中声明为 private 的方法，不能够被继承。\n\n#### 非访问修饰符\nstatic,abstract,final,synchronized,volatile\n（1）final：用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。\n* final 变量：能被显式地初始化并且只能初始化一次。被声明为 final 的对象的引用不能指向不同的对象。但是 final 对象里的数据可以被改变。也就是说 final 对象的引用不能改变，但是里面的值可以改变。final 修饰符通常和 static 修饰符一起使用来创建类常量。\n* final 方法：类中的 final 方法可以被子类继承，但是不能被子类修改。\n* final 类：final 类不能被继承，没有类能够继承 final 类的任何特性。\n* 被声明为 final 类的方法自动地声明为 final，但是实例变量并不是 final\n* 在声明时未初始化的静态final变量称为静态空白final变量。 它只能在静态块中初始化。\n（2）abstract: 抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充\n一个类不能同时被 abstract 和 final 修饰。\n抽象方法:是一种没有任何实现的方法，该方法的的具体实现由子类提供。\n* 抽象方法不能被声明成 final 和 static。\n* 任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。\n* 如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。抽象类可以包含抽象方法和非抽象方法。\n* 抽象方法的声明以分号结尾，例如：public abstract sample()。\n在java中有两种实现抽象的方法，它们分别是：\n* 抽象类(部分)\n* 接口 (完全)\n抽象类实现了部分抽象(0到100％)，而接口实现了完全抽象(100％)。\n![抽象类与接口](http://o8cfktdb3.bkt.clouddn.com/acAndIfa.png)\n\n### 9.instanceof: name instanceof String\n增强for循环：for(声明语句 : 表达式)\nswitch支持字符串，直到break退出\n\n### 10.装箱/拆箱\n装箱：int->number  拆箱：number->int\nintValue() valueOf() compareo() equals() parseInt()(string->int) ceil() floor() random()\n\n### 11.Character char的包装类 \nisLetter() isDigit() isUpperCase() isWhitespace() toUpperCase() toString()\n\n### 12.String\nlength() s1.concat(s2)  s = format(”---%f %d %s”,floatVar,.,.) charAt(index) int compareo()(对象，字符串)\nboolean contentEquals(StringBuffer)  endsWith() equals()  indexOf(ch) split substring\n\n### 13. StringBuffer/StringBuilder\n当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。\nStringBuffer(线程安全) StringBuilder(速度优势,不是线程安全的,不能同步访问)  多数情况下建议使用 StringBuilder 类\nStringBuffer：append(s) reverse dekete(start,end) replace(start,end,str) capacity() charAt() indexOf() toString substring\n\n### 14.Arrays数组\ndouble[] list = new double[10];  参数：(int[] array)  返回值：int[]  \nfill sort equals binarySearch\n\n### 15.Date\ndate.toString() getime() after before equals compareo   format parse\nSimpleDateFormat(E yyyy-MM-dd HH:mm:ss a zzz) PM\nSleep(1000*3)  Calender.getInstance()\n\n### 16.正则表达式\nPattern Matcher\n\\s+ 多个空格  ^$ 以什么开始  \\d+多个数字  ()? 0/1 可选  * 0/n  +1\\n   {n} (n,) >=n  . 除\\n\\r之外的任何单个字符\n[xyz] [^xyz] [a-z]  \\b字符边界\n\n### 17.function\n重载：方法名相同，参数列表不同\n构造方法：方法名与类名相同，没有返回值，自定义则默认构造方法失效\n可变参数：一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明\n（double... numbers）\nprotected void finalize()\n### 18.BufferReader \nread() write() scanner() print() println()\n\n### 19.I/O\nFileInputStream FileOutputStream File FileReader FileWrite mkdir mkdirs isDirectory delete()\n\n20.Scanner(System.in)  \nnext nextLine\n\n21.Exception \njava.lang.Exception Error  Throwable\nIOException RuntimeException\n\n### 22.面向对象\n#### 继承\nextends final修饰的类不能被集成，方法不能被重写  单继承\n#### 重写与重载\nOverride(返回值和形参都不能改变) Overload(方法名字相同，而参数不同。返回类型可以相同也可以不同)   \n构造方法不能被重写\n最常用的地方就是构造器的重载\n#### 多态\n父类指向子类对象  Animal a = new Cat()   实现方式：重写，接口，抽象类和抽象方法  变量不能被重写\n#### 抽象类\n抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。\n#### 封装\n修改属性的可见性来限制对属性的访问（一般限制为private）\n对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问\n#### 接口\n是抽象方法的集合。\n有静态、final变量和抽象方法（JAVA8还可以有默认方法，静态方法），接口字段默认是public，static和final，方法默认是public和abstract\n类描述对象的属性和方法。接口则包含类要实现的方法。\n除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。\n一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。\n接口中的方法会被隐式的指定为 public abstract，接口中的变量会被隐式的指定为 public static final\n类的多重继承是不合法，但接口允许多重继承\n#### 包\n小写开头\n使用类全名描述 或 import(import 声明必须在包声明之后，类声明之前)\n\n\n## java高级\n### 1.一些概念理解\n#### JVM(Java虚拟机)\n一个抽象机器。它是一个提供可以执行Java字节码的运行时环境的规范。\nJVM执行以下主要任务：\n* 加载代码\n* 验证代码\n* 执行代码\n* 提供运行时环境\n#### JRE（Java Runtime Environment）\n用于提供Java运行时环境。它是JVM的实现。它是实际存在的。它包含一组库和JVM在运行时使用的其他文件。\n#### JDK（Java Development Kit）\n它是实际上存在的。它包含JRE+开发工具。\n\nJDK(JRE(JVM+LIB+OTHER)+IDE)\n","source":"_posts/Java语言学习笔记.md","raw":"---\ntitle: Java语言学习笔记\ndate: 2017-06-09 09:59:09\ncategories: 笔记\ntags: [Java,语法]\ntoc: true\n---\n\n##JAVA基础\n### 1.public类\n* 一个源文件中只能有一个public类\n* 一个源文件可以有多个非public类\n\n### 2.package/import\n编译java包：\n> $ javac -d directory javafilename\n```\nE:\\sources> javac -d c:\\classes Simple.java\n//运行\ne:\\sources> set classpath=c:\\classes;.;\ne:\\sources> java mypack.Simple\n```\nOR\n```\ne:\\sources> java -classpath c:\\classes mypack.Simple\n```\n<!--more-->\n加载类文件或jar文件的方式:\n* 加载临时类文件\n    + 通过在命令提示符中设置类路径\n    + 通过 -classpath 开关选项\n* 永久加载类文件\n    + 通过在环境变量中设置类路径\n    + 通过创建jar文件，其中包含所有类文件，并将jar文件复制到JDK安装目录的jre/lib/ext文件夹中。\n\n### 3.引用类型\n对象、数组都是引用数据类型。\n所有引用类型的默认值都是null。\n\n### 4.JAVA常量\n在 Java 中使用 final 关键字来修饰常量，通常使用大写字母表示常量\n\n### 5. 基本数据类型\n* 不能对boolean类型进行类型转换。\n* 在把容量大的类型转换为容量小的类型时必须使用强制类型转换 double->float\n\n6.自动类型转换\n转换前的数据类型的位数要低于转换后的数据类型。Float->double\n\n7. Java语言支持的变量类型\n#### 类变量：独立于方法之外的变量，用 static 修饰。\n+ 在类中以static关键字声明，但必须在方法构造方法和语句块之外\n+ 静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。\n+ 静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。\n+ 为了对类的使用者可见，大多数静态变量声明为public类型\n+ 默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。\n+ 类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。\n+ 静态块在类加载时main之前执行\n#### 实例变量：独立于方法之外的变量，不过没有 static 修饰。\n+ 当一个对象被实例化之后，每个实例变量的值就跟着确定；\n+ 实例变量可以声明在使用前或者使用后；\n+ 一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；\n+ 实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；\n+ 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名\n#### 局部变量：类的方法中的变量。\n+ 访问修饰符不能用于局部变量；\n+ 局部变量是在栈上分配的。\n+ 局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。\n\n#### 实例初始化块\n主要有三个规则。 它们如下：\n* 在创建类的实例时创建实例初始化程序块。\n* 在父类构造函数被调用之后(即在super()构造函数调用之后)调用实例初始化块。\n* 实例初始化程序块按它们显示的顺序排列。\n\n### 8．修饰符：访问修饰符、非访问修饰符\n+ 修饰符用来定义类、方法或者变量，通常放在语句的最前端，默认default\n#### 访问修饰符\n（1） public/protected/default/private\n（2） private: 只能通过类中公共的 getter 方法被外部类访问\n（3） protected: 同一个包中的任何其他类访问，也能够被不同包中的子类访问\n+ public: 如果几个相互访问的 public 类分布在不同的包中，则需要导入相应 public 类所在的包\n+ 注意：父类中声明为 public 的方法在子类中也必须为 public。\n+ 父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。\n+ 父类中声明为 private 的方法，不能够被继承。\n\n#### 非访问修饰符\nstatic,abstract,final,synchronized,volatile\n（1）final：用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。\n* final 变量：能被显式地初始化并且只能初始化一次。被声明为 final 的对象的引用不能指向不同的对象。但是 final 对象里的数据可以被改变。也就是说 final 对象的引用不能改变，但是里面的值可以改变。final 修饰符通常和 static 修饰符一起使用来创建类常量。\n* final 方法：类中的 final 方法可以被子类继承，但是不能被子类修改。\n* final 类：final 类不能被继承，没有类能够继承 final 类的任何特性。\n* 被声明为 final 类的方法自动地声明为 final，但是实例变量并不是 final\n* 在声明时未初始化的静态final变量称为静态空白final变量。 它只能在静态块中初始化。\n（2）abstract: 抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充\n一个类不能同时被 abstract 和 final 修饰。\n抽象方法:是一种没有任何实现的方法，该方法的的具体实现由子类提供。\n* 抽象方法不能被声明成 final 和 static。\n* 任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。\n* 如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。抽象类可以包含抽象方法和非抽象方法。\n* 抽象方法的声明以分号结尾，例如：public abstract sample()。\n在java中有两种实现抽象的方法，它们分别是：\n* 抽象类(部分)\n* 接口 (完全)\n抽象类实现了部分抽象(0到100％)，而接口实现了完全抽象(100％)。\n![抽象类与接口](http://o8cfktdb3.bkt.clouddn.com/acAndIfa.png)\n\n### 9.instanceof: name instanceof String\n增强for循环：for(声明语句 : 表达式)\nswitch支持字符串，直到break退出\n\n### 10.装箱/拆箱\n装箱：int->number  拆箱：number->int\nintValue() valueOf() compareo() equals() parseInt()(string->int) ceil() floor() random()\n\n### 11.Character char的包装类 \nisLetter() isDigit() isUpperCase() isWhitespace() toUpperCase() toString()\n\n### 12.String\nlength() s1.concat(s2)  s = format(”---%f %d %s”,floatVar,.,.) charAt(index) int compareo()(对象，字符串)\nboolean contentEquals(StringBuffer)  endsWith() equals()  indexOf(ch) split substring\n\n### 13. StringBuffer/StringBuilder\n当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。\nStringBuffer(线程安全) StringBuilder(速度优势,不是线程安全的,不能同步访问)  多数情况下建议使用 StringBuilder 类\nStringBuffer：append(s) reverse dekete(start,end) replace(start,end,str) capacity() charAt() indexOf() toString substring\n\n### 14.Arrays数组\ndouble[] list = new double[10];  参数：(int[] array)  返回值：int[]  \nfill sort equals binarySearch\n\n### 15.Date\ndate.toString() getime() after before equals compareo   format parse\nSimpleDateFormat(E yyyy-MM-dd HH:mm:ss a zzz) PM\nSleep(1000*3)  Calender.getInstance()\n\n### 16.正则表达式\nPattern Matcher\n\\s+ 多个空格  ^$ 以什么开始  \\d+多个数字  ()? 0/1 可选  * 0/n  +1\\n   {n} (n,) >=n  . 除\\n\\r之外的任何单个字符\n[xyz] [^xyz] [a-z]  \\b字符边界\n\n### 17.function\n重载：方法名相同，参数列表不同\n构造方法：方法名与类名相同，没有返回值，自定义则默认构造方法失效\n可变参数：一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明\n（double... numbers）\nprotected void finalize()\n### 18.BufferReader \nread() write() scanner() print() println()\n\n### 19.I/O\nFileInputStream FileOutputStream File FileReader FileWrite mkdir mkdirs isDirectory delete()\n\n20.Scanner(System.in)  \nnext nextLine\n\n21.Exception \njava.lang.Exception Error  Throwable\nIOException RuntimeException\n\n### 22.面向对象\n#### 继承\nextends final修饰的类不能被集成，方法不能被重写  单继承\n#### 重写与重载\nOverride(返回值和形参都不能改变) Overload(方法名字相同，而参数不同。返回类型可以相同也可以不同)   \n构造方法不能被重写\n最常用的地方就是构造器的重载\n#### 多态\n父类指向子类对象  Animal a = new Cat()   实现方式：重写，接口，抽象类和抽象方法  变量不能被重写\n#### 抽象类\n抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。\n#### 封装\n修改属性的可见性来限制对属性的访问（一般限制为private）\n对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问\n#### 接口\n是抽象方法的集合。\n有静态、final变量和抽象方法（JAVA8还可以有默认方法，静态方法），接口字段默认是public，static和final，方法默认是public和abstract\n类描述对象的属性和方法。接口则包含类要实现的方法。\n除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。\n一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。\n接口中的方法会被隐式的指定为 public abstract，接口中的变量会被隐式的指定为 public static final\n类的多重继承是不合法，但接口允许多重继承\n#### 包\n小写开头\n使用类全名描述 或 import(import 声明必须在包声明之后，类声明之前)\n\n\n## java高级\n### 1.一些概念理解\n#### JVM(Java虚拟机)\n一个抽象机器。它是一个提供可以执行Java字节码的运行时环境的规范。\nJVM执行以下主要任务：\n* 加载代码\n* 验证代码\n* 执行代码\n* 提供运行时环境\n#### JRE（Java Runtime Environment）\n用于提供Java运行时环境。它是JVM的实现。它是实际存在的。它包含一组库和JVM在运行时使用的其他文件。\n#### JDK（Java Development Kit）\n它是实际上存在的。它包含JRE+开发工具。\n\nJDK(JRE(JVM+LIB+OTHER)+IDE)\n","slug":"Java语言学习笔记","published":1,"updated":"2017-07-14T03:57:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj53c1dv9000bh3jj9lj3ezxy","content":"<p>##JAVA基础</p>\n<h3 id=\"1-public类\"><a href=\"#1-public类\" class=\"headerlink\" title=\"1.public类\"></a>1.public类</h3><ul>\n<li>一个源文件中只能有一个public类</li>\n<li>一个源文件可以有多个非public类</li>\n</ul>\n<h3 id=\"2-package-import\"><a href=\"#2-package-import\" class=\"headerlink\" title=\"2.package/import\"></a>2.package/import</h3><p>编译java包：</p>\n<blockquote>\n<p>$ javac -d directory javafilename<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">E:\\sources&gt; javac -d c:\\classes Simple.java</div><div class=\"line\">//运行</div><div class=\"line\">e:\\sources&gt; set classpath=c:\\classes;.;</div><div class=\"line\">e:\\sources&gt; java mypack.Simple</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>OR<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">e:\\sources&gt; java -classpath c:\\classes mypack.Simple</div></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>加载类文件或jar文件的方式:</p>\n<ul>\n<li>加载临时类文件<ul>\n<li>通过在命令提示符中设置类路径</li>\n<li>通过 -classpath 开关选项</li>\n</ul>\n</li>\n<li>永久加载类文件<ul>\n<li>通过在环境变量中设置类路径</li>\n<li>通过创建jar文件，其中包含所有类文件，并将jar文件复制到JDK安装目录的jre/lib/ext文件夹中。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-引用类型\"><a href=\"#3-引用类型\" class=\"headerlink\" title=\"3.引用类型\"></a>3.引用类型</h3><p>对象、数组都是引用数据类型。<br>所有引用类型的默认值都是null。</p>\n<h3 id=\"4-JAVA常量\"><a href=\"#4-JAVA常量\" class=\"headerlink\" title=\"4.JAVA常量\"></a>4.JAVA常量</h3><p>在 Java 中使用 final 关键字来修饰常量，通常使用大写字母表示常量</p>\n<h3 id=\"5-基本数据类型\"><a href=\"#5-基本数据类型\" class=\"headerlink\" title=\"5. 基本数据类型\"></a>5. 基本数据类型</h3><ul>\n<li>不能对boolean类型进行类型转换。</li>\n<li>在把容量大的类型转换为容量小的类型时必须使用强制类型转换 double-&gt;float</li>\n</ul>\n<p>6.自动类型转换<br>转换前的数据类型的位数要低于转换后的数据类型。Float-&gt;double</p>\n<ol>\n<li>Java语言支持的变量类型<h4 id=\"类变量：独立于方法之外的变量，用-static-修饰。\"><a href=\"#类变量：独立于方法之外的变量，用-static-修饰。\" class=\"headerlink\" title=\"类变量：独立于方法之外的变量，用 static 修饰。\"></a>类变量：独立于方法之外的变量，用 static 修饰。</h4></li>\n</ol>\n<ul>\n<li>在类中以static关键字声明，但必须在方法构造方法和语句块之外</li>\n<li>静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。</li>\n<li>静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。</li>\n<li>为了对类的使用者可见，大多数静态变量声明为public类型</li>\n<li>默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。</li>\n<li>类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。</li>\n<li>静态块在类加载时main之前执行<h4 id=\"实例变量：独立于方法之外的变量，不过没有-static-修饰。\"><a href=\"#实例变量：独立于方法之外的变量，不过没有-static-修饰。\" class=\"headerlink\" title=\"实例变量：独立于方法之外的变量，不过没有 static 修饰。\"></a>实例变量：独立于方法之外的变量，不过没有 static 修饰。</h4></li>\n<li>当一个对象被实例化之后，每个实例变量的值就跟着确定；</li>\n<li>实例变量可以声明在使用前或者使用后；</li>\n<li>一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；</li>\n<li>实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；</li>\n<li>实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名<h4 id=\"局部变量：类的方法中的变量。\"><a href=\"#局部变量：类的方法中的变量。\" class=\"headerlink\" title=\"局部变量：类的方法中的变量。\"></a>局部变量：类的方法中的变量。</h4></li>\n<li>访问修饰符不能用于局部变量；</li>\n<li>局部变量是在栈上分配的。</li>\n<li>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。</li>\n</ul>\n<h4 id=\"实例初始化块\"><a href=\"#实例初始化块\" class=\"headerlink\" title=\"实例初始化块\"></a>实例初始化块</h4><p>主要有三个规则。 它们如下：</p>\n<ul>\n<li>在创建类的实例时创建实例初始化程序块。</li>\n<li>在父类构造函数被调用之后(即在super()构造函数调用之后)调用实例初始化块。</li>\n<li>实例初始化程序块按它们显示的顺序排列。</li>\n</ul>\n<h3 id=\"8．修饰符：访问修饰符、非访问修饰符\"><a href=\"#8．修饰符：访问修饰符、非访问修饰符\" class=\"headerlink\" title=\"8．修饰符：访问修饰符、非访问修饰符\"></a>8．修饰符：访问修饰符、非访问修饰符</h3><ul>\n<li>修饰符用来定义类、方法或者变量，通常放在语句的最前端，默认default<h4 id=\"访问修饰符\"><a href=\"#访问修饰符\" class=\"headerlink\" title=\"访问修饰符\"></a>访问修饰符</h4>（1） public/protected/default/private<br>（2） private: 只能通过类中公共的 getter 方法被外部类访问<br>（3） protected: 同一个包中的任何其他类访问，也能够被不同包中的子类访问</li>\n<li>public: 如果几个相互访问的 public 类分布在不同的包中，则需要导入相应 public 类所在的包</li>\n<li>注意：父类中声明为 public 的方法在子类中也必须为 public。</li>\n<li>父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。</li>\n<li>父类中声明为 private 的方法，不能够被继承。</li>\n</ul>\n<h4 id=\"非访问修饰符\"><a href=\"#非访问修饰符\" class=\"headerlink\" title=\"非访问修饰符\"></a>非访问修饰符</h4><p>static,abstract,final,synchronized,volatile<br>（1）final：用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。</p>\n<ul>\n<li>final 变量：能被显式地初始化并且只能初始化一次。被声明为 final 的对象的引用不能指向不同的对象。但是 final 对象里的数据可以被改变。也就是说 final 对象的引用不能改变，但是里面的值可以改变。final 修饰符通常和 static 修饰符一起使用来创建类常量。</li>\n<li>final 方法：类中的 final 方法可以被子类继承，但是不能被子类修改。</li>\n<li>final 类：final 类不能被继承，没有类能够继承 final 类的任何特性。</li>\n<li>被声明为 final 类的方法自动地声明为 final，但是实例变量并不是 final</li>\n<li>在声明时未初始化的静态final变量称为静态空白final变量。 它只能在静态块中初始化。<br>（2）abstract: 抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充<br>一个类不能同时被 abstract 和 final 修饰。<br>抽象方法:是一种没有任何实现的方法，该方法的的具体实现由子类提供。</li>\n<li>抽象方法不能被声明成 final 和 static。</li>\n<li>任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。</li>\n<li>如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。抽象类可以包含抽象方法和非抽象方法。</li>\n<li>抽象方法的声明以分号结尾，例如：public abstract sample()。<br>在java中有两种实现抽象的方法，它们分别是：</li>\n<li>抽象类(部分)</li>\n<li>接口 (完全)<br>抽象类实现了部分抽象(0到100％)，而接口实现了完全抽象(100％)。<br><img src=\"http://o8cfktdb3.bkt.clouddn.com/acAndIfa.png\" alt=\"抽象类与接口\"></li>\n</ul>\n<h3 id=\"9-instanceof-name-instanceof-String\"><a href=\"#9-instanceof-name-instanceof-String\" class=\"headerlink\" title=\"9.instanceof: name instanceof String\"></a>9.instanceof: name instanceof String</h3><p>增强for循环：for(声明语句 : 表达式)<br>switch支持字符串，直到break退出</p>\n<h3 id=\"10-装箱-拆箱\"><a href=\"#10-装箱-拆箱\" class=\"headerlink\" title=\"10.装箱/拆箱\"></a>10.装箱/拆箱</h3><p>装箱：int-&gt;number  拆箱：number-&gt;int<br>intValue() valueOf() compareo() equals() parseInt()(string-&gt;int) ceil() floor() random()</p>\n<h3 id=\"11-Character-char的包装类\"><a href=\"#11-Character-char的包装类\" class=\"headerlink\" title=\"11.Character char的包装类\"></a>11.Character char的包装类</h3><p>isLetter() isDigit() isUpperCase() isWhitespace() toUpperCase() toString()</p>\n<h3 id=\"12-String\"><a href=\"#12-String\" class=\"headerlink\" title=\"12.String\"></a>12.String</h3><p>length() s1.concat(s2)  s = format(”—%f %d %s”,floatVar,.,.) charAt(index) int compareo()(对象，字符串)<br>boolean contentEquals(StringBuffer)  endsWith() equals()  indexOf(ch) split substring</p>\n<h3 id=\"13-StringBuffer-StringBuilder\"><a href=\"#13-StringBuffer-StringBuilder\" class=\"headerlink\" title=\"13. StringBuffer/StringBuilder\"></a>13. StringBuffer/StringBuilder</h3><p>当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。<br>StringBuffer(线程安全) StringBuilder(速度优势,不是线程安全的,不能同步访问)  多数情况下建议使用 StringBuilder 类<br>StringBuffer：append(s) reverse dekete(start,end) replace(start,end,str) capacity() charAt() indexOf() toString substring</p>\n<h3 id=\"14-Arrays数组\"><a href=\"#14-Arrays数组\" class=\"headerlink\" title=\"14.Arrays数组\"></a>14.Arrays数组</h3><p>double[] list = new double[10];  参数：(int[] array)  返回值：int[]<br>fill sort equals binarySearch</p>\n<h3 id=\"15-Date\"><a href=\"#15-Date\" class=\"headerlink\" title=\"15.Date\"></a>15.Date</h3><p>date.toString() getime() after before equals compareo   format parse<br>SimpleDateFormat(E yyyy-MM-dd HH:mm:ss a zzz) PM<br>Sleep(1000*3)  Calender.getInstance()</p>\n<h3 id=\"16-正则表达式\"><a href=\"#16-正则表达式\" class=\"headerlink\" title=\"16.正则表达式\"></a>16.正则表达式</h3><p>Pattern Matcher<br>\\s+ 多个空格  ^$ 以什么开始  \\d+多个数字  ()? 0/1 可选  * 0/n  +1\\n   {n} (n,) &gt;=n  . 除\\n\\r之外的任何单个字符<br>[xyz] [^xyz] [a-z]  \\b字符边界</p>\n<h3 id=\"17-function\"><a href=\"#17-function\" class=\"headerlink\" title=\"17.function\"></a>17.function</h3><p>重载：方法名相同，参数列表不同<br>构造方法：方法名与类名相同，没有返回值，自定义则默认构造方法失效<br>可变参数：一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明<br>（double… numbers）<br>protected void finalize()</p>\n<h3 id=\"18-BufferReader\"><a href=\"#18-BufferReader\" class=\"headerlink\" title=\"18.BufferReader\"></a>18.BufferReader</h3><p>read() write() scanner() print() println()</p>\n<h3 id=\"19-I-O\"><a href=\"#19-I-O\" class=\"headerlink\" title=\"19.I/O\"></a>19.I/O</h3><p>FileInputStream FileOutputStream File FileReader FileWrite mkdir mkdirs isDirectory delete()</p>\n<p>20.Scanner(System.in)<br>next nextLine</p>\n<p>21.Exception<br>java.lang.Exception Error  Throwable<br>IOException RuntimeException</p>\n<h3 id=\"22-面向对象\"><a href=\"#22-面向对象\" class=\"headerlink\" title=\"22.面向对象\"></a>22.面向对象</h3><h4 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h4><p>extends final修饰的类不能被集成，方法不能被重写  单继承</p>\n<h4 id=\"重写与重载\"><a href=\"#重写与重载\" class=\"headerlink\" title=\"重写与重载\"></a>重写与重载</h4><p>Override(返回值和形参都不能改变) Overload(方法名字相同，而参数不同。返回类型可以相同也可以不同)<br>构造方法不能被重写<br>最常用的地方就是构造器的重载</p>\n<h4 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h4><p>父类指向子类对象  Animal a = new Cat()   实现方式：重写，接口，抽象类和抽象方法  变量不能被重写</p>\n<h4 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h4><p>抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。</p>\n<h4 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h4><p>修改属性的可见性来限制对属性的访问（一般限制为private）<br>对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问</p>\n<h4 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h4><p>是抽象方法的集合。<br>有静态、final变量和抽象方法（JAVA8还可以有默认方法，静态方法），接口字段默认是public，static和final，方法默认是public和abstract<br>类描述对象的属性和方法。接口则包含类要实现的方法。<br>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。<br>一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。<br>接口中的方法会被隐式的指定为 public abstract，接口中的变量会被隐式的指定为 public static final<br>类的多重继承是不合法，但接口允许多重继承</p>\n<h4 id=\"包\"><a href=\"#包\" class=\"headerlink\" title=\"包\"></a>包</h4><p>小写开头<br>使用类全名描述 或 import(import 声明必须在包声明之后，类声明之前)</p>\n<h2 id=\"java高级\"><a href=\"#java高级\" class=\"headerlink\" title=\"java高级\"></a>java高级</h2><h3 id=\"1-一些概念理解\"><a href=\"#1-一些概念理解\" class=\"headerlink\" title=\"1.一些概念理解\"></a>1.一些概念理解</h3><h4 id=\"JVM-Java虚拟机\"><a href=\"#JVM-Java虚拟机\" class=\"headerlink\" title=\"JVM(Java虚拟机)\"></a>JVM(Java虚拟机)</h4><p>一个抽象机器。它是一个提供可以执行Java字节码的运行时环境的规范。<br>JVM执行以下主要任务：</p>\n<ul>\n<li>加载代码</li>\n<li>验证代码</li>\n<li>执行代码</li>\n<li>提供运行时环境<h4 id=\"JRE（Java-Runtime-Environment）\"><a href=\"#JRE（Java-Runtime-Environment）\" class=\"headerlink\" title=\"JRE（Java Runtime Environment）\"></a>JRE（Java Runtime Environment）</h4>用于提供Java运行时环境。它是JVM的实现。它是实际存在的。它包含一组库和JVM在运行时使用的其他文件。<h4 id=\"JDK（Java-Development-Kit）\"><a href=\"#JDK（Java-Development-Kit）\" class=\"headerlink\" title=\"JDK（Java Development Kit）\"></a>JDK（Java Development Kit）</h4>它是实际上存在的。它包含JRE+开发工具。</li>\n</ul>\n<p>JDK(JRE(JVM+LIB+OTHER)+IDE)</p>\n","site":{"data":{}},"excerpt":"<p>##JAVA基础</p>\n<h3 id=\"1-public类\"><a href=\"#1-public类\" class=\"headerlink\" title=\"1.public类\"></a>1.public类</h3><ul>\n<li>一个源文件中只能有一个public类</li>\n<li>一个源文件可以有多个非public类</li>\n</ul>\n<h3 id=\"2-package-import\"><a href=\"#2-package-import\" class=\"headerlink\" title=\"2.package/import\"></a>2.package/import</h3><p>编译java包：</p>\n<blockquote>\n<p>$ javac -d directory javafilename<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">E:\\sources&gt; javac -d c:\\classes Simple.java</div><div class=\"line\">//运行</div><div class=\"line\">e:\\sources&gt; set classpath=c:\\classes;.;</div><div class=\"line\">e:\\sources&gt; java mypack.Simple</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>OR<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">e:\\sources&gt; java -classpath c:\\classes mypack.Simple</div></pre></td></tr></table></figure></p>","more":"<p>加载类文件或jar文件的方式:</p>\n<ul>\n<li>加载临时类文件<ul>\n<li>通过在命令提示符中设置类路径</li>\n<li>通过 -classpath 开关选项</li>\n</ul>\n</li>\n<li>永久加载类文件<ul>\n<li>通过在环境变量中设置类路径</li>\n<li>通过创建jar文件，其中包含所有类文件，并将jar文件复制到JDK安装目录的jre/lib/ext文件夹中。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-引用类型\"><a href=\"#3-引用类型\" class=\"headerlink\" title=\"3.引用类型\"></a>3.引用类型</h3><p>对象、数组都是引用数据类型。<br>所有引用类型的默认值都是null。</p>\n<h3 id=\"4-JAVA常量\"><a href=\"#4-JAVA常量\" class=\"headerlink\" title=\"4.JAVA常量\"></a>4.JAVA常量</h3><p>在 Java 中使用 final 关键字来修饰常量，通常使用大写字母表示常量</p>\n<h3 id=\"5-基本数据类型\"><a href=\"#5-基本数据类型\" class=\"headerlink\" title=\"5. 基本数据类型\"></a>5. 基本数据类型</h3><ul>\n<li>不能对boolean类型进行类型转换。</li>\n<li>在把容量大的类型转换为容量小的类型时必须使用强制类型转换 double-&gt;float</li>\n</ul>\n<p>6.自动类型转换<br>转换前的数据类型的位数要低于转换后的数据类型。Float-&gt;double</p>\n<ol>\n<li>Java语言支持的变量类型<h4 id=\"类变量：独立于方法之外的变量，用-static-修饰。\"><a href=\"#类变量：独立于方法之外的变量，用-static-修饰。\" class=\"headerlink\" title=\"类变量：独立于方法之外的变量，用 static 修饰。\"></a>类变量：独立于方法之外的变量，用 static 修饰。</h4></li>\n</ol>\n<ul>\n<li>在类中以static关键字声明，但必须在方法构造方法和语句块之外</li>\n<li>静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。</li>\n<li>静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。</li>\n<li>为了对类的使用者可见，大多数静态变量声明为public类型</li>\n<li>默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。</li>\n<li>类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。</li>\n<li>静态块在类加载时main之前执行<h4 id=\"实例变量：独立于方法之外的变量，不过没有-static-修饰。\"><a href=\"#实例变量：独立于方法之外的变量，不过没有-static-修饰。\" class=\"headerlink\" title=\"实例变量：独立于方法之外的变量，不过没有 static 修饰。\"></a>实例变量：独立于方法之外的变量，不过没有 static 修饰。</h4></li>\n<li>当一个对象被实例化之后，每个实例变量的值就跟着确定；</li>\n<li>实例变量可以声明在使用前或者使用后；</li>\n<li>一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；</li>\n<li>实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；</li>\n<li>实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名<h4 id=\"局部变量：类的方法中的变量。\"><a href=\"#局部变量：类的方法中的变量。\" class=\"headerlink\" title=\"局部变量：类的方法中的变量。\"></a>局部变量：类的方法中的变量。</h4></li>\n<li>访问修饰符不能用于局部变量；</li>\n<li>局部变量是在栈上分配的。</li>\n<li>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。</li>\n</ul>\n<h4 id=\"实例初始化块\"><a href=\"#实例初始化块\" class=\"headerlink\" title=\"实例初始化块\"></a>实例初始化块</h4><p>主要有三个规则。 它们如下：</p>\n<ul>\n<li>在创建类的实例时创建实例初始化程序块。</li>\n<li>在父类构造函数被调用之后(即在super()构造函数调用之后)调用实例初始化块。</li>\n<li>实例初始化程序块按它们显示的顺序排列。</li>\n</ul>\n<h3 id=\"8．修饰符：访问修饰符、非访问修饰符\"><a href=\"#8．修饰符：访问修饰符、非访问修饰符\" class=\"headerlink\" title=\"8．修饰符：访问修饰符、非访问修饰符\"></a>8．修饰符：访问修饰符、非访问修饰符</h3><ul>\n<li>修饰符用来定义类、方法或者变量，通常放在语句的最前端，默认default<h4 id=\"访问修饰符\"><a href=\"#访问修饰符\" class=\"headerlink\" title=\"访问修饰符\"></a>访问修饰符</h4>（1） public/protected/default/private<br>（2） private: 只能通过类中公共的 getter 方法被外部类访问<br>（3） protected: 同一个包中的任何其他类访问，也能够被不同包中的子类访问</li>\n<li>public: 如果几个相互访问的 public 类分布在不同的包中，则需要导入相应 public 类所在的包</li>\n<li>注意：父类中声明为 public 的方法在子类中也必须为 public。</li>\n<li>父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。</li>\n<li>父类中声明为 private 的方法，不能够被继承。</li>\n</ul>\n<h4 id=\"非访问修饰符\"><a href=\"#非访问修饰符\" class=\"headerlink\" title=\"非访问修饰符\"></a>非访问修饰符</h4><p>static,abstract,final,synchronized,volatile<br>（1）final：用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。</p>\n<ul>\n<li>final 变量：能被显式地初始化并且只能初始化一次。被声明为 final 的对象的引用不能指向不同的对象。但是 final 对象里的数据可以被改变。也就是说 final 对象的引用不能改变，但是里面的值可以改变。final 修饰符通常和 static 修饰符一起使用来创建类常量。</li>\n<li>final 方法：类中的 final 方法可以被子类继承，但是不能被子类修改。</li>\n<li>final 类：final 类不能被继承，没有类能够继承 final 类的任何特性。</li>\n<li>被声明为 final 类的方法自动地声明为 final，但是实例变量并不是 final</li>\n<li>在声明时未初始化的静态final变量称为静态空白final变量。 它只能在静态块中初始化。<br>（2）abstract: 抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充<br>一个类不能同时被 abstract 和 final 修饰。<br>抽象方法:是一种没有任何实现的方法，该方法的的具体实现由子类提供。</li>\n<li>抽象方法不能被声明成 final 和 static。</li>\n<li>任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。</li>\n<li>如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。抽象类可以包含抽象方法和非抽象方法。</li>\n<li>抽象方法的声明以分号结尾，例如：public abstract sample()。<br>在java中有两种实现抽象的方法，它们分别是：</li>\n<li>抽象类(部分)</li>\n<li>接口 (完全)<br>抽象类实现了部分抽象(0到100％)，而接口实现了完全抽象(100％)。<br><img src=\"http://o8cfktdb3.bkt.clouddn.com/acAndIfa.png\" alt=\"抽象类与接口\"></li>\n</ul>\n<h3 id=\"9-instanceof-name-instanceof-String\"><a href=\"#9-instanceof-name-instanceof-String\" class=\"headerlink\" title=\"9.instanceof: name instanceof String\"></a>9.instanceof: name instanceof String</h3><p>增强for循环：for(声明语句 : 表达式)<br>switch支持字符串，直到break退出</p>\n<h3 id=\"10-装箱-拆箱\"><a href=\"#10-装箱-拆箱\" class=\"headerlink\" title=\"10.装箱/拆箱\"></a>10.装箱/拆箱</h3><p>装箱：int-&gt;number  拆箱：number-&gt;int<br>intValue() valueOf() compareo() equals() parseInt()(string-&gt;int) ceil() floor() random()</p>\n<h3 id=\"11-Character-char的包装类\"><a href=\"#11-Character-char的包装类\" class=\"headerlink\" title=\"11.Character char的包装类\"></a>11.Character char的包装类</h3><p>isLetter() isDigit() isUpperCase() isWhitespace() toUpperCase() toString()</p>\n<h3 id=\"12-String\"><a href=\"#12-String\" class=\"headerlink\" title=\"12.String\"></a>12.String</h3><p>length() s1.concat(s2)  s = format(”—%f %d %s”,floatVar,.,.) charAt(index) int compareo()(对象，字符串)<br>boolean contentEquals(StringBuffer)  endsWith() equals()  indexOf(ch) split substring</p>\n<h3 id=\"13-StringBuffer-StringBuilder\"><a href=\"#13-StringBuffer-StringBuilder\" class=\"headerlink\" title=\"13. StringBuffer/StringBuilder\"></a>13. StringBuffer/StringBuilder</h3><p>当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。<br>StringBuffer(线程安全) StringBuilder(速度优势,不是线程安全的,不能同步访问)  多数情况下建议使用 StringBuilder 类<br>StringBuffer：append(s) reverse dekete(start,end) replace(start,end,str) capacity() charAt() indexOf() toString substring</p>\n<h3 id=\"14-Arrays数组\"><a href=\"#14-Arrays数组\" class=\"headerlink\" title=\"14.Arrays数组\"></a>14.Arrays数组</h3><p>double[] list = new double[10];  参数：(int[] array)  返回值：int[]<br>fill sort equals binarySearch</p>\n<h3 id=\"15-Date\"><a href=\"#15-Date\" class=\"headerlink\" title=\"15.Date\"></a>15.Date</h3><p>date.toString() getime() after before equals compareo   format parse<br>SimpleDateFormat(E yyyy-MM-dd HH:mm:ss a zzz) PM<br>Sleep(1000*3)  Calender.getInstance()</p>\n<h3 id=\"16-正则表达式\"><a href=\"#16-正则表达式\" class=\"headerlink\" title=\"16.正则表达式\"></a>16.正则表达式</h3><p>Pattern Matcher<br>\\s+ 多个空格  ^$ 以什么开始  \\d+多个数字  ()? 0/1 可选  * 0/n  +1\\n   {n} (n,) &gt;=n  . 除\\n\\r之外的任何单个字符<br>[xyz] [^xyz] [a-z]  \\b字符边界</p>\n<h3 id=\"17-function\"><a href=\"#17-function\" class=\"headerlink\" title=\"17.function\"></a>17.function</h3><p>重载：方法名相同，参数列表不同<br>构造方法：方法名与类名相同，没有返回值，自定义则默认构造方法失效<br>可变参数：一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明<br>（double… numbers）<br>protected void finalize()</p>\n<h3 id=\"18-BufferReader\"><a href=\"#18-BufferReader\" class=\"headerlink\" title=\"18.BufferReader\"></a>18.BufferReader</h3><p>read() write() scanner() print() println()</p>\n<h3 id=\"19-I-O\"><a href=\"#19-I-O\" class=\"headerlink\" title=\"19.I/O\"></a>19.I/O</h3><p>FileInputStream FileOutputStream File FileReader FileWrite mkdir mkdirs isDirectory delete()</p>\n<p>20.Scanner(System.in)<br>next nextLine</p>\n<p>21.Exception<br>java.lang.Exception Error  Throwable<br>IOException RuntimeException</p>\n<h3 id=\"22-面向对象\"><a href=\"#22-面向对象\" class=\"headerlink\" title=\"22.面向对象\"></a>22.面向对象</h3><h4 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h4><p>extends final修饰的类不能被集成，方法不能被重写  单继承</p>\n<h4 id=\"重写与重载\"><a href=\"#重写与重载\" class=\"headerlink\" title=\"重写与重载\"></a>重写与重载</h4><p>Override(返回值和形参都不能改变) Overload(方法名字相同，而参数不同。返回类型可以相同也可以不同)<br>构造方法不能被重写<br>最常用的地方就是构造器的重载</p>\n<h4 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h4><p>父类指向子类对象  Animal a = new Cat()   实现方式：重写，接口，抽象类和抽象方法  变量不能被重写</p>\n<h4 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h4><p>抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。</p>\n<h4 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h4><p>修改属性的可见性来限制对属性的访问（一般限制为private）<br>对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问</p>\n<h4 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h4><p>是抽象方法的集合。<br>有静态、final变量和抽象方法（JAVA8还可以有默认方法，静态方法），接口字段默认是public，static和final，方法默认是public和abstract<br>类描述对象的属性和方法。接口则包含类要实现的方法。<br>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。<br>一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。<br>接口中的方法会被隐式的指定为 public abstract，接口中的变量会被隐式的指定为 public static final<br>类的多重继承是不合法，但接口允许多重继承</p>\n<h4 id=\"包\"><a href=\"#包\" class=\"headerlink\" title=\"包\"></a>包</h4><p>小写开头<br>使用类全名描述 或 import(import 声明必须在包声明之后，类声明之前)</p>\n<h2 id=\"java高级\"><a href=\"#java高级\" class=\"headerlink\" title=\"java高级\"></a>java高级</h2><h3 id=\"1-一些概念理解\"><a href=\"#1-一些概念理解\" class=\"headerlink\" title=\"1.一些概念理解\"></a>1.一些概念理解</h3><h4 id=\"JVM-Java虚拟机\"><a href=\"#JVM-Java虚拟机\" class=\"headerlink\" title=\"JVM(Java虚拟机)\"></a>JVM(Java虚拟机)</h4><p>一个抽象机器。它是一个提供可以执行Java字节码的运行时环境的规范。<br>JVM执行以下主要任务：</p>\n<ul>\n<li>加载代码</li>\n<li>验证代码</li>\n<li>执行代码</li>\n<li>提供运行时环境<h4 id=\"JRE（Java-Runtime-Environment）\"><a href=\"#JRE（Java-Runtime-Environment）\" class=\"headerlink\" title=\"JRE（Java Runtime Environment）\"></a>JRE（Java Runtime Environment）</h4>用于提供Java运行时环境。它是JVM的实现。它是实际存在的。它包含一组库和JVM在运行时使用的其他文件。<h4 id=\"JDK（Java-Development-Kit）\"><a href=\"#JDK（Java-Development-Kit）\" class=\"headerlink\" title=\"JDK（Java Development Kit）\"></a>JDK（Java Development Kit）</h4>它是实际上存在的。它包含JRE+开发工具。</li>\n</ul>\n<p>JDK(JRE(JVM+LIB+OTHER)+IDE)</p>"},{"title":"MVVM学习笔记","date":"2017-05-20T03:38:51.000Z","_content":"\n## MVVM的四个组件：\n* view ：由 MVC 中的 view 和 controller 组成，负责 UI 的展示，绑定 viewModel 中的属性，触发 viewModel 中的命令；\n* viewModel ：从 MVC 的 controller 中抽取出来的展示逻辑，负责从 model 中获取 view 所需的数据，转换成 view 可以展示的数据，并暴露公开的属性和命令供 view 进行绑定；\n* model ：与 MVC 中的 model 一致，包括数据模型、访问数据库的操作和网络请求等；\n* binder ：在 MVVM 中，声明式的数据和命令绑定是一个隐含的约定，它可以让开发者非常方便地实现 view 和 viewModel 的同步，避免编写大量繁杂的样板化代码。在微软的 MVVM 实现中，使用的是一种被称为 XAML 的标记语言。\n<!--more-->\n总结：在 iOS 的 MVVM 实现中，我们可以使用 RAC 来在 view 和 viewModel 之间充当 binder 的角色，优雅地实现两者之间的同步。此外，我们还可以把 RAC 用在 model 层，使用 Signal 来代表异步的数据获取操作，比如读取文件、访问数据库和网络请求等。\n\n## 实现MVC到MVVM的转变\n> 将 MVC 中的 controller 中的展示逻辑抽取出来，放置到 viewModel 中，然后通过一定的技术手段，比如 RAC 来同步 view 和 viewModel。\n\n## MVVM相较于MVM的优势\n* 由于展示逻辑被抽取到了 viewModel 中，所以 view 中的代码将会变得非常轻量级；\n* 由于 viewModel 中的代码是与 UI 无关的，所以它具有良好的可测试性；\n* 对于一个封装了大量业务逻辑的 model 来说，改变它可能会比较困难，并且存在一定的风险。在这种场景下，viewModel 可以作为 model 的适配器使用，从而避免对 model 进行较大的改动。\n\n参考链接：[MVVM With ReactiveCocoa](http://blog.leichunfeng.com/blog/2016/02/27/mvvm-with-reactivecocoa/)\n","source":"_posts/MVVM学习笔记.md","raw":"---\ntitle: MVVM学习笔记\ndate: 2017-05-20 11:38:51\ncategories: 笔记\ntags: [iOS,MVVM]\n---\n\n## MVVM的四个组件：\n* view ：由 MVC 中的 view 和 controller 组成，负责 UI 的展示，绑定 viewModel 中的属性，触发 viewModel 中的命令；\n* viewModel ：从 MVC 的 controller 中抽取出来的展示逻辑，负责从 model 中获取 view 所需的数据，转换成 view 可以展示的数据，并暴露公开的属性和命令供 view 进行绑定；\n* model ：与 MVC 中的 model 一致，包括数据模型、访问数据库的操作和网络请求等；\n* binder ：在 MVVM 中，声明式的数据和命令绑定是一个隐含的约定，它可以让开发者非常方便地实现 view 和 viewModel 的同步，避免编写大量繁杂的样板化代码。在微软的 MVVM 实现中，使用的是一种被称为 XAML 的标记语言。\n<!--more-->\n总结：在 iOS 的 MVVM 实现中，我们可以使用 RAC 来在 view 和 viewModel 之间充当 binder 的角色，优雅地实现两者之间的同步。此外，我们还可以把 RAC 用在 model 层，使用 Signal 来代表异步的数据获取操作，比如读取文件、访问数据库和网络请求等。\n\n## 实现MVC到MVVM的转变\n> 将 MVC 中的 controller 中的展示逻辑抽取出来，放置到 viewModel 中，然后通过一定的技术手段，比如 RAC 来同步 view 和 viewModel。\n\n## MVVM相较于MVM的优势\n* 由于展示逻辑被抽取到了 viewModel 中，所以 view 中的代码将会变得非常轻量级；\n* 由于 viewModel 中的代码是与 UI 无关的，所以它具有良好的可测试性；\n* 对于一个封装了大量业务逻辑的 model 来说，改变它可能会比较困难，并且存在一定的风险。在这种场景下，viewModel 可以作为 model 的适配器使用，从而避免对 model 进行较大的改动。\n\n参考链接：[MVVM With ReactiveCocoa](http://blog.leichunfeng.com/blog/2016/02/27/mvvm-with-reactivecocoa/)\n","slug":"MVVM学习笔记","published":1,"updated":"2017-07-14T03:57:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj53c1dva000dh3jjf5rwkwss","content":"<h2 id=\"MVVM的四个组件：\"><a href=\"#MVVM的四个组件：\" class=\"headerlink\" title=\"MVVM的四个组件：\"></a>MVVM的四个组件：</h2><ul>\n<li>view ：由 MVC 中的 view 和 controller 组成，负责 UI 的展示，绑定 viewModel 中的属性，触发 viewModel 中的命令；</li>\n<li>viewModel ：从 MVC 的 controller 中抽取出来的展示逻辑，负责从 model 中获取 view 所需的数据，转换成 view 可以展示的数据，并暴露公开的属性和命令供 view 进行绑定；</li>\n<li>model ：与 MVC 中的 model 一致，包括数据模型、访问数据库的操作和网络请求等；</li>\n<li>binder ：在 MVVM 中，声明式的数据和命令绑定是一个隐含的约定，它可以让开发者非常方便地实现 view 和 viewModel 的同步，避免编写大量繁杂的样板化代码。在微软的 MVVM 实现中，使用的是一种被称为 XAML 的标记语言。<a id=\"more\"></a>\n总结：在 iOS 的 MVVM 实现中，我们可以使用 RAC 来在 view 和 viewModel 之间充当 binder 的角色，优雅地实现两者之间的同步。此外，我们还可以把 RAC 用在 model 层，使用 Signal 来代表异步的数据获取操作，比如读取文件、访问数据库和网络请求等。</li>\n</ul>\n<h2 id=\"实现MVC到MVVM的转变\"><a href=\"#实现MVC到MVVM的转变\" class=\"headerlink\" title=\"实现MVC到MVVM的转变\"></a>实现MVC到MVVM的转变</h2><blockquote>\n<p>将 MVC 中的 controller 中的展示逻辑抽取出来，放置到 viewModel 中，然后通过一定的技术手段，比如 RAC 来同步 view 和 viewModel。</p>\n</blockquote>\n<h2 id=\"MVVM相较于MVM的优势\"><a href=\"#MVVM相较于MVM的优势\" class=\"headerlink\" title=\"MVVM相较于MVM的优势\"></a>MVVM相较于MVM的优势</h2><ul>\n<li>由于展示逻辑被抽取到了 viewModel 中，所以 view 中的代码将会变得非常轻量级；</li>\n<li>由于 viewModel 中的代码是与 UI 无关的，所以它具有良好的可测试性；</li>\n<li>对于一个封装了大量业务逻辑的 model 来说，改变它可能会比较困难，并且存在一定的风险。在这种场景下，viewModel 可以作为 model 的适配器使用，从而避免对 model 进行较大的改动。</li>\n</ul>\n<p>参考链接：<a href=\"http://blog.leichunfeng.com/blog/2016/02/27/mvvm-with-reactivecocoa/\" target=\"_blank\" rel=\"external\">MVVM With ReactiveCocoa</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"MVVM的四个组件：\"><a href=\"#MVVM的四个组件：\" class=\"headerlink\" title=\"MVVM的四个组件：\"></a>MVVM的四个组件：</h2><ul>\n<li>view ：由 MVC 中的 view 和 controller 组成，负责 UI 的展示，绑定 viewModel 中的属性，触发 viewModel 中的命令；</li>\n<li>viewModel ：从 MVC 的 controller 中抽取出来的展示逻辑，负责从 model 中获取 view 所需的数据，转换成 view 可以展示的数据，并暴露公开的属性和命令供 view 进行绑定；</li>\n<li>model ：与 MVC 中的 model 一致，包括数据模型、访问数据库的操作和网络请求等；</li>\n<li>binder ：在 MVVM 中，声明式的数据和命令绑定是一个隐含的约定，它可以让开发者非常方便地实现 view 和 viewModel 的同步，避免编写大量繁杂的样板化代码。在微软的 MVVM 实现中，使用的是一种被称为 XAML 的标记语言。","more":"总结：在 iOS 的 MVVM 实现中，我们可以使用 RAC 来在 view 和 viewModel 之间充当 binder 的角色，优雅地实现两者之间的同步。此外，我们还可以把 RAC 用在 model 层，使用 Signal 来代表异步的数据获取操作，比如读取文件、访问数据库和网络请求等。</li>\n</ul>\n<h2 id=\"实现MVC到MVVM的转变\"><a href=\"#实现MVC到MVVM的转变\" class=\"headerlink\" title=\"实现MVC到MVVM的转变\"></a>实现MVC到MVVM的转变</h2><blockquote>\n<p>将 MVC 中的 controller 中的展示逻辑抽取出来，放置到 viewModel 中，然后通过一定的技术手段，比如 RAC 来同步 view 和 viewModel。</p>\n</blockquote>\n<h2 id=\"MVVM相较于MVM的优势\"><a href=\"#MVVM相较于MVM的优势\" class=\"headerlink\" title=\"MVVM相较于MVM的优势\"></a>MVVM相较于MVM的优势</h2><ul>\n<li>由于展示逻辑被抽取到了 viewModel 中，所以 view 中的代码将会变得非常轻量级；</li>\n<li>由于 viewModel 中的代码是与 UI 无关的，所以它具有良好的可测试性；</li>\n<li>对于一个封装了大量业务逻辑的 model 来说，改变它可能会比较困难，并且存在一定的风险。在这种场景下，viewModel 可以作为 model 的适配器使用，从而避免对 model 进行较大的改动。</li>\n</ul>\n<p>参考链接：<a href=\"http://blog.leichunfeng.com/blog/2016/02/27/mvvm-with-reactivecocoa/\" target=\"_blank\" rel=\"external\">MVVM With ReactiveCocoa</a></p>"},{"title":"Markdown学习笔记","date":"2017-02-19T01:48:39.000Z","_content":"\n基本语法\n----------  \n\n### 1.换行符： 一行结束时输入两个空格\n>line1  \n>line2  \n\n### 2.段落： 段落之间空一行  \n>p1\n\n>p2\n>p3  \n<!--more-->\n### 3.标题：\n+ （1）Setext形式：= 大标题 - 中标题  \n+ （2）atx形式：#  \n>大标题\n>====== \n>中标题\n>------ \n># 一级标题  \n>## 二级标题  \n>### 三级标题  \n>#### 四级标题  \n>##### 五级标题  \n>###### 六级标题  \n\n### 4.区块引用：\\>  \n>区块1\n>>区块2\n>>>区块3  \n\n\n### 5.列表：*/+/-  前后加空格，tab键或四个空格可分级\n>* 列表1\n>    + 列表2\n>        - 列表3  \n\n### 6.斜体、粗体、删除线\n斜体：`*斜体*`   *斜体*  \n粗体：`**斜体**`   **粗体**\n粗斜体：`***斜体***`   ***粗斜体***  \n删除线：`~~删除线~~`   ~~删除线~~\n\n### 7.内嵌代码：\\` 内嵌代码 \\`  ` 内嵌代码 `  \n\n### 8.水平线：------  \n>----------------------\n\n### 9.链接：  \n+ [文字]（url title）\n+ ![]（图片 title）\n>[百度一下-你就知道](http://www.baidu.com \"百度一下\")\n>![百度](baidu.png \"百度图片\")\n\n### 10.注意：反斜杠\\实现转义效果\n\n### 11.表格\n```\n| title1 | title2 |   title3  |\n|--------|--------|-----------|\n|   a    |   aa   |    aaa    |\n|   b    |   bb   |    bbb    |\n|   c    |   cc   |    ccc    |\n```\n\n| title1 | title2 |   title3  |\n|--------|--------|-----------|\n|   a    |   aa   |    aaa    |\n|   b    |   bb   |    bbb    |\n|   c    |   cc   |    ccc    |\n","source":"_posts/Markdown学习笔记.md","raw":"---\ntitle: Markdown学习笔记\ndate: 2017-02-19 09:48:39\ncategories: 笔记\ntags: [markdown]\n---\n\n基本语法\n----------  \n\n### 1.换行符： 一行结束时输入两个空格\n>line1  \n>line2  \n\n### 2.段落： 段落之间空一行  \n>p1\n\n>p2\n>p3  \n<!--more-->\n### 3.标题：\n+ （1）Setext形式：= 大标题 - 中标题  \n+ （2）atx形式：#  \n>大标题\n>====== \n>中标题\n>------ \n># 一级标题  \n>## 二级标题  \n>### 三级标题  \n>#### 四级标题  \n>##### 五级标题  \n>###### 六级标题  \n\n### 4.区块引用：\\>  \n>区块1\n>>区块2\n>>>区块3  \n\n\n### 5.列表：*/+/-  前后加空格，tab键或四个空格可分级\n>* 列表1\n>    + 列表2\n>        - 列表3  \n\n### 6.斜体、粗体、删除线\n斜体：`*斜体*`   *斜体*  \n粗体：`**斜体**`   **粗体**\n粗斜体：`***斜体***`   ***粗斜体***  \n删除线：`~~删除线~~`   ~~删除线~~\n\n### 7.内嵌代码：\\` 内嵌代码 \\`  ` 内嵌代码 `  \n\n### 8.水平线：------  \n>----------------------\n\n### 9.链接：  \n+ [文字]（url title）\n+ ![]（图片 title）\n>[百度一下-你就知道](http://www.baidu.com \"百度一下\")\n>![百度](baidu.png \"百度图片\")\n\n### 10.注意：反斜杠\\实现转义效果\n\n### 11.表格\n```\n| title1 | title2 |   title3  |\n|--------|--------|-----------|\n|   a    |   aa   |    aaa    |\n|   b    |   bb   |    bbb    |\n|   c    |   cc   |    ccc    |\n```\n\n| title1 | title2 |   title3  |\n|--------|--------|-----------|\n|   a    |   aa   |    aaa    |\n|   b    |   bb   |    bbb    |\n|   c    |   cc   |    ccc    |\n","slug":"Markdown学习笔记","published":1,"updated":"2017-07-14T03:57:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj53c1dvd000gh3jjloql2all","content":"<h2 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h2><h3 id=\"1-换行符：-一行结束时输入两个空格\"><a href=\"#1-换行符：-一行结束时输入两个空格\" class=\"headerlink\" title=\"1.换行符： 一行结束时输入两个空格\"></a>1.换行符： 一行结束时输入两个空格</h3><blockquote>\n<p>line1<br>line2  </p>\n</blockquote>\n<h3 id=\"2-段落：-段落之间空一行\"><a href=\"#2-段落：-段落之间空一行\" class=\"headerlink\" title=\"2.段落： 段落之间空一行\"></a>2.段落： 段落之间空一行</h3><blockquote>\n<p>p1</p>\n<p>p2<br>p3<br><a id=\"more\"></a></p>\n<h3 id=\"3-标题：\"><a href=\"#3-标题：\" class=\"headerlink\" title=\"3.标题：\"></a>3.标题：</h3><ul>\n<li>（1）Setext形式：= 大标题 - 中标题  </li>\n<li>（2）atx形式：#  <h1 id=\"大标题\"><a href=\"#大标题\" class=\"headerlink\" title=\"大标题\"></a>大标题</h1>中标题</li>\n</ul>\n<hr>\n<h1 id=\"一级标题\"><a href=\"#一级标题\" class=\"headerlink\" title=\"一级标题\"></a>一级标题</h1><h2 id=\"二级标题\"><a href=\"#二级标题\" class=\"headerlink\" title=\"二级标题\"></a>二级标题</h2><h3 id=\"三级标题\"><a href=\"#三级标题\" class=\"headerlink\" title=\"三级标题\"></a>三级标题</h3><h4 id=\"四级标题\"><a href=\"#四级标题\" class=\"headerlink\" title=\"四级标题\"></a>四级标题</h4><h5 id=\"五级标题\"><a href=\"#五级标题\" class=\"headerlink\" title=\"五级标题\"></a>五级标题</h5><h6 id=\"六级标题\"><a href=\"#六级标题\" class=\"headerlink\" title=\"六级标题\"></a>六级标题</h6></blockquote>\n<h3 id=\"4-区块引用：\"><a href=\"#4-区块引用：\" class=\"headerlink\" title=\"4.区块引用：>\"></a>4.区块引用：></h3><blockquote>\n<p>区块1</p>\n<blockquote>\n<p>区块2</p>\n<blockquote>\n<p>区块3  </p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h3 id=\"5-列表：-前后加空格，tab键或四个空格可分级\"><a href=\"#5-列表：-前后加空格，tab键或四个空格可分级\" class=\"headerlink\" title=\"5.列表：*/+/-  前后加空格，tab键或四个空格可分级\"></a>5.列表：*/+/-  前后加空格，tab键或四个空格可分级</h3><blockquote>\n<ul>\n<li>列表1<ul>\n<li>列表2<ul>\n<li>列表3  </li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"6-斜体、粗体、删除线\"><a href=\"#6-斜体、粗体、删除线\" class=\"headerlink\" title=\"6.斜体、粗体、删除线\"></a>6.斜体、粗体、删除线</h3><p>斜体：<code>*斜体*</code>   <em>斜体</em><br>粗体：<code>**斜体**</code>   <strong>粗体</strong><br>粗斜体：<code>***斜体***</code>   <strong><em>粗斜体</em></strong><br>删除线：<code>~~删除线~~</code>   <del>删除线</del></p>\n<h3 id=\"7-内嵌代码：-内嵌代码-内嵌代码\"><a href=\"#7-内嵌代码：-内嵌代码-内嵌代码\" class=\"headerlink\" title=\"7.内嵌代码：` 内嵌代码 `  内嵌代码\"></a>7.内嵌代码：` 内嵌代码 `  <code>内嵌代码</code></h3><h3 id=\"8-水平线：——\"><a href=\"#8-水平线：——\" class=\"headerlink\" title=\"8.水平线：——\"></a>8.水平线：——</h3><blockquote>\n<hr>\n</blockquote>\n<h3 id=\"9-链接：\"><a href=\"#9-链接：\" class=\"headerlink\" title=\"9.链接：\"></a>9.链接：</h3><ul>\n<li>[文字]（url title）</li>\n<li>![]（图片 title）<blockquote>\n<p><a href=\"http://www.baidu.com\" title=\"百度一下\" target=\"_blank\" rel=\"external\">百度一下-你就知道</a><br><img src=\"baidu.png\" alt=\"百度\" title=\"百度图片\"></p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"10-注意：反斜杠-实现转义效果\"><a href=\"#10-注意：反斜杠-实现转义效果\" class=\"headerlink\" title=\"10.注意：反斜杠\\实现转义效果\"></a>10.注意：反斜杠\\实现转义效果</h3><h3 id=\"11-表格\"><a href=\"#11-表格\" class=\"headerlink\" title=\"11.表格\"></a>11.表格</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">| title1 | title2 |   title3  |</div><div class=\"line\">|--------|--------|-----------|</div><div class=\"line\">|   a    |   aa   |    aaa    |</div><div class=\"line\">|   b    |   bb   |    bbb    |</div><div class=\"line\">|   c    |   cc   |    ccc    |</div></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>title1</th>\n<th>title2</th>\n<th>title3</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a</td>\n<td>aa</td>\n<td>aaa</td>\n</tr>\n<tr>\n<td>b</td>\n<td>bb</td>\n<td>bbb</td>\n</tr>\n<tr>\n<td>c</td>\n<td>cc</td>\n<td>ccc</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"<h2 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h2><h3 id=\"1-换行符：-一行结束时输入两个空格\"><a href=\"#1-换行符：-一行结束时输入两个空格\" class=\"headerlink\" title=\"1.换行符： 一行结束时输入两个空格\"></a>1.换行符： 一行结束时输入两个空格</h3><blockquote>\n<p>line1<br>line2  </p>\n</blockquote>\n<h3 id=\"2-段落：-段落之间空一行\"><a href=\"#2-段落：-段落之间空一行\" class=\"headerlink\" title=\"2.段落： 段落之间空一行\"></a>2.段落： 段落之间空一行</h3><blockquote>\n<p>p1</p>\n<p>p2<br>p3<br>","more":"</p>\n<h3 id=\"3-标题：\"><a href=\"#3-标题：\" class=\"headerlink\" title=\"3.标题：\"></a>3.标题：</h3><ul>\n<li>（1）Setext形式：= 大标题 - 中标题  </li>\n<li>（2）atx形式：#  <h1 id=\"大标题\"><a href=\"#大标题\" class=\"headerlink\" title=\"大标题\"></a>大标题</h1>中标题</li>\n</ul>\n<hr>\n<h1 id=\"一级标题\"><a href=\"#一级标题\" class=\"headerlink\" title=\"一级标题\"></a>一级标题</h1><h2 id=\"二级标题\"><a href=\"#二级标题\" class=\"headerlink\" title=\"二级标题\"></a>二级标题</h2><h3 id=\"三级标题\"><a href=\"#三级标题\" class=\"headerlink\" title=\"三级标题\"></a>三级标题</h3><h4 id=\"四级标题\"><a href=\"#四级标题\" class=\"headerlink\" title=\"四级标题\"></a>四级标题</h4><h5 id=\"五级标题\"><a href=\"#五级标题\" class=\"headerlink\" title=\"五级标题\"></a>五级标题</h5><h6 id=\"六级标题\"><a href=\"#六级标题\" class=\"headerlink\" title=\"六级标题\"></a>六级标题</h6></blockquote>\n<h3 id=\"4-区块引用：\"><a href=\"#4-区块引用：\" class=\"headerlink\" title=\"4.区块引用：>\"></a>4.区块引用：></h3><blockquote>\n<p>区块1</p>\n<blockquote>\n<p>区块2</p>\n<blockquote>\n<p>区块3  </p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h3 id=\"5-列表：-前后加空格，tab键或四个空格可分级\"><a href=\"#5-列表：-前后加空格，tab键或四个空格可分级\" class=\"headerlink\" title=\"5.列表：*/+/-  前后加空格，tab键或四个空格可分级\"></a>5.列表：*/+/-  前后加空格，tab键或四个空格可分级</h3><blockquote>\n<ul>\n<li>列表1<ul>\n<li>列表2<ul>\n<li>列表3  </li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"6-斜体、粗体、删除线\"><a href=\"#6-斜体、粗体、删除线\" class=\"headerlink\" title=\"6.斜体、粗体、删除线\"></a>6.斜体、粗体、删除线</h3><p>斜体：<code>*斜体*</code>   <em>斜体</em><br>粗体：<code>**斜体**</code>   <strong>粗体</strong><br>粗斜体：<code>***斜体***</code>   <strong><em>粗斜体</em></strong><br>删除线：<code>~~删除线~~</code>   <del>删除线</del></p>\n<h3 id=\"7-内嵌代码：-内嵌代码-内嵌代码\"><a href=\"#7-内嵌代码：-内嵌代码-内嵌代码\" class=\"headerlink\" title=\"7.内嵌代码：` 内嵌代码 `  内嵌代码\"></a>7.内嵌代码：` 内嵌代码 `  <code>内嵌代码</code></h3><h3 id=\"8-水平线：——\"><a href=\"#8-水平线：——\" class=\"headerlink\" title=\"8.水平线：——\"></a>8.水平线：——</h3><blockquote>\n<hr>\n</blockquote>\n<h3 id=\"9-链接：\"><a href=\"#9-链接：\" class=\"headerlink\" title=\"9.链接：\"></a>9.链接：</h3><ul>\n<li>[文字]（url title）</li>\n<li>![]（图片 title）<blockquote>\n<p><a href=\"http://www.baidu.com\" title=\"百度一下\" target=\"_blank\" rel=\"external\">百度一下-你就知道</a><br><img src=\"baidu.png\" alt=\"百度\" title=\"百度图片\"></p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"10-注意：反斜杠-实现转义效果\"><a href=\"#10-注意：反斜杠-实现转义效果\" class=\"headerlink\" title=\"10.注意：反斜杠\\实现转义效果\"></a>10.注意：反斜杠\\实现转义效果</h3><h3 id=\"11-表格\"><a href=\"#11-表格\" class=\"headerlink\" title=\"11.表格\"></a>11.表格</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">| title1 | title2 |   title3  |</div><div class=\"line\">|--------|--------|-----------|</div><div class=\"line\">|   a    |   aa   |    aaa    |</div><div class=\"line\">|   b    |   bb   |    bbb    |</div><div class=\"line\">|   c    |   cc   |    ccc    |</div></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>title1</th>\n<th>title2</th>\n<th>title3</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a</td>\n<td>aa</td>\n<td>aaa</td>\n</tr>\n<tr>\n<td>b</td>\n<td>bb</td>\n<td>bbb</td>\n</tr>\n<tr>\n<td>c</td>\n<td>cc</td>\n<td>ccc</td>\n</tr>\n</tbody>\n</table>"},{"title":"MyEclipse快捷键","date":"2017-06-09T01:33:03.000Z","_content":"\n1.补全：alt+/\n2.修复：ctrl+1\n3.删除当前行：ctrl+d\n4.复制当前行到上一行/下一行：ctrl+alt+上/下方向键\n5.互换位置：alt+上/下方向键\n<!--more-->\n6.上/下一个编辑的页面：alt+左/右方向键\n7.显示工程文件目录：alt+enter\n8.当前行插入空行：shift+enter(+ctrl 下一行插入)\n9.格式化：ctrl+shift+f\n10.重命名：alt+shift+r\n11.抽取方法：alt+shift+m\n12.组织导入（自动加入引用）：ctrl+shift+o\n13.添加导入：Ctrl+Shift+M \n14.单步返回 F7 \n15.单步跳过 F6 \n16.单步跳入 F5 \n17.单步跳入选择 Ctrl+F5 \n18.调试上次启动 F11 \n19.继续 F8 \n","source":"_posts/MyEclipse快捷键.md","raw":"---\ntitle: MyEclipse快捷键\ndate: 2017-06-09 09:33:03\ncategories: 笔记\ntags: [Java,快捷键]\n---\n\n1.补全：alt+/\n2.修复：ctrl+1\n3.删除当前行：ctrl+d\n4.复制当前行到上一行/下一行：ctrl+alt+上/下方向键\n5.互换位置：alt+上/下方向键\n<!--more-->\n6.上/下一个编辑的页面：alt+左/右方向键\n7.显示工程文件目录：alt+enter\n8.当前行插入空行：shift+enter(+ctrl 下一行插入)\n9.格式化：ctrl+shift+f\n10.重命名：alt+shift+r\n11.抽取方法：alt+shift+m\n12.组织导入（自动加入引用）：ctrl+shift+o\n13.添加导入：Ctrl+Shift+M \n14.单步返回 F7 \n15.单步跳过 F6 \n16.单步跳入 F5 \n17.单步跳入选择 Ctrl+F5 \n18.调试上次启动 F11 \n19.继续 F8 \n","slug":"MyEclipse快捷键","published":1,"updated":"2017-07-14T03:57:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj53c1dve000jh3jj67zuf972","content":"<p>1.补全：alt+/<br>2.修复：ctrl+1<br>3.删除当前行：ctrl+d<br>4.复制当前行到上一行/下一行：ctrl+alt+上/下方向键<br>5.互换位置：alt+上/下方向键<br><a id=\"more\"></a><br>6.上/下一个编辑的页面：alt+左/右方向键<br>7.显示工程文件目录：alt+enter<br>8.当前行插入空行：shift+enter(+ctrl 下一行插入)<br>9.格式化：ctrl+shift+f<br>10.重命名：alt+shift+r<br>11.抽取方法：alt+shift+m<br>12.组织导入（自动加入引用）：ctrl+shift+o<br>13.添加导入：Ctrl+Shift+M<br>14.单步返回 F7<br>15.单步跳过 F6<br>16.单步跳入 F5<br>17.单步跳入选择 Ctrl+F5<br>18.调试上次启动 F11<br>19.继续 F8 </p>\n","site":{"data":{}},"excerpt":"<p>1.补全：alt+/<br>2.修复：ctrl+1<br>3.删除当前行：ctrl+d<br>4.复制当前行到上一行/下一行：ctrl+alt+上/下方向键<br>5.互换位置：alt+上/下方向键<br>","more":"<br>6.上/下一个编辑的页面：alt+左/右方向键<br>7.显示工程文件目录：alt+enter<br>8.当前行插入空行：shift+enter(+ctrl 下一行插入)<br>9.格式化：ctrl+shift+f<br>10.重命名：alt+shift+r<br>11.抽取方法：alt+shift+m<br>12.组织导入（自动加入引用）：ctrl+shift+o<br>13.添加导入：Ctrl+Shift+M<br>14.单步返回 F7<br>15.单步跳过 F6<br>16.单步跳入 F5<br>17.单步跳入选择 Ctrl+F5<br>18.调试上次启动 F11<br>19.继续 F8 </p>"},{"title":"OC与JS交互的几种方法","date":"2017-07-04T03:59:35.000Z","_content":"\nOC与JS交互的几种方法\n1.JavaScriptCore\n2.WebViewJavascriptBridge\n\n<!--more-->\n# JavaScriptCore\n## 通过JSContext实现OC与JS的交互\n1.在webViewDidFinishLoad方法中创建JSContext对象,获取该UIWebview的javascript执行环境\n```\n- (void)webViewDidFinishLoad:(UIWebView *)webView {\n\n    //通过当前webView的键获取到jscontext\n    self.jsContext = [webView valueForKeyPath:@\"documentView.webView.mainFrame.javaScriptContext\"];\n    //以后JS就可以通过 OCModel 调用OC方法\n    self.jsContext[@\"OCModel\"] = self;\n    self.jsContext.exceptionHandler = ^(JSContext *context, JSValue *exceptionValue) {\n        context.exception = exceptionValue;\n        NSLog(@\"异常信息：%@\", exceptionValue);\n    };\n};\n```\n\n2.OC调用JS方法并传递一个参数\nJS方法：\n```\nfunction getImg(path){\n    //document.getElementById(\"test\").src=path;\n}\n```\n\nOC通过`evaluateScript`调用JS方法：\n```\nNSString *alertJS=[NSString stringWithFormat:@\"getImg('%@')\",@\"abc\"]; //准备执行的js代码\n[self.jsContext evaluateScript:alertJS];\n```\n\n3.JS调用OC方法并传递一个参数\nOC方法：\n```\n- (void)getImg:(NSString *)source{\n    NSLog(@\"%@\",source);\n}\n```\n\nJS通过`OCModel`调用OC方法：\n```\nfunction getGalleryImg(){\n    OCModel.getImg('gallery');\n}\n```\n\n## 通过request的URL实现交互\nJS代码:\n```\n<script>\n//触发该方法，调用OC中webview的`shouldStartLoadWithRequest`方法实现与OC交互\nfunction goCamera(){\n    window.location.href=\"js-call://camera/cameraCallback\";\n}\n//OC回调的JS方法\nfunction cameraCallback(data) {\n    //获取到OC传递过来的参数\n    alert(data);\n}\n</script>\n```\n\nOC代码:\n```\n- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType\n{\n    NSString *requestString = [[request URL] absoluteString];\n    //jS协议头\n    NSString *protocol = @\"js-call://\";\n    //请求的字符串符合协议头\n    if ([requestString hasPrefix:protocol]) {\n        //从协议头后的位置截取字符串到最后\n        NSString *requestContent = [requestString substringFromIndex:[protocol length]];\n        //将/分隔的字符串转换成数组\n        NSArray *vals = [requestContent componentsSeparatedByString:@\"/\"];\n        if ([[vals objectAtIndex:0] isEqualToString:@\"camera\"]) {\n            //获取到回调方法：cameraCallback\n            callback = [vals objectAtIndex:1];\n            //OC回调JS方法，并传递一个参数\n            [_webView stringByEvaluatingJavaScriptFromString:[NSString stringWithFormat:@\"%@('%@');\", callback, @\"abc\"]];\n        } \n        else {\n            [webView stringByEvaluatingJavaScriptFromString:@\"alert('未定义');\"];\n        }\n        return NO;\n    }\n    return YES;\n}\n```\n\n# WebViewJavascriptBridge\n1.通过cocoapods或手动导入WebViewJavascriptBridge框架\n2.OC端:创建webview,与bridge对象建立联系\n```\n// 开启日志\n[WebViewJavascriptBridge enableLogging];\n\n// 指定webview，建立JS与OjbC的沟通桥梁\nself.bridge = [WebViewJavascriptBridge bridgeForWebView:webView];\n[self.bridge setWebViewDelegate:self];\n```\n\n3.JS端：创建setupWebViewJavascriptBridge\n```\n<script>\nwindow.onerror = function(err) {\nlog('window.onerror: ' + err)\n}\n\n/*这段代码是固定的，必须要放到js中*/\nfunction setupWebViewJavascriptBridge(callback) {\nif (window.WebViewJavascriptBridge) { return callback(WebViewJavascriptBridge); }\nif (window.WVJBCallbacks) { return window.WVJBCallbacks.push(callback); }\nwindow.WVJBCallbacks = [callback];\nvar WVJBIframe = document.createElement('iframe');\nWVJBIframe.style.display = 'none';\nWVJBIframe.src = 'wvjbscheme://__BRIDGE_LOADED__';\ndocument.documentElement.appendChild(WVJBIframe);\nsetTimeout(function() { document.documentElement.removeChild(WVJBIframe) }, 0)\n}\n\n/*与OC交互的所有JS方法都要放在此处注册，才能调用通过JS调用OC方法或者让OC调用这里的JS方法*/\nsetupWebViewJavascriptBridge(function(bridge) {\n\n    //在这注册OC调用JS的方法，可以接收OC传过来的参数 data ，还可以通过 responseCallback 回调OC\n    /*\n    bridge.registerHandler('JSFunction', function(data, responseCallback) {\n        responseCallback({'': ''})\n    }\n    */\n\n    //这里可以调用OC方法，OC端在处理完成后，反馈给JS，这样写是在载入页面完成时就先调用\n    document.getElementById('btn').onclick = function (e) {\n    bridge.callHandler('OCFunction', {'js': 'abc'}, function(response) {\n        alert(response)\n    })\n}\n\n</script>\n```\n\n3.JS调用OC方法\nbridge通过`registerHandler`注册提供给JS调用的方法\nOC端通过responseCallback回调JS，JS就可以得到所需要的数据\nOC方法：\n```\n[self.bridge registerHandler:@\"JSCallOC\" handler:^(id data, WVJBResponseCallback responseCallback) {\n    NSLog(@\"%@\", data);     //js-oc,abc\n    if (responseCallback) {\n        // 回调给JS\n        responseCallback(@{@\"oc-js\": @\"123\"});\n    }\n}];\n```\n\nJS调用OC方法：\n```\nbridge.callHandler('JSCallOC', {'js-oc': 'abc'}, function(responseData) {\n    alert(responseData)     //oc-js,123\n})\n```\n\n4.OC调用JS方法\nJS方法：\n```\n/*JS给ObjC提供公开的API，在ObjC端可以手动调用JS的这个API。接收ObjC传过来的参数，且可以回调ObjC*/\nbridge.registerHandler('OCCallJS', function(data, responseCallback) {\n    alert(data)     //oc-js,123\n    responseCallback({'a': '1', 'b': '2'})\n})\n```\n\nOC调用JS方法：\n```\n[self.bridge callHandler:@\"OCCallJS\" data:@{@\"oc-js\": @\"123\"} responseCallback:^(id responseData) {\n    NSLog(@\"%@\", responseData);     //'a': '1', 'b': '2'\n}];\n```\n","source":"_posts/OC与JS交互的几种方法.md","raw":"---\ntitle: OC与JS交互的几种方法\ndate: 2017-07-04 11:59:35\ncategories: 笔记\ntags: [OC,JS]\n---\n\nOC与JS交互的几种方法\n1.JavaScriptCore\n2.WebViewJavascriptBridge\n\n<!--more-->\n# JavaScriptCore\n## 通过JSContext实现OC与JS的交互\n1.在webViewDidFinishLoad方法中创建JSContext对象,获取该UIWebview的javascript执行环境\n```\n- (void)webViewDidFinishLoad:(UIWebView *)webView {\n\n    //通过当前webView的键获取到jscontext\n    self.jsContext = [webView valueForKeyPath:@\"documentView.webView.mainFrame.javaScriptContext\"];\n    //以后JS就可以通过 OCModel 调用OC方法\n    self.jsContext[@\"OCModel\"] = self;\n    self.jsContext.exceptionHandler = ^(JSContext *context, JSValue *exceptionValue) {\n        context.exception = exceptionValue;\n        NSLog(@\"异常信息：%@\", exceptionValue);\n    };\n};\n```\n\n2.OC调用JS方法并传递一个参数\nJS方法：\n```\nfunction getImg(path){\n    //document.getElementById(\"test\").src=path;\n}\n```\n\nOC通过`evaluateScript`调用JS方法：\n```\nNSString *alertJS=[NSString stringWithFormat:@\"getImg('%@')\",@\"abc\"]; //准备执行的js代码\n[self.jsContext evaluateScript:alertJS];\n```\n\n3.JS调用OC方法并传递一个参数\nOC方法：\n```\n- (void)getImg:(NSString *)source{\n    NSLog(@\"%@\",source);\n}\n```\n\nJS通过`OCModel`调用OC方法：\n```\nfunction getGalleryImg(){\n    OCModel.getImg('gallery');\n}\n```\n\n## 通过request的URL实现交互\nJS代码:\n```\n<script>\n//触发该方法，调用OC中webview的`shouldStartLoadWithRequest`方法实现与OC交互\nfunction goCamera(){\n    window.location.href=\"js-call://camera/cameraCallback\";\n}\n//OC回调的JS方法\nfunction cameraCallback(data) {\n    //获取到OC传递过来的参数\n    alert(data);\n}\n</script>\n```\n\nOC代码:\n```\n- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType\n{\n    NSString *requestString = [[request URL] absoluteString];\n    //jS协议头\n    NSString *protocol = @\"js-call://\";\n    //请求的字符串符合协议头\n    if ([requestString hasPrefix:protocol]) {\n        //从协议头后的位置截取字符串到最后\n        NSString *requestContent = [requestString substringFromIndex:[protocol length]];\n        //将/分隔的字符串转换成数组\n        NSArray *vals = [requestContent componentsSeparatedByString:@\"/\"];\n        if ([[vals objectAtIndex:0] isEqualToString:@\"camera\"]) {\n            //获取到回调方法：cameraCallback\n            callback = [vals objectAtIndex:1];\n            //OC回调JS方法，并传递一个参数\n            [_webView stringByEvaluatingJavaScriptFromString:[NSString stringWithFormat:@\"%@('%@');\", callback, @\"abc\"]];\n        } \n        else {\n            [webView stringByEvaluatingJavaScriptFromString:@\"alert('未定义');\"];\n        }\n        return NO;\n    }\n    return YES;\n}\n```\n\n# WebViewJavascriptBridge\n1.通过cocoapods或手动导入WebViewJavascriptBridge框架\n2.OC端:创建webview,与bridge对象建立联系\n```\n// 开启日志\n[WebViewJavascriptBridge enableLogging];\n\n// 指定webview，建立JS与OjbC的沟通桥梁\nself.bridge = [WebViewJavascriptBridge bridgeForWebView:webView];\n[self.bridge setWebViewDelegate:self];\n```\n\n3.JS端：创建setupWebViewJavascriptBridge\n```\n<script>\nwindow.onerror = function(err) {\nlog('window.onerror: ' + err)\n}\n\n/*这段代码是固定的，必须要放到js中*/\nfunction setupWebViewJavascriptBridge(callback) {\nif (window.WebViewJavascriptBridge) { return callback(WebViewJavascriptBridge); }\nif (window.WVJBCallbacks) { return window.WVJBCallbacks.push(callback); }\nwindow.WVJBCallbacks = [callback];\nvar WVJBIframe = document.createElement('iframe');\nWVJBIframe.style.display = 'none';\nWVJBIframe.src = 'wvjbscheme://__BRIDGE_LOADED__';\ndocument.documentElement.appendChild(WVJBIframe);\nsetTimeout(function() { document.documentElement.removeChild(WVJBIframe) }, 0)\n}\n\n/*与OC交互的所有JS方法都要放在此处注册，才能调用通过JS调用OC方法或者让OC调用这里的JS方法*/\nsetupWebViewJavascriptBridge(function(bridge) {\n\n    //在这注册OC调用JS的方法，可以接收OC传过来的参数 data ，还可以通过 responseCallback 回调OC\n    /*\n    bridge.registerHandler('JSFunction', function(data, responseCallback) {\n        responseCallback({'': ''})\n    }\n    */\n\n    //这里可以调用OC方法，OC端在处理完成后，反馈给JS，这样写是在载入页面完成时就先调用\n    document.getElementById('btn').onclick = function (e) {\n    bridge.callHandler('OCFunction', {'js': 'abc'}, function(response) {\n        alert(response)\n    })\n}\n\n</script>\n```\n\n3.JS调用OC方法\nbridge通过`registerHandler`注册提供给JS调用的方法\nOC端通过responseCallback回调JS，JS就可以得到所需要的数据\nOC方法：\n```\n[self.bridge registerHandler:@\"JSCallOC\" handler:^(id data, WVJBResponseCallback responseCallback) {\n    NSLog(@\"%@\", data);     //js-oc,abc\n    if (responseCallback) {\n        // 回调给JS\n        responseCallback(@{@\"oc-js\": @\"123\"});\n    }\n}];\n```\n\nJS调用OC方法：\n```\nbridge.callHandler('JSCallOC', {'js-oc': 'abc'}, function(responseData) {\n    alert(responseData)     //oc-js,123\n})\n```\n\n4.OC调用JS方法\nJS方法：\n```\n/*JS给ObjC提供公开的API，在ObjC端可以手动调用JS的这个API。接收ObjC传过来的参数，且可以回调ObjC*/\nbridge.registerHandler('OCCallJS', function(data, responseCallback) {\n    alert(data)     //oc-js,123\n    responseCallback({'a': '1', 'b': '2'})\n})\n```\n\nOC调用JS方法：\n```\n[self.bridge callHandler:@\"OCCallJS\" data:@{@\"oc-js\": @\"123\"} responseCallback:^(id responseData) {\n    NSLog(@\"%@\", responseData);     //'a': '1', 'b': '2'\n}];\n```\n","slug":"OC与JS交互的几种方法","published":1,"updated":"2017-07-14T03:57:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj53c1dvg000nh3jjual13wj6","content":"<p>OC与JS交互的几种方法<br>1.JavaScriptCore<br>2.WebViewJavascriptBridge</p>\n<a id=\"more\"></a>\n<h1 id=\"JavaScriptCore\"><a href=\"#JavaScriptCore\" class=\"headerlink\" title=\"JavaScriptCore\"></a>JavaScriptCore</h1><h2 id=\"通过JSContext实现OC与JS的交互\"><a href=\"#通过JSContext实现OC与JS的交互\" class=\"headerlink\" title=\"通过JSContext实现OC与JS的交互\"></a>通过JSContext实现OC与JS的交互</h2><p>1.在webViewDidFinishLoad方法中创建JSContext对象,获取该UIWebview的javascript执行环境<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)webViewDidFinishLoad:(UIWebView *)webView &#123;</div><div class=\"line\"></div><div class=\"line\">    //通过当前webView的键获取到jscontext</div><div class=\"line\">    self.jsContext = [webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];</div><div class=\"line\">    //以后JS就可以通过 OCModel 调用OC方法</div><div class=\"line\">    self.jsContext[@&quot;OCModel&quot;] = self;</div><div class=\"line\">    self.jsContext.exceptionHandler = ^(JSContext *context, JSValue *exceptionValue) &#123;</div><div class=\"line\">        context.exception = exceptionValue;</div><div class=\"line\">        NSLog(@&quot;异常信息：%@&quot;, exceptionValue);</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>2.OC调用JS方法并传递一个参数<br>JS方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">function getImg(path)&#123;</div><div class=\"line\">    //document.getElementById(&quot;test&quot;).src=path;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>OC通过<code>evaluateScript</code>调用JS方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSString *alertJS=[NSString stringWithFormat:@&quot;getImg(&apos;%@&apos;)&quot;,@&quot;abc&quot;]; //准备执行的js代码</div><div class=\"line\">[self.jsContext evaluateScript:alertJS];</div></pre></td></tr></table></figure></p>\n<p>3.JS调用OC方法并传递一个参数<br>OC方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)getImg:(NSString *)source&#123;</div><div class=\"line\">    NSLog(@&quot;%@&quot;,source);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>JS通过<code>OCModel</code>调用OC方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">function getGalleryImg()&#123;</div><div class=\"line\">    OCModel.getImg(&apos;gallery&apos;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"通过request的URL实现交互\"><a href=\"#通过request的URL实现交互\" class=\"headerlink\" title=\"通过request的URL实现交互\"></a>通过request的URL实现交互</h2><p>JS代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script&gt;</div><div class=\"line\">//触发该方法，调用OC中webview的`shouldStartLoadWithRequest`方法实现与OC交互</div><div class=\"line\">function goCamera()&#123;</div><div class=\"line\">    window.location.href=&quot;js-call://camera/cameraCallback&quot;;</div><div class=\"line\">&#125;</div><div class=\"line\">//OC回调的JS方法</div><div class=\"line\">function cameraCallback(data) &#123;</div><div class=\"line\">    //获取到OC传递过来的参数</div><div class=\"line\">    alert(data);</div><div class=\"line\">&#125;</div><div class=\"line\">&lt;/script&gt;</div></pre></td></tr></table></figure></p>\n<p>OC代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType</div><div class=\"line\">&#123;</div><div class=\"line\">    NSString *requestString = [[request URL] absoluteString];</div><div class=\"line\">    //jS协议头</div><div class=\"line\">    NSString *protocol = @&quot;js-call://&quot;;</div><div class=\"line\">    //请求的字符串符合协议头</div><div class=\"line\">    if ([requestString hasPrefix:protocol]) &#123;</div><div class=\"line\">        //从协议头后的位置截取字符串到最后</div><div class=\"line\">        NSString *requestContent = [requestString substringFromIndex:[protocol length]];</div><div class=\"line\">        //将/分隔的字符串转换成数组</div><div class=\"line\">        NSArray *vals = [requestContent componentsSeparatedByString:@&quot;/&quot;];</div><div class=\"line\">        if ([[vals objectAtIndex:0] isEqualToString:@&quot;camera&quot;]) &#123;</div><div class=\"line\">            //获取到回调方法：cameraCallback</div><div class=\"line\">            callback = [vals objectAtIndex:1];</div><div class=\"line\">            //OC回调JS方法，并传递一个参数</div><div class=\"line\">            [_webView stringByEvaluatingJavaScriptFromString:[NSString stringWithFormat:@&quot;%@(&apos;%@&apos;);&quot;, callback, @&quot;abc&quot;]];</div><div class=\"line\">        &#125; </div><div class=\"line\">        else &#123;</div><div class=\"line\">            [webView stringByEvaluatingJavaScriptFromString:@&quot;alert(&apos;未定义&apos;);&quot;];</div><div class=\"line\">        &#125;</div><div class=\"line\">        return NO;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return YES;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h1 id=\"WebViewJavascriptBridge\"><a href=\"#WebViewJavascriptBridge\" class=\"headerlink\" title=\"WebViewJavascriptBridge\"></a>WebViewJavascriptBridge</h1><p>1.通过cocoapods或手动导入WebViewJavascriptBridge框架<br>2.OC端:创建webview,与bridge对象建立联系<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 开启日志</div><div class=\"line\">[WebViewJavascriptBridge enableLogging];</div><div class=\"line\"></div><div class=\"line\">// 指定webview，建立JS与OjbC的沟通桥梁</div><div class=\"line\">self.bridge = [WebViewJavascriptBridge bridgeForWebView:webView];</div><div class=\"line\">[self.bridge setWebViewDelegate:self];</div></pre></td></tr></table></figure></p>\n<p>3.JS端：创建setupWebViewJavascriptBridge<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script&gt;</div><div class=\"line\">window.onerror = function(err) &#123;</div><div class=\"line\">log(&apos;window.onerror: &apos; + err)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">/*这段代码是固定的，必须要放到js中*/</div><div class=\"line\">function setupWebViewJavascriptBridge(callback) &#123;</div><div class=\"line\">if (window.WebViewJavascriptBridge) &#123; return callback(WebViewJavascriptBridge); &#125;</div><div class=\"line\">if (window.WVJBCallbacks) &#123; return window.WVJBCallbacks.push(callback); &#125;</div><div class=\"line\">window.WVJBCallbacks = [callback];</div><div class=\"line\">var WVJBIframe = document.createElement(&apos;iframe&apos;);</div><div class=\"line\">WVJBIframe.style.display = &apos;none&apos;;</div><div class=\"line\">WVJBIframe.src = &apos;wvjbscheme://__BRIDGE_LOADED__&apos;;</div><div class=\"line\">document.documentElement.appendChild(WVJBIframe);</div><div class=\"line\">setTimeout(function() &#123; document.documentElement.removeChild(WVJBIframe) &#125;, 0)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">/*与OC交互的所有JS方法都要放在此处注册，才能调用通过JS调用OC方法或者让OC调用这里的JS方法*/</div><div class=\"line\">setupWebViewJavascriptBridge(function(bridge) &#123;</div><div class=\"line\"></div><div class=\"line\">    //在这注册OC调用JS的方法，可以接收OC传过来的参数 data ，还可以通过 responseCallback 回调OC</div><div class=\"line\">    /*</div><div class=\"line\">    bridge.registerHandler(&apos;JSFunction&apos;, function(data, responseCallback) &#123;</div><div class=\"line\">        responseCallback(&#123;&apos;&apos;: &apos;&apos;&#125;)</div><div class=\"line\">    &#125;</div><div class=\"line\">    */</div><div class=\"line\"></div><div class=\"line\">    //这里可以调用OC方法，OC端在处理完成后，反馈给JS，这样写是在载入页面完成时就先调用</div><div class=\"line\">    document.getElementById(&apos;btn&apos;).onclick = function (e) &#123;</div><div class=\"line\">    bridge.callHandler(&apos;OCFunction&apos;, &#123;&apos;js&apos;: &apos;abc&apos;&#125;, function(response) &#123;</div><div class=\"line\">        alert(response)</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">&lt;/script&gt;</div></pre></td></tr></table></figure></p>\n<p>3.JS调用OC方法<br>bridge通过<code>registerHandler</code>注册提供给JS调用的方法<br>OC端通过responseCallback回调JS，JS就可以得到所需要的数据<br>OC方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">[self.bridge registerHandler:@&quot;JSCallOC&quot; handler:^(id data, WVJBResponseCallback responseCallback) &#123;</div><div class=\"line\">    NSLog(@&quot;%@&quot;, data);     //js-oc,abc</div><div class=\"line\">    if (responseCallback) &#123;</div><div class=\"line\">        // 回调给JS</div><div class=\"line\">        responseCallback(@&#123;@&quot;oc-js&quot;: @&quot;123&quot;&#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<p>JS调用OC方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">bridge.callHandler(&apos;JSCallOC&apos;, &#123;&apos;js-oc&apos;: &apos;abc&apos;&#125;, function(responseData) &#123;</div><div class=\"line\">    alert(responseData)     //oc-js,123</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>4.OC调用JS方法<br>JS方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*JS给ObjC提供公开的API，在ObjC端可以手动调用JS的这个API。接收ObjC传过来的参数，且可以回调ObjC*/</div><div class=\"line\">bridge.registerHandler(&apos;OCCallJS&apos;, function(data, responseCallback) &#123;</div><div class=\"line\">    alert(data)     //oc-js,123</div><div class=\"line\">    responseCallback(&#123;&apos;a&apos;: &apos;1&apos;, &apos;b&apos;: &apos;2&apos;&#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>OC调用JS方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[self.bridge callHandler:@&quot;OCCallJS&quot; data:@&#123;@&quot;oc-js&quot;: @&quot;123&quot;&#125; responseCallback:^(id responseData) &#123;</div><div class=\"line\">    NSLog(@&quot;%@&quot;, responseData);     //&apos;a&apos;: &apos;1&apos;, &apos;b&apos;: &apos;2&apos;</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>OC与JS交互的几种方法<br>1.JavaScriptCore<br>2.WebViewJavascriptBridge</p>","more":"<h1 id=\"JavaScriptCore\"><a href=\"#JavaScriptCore\" class=\"headerlink\" title=\"JavaScriptCore\"></a>JavaScriptCore</h1><h2 id=\"通过JSContext实现OC与JS的交互\"><a href=\"#通过JSContext实现OC与JS的交互\" class=\"headerlink\" title=\"通过JSContext实现OC与JS的交互\"></a>通过JSContext实现OC与JS的交互</h2><p>1.在webViewDidFinishLoad方法中创建JSContext对象,获取该UIWebview的javascript执行环境<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)webViewDidFinishLoad:(UIWebView *)webView &#123;</div><div class=\"line\"></div><div class=\"line\">    //通过当前webView的键获取到jscontext</div><div class=\"line\">    self.jsContext = [webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];</div><div class=\"line\">    //以后JS就可以通过 OCModel 调用OC方法</div><div class=\"line\">    self.jsContext[@&quot;OCModel&quot;] = self;</div><div class=\"line\">    self.jsContext.exceptionHandler = ^(JSContext *context, JSValue *exceptionValue) &#123;</div><div class=\"line\">        context.exception = exceptionValue;</div><div class=\"line\">        NSLog(@&quot;异常信息：%@&quot;, exceptionValue);</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>2.OC调用JS方法并传递一个参数<br>JS方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">function getImg(path)&#123;</div><div class=\"line\">    //document.getElementById(&quot;test&quot;).src=path;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>OC通过<code>evaluateScript</code>调用JS方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSString *alertJS=[NSString stringWithFormat:@&quot;getImg(&apos;%@&apos;)&quot;,@&quot;abc&quot;]; //准备执行的js代码</div><div class=\"line\">[self.jsContext evaluateScript:alertJS];</div></pre></td></tr></table></figure></p>\n<p>3.JS调用OC方法并传递一个参数<br>OC方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)getImg:(NSString *)source&#123;</div><div class=\"line\">    NSLog(@&quot;%@&quot;,source);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>JS通过<code>OCModel</code>调用OC方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">function getGalleryImg()&#123;</div><div class=\"line\">    OCModel.getImg(&apos;gallery&apos;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"通过request的URL实现交互\"><a href=\"#通过request的URL实现交互\" class=\"headerlink\" title=\"通过request的URL实现交互\"></a>通过request的URL实现交互</h2><p>JS代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script&gt;</div><div class=\"line\">//触发该方法，调用OC中webview的`shouldStartLoadWithRequest`方法实现与OC交互</div><div class=\"line\">function goCamera()&#123;</div><div class=\"line\">    window.location.href=&quot;js-call://camera/cameraCallback&quot;;</div><div class=\"line\">&#125;</div><div class=\"line\">//OC回调的JS方法</div><div class=\"line\">function cameraCallback(data) &#123;</div><div class=\"line\">    //获取到OC传递过来的参数</div><div class=\"line\">    alert(data);</div><div class=\"line\">&#125;</div><div class=\"line\">&lt;/script&gt;</div></pre></td></tr></table></figure></p>\n<p>OC代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType</div><div class=\"line\">&#123;</div><div class=\"line\">    NSString *requestString = [[request URL] absoluteString];</div><div class=\"line\">    //jS协议头</div><div class=\"line\">    NSString *protocol = @&quot;js-call://&quot;;</div><div class=\"line\">    //请求的字符串符合协议头</div><div class=\"line\">    if ([requestString hasPrefix:protocol]) &#123;</div><div class=\"line\">        //从协议头后的位置截取字符串到最后</div><div class=\"line\">        NSString *requestContent = [requestString substringFromIndex:[protocol length]];</div><div class=\"line\">        //将/分隔的字符串转换成数组</div><div class=\"line\">        NSArray *vals = [requestContent componentsSeparatedByString:@&quot;/&quot;];</div><div class=\"line\">        if ([[vals objectAtIndex:0] isEqualToString:@&quot;camera&quot;]) &#123;</div><div class=\"line\">            //获取到回调方法：cameraCallback</div><div class=\"line\">            callback = [vals objectAtIndex:1];</div><div class=\"line\">            //OC回调JS方法，并传递一个参数</div><div class=\"line\">            [_webView stringByEvaluatingJavaScriptFromString:[NSString stringWithFormat:@&quot;%@(&apos;%@&apos;);&quot;, callback, @&quot;abc&quot;]];</div><div class=\"line\">        &#125; </div><div class=\"line\">        else &#123;</div><div class=\"line\">            [webView stringByEvaluatingJavaScriptFromString:@&quot;alert(&apos;未定义&apos;);&quot;];</div><div class=\"line\">        &#125;</div><div class=\"line\">        return NO;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return YES;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h1 id=\"WebViewJavascriptBridge\"><a href=\"#WebViewJavascriptBridge\" class=\"headerlink\" title=\"WebViewJavascriptBridge\"></a>WebViewJavascriptBridge</h1><p>1.通过cocoapods或手动导入WebViewJavascriptBridge框架<br>2.OC端:创建webview,与bridge对象建立联系<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 开启日志</div><div class=\"line\">[WebViewJavascriptBridge enableLogging];</div><div class=\"line\"></div><div class=\"line\">// 指定webview，建立JS与OjbC的沟通桥梁</div><div class=\"line\">self.bridge = [WebViewJavascriptBridge bridgeForWebView:webView];</div><div class=\"line\">[self.bridge setWebViewDelegate:self];</div></pre></td></tr></table></figure></p>\n<p>3.JS端：创建setupWebViewJavascriptBridge<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script&gt;</div><div class=\"line\">window.onerror = function(err) &#123;</div><div class=\"line\">log(&apos;window.onerror: &apos; + err)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">/*这段代码是固定的，必须要放到js中*/</div><div class=\"line\">function setupWebViewJavascriptBridge(callback) &#123;</div><div class=\"line\">if (window.WebViewJavascriptBridge) &#123; return callback(WebViewJavascriptBridge); &#125;</div><div class=\"line\">if (window.WVJBCallbacks) &#123; return window.WVJBCallbacks.push(callback); &#125;</div><div class=\"line\">window.WVJBCallbacks = [callback];</div><div class=\"line\">var WVJBIframe = document.createElement(&apos;iframe&apos;);</div><div class=\"line\">WVJBIframe.style.display = &apos;none&apos;;</div><div class=\"line\">WVJBIframe.src = &apos;wvjbscheme://__BRIDGE_LOADED__&apos;;</div><div class=\"line\">document.documentElement.appendChild(WVJBIframe);</div><div class=\"line\">setTimeout(function() &#123; document.documentElement.removeChild(WVJBIframe) &#125;, 0)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">/*与OC交互的所有JS方法都要放在此处注册，才能调用通过JS调用OC方法或者让OC调用这里的JS方法*/</div><div class=\"line\">setupWebViewJavascriptBridge(function(bridge) &#123;</div><div class=\"line\"></div><div class=\"line\">    //在这注册OC调用JS的方法，可以接收OC传过来的参数 data ，还可以通过 responseCallback 回调OC</div><div class=\"line\">    /*</div><div class=\"line\">    bridge.registerHandler(&apos;JSFunction&apos;, function(data, responseCallback) &#123;</div><div class=\"line\">        responseCallback(&#123;&apos;&apos;: &apos;&apos;&#125;)</div><div class=\"line\">    &#125;</div><div class=\"line\">    */</div><div class=\"line\"></div><div class=\"line\">    //这里可以调用OC方法，OC端在处理完成后，反馈给JS，这样写是在载入页面完成时就先调用</div><div class=\"line\">    document.getElementById(&apos;btn&apos;).onclick = function (e) &#123;</div><div class=\"line\">    bridge.callHandler(&apos;OCFunction&apos;, &#123;&apos;js&apos;: &apos;abc&apos;&#125;, function(response) &#123;</div><div class=\"line\">        alert(response)</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">&lt;/script&gt;</div></pre></td></tr></table></figure></p>\n<p>3.JS调用OC方法<br>bridge通过<code>registerHandler</code>注册提供给JS调用的方法<br>OC端通过responseCallback回调JS，JS就可以得到所需要的数据<br>OC方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">[self.bridge registerHandler:@&quot;JSCallOC&quot; handler:^(id data, WVJBResponseCallback responseCallback) &#123;</div><div class=\"line\">    NSLog(@&quot;%@&quot;, data);     //js-oc,abc</div><div class=\"line\">    if (responseCallback) &#123;</div><div class=\"line\">        // 回调给JS</div><div class=\"line\">        responseCallback(@&#123;@&quot;oc-js&quot;: @&quot;123&quot;&#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<p>JS调用OC方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">bridge.callHandler(&apos;JSCallOC&apos;, &#123;&apos;js-oc&apos;: &apos;abc&apos;&#125;, function(responseData) &#123;</div><div class=\"line\">    alert(responseData)     //oc-js,123</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>4.OC调用JS方法<br>JS方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*JS给ObjC提供公开的API，在ObjC端可以手动调用JS的这个API。接收ObjC传过来的参数，且可以回调ObjC*/</div><div class=\"line\">bridge.registerHandler(&apos;OCCallJS&apos;, function(data, responseCallback) &#123;</div><div class=\"line\">    alert(data)     //oc-js,123</div><div class=\"line\">    responseCallback(&#123;&apos;a&apos;: &apos;1&apos;, &apos;b&apos;: &apos;2&apos;&#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>OC调用JS方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[self.bridge callHandler:@&quot;OCCallJS&quot; data:@&#123;@&quot;oc-js&quot;: @&quot;123&quot;&#125; responseCallback:^(id responseData) &#123;</div><div class=\"line\">    NSLog(@&quot;%@&quot;, responseData);     //&apos;a&apos;: &apos;1&apos;, &apos;b&apos;: &apos;2&apos;</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>"},{"title":"OC中的block","date":"2017-07-01T06:59:03.000Z","_content":"\n## 1.block定义：returnType(^blockName)(parameterTypes) = ^(parameters) {};\n## 2.block用copy修饰，delegate用weak修饰\n## 3.MRC环境下：\n### (1)block引用局部变量\n局部变量a:block代码块中使用局部变量,会自动拷贝一份到常量区,所以不可改变量\n如果要修改局部变量，需要加__block修饰变量\n<!--more-->\n```\n__block int number = 10;\nvoid (^myBlock)(void) = ^(void) {\nnumber = 20;    //不用__block，则不能修改\nNSLog(@\"%d\",number);;\n};\n\n```\n\n### (2)block中引用一个局部OC对象\n该对象会被retain，如果局部变量使用__block修饰，则不会retain\n```\n__block NSObject *obj = [[NSObject alloc]init];\nvoid (^myBlock)(void) = ^(void) {\nNSLog(@\"%ld\",obj.retainCount);  //不用__block，则为2\n};\nmyBlock();\n```\n\n### (3)block中引用一个全局变量\n在block代码块中使用全局变量或方法时,会将这个变量或方法所在的对象self引用计数加1,引起循环引用\n解决方法:使用__block修饰self\n```\n__block SecondViewController *weakSelf =self;\n```\n\n## 4.ARC环境下：\n### (1)在block中引用局部变量，同MRC需要__block修饰\n### (2)在block中引用局部对象，不用加__block\n### (3)在block中引用全局变量，\n```\n_index = 1;\n__weak SecondViewController *weakThis = self;\n[btn addTapAction:^(UIButton *btn) {\n\n//可修改值,但控制器不销毁,发生了循环引用\n//        _index = 2;\n//        NSLog(@\"index:%ld\",_index);\n\n//属性\n__strong SecondViewController *strongThis = weakThis;\nstrongThis->_index = 2;\nNSLog(@\"index:%ld\",strongThis->_index);\n\n//方法\n//[weakThis test];\n[strongThis test];\n}];\n\n```\n\n## 5.__weak与__block区别\nMRC，__block 修饰，可以避免循环引用；ARC，__block 修饰，同样会引起循环引用问题；\n__block不管是ARC还是MRC模式下都可以使用，可以修饰对象，还可以修饰基本数据类型；\n__weak只能在ARC模式下使用，也只能修饰对象，不能修饰基本数据类型；\n(1)block下循环引用的问题\n__block本身并不能避免循环引用，避免循环引用需要在block内部把__block修饰的obj置为nil\n__weak可以避免循环引用，但是其会导致外部对象释放了之后，block 内部也访问不到这个对象的问题，我们可以通过在 block 内部声明一个 __strong\n的变量来指向 weakObj，使外部对象既能在 block 内部保持住，又能避免循环引用的问题\n(2)__block与__weak功能上的区别。\n__block会持有该对象，即使超出了该对象的作用域，该对象还是会存在的，直到block对象从堆上销毁；而__weak仅仅是将该对象赋值给weak对象，当该对象销毁时，weak对象将指向nil；\n__block可以让block修改局部变量，而__weak不能。\n另外，MRC中__block是不会引起retain；但在ARC中__block则会引起retain。所以ARC中应该使用__weak。\n\n\n","source":"_posts/OC中的block.md","raw":"---\ntitle: OC中的block\ndate: 2017-07-01 14:59:03\ncategories: 笔记\ntags: [OC,block]\n---\n\n## 1.block定义：returnType(^blockName)(parameterTypes) = ^(parameters) {};\n## 2.block用copy修饰，delegate用weak修饰\n## 3.MRC环境下：\n### (1)block引用局部变量\n局部变量a:block代码块中使用局部变量,会自动拷贝一份到常量区,所以不可改变量\n如果要修改局部变量，需要加__block修饰变量\n<!--more-->\n```\n__block int number = 10;\nvoid (^myBlock)(void) = ^(void) {\nnumber = 20;    //不用__block，则不能修改\nNSLog(@\"%d\",number);;\n};\n\n```\n\n### (2)block中引用一个局部OC对象\n该对象会被retain，如果局部变量使用__block修饰，则不会retain\n```\n__block NSObject *obj = [[NSObject alloc]init];\nvoid (^myBlock)(void) = ^(void) {\nNSLog(@\"%ld\",obj.retainCount);  //不用__block，则为2\n};\nmyBlock();\n```\n\n### (3)block中引用一个全局变量\n在block代码块中使用全局变量或方法时,会将这个变量或方法所在的对象self引用计数加1,引起循环引用\n解决方法:使用__block修饰self\n```\n__block SecondViewController *weakSelf =self;\n```\n\n## 4.ARC环境下：\n### (1)在block中引用局部变量，同MRC需要__block修饰\n### (2)在block中引用局部对象，不用加__block\n### (3)在block中引用全局变量，\n```\n_index = 1;\n__weak SecondViewController *weakThis = self;\n[btn addTapAction:^(UIButton *btn) {\n\n//可修改值,但控制器不销毁,发生了循环引用\n//        _index = 2;\n//        NSLog(@\"index:%ld\",_index);\n\n//属性\n__strong SecondViewController *strongThis = weakThis;\nstrongThis->_index = 2;\nNSLog(@\"index:%ld\",strongThis->_index);\n\n//方法\n//[weakThis test];\n[strongThis test];\n}];\n\n```\n\n## 5.__weak与__block区别\nMRC，__block 修饰，可以避免循环引用；ARC，__block 修饰，同样会引起循环引用问题；\n__block不管是ARC还是MRC模式下都可以使用，可以修饰对象，还可以修饰基本数据类型；\n__weak只能在ARC模式下使用，也只能修饰对象，不能修饰基本数据类型；\n(1)block下循环引用的问题\n__block本身并不能避免循环引用，避免循环引用需要在block内部把__block修饰的obj置为nil\n__weak可以避免循环引用，但是其会导致外部对象释放了之后，block 内部也访问不到这个对象的问题，我们可以通过在 block 内部声明一个 __strong\n的变量来指向 weakObj，使外部对象既能在 block 内部保持住，又能避免循环引用的问题\n(2)__block与__weak功能上的区别。\n__block会持有该对象，即使超出了该对象的作用域，该对象还是会存在的，直到block对象从堆上销毁；而__weak仅仅是将该对象赋值给weak对象，当该对象销毁时，weak对象将指向nil；\n__block可以让block修改局部变量，而__weak不能。\n另外，MRC中__block是不会引起retain；但在ARC中__block则会引起retain。所以ARC中应该使用__weak。\n\n\n","slug":"OC中的block","published":1,"updated":"2017-07-14T03:57:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj53c1dvh000qh3jj8kq8qcty","content":"<h2 id=\"1-block定义：returnType-blockName-parameterTypes-parameters\"><a href=\"#1-block定义：returnType-blockName-parameterTypes-parameters\" class=\"headerlink\" title=\"1.block定义：returnType(^blockName)(parameterTypes) = ^(parameters) {};\"></a>1.block定义：returnType(^blockName)(parameterTypes) = ^(parameters) {};</h2><h2 id=\"2-block用copy修饰，delegate用weak修饰\"><a href=\"#2-block用copy修饰，delegate用weak修饰\" class=\"headerlink\" title=\"2.block用copy修饰，delegate用weak修饰\"></a>2.block用copy修饰，delegate用weak修饰</h2><h2 id=\"3-MRC环境下：\"><a href=\"#3-MRC环境下：\" class=\"headerlink\" title=\"3.MRC环境下：\"></a>3.MRC环境下：</h2><h3 id=\"1-block引用局部变量\"><a href=\"#1-block引用局部变量\" class=\"headerlink\" title=\"(1)block引用局部变量\"></a>(1)block引用局部变量</h3><p>局部变量a:block代码块中使用局部变量,会自动拷贝一份到常量区,所以不可改变量<br>如果要修改局部变量，需要加__block修饰变量<br><a id=\"more\"></a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">__block int number = 10;</div><div class=\"line\">void (^myBlock)(void) = ^(void) &#123;</div><div class=\"line\">number = 20;    //不用__block，则不能修改</div><div class=\"line\">NSLog(@&quot;%d&quot;,number);;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<h3 id=\"2-block中引用一个局部OC对象\"><a href=\"#2-block中引用一个局部OC对象\" class=\"headerlink\" title=\"(2)block中引用一个局部OC对象\"></a>(2)block中引用一个局部OC对象</h3><p>该对象会被retain，如果局部变量使用__block修饰，则不会retain<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">__block NSObject *obj = [[NSObject alloc]init];</div><div class=\"line\">void (^myBlock)(void) = ^(void) &#123;</div><div class=\"line\">NSLog(@&quot;%ld&quot;,obj.retainCount);  //不用__block，则为2</div><div class=\"line\">&#125;;</div><div class=\"line\">myBlock();</div></pre></td></tr></table></figure></p>\n<h3 id=\"3-block中引用一个全局变量\"><a href=\"#3-block中引用一个全局变量\" class=\"headerlink\" title=\"(3)block中引用一个全局变量\"></a>(3)block中引用一个全局变量</h3><p>在block代码块中使用全局变量或方法时,会将这个变量或方法所在的对象self引用计数加1,引起循环引用<br>解决方法:使用__block修饰self<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">__block SecondViewController *weakSelf =self;</div></pre></td></tr></table></figure></p>\n<h2 id=\"4-ARC环境下：\"><a href=\"#4-ARC环境下：\" class=\"headerlink\" title=\"4.ARC环境下：\"></a>4.ARC环境下：</h2><h3 id=\"1-在block中引用局部变量，同MRC需要-block修饰\"><a href=\"#1-在block中引用局部变量，同MRC需要-block修饰\" class=\"headerlink\" title=\"(1)在block中引用局部变量，同MRC需要__block修饰\"></a>(1)在block中引用局部变量，同MRC需要__block修饰</h3><h3 id=\"2-在block中引用局部对象，不用加-block\"><a href=\"#2-在block中引用局部对象，不用加-block\" class=\"headerlink\" title=\"(2)在block中引用局部对象，不用加__block\"></a>(2)在block中引用局部对象，不用加__block</h3><h3 id=\"3-在block中引用全局变量，\"><a href=\"#3-在block中引用全局变量，\" class=\"headerlink\" title=\"(3)在block中引用全局变量，\"></a>(3)在block中引用全局变量，</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">_index = 1;</div><div class=\"line\">__weak SecondViewController *weakThis = self;</div><div class=\"line\">[btn addTapAction:^(UIButton *btn) &#123;</div><div class=\"line\"></div><div class=\"line\">//可修改值,但控制器不销毁,发生了循环引用</div><div class=\"line\">//        _index = 2;</div><div class=\"line\">//        NSLog(@&quot;index:%ld&quot;,_index);</div><div class=\"line\"></div><div class=\"line\">//属性</div><div class=\"line\">__strong SecondViewController *strongThis = weakThis;</div><div class=\"line\">strongThis-&gt;_index = 2;</div><div class=\"line\">NSLog(@&quot;index:%ld&quot;,strongThis-&gt;_index);</div><div class=\"line\"></div><div class=\"line\">//方法</div><div class=\"line\">//[weakThis test];</div><div class=\"line\">[strongThis test];</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<h2 id=\"5-weak与block区别\"><a href=\"#5-weak与block区别\" class=\"headerlink\" title=\"5.weak与block区别\"></a>5.<strong>weak与</strong>block区别</h2><p>MRC，<strong>block 修饰，可以避免循环引用；ARC，</strong>block 修饰，同样会引起循环引用问题；<br><strong>block不管是ARC还是MRC模式下都可以使用，可以修饰对象，还可以修饰基本数据类型；\n</strong>weak只能在ARC模式下使用，也只能修饰对象，不能修饰基本数据类型；<br>(1)block下循环引用的问题<br><strong>block本身并不能避免循环引用，避免循环引用需要在block内部把</strong>block修饰的obj置为nil<br><strong>weak可以避免循环引用，但是其会导致外部对象释放了之后，block 内部也访问不到这个对象的问题，我们可以通过在 block 内部声明一个 </strong>strong<br>的变量来指向 weakObj，使外部对象既能在 block 内部保持住，又能避免循环引用的问题<br>(2)<strong>block与</strong>weak功能上的区别。<br><strong>block会持有该对象，即使超出了该对象的作用域，该对象还是会存在的，直到block对象从堆上销毁；而</strong>weak仅仅是将该对象赋值给weak对象，当该对象销毁时，weak对象将指向nil；<br><strong>block可以让block修改局部变量，而</strong>weak不能。<br>另外，MRC中<strong>block是不会引起retain；但在ARC中</strong>block则会引起retain。所以ARC中应该使用__weak。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-block定义：returnType-blockName-parameterTypes-parameters\"><a href=\"#1-block定义：returnType-blockName-parameterTypes-parameters\" class=\"headerlink\" title=\"1.block定义：returnType(^blockName)(parameterTypes) = ^(parameters) {};\"></a>1.block定义：returnType(^blockName)(parameterTypes) = ^(parameters) {};</h2><h2 id=\"2-block用copy修饰，delegate用weak修饰\"><a href=\"#2-block用copy修饰，delegate用weak修饰\" class=\"headerlink\" title=\"2.block用copy修饰，delegate用weak修饰\"></a>2.block用copy修饰，delegate用weak修饰</h2><h2 id=\"3-MRC环境下：\"><a href=\"#3-MRC环境下：\" class=\"headerlink\" title=\"3.MRC环境下：\"></a>3.MRC环境下：</h2><h3 id=\"1-block引用局部变量\"><a href=\"#1-block引用局部变量\" class=\"headerlink\" title=\"(1)block引用局部变量\"></a>(1)block引用局部变量</h3><p>局部变量a:block代码块中使用局部变量,会自动拷贝一份到常量区,所以不可改变量<br>如果要修改局部变量，需要加__block修饰变量<br>","more":"<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">__block int number = 10;</div><div class=\"line\">void (^myBlock)(void) = ^(void) &#123;</div><div class=\"line\">number = 20;    //不用__block，则不能修改</div><div class=\"line\">NSLog(@&quot;%d&quot;,number);;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<h3 id=\"2-block中引用一个局部OC对象\"><a href=\"#2-block中引用一个局部OC对象\" class=\"headerlink\" title=\"(2)block中引用一个局部OC对象\"></a>(2)block中引用一个局部OC对象</h3><p>该对象会被retain，如果局部变量使用__block修饰，则不会retain<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">__block NSObject *obj = [[NSObject alloc]init];</div><div class=\"line\">void (^myBlock)(void) = ^(void) &#123;</div><div class=\"line\">NSLog(@&quot;%ld&quot;,obj.retainCount);  //不用__block，则为2</div><div class=\"line\">&#125;;</div><div class=\"line\">myBlock();</div></pre></td></tr></table></figure></p>\n<h3 id=\"3-block中引用一个全局变量\"><a href=\"#3-block中引用一个全局变量\" class=\"headerlink\" title=\"(3)block中引用一个全局变量\"></a>(3)block中引用一个全局变量</h3><p>在block代码块中使用全局变量或方法时,会将这个变量或方法所在的对象self引用计数加1,引起循环引用<br>解决方法:使用__block修饰self<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">__block SecondViewController *weakSelf =self;</div></pre></td></tr></table></figure></p>\n<h2 id=\"4-ARC环境下：\"><a href=\"#4-ARC环境下：\" class=\"headerlink\" title=\"4.ARC环境下：\"></a>4.ARC环境下：</h2><h3 id=\"1-在block中引用局部变量，同MRC需要-block修饰\"><a href=\"#1-在block中引用局部变量，同MRC需要-block修饰\" class=\"headerlink\" title=\"(1)在block中引用局部变量，同MRC需要__block修饰\"></a>(1)在block中引用局部变量，同MRC需要__block修饰</h3><h3 id=\"2-在block中引用局部对象，不用加-block\"><a href=\"#2-在block中引用局部对象，不用加-block\" class=\"headerlink\" title=\"(2)在block中引用局部对象，不用加__block\"></a>(2)在block中引用局部对象，不用加__block</h3><h3 id=\"3-在block中引用全局变量，\"><a href=\"#3-在block中引用全局变量，\" class=\"headerlink\" title=\"(3)在block中引用全局变量，\"></a>(3)在block中引用全局变量，</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">_index = 1;</div><div class=\"line\">__weak SecondViewController *weakThis = self;</div><div class=\"line\">[btn addTapAction:^(UIButton *btn) &#123;</div><div class=\"line\"></div><div class=\"line\">//可修改值,但控制器不销毁,发生了循环引用</div><div class=\"line\">//        _index = 2;</div><div class=\"line\">//        NSLog(@&quot;index:%ld&quot;,_index);</div><div class=\"line\"></div><div class=\"line\">//属性</div><div class=\"line\">__strong SecondViewController *strongThis = weakThis;</div><div class=\"line\">strongThis-&gt;_index = 2;</div><div class=\"line\">NSLog(@&quot;index:%ld&quot;,strongThis-&gt;_index);</div><div class=\"line\"></div><div class=\"line\">//方法</div><div class=\"line\">//[weakThis test];</div><div class=\"line\">[strongThis test];</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<h2 id=\"5-weak与block区别\"><a href=\"#5-weak与block区别\" class=\"headerlink\" title=\"5.weak与block区别\"></a>5.<strong>weak与</strong>block区别</h2><p>MRC，<strong>block 修饰，可以避免循环引用；ARC，</strong>block 修饰，同样会引起循环引用问题；<br><strong>block不管是ARC还是MRC模式下都可以使用，可以修饰对象，还可以修饰基本数据类型；\n</strong>weak只能在ARC模式下使用，也只能修饰对象，不能修饰基本数据类型；<br>(1)block下循环引用的问题<br><strong>block本身并不能避免循环引用，避免循环引用需要在block内部把</strong>block修饰的obj置为nil<br><strong>weak可以避免循环引用，但是其会导致外部对象释放了之后，block 内部也访问不到这个对象的问题，我们可以通过在 block 内部声明一个 </strong>strong<br>的变量来指向 weakObj，使外部对象既能在 block 内部保持住，又能避免循环引用的问题<br>(2)<strong>block与</strong>weak功能上的区别。<br><strong>block会持有该对象，即使超出了该对象的作用域，该对象还是会存在的，直到block对象从堆上销毁；而</strong>weak仅仅是将该对象赋值给weak对象，当该对象销毁时，weak对象将指向nil；<br><strong>block可以让block修改局部变量，而</strong>weak不能。<br>另外，MRC中<strong>block是不会引起retain；但在ARC中</strong>block则会引起retain。所以ARC中应该使用__weak。</p>"},{"title":"RAC与Target-Action、通知、代理、KVO","date":"2017-04-23T03:30:03.000Z","_content":"\nReactiveCocoa作用\n1.target-action:rac_signalForControlEvents \nrac_textSignal rac_gestureSignal\n2.代理 rac_signalForSelector:@selector() fromProtocol:()\n3.通知 rac_addObserverForName\n4.KVO RACObserve(object, value)\n<!--more-->\n\n代码示例：\n1.target-action\n```\n//1.1 监听textfield文字更改\n[[self.textfiled rac_signalForControlEvents:UIControlEventEditingChanged] subscribeNext:^(id x){\n    NSLog(@\"change\");\n}];\n\n//简写\n[[self.textfiled rac_textSignal] subscribeNext:^(id x) {\n    NSLog(@\"%@\",x);\n}];\n\n//1.2\nUITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] init];\n    [[tap rac_gestureSignal] subscribeNext:^(id x) {\n    NSLog(@\"tap\");\n}];\n//注意：如果给label添加手势，需要打开userInteractionEnabled\nself.lab.userInteractionEnabled = YES;\n[self.lab addGestureRecognizer:tap];\n```\n\n2.代理：rac_signalForSelector:@selector() fromProtocol:()\n*** 注意：只能实现返回值为void的代理方法\n```\nUIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@\"title\" message:@\"rac test\" delegate:self cancelButtonTitle:@\"no\" otherButtonTitles:@\"yes\", nil];\n    [[self rac_signalForSelector:@selector(alertView:clickedButtonAtIndex:) fromProtocol:@protocol(UIAlertViewDelegate)] subscribeNext:^(RACTuple *tuple) {\n        //tuple为点击按钮的各个参数\n        NSLog(@\"%ld\",tuple.count);    //参数个数 2 \n        NSLog(@\"%@\",tuple.first);     //alertView\n        NSLog(@\"%@\",tuple.second);    //buttonIndex\n        NSLog(@\"%@\",tuple.third);     //null\n    }];\n//简写\n[[alertView rac_buttonClickedSignal] subscribeNext:^(id x) {\n    NSLog(@\"%@\",x);     //buttonIndex\n}];\n[alertView show];\n```\n\n3.通知 rac_addObserverForName\n点击一个页面可以更新另一个页面数据\n```\n[[[NSNotificationCenter defaultCenter] rac_addObserverForName:@\"postData\" object:nil] subscribeNext:^(NSNotification *notification) {\n    NSLog(@\"%@\", notification.name);\n    NSLog(@\"%@\", notification.object);\n}];\n\n[self presentViewController:[[SecondViewController alloc]init] animated:YES completion:nil];\n```\n\nSecondViewController代码：\n```\nNSMutableArray *dataArray = [[NSMutableArray alloc] initWithObjects:@\"1\", @\"2\", @\"3\", nil];\n[[NSNotificationCenter defaultCenter] postNotificationName:@\"postData\" object:dataArray];\n[self dismissViewControllerAnimated:YES completion:nil];\n```\n\n4.KVO RACObserve(object, value)\n```\nUIScrollView *scrolView = [[UIScrollView alloc] initWithFrame:CGRectMake(0, 300, 200, 400)];\nscrolView.contentSize = CGSizeMake(200, 800);\nscrolView.backgroundColor = [UIColor greenColor];\n[self.view addSubview:scrolView];\n[RACObserve(scrolView, contentOffset) subscribeNext:^(id x) {\n    NSLog(@\"success\");\n}];\n\n```\n\n原文链接：[学习RAC小记-适合给新手看的RAC用法总结](http://www.jianshu.com/p/ff79a5ae0353)\n","source":"_posts/RAC与Target-Action、通知、代理、KVO.md","raw":"---\ntitle: RAC与Target-Action、通知、代理、KVO\ndate: 2017-04-23 11:30:03\ncategories: 笔记\ntags: [iOS,RAC]\n---\n\nReactiveCocoa作用\n1.target-action:rac_signalForControlEvents \nrac_textSignal rac_gestureSignal\n2.代理 rac_signalForSelector:@selector() fromProtocol:()\n3.通知 rac_addObserverForName\n4.KVO RACObserve(object, value)\n<!--more-->\n\n代码示例：\n1.target-action\n```\n//1.1 监听textfield文字更改\n[[self.textfiled rac_signalForControlEvents:UIControlEventEditingChanged] subscribeNext:^(id x){\n    NSLog(@\"change\");\n}];\n\n//简写\n[[self.textfiled rac_textSignal] subscribeNext:^(id x) {\n    NSLog(@\"%@\",x);\n}];\n\n//1.2\nUITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] init];\n    [[tap rac_gestureSignal] subscribeNext:^(id x) {\n    NSLog(@\"tap\");\n}];\n//注意：如果给label添加手势，需要打开userInteractionEnabled\nself.lab.userInteractionEnabled = YES;\n[self.lab addGestureRecognizer:tap];\n```\n\n2.代理：rac_signalForSelector:@selector() fromProtocol:()\n*** 注意：只能实现返回值为void的代理方法\n```\nUIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@\"title\" message:@\"rac test\" delegate:self cancelButtonTitle:@\"no\" otherButtonTitles:@\"yes\", nil];\n    [[self rac_signalForSelector:@selector(alertView:clickedButtonAtIndex:) fromProtocol:@protocol(UIAlertViewDelegate)] subscribeNext:^(RACTuple *tuple) {\n        //tuple为点击按钮的各个参数\n        NSLog(@\"%ld\",tuple.count);    //参数个数 2 \n        NSLog(@\"%@\",tuple.first);     //alertView\n        NSLog(@\"%@\",tuple.second);    //buttonIndex\n        NSLog(@\"%@\",tuple.third);     //null\n    }];\n//简写\n[[alertView rac_buttonClickedSignal] subscribeNext:^(id x) {\n    NSLog(@\"%@\",x);     //buttonIndex\n}];\n[alertView show];\n```\n\n3.通知 rac_addObserverForName\n点击一个页面可以更新另一个页面数据\n```\n[[[NSNotificationCenter defaultCenter] rac_addObserverForName:@\"postData\" object:nil] subscribeNext:^(NSNotification *notification) {\n    NSLog(@\"%@\", notification.name);\n    NSLog(@\"%@\", notification.object);\n}];\n\n[self presentViewController:[[SecondViewController alloc]init] animated:YES completion:nil];\n```\n\nSecondViewController代码：\n```\nNSMutableArray *dataArray = [[NSMutableArray alloc] initWithObjects:@\"1\", @\"2\", @\"3\", nil];\n[[NSNotificationCenter defaultCenter] postNotificationName:@\"postData\" object:dataArray];\n[self dismissViewControllerAnimated:YES completion:nil];\n```\n\n4.KVO RACObserve(object, value)\n```\nUIScrollView *scrolView = [[UIScrollView alloc] initWithFrame:CGRectMake(0, 300, 200, 400)];\nscrolView.contentSize = CGSizeMake(200, 800);\nscrolView.backgroundColor = [UIColor greenColor];\n[self.view addSubview:scrolView];\n[RACObserve(scrolView, contentOffset) subscribeNext:^(id x) {\n    NSLog(@\"success\");\n}];\n\n```\n\n原文链接：[学习RAC小记-适合给新手看的RAC用法总结](http://www.jianshu.com/p/ff79a5ae0353)\n","slug":"RAC与Target-Action、通知、代理、KVO","published":1,"updated":"2017-07-14T03:57:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj53c1dvj000uh3jjk3c6yais","content":"<p>ReactiveCocoa作用<br>1.target-action:rac_signalForControlEvents<br>rac_textSignal rac_gestureSignal<br>2.代理 rac_signalForSelector:@selector() fromProtocol:()<br>3.通知 rac_addObserverForName<br>4.KVO RACObserve(object, value)<br><a id=\"more\"></a></p>\n<p>代码示例：<br>1.target-action<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">//1.1 监听textfield文字更改</div><div class=\"line\">[[self.textfiled rac_signalForControlEvents:UIControlEventEditingChanged] subscribeNext:^(id x)&#123;</div><div class=\"line\">    NSLog(@&quot;change&quot;);</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">//简写</div><div class=\"line\">[[self.textfiled rac_textSignal] subscribeNext:^(id x) &#123;</div><div class=\"line\">    NSLog(@&quot;%@&quot;,x);</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">//1.2</div><div class=\"line\">UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] init];</div><div class=\"line\">    [[tap rac_gestureSignal] subscribeNext:^(id x) &#123;</div><div class=\"line\">    NSLog(@&quot;tap&quot;);</div><div class=\"line\">&#125;];</div><div class=\"line\">//注意：如果给label添加手势，需要打开userInteractionEnabled</div><div class=\"line\">self.lab.userInteractionEnabled = YES;</div><div class=\"line\">[self.lab addGestureRecognizer:tap];</div></pre></td></tr></table></figure></p>\n<p>2.代理：rac_signalForSelector:@selector() fromProtocol:()<br><em>*</em> 注意：只能实现返回值为void的代理方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@&quot;title&quot; message:@&quot;rac test&quot; delegate:self cancelButtonTitle:@&quot;no&quot; otherButtonTitles:@&quot;yes&quot;, nil];</div><div class=\"line\">    [[self rac_signalForSelector:@selector(alertView:clickedButtonAtIndex:) fromProtocol:@protocol(UIAlertViewDelegate)] subscribeNext:^(RACTuple *tuple) &#123;</div><div class=\"line\">        //tuple为点击按钮的各个参数</div><div class=\"line\">        NSLog(@&quot;%ld&quot;,tuple.count);    //参数个数 2 </div><div class=\"line\">        NSLog(@&quot;%@&quot;,tuple.first);     //alertView</div><div class=\"line\">        NSLog(@&quot;%@&quot;,tuple.second);    //buttonIndex</div><div class=\"line\">        NSLog(@&quot;%@&quot;,tuple.third);     //null</div><div class=\"line\">    &#125;];</div><div class=\"line\">//简写</div><div class=\"line\">[[alertView rac_buttonClickedSignal] subscribeNext:^(id x) &#123;</div><div class=\"line\">    NSLog(@&quot;%@&quot;,x);     //buttonIndex</div><div class=\"line\">&#125;];</div><div class=\"line\">[alertView show];</div></pre></td></tr></table></figure></p>\n<p>3.通知 rac_addObserverForName<br>点击一个页面可以更新另一个页面数据<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">[[[NSNotificationCenter defaultCenter] rac_addObserverForName:@&quot;postData&quot; object:nil] subscribeNext:^(NSNotification *notification) &#123;</div><div class=\"line\">    NSLog(@&quot;%@&quot;, notification.name);</div><div class=\"line\">    NSLog(@&quot;%@&quot;, notification.object);</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">[self presentViewController:[[SecondViewController alloc]init] animated:YES completion:nil];</div></pre></td></tr></table></figure></p>\n<p>SecondViewController代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSMutableArray *dataArray = [[NSMutableArray alloc] initWithObjects:@&quot;1&quot;, @&quot;2&quot;, @&quot;3&quot;, nil];</div><div class=\"line\">[[NSNotificationCenter defaultCenter] postNotificationName:@&quot;postData&quot; object:dataArray];</div><div class=\"line\">[self dismissViewControllerAnimated:YES completion:nil];</div></pre></td></tr></table></figure></p>\n<p>4.KVO RACObserve(object, value)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIScrollView *scrolView = [[UIScrollView alloc] initWithFrame:CGRectMake(0, 300, 200, 400)];</div><div class=\"line\">scrolView.contentSize = CGSizeMake(200, 800);</div><div class=\"line\">scrolView.backgroundColor = [UIColor greenColor];</div><div class=\"line\">[self.view addSubview:scrolView];</div><div class=\"line\">[RACObserve(scrolView, contentOffset) subscribeNext:^(id x) &#123;</div><div class=\"line\">    NSLog(@&quot;success&quot;);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<p>原文链接：<a href=\"http://www.jianshu.com/p/ff79a5ae0353\" target=\"_blank\" rel=\"external\">学习RAC小记-适合给新手看的RAC用法总结</a></p>\n","site":{"data":{}},"excerpt":"<p>ReactiveCocoa作用<br>1.target-action:rac_signalForControlEvents<br>rac_textSignal rac_gestureSignal<br>2.代理 rac_signalForSelector:@selector() fromProtocol:()<br>3.通知 rac_addObserverForName<br>4.KVO RACObserve(object, value)<br>","more":"</p>\n<p>代码示例：<br>1.target-action<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">//1.1 监听textfield文字更改</div><div class=\"line\">[[self.textfiled rac_signalForControlEvents:UIControlEventEditingChanged] subscribeNext:^(id x)&#123;</div><div class=\"line\">    NSLog(@&quot;change&quot;);</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">//简写</div><div class=\"line\">[[self.textfiled rac_textSignal] subscribeNext:^(id x) &#123;</div><div class=\"line\">    NSLog(@&quot;%@&quot;,x);</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">//1.2</div><div class=\"line\">UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] init];</div><div class=\"line\">    [[tap rac_gestureSignal] subscribeNext:^(id x) &#123;</div><div class=\"line\">    NSLog(@&quot;tap&quot;);</div><div class=\"line\">&#125;];</div><div class=\"line\">//注意：如果给label添加手势，需要打开userInteractionEnabled</div><div class=\"line\">self.lab.userInteractionEnabled = YES;</div><div class=\"line\">[self.lab addGestureRecognizer:tap];</div></pre></td></tr></table></figure></p>\n<p>2.代理：rac_signalForSelector:@selector() fromProtocol:()<br><em>*</em> 注意：只能实现返回值为void的代理方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@&quot;title&quot; message:@&quot;rac test&quot; delegate:self cancelButtonTitle:@&quot;no&quot; otherButtonTitles:@&quot;yes&quot;, nil];</div><div class=\"line\">    [[self rac_signalForSelector:@selector(alertView:clickedButtonAtIndex:) fromProtocol:@protocol(UIAlertViewDelegate)] subscribeNext:^(RACTuple *tuple) &#123;</div><div class=\"line\">        //tuple为点击按钮的各个参数</div><div class=\"line\">        NSLog(@&quot;%ld&quot;,tuple.count);    //参数个数 2 </div><div class=\"line\">        NSLog(@&quot;%@&quot;,tuple.first);     //alertView</div><div class=\"line\">        NSLog(@&quot;%@&quot;,tuple.second);    //buttonIndex</div><div class=\"line\">        NSLog(@&quot;%@&quot;,tuple.third);     //null</div><div class=\"line\">    &#125;];</div><div class=\"line\">//简写</div><div class=\"line\">[[alertView rac_buttonClickedSignal] subscribeNext:^(id x) &#123;</div><div class=\"line\">    NSLog(@&quot;%@&quot;,x);     //buttonIndex</div><div class=\"line\">&#125;];</div><div class=\"line\">[alertView show];</div></pre></td></tr></table></figure></p>\n<p>3.通知 rac_addObserverForName<br>点击一个页面可以更新另一个页面数据<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">[[[NSNotificationCenter defaultCenter] rac_addObserverForName:@&quot;postData&quot; object:nil] subscribeNext:^(NSNotification *notification) &#123;</div><div class=\"line\">    NSLog(@&quot;%@&quot;, notification.name);</div><div class=\"line\">    NSLog(@&quot;%@&quot;, notification.object);</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">[self presentViewController:[[SecondViewController alloc]init] animated:YES completion:nil];</div></pre></td></tr></table></figure></p>\n<p>SecondViewController代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSMutableArray *dataArray = [[NSMutableArray alloc] initWithObjects:@&quot;1&quot;, @&quot;2&quot;, @&quot;3&quot;, nil];</div><div class=\"line\">[[NSNotificationCenter defaultCenter] postNotificationName:@&quot;postData&quot; object:dataArray];</div><div class=\"line\">[self dismissViewControllerAnimated:YES completion:nil];</div></pre></td></tr></table></figure></p>\n<p>4.KVO RACObserve(object, value)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIScrollView *scrolView = [[UIScrollView alloc] initWithFrame:CGRectMake(0, 300, 200, 400)];</div><div class=\"line\">scrolView.contentSize = CGSizeMake(200, 800);</div><div class=\"line\">scrolView.backgroundColor = [UIColor greenColor];</div><div class=\"line\">[self.view addSubview:scrolView];</div><div class=\"line\">[RACObserve(scrolView, contentOffset) subscribeNext:^(id x) &#123;</div><div class=\"line\">    NSLog(@&quot;success&quot;);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<p>原文链接：<a href=\"http://www.jianshu.com/p/ff79a5ae0353\" target=\"_blank\" rel=\"external\">学习RAC小记-适合给新手看的RAC用法总结</a></p>"},{"title":"OpenGL学习笔记","date":"2017-07-03T10:23:19.000Z","_content":"\n1.GPUImage底层使用的是OPENGL,操控GPU来实现屏幕展示\n\n01-自定义图层类型\n02-初始化CAEAGLLayer图层属性\n03-创建EAGLContext\n04-创建渲染缓冲区\n05-创建帧缓冲区\n06-创建着色器\n<!--more-->\n07-创建着色器程序\n08-创建纹理对象\n09-YUV转RGB绘制纹理\n10-渲染缓冲区到屏幕\n11-清理内存\n","source":"_posts/OpenGL学习笔记.md","raw":"---\ntitle: OpenGL学习笔记\ndate: 2017-07-03 18:23:19\ncategories: 笔记\ntags: [iOS,OpenGL]\n---\n\n1.GPUImage底层使用的是OPENGL,操控GPU来实现屏幕展示\n\n01-自定义图层类型\n02-初始化CAEAGLLayer图层属性\n03-创建EAGLContext\n04-创建渲染缓冲区\n05-创建帧缓冲区\n06-创建着色器\n<!--more-->\n07-创建着色器程序\n08-创建纹理对象\n09-YUV转RGB绘制纹理\n10-渲染缓冲区到屏幕\n11-清理内存\n","slug":"OpenGL学习笔记","published":1,"updated":"2017-07-14T03:57:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj53c1dvk000wh3jji6n4ys48","content":"<p>1.GPUImage底层使用的是OPENGL,操控GPU来实现屏幕展示</p>\n<p>01-自定义图层类型<br>02-初始化CAEAGLLayer图层属性<br>03-创建EAGLContext<br>04-创建渲染缓冲区<br>05-创建帧缓冲区<br>06-创建着色器<br><a id=\"more\"></a><br>07-创建着色器程序<br>08-创建纹理对象<br>09-YUV转RGB绘制纹理<br>10-渲染缓冲区到屏幕<br>11-清理内存</p>\n","site":{"data":{}},"excerpt":"<p>1.GPUImage底层使用的是OPENGL,操控GPU来实现屏幕展示</p>\n<p>01-自定义图层类型<br>02-初始化CAEAGLLayer图层属性<br>03-创建EAGLContext<br>04-创建渲染缓冲区<br>05-创建帧缓冲区<br>06-创建着色器<br>","more":"<br>07-创建着色器程序<br>08-创建纹理对象<br>09-YUV转RGB绘制纹理<br>10-渲染缓冲区到屏幕<br>11-清理内存</p>"},{"title":"RAC学习笔记","date":"2017-05-20T02:31:47.000Z","toc":true,"_content":"\nReactiveCocoa(RAC):是函数响应式编程(Functional Reactive Programming:FRP)框架，高聚合、低耦合思想。\n使用cocoapods导入时加上`use_frameworks!`\n\n## ReactiveCocoa常见类\n### RACSiganl:信号类(核心)\n一般表示将来有数据传递，只要有数据改变，信号内部接收到数据，就会马上发出数据。\n#### 注意：\n* 信号类(RACSiganl)，只是表示当数据改变时，信号内部会发出数据，它本身不具备发送信号的能力，而是交给内部一个订阅者去发出。\n<!--more-->\n* 默认一个信号都是冷信号，也就是值改变了，也不会触发，只有订阅了这个信号，这个信号才会变为热信号，值改变了才会触发。\n* 如何订阅信号：调用信号RACSignal的subscribeNext就能订阅。\n\n#### RACSiganl简单使用\n* 1.创建信号 \n```\n$ + (RACSignal *)createSignal:(RACDisposable * (^)(id<RACSubscriber> subscriber))didSubscribe\n```\n\n* 2.订阅信号,才会激活信号. \n```\n$ - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock\n```\n\n* 3.发送信号 \n```\n$ - (void)sendNext:(id)value\n```\n\n#### RACSignal底层实现\n* 1.创建信号，首先把didSubscribe保存到信号中，还不会触发。\n* 2.当信号被订阅，也就是调用signal的subscribeNext:nextBlock\n    + 2.1 subscribeNext内部会创建订阅者subscriber，并且把nextBlock保存到subscriber中。\n    + 2.2 subscribeNext内部会调用signal的didSubscribe\n* 3.siganl的didSubscribe中调用[subscriber sendNext:@1];\n    + 3.1 sendNext底层其实就是执行subscriber的nextBlock\n```\n// 1.创建信号\nRACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n\n    // block调用时刻：每当有订阅者订阅信号，就会调用block。\n    // 2.发送信号\n    [subscriber sendNext:@1];\n    // 如果不在发送数据，最好发送信号完成，内部会自动调用[RACDisposable disposable]取消订阅信号。\n    [subscriber sendCompleted];\n    return [RACDisposable disposableWithBlock:^{\n        // block调用时刻：当信号发送完成或者发送错误，就会自动执行这个block,取消订阅信号。\n        // 执行完Block后，当前信号就不在被订阅了。\n        NSLog(@\"信号被销毁\");\n    }];\n}];\n\n// 3.订阅信号,才会激活信号.\n[siganl subscribeNext:^(id x) {\n    // block调用时刻：每当有信号发出数据，就会调用block.\n    NSLog(@\"接收到数据:%@\",x);\n}];\n```\n\n### RACSubscriber\n表示订阅者的意思，用于发送信号，这是一个协议，不是一个类，只要遵守这个协议，并且实现方法才能成为订阅者。通过create创建的信号，都有一个订阅者，帮助他发送数据。\n\n### RACDisposable\n* 用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。\n* 使用场景:不想监听某个信号时，可以通过它主动取消订阅信号。\n\n### RACSubject\n* 信号提供者，自己可以充当信号，又能发送信号。\n* 使用场景:通常用来代替代理，有了它，就不必要定义代理了。\n* RACSubject:底层实现和RACSignal不一样。\n    + 1.调用subscribeNext订阅信号，只是把订阅者保存起来，并且订阅者的nextBlock已经赋值了。\n    + 2.调用sendNext发送信号，遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。\n* RACSubject使用步骤:\n    + 1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。\n    + 2.订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock\n    + 3.发送信号 sendNext:(id)value\n```\n// 1.创建信号\nRACSubject *subject = [RACSubject subject];\n\n// 2.订阅信号\n[subject subscribeNext:^(id x) {\n// block调用时刻：当信号发出新值，就会调用.\nNSLog(@\"第一个订阅者%@\",x);\n}];\n[subject subscribeNext:^(id x) {\n// block调用时刻：当信号发出新值，就会调用.\nNSLog(@\"第二个订阅者%@\",x);\n}];\n\n// 3.发送信号\n[subject sendNext:@\"1\"];\n\n```\n\n***RACSubject替换代理***\n需求:\n1.给当前控制器添加一个按钮，modal到另一个控制器界面\n2.另一个控制器view中有个按钮，点击按钮，通知当前控制器\n\n* 步骤一：在第二个控制器.h，添加一个RACSubject代替代理。\n```\n@interface TwoViewController : UIViewController\n@property (nonatomic, strong) RACSubject *delegateSignal;\n@end\n```\n\n* 步骤二：监听第二个控制器按钮点击\n```\n@implementation TwoViewController\n- (IBAction)notice:(id)sender {\n// 通知第一个控制器，告诉它，按钮被点了\n\n// 通知代理\n// 判断代理信号是否有值\nif (self.delegateSignal) {\n    // 有值，才需要通知\n    [self.delegateSignal sendNext:nil];\n    }\n}\n@end\n```\n\n* 步骤三：在第一个控制器中，监听跳转按钮，给第二个控制器的代理信号赋值，并且监听.\n```\n@implementation OneViewController \n- (IBAction)btnClick:(id)sender {\n    // 创建第二个控制器\n    TwoViewController *twoVc = [[TwoViewController alloc] init];\n    // 设置代理信号\n    twoVc.delegateSignal = [RACSubject subject];\n    // 订阅代理信号\n    [twoVc.delegateSignal subscribeNext:^(id x) {\n        NSLog(@\"点击了通知按钮\");\n    }];\n    // 跳转到第二个控制器\n    [self presentViewController:twoVc animated:YES completion:nil];\n}\n@end\n```\n\n### RACReplaySubject\n重复提供信号类，是RACSubject的子类。\nRACReplaySubject与RACSubject区别:\n* RACReplaySubject可以先发送信号，在订阅信号，RACSubject就不可以。\n* 使用场景一:如果一个信号每被订阅一次，就需要把之前的值重复发送一遍，使用重复提供信号类。\n* 使用场景二:可以设置capacity数量来限制缓存的value的数量,即只缓充最新的几个值。\nRACReplaySubject:底层实现和RACSubject不一样。\n* 1.调用sendNext发送信号，把值保存起来，然后遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。\n* 2.调用subscribeNext订阅信号，遍历保存的所有值，一个一个调用订阅者的nextBlock\n注意：如果想当一个信号被订阅，就重复播放之前所有值，需要先发送信号，在订阅信号。也就是先保存值，在订阅值。\nRACReplaySubject使用步骤:\n* 1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。\n* 2.可以先订阅信号，也可以先发送信号。\n    + 2.1 订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock\n    + 2.2 发送信号 sendNext:(id)value\n```\n// 1.创建信号\nRACReplaySubject *replaySubject = [RACReplaySubject subject];\n\n// 2.发送信号\n[replaySubject sendNext:@1];\n[replaySubject sendNext:@2];\n\n// 3.订阅信号\n[replaySubject subscribeNext:^(id x) {\n    NSLog(@\"第一个订阅者接收到的数据%@\",x);\n}];\n\n// 订阅信号\n[replaySubject subscribeNext:^(id x) {\n    NSLog(@\"第二个订阅者接收到的数据%@\",x);\n}];\n```\n\n### RACTuple\n元组类,类似NSArray,用来包装值.\n\n### RACSequence\nRAC中的集合类，用于代替NSArray,NSDictionary,可以使用它来快速遍历数组和字典。\n使用场景：字典转模型\nRACSequence和RACTuple简单使用\n```\n// 1.遍历数组\nNSArray *numbers = @[@1,@2,@3,@4];\n\n// 第一步: 把数组转换成集合RACSequence numbers.rac_sequence\n// 第二步: 把集合RACSequence转换RACSignal信号类,numbers.rac_sequence.signal\n// 第三步: 订阅信号，激活信号，会自动把集合中的所有值，遍历出来。\n[numbers.rac_sequence.signal subscribeNext:^(id x) {\n    NSLog(@\"%@\",x);\n}];\n\n// 2.遍历字典,遍历出来的键值对会包装成RACTuple(元组对象)\nNSDictionary *dict = @{@\"name\":@\"zs\",@\"age\":@18};\n[dict.rac_sequence.signal subscribeNext:^(RACTuple *x) {\n\n// 解包元组，会把元组的值，按顺序给参数里面的变量赋值\nRACTupleUnpack(NSString *key,NSString *value) = x;\n    // 相当于以下写法\n    // NSString *key = x[0];\n    // NSString *value = x[1];\n\n    NSLog(@\"%@ %@\",key,value);\n}];\n\n// 3.字典转模型\n// 3.1 OC写法\nNSString *filePath = [[NSBundle mainBundle] pathForResource:@\"flags.plist\" ofType:nil];\nNSArray *dictArr = [NSArray arrayWithContentsOfFile:filePath];\nNSMutableArray *items = [NSMutableArray array];\nfor (NSDictionary *dict in dictArr) {\n    FlagItem *item = [FlagItem flagWithDict:dict];\n    [items addObject:item];\n}\n\n// 3.2 RAC写法\nNSString *filePath = [[NSBundle mainBundle] pathForResource:@\"flags.plist\" ofType:nil];\nNSArray *dictArr = [NSArray arrayWithContentsOfFile:filePath];\nNSMutableArray *flags = [NSMutableArray array];\n_flags = flags;\n// rac_sequence注意点：调用subscribeNext，并不会马上执行nextBlock，而是会等一会。\n[dictArr.rac_sequence.signal subscribeNext:^(id x) {\n    // 运用RAC遍历字典，x：字典\n    FlagItem *item = [FlagItem flagWithDict:x];\n    [flags addObject:item];\n}];\nNSLog(@\"%@\",  NSStringFromCGRect([UIScreen mainScreen].bounds));\n\n\n// 3.3 RAC高级写法:\nNSString *filePath = [[NSBundle mainBundle] pathForResource:@\"flags.plist\" ofType:nil];\nNSArray *dictArr = [NSArray arrayWithContentsOfFile:filePath];\n// map:映射的意思，目的：把原始值value映射成一个新值\n// array: 把集合转换成数组\n// 底层实现：当信号被订阅，会遍历集合中的原始值，映射成新值，并且保存到新的数组里。\nNSArray *flags = [[dictArr.rac_sequence map:^id(id value) {\n    return [FlagItem flagWithDict:value];\n}] array];\n\n```\n\n### RACCommand\nRAC中用于处理事件的类，可以把事件如何处理,事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。\n使用场景:监听按钮点击，网络请求\n* RACCommand使用步骤:\n    + 1.创建命令 initWithSignalBlock:(RACSignal * (^)(id input))signalBlock\n    + 2.在signalBlock中，创建RACSignal，并且作为signalBlock的返回值\n    + 3.执行命令 - (RACSignal *)execute:(id)input\n\n* RACCommand使用注意\n    + 1.signalBlock必须要返回一个信号，不能传nil.\n    + 2.如果不想要传递信号，直接创建空的信号[RACSignal empty];\n    + 3.RACCommand中信号如果数据传递完，必须调用[subscriber sendCompleted]，这时命令才会执行完毕，否则永远处于执行中。\n    + 4.RACCommand需要被强引用，否则接收不到RACCommand中的信号，因此RACCommand中的信号是延迟发送的。\n\n* RACCommand设计思想：内部signalBlock为什么要返回一个信号，这个信号有什么用。\n    + 1.在RAC开发中，通常会把网络请求封装到RACCommand，直接执行某个RACCommand就能发送请求。\n    + 2.当RACCommand内部请求到数据的时候，需要把请求的数据传递给外界，这时候就需要通过signalBlock返回的信号传递了。\n\n* 如何拿到RACCommand中返回信号发出的数据。\n    + 1.RACCommand有个执行信号源executionSignals，这个是signal of signals(信号的信号),意思是信号发出的数据是信号，不是普通的类型。\n    + 2.订阅executionSignals就能拿到RACCommand中返回的信号，然后订阅signalBlock返回的信号，就能获取发出的值。\n\n* 五、监听当前命令是否正在执行executing\n\n* 六、使用场景,监听按钮点击，网络请求\n```\n// 1.创建命令\nRACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) {\n    NSLog(@\"执行命令\");\n    // 创建空信号,必须返回信号\n    // return [RACSignal empty];\n\n    // 2.创建信号,用来传递数据\n    return [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n        [subscriber sendNext:@\"请求数据\"];\n        // 注意：数据传递完，最好调用sendCompleted，这时命令才执行完毕。\n        [subscriber sendCompleted];\n        return nil;\n    }];\n}];\n\n// 强引用命令，不要被销毁，否则接收不到数据\n_conmmand = command;\n\n// 3.订阅RACCommand中的信号\n[command.executionSignals subscribeNext:^(id x) {\n    [x subscribeNext:^(id x) {\n    NSLog(@\"%@\",x);\n    }];\n}];\n\n// RAC高级用法\n// switchToLatest:用于signal of signals，获取signal of signals发出的最新信号,也就是可以直接拿到RACCommand中的信号\n[command.executionSignals.switchToLatest subscribeNext:^(id x) {\n    NSLog(@\"%@\",x);\n}];\n\n// 4.监听命令是否执行完毕,默认会来一次，可以直接跳过，skip表示跳过第一次信号。\n[[command.executing skip:1] subscribeNext:^(id x) {\n\n    if ([x boolValue] == YES) {\n    // 正在执行\n    NSLog(@\"正在执行\");\n    }else{\n    // 执行完成\n    NSLog(@\"执行完成\");\n    }\n}];\n\n// 5.执行命令\n[self.conmmand execute:@1];\n```\n\n### RACMulticastConnection\n用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。\n注意:RACMulticastConnection通过RACSignal的-publish或者-muticast:方法创建.\n* RACMulticastConnection使用步骤:\n    + 1.创建信号 + (RACSignal *)createSignal:(RACDisposable * (^)(id<RACSubscriber> subscriber))didSubscribe\n    + 2.创建连接 RACMulticastConnection *connect = [signal publish];\n    + 3.订阅信号,注意：订阅的不在是之前的信号，而是连接的信号。 [connect.signal subscribeNext:nextBlock]\n    + 4.连接 [connect connect]\n\n* RACMulticastConnection底层原理:\n    + 1.创建connect，connect.sourceSignal -> RACSignal(原始信号)  connect.signal -> RACSubject\n    + 2.订阅connect.signal，会调用RACSubject的subscribeNext，创建订阅者，而且把订阅者保存起来，不会执行block。\n    + 3.[connect connect]内部会订阅RACSignal(原始信号)，并且订阅者是RACSubject\n        - 3.1.订阅原始信号，就会调用原始信号中的didSubscribe\n        - 3.2 didSubscribe，拿到订阅者调用sendNext，其实是调用RACSubject的sendNext\n    + 4.RACSubject的sendNext,会遍历RACSubject所有订阅者发送信号。\n        - 4.1 因为刚刚第二步，都是在订阅RACSubject，因此会拿到第二步所有的订阅者，调用他们的nextBlock\n\n* 需求：假设在一个信号中发送请求，每次订阅一次都会发送请求，这样就会导致多次请求。\n解决：使用RACMulticastConnection就能解决.\n```\n// 1.创建请求信号\nRACSignal *signal = [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n    NSLog(@\"发送请求\");\n    return nil;\n}];\n// 2.订阅信号\n[signal subscribeNext:^(id x) {\n    NSLog(@\"接收数据\");\n}];\n// 2.订阅信号\n[signal subscribeNext:^(id x) {\n    NSLog(@\"接收数据\");\n}];\n\n// 3.运行结果，会执行两遍发送请求，也就是每次订阅都会发送一次请求\n```\n\n* RACMulticastConnection:解决重复请求问题\n```\n// 1.创建信号\nRACSignal *signal = [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n    NSLog(@\"发送请求\");\n    [subscriber sendNext:@1];\n    return nil;\n}];\n\n// 2.创建连接\nRACMulticastConnection *connect = [signal publish];\n\n// 3.订阅信号，\n// 注意：订阅信号，也不能激活信号，只是保存订阅者到数组，必须通过连接,当调用连接，就会一次性调用所有订阅者的sendNext:\n[connect.signal subscribeNext:^(id x) {\n    NSLog(@\"订阅者一信号\");\n}];\n\n[connect.signal subscribeNext:^(id x) {\n    NSLog(@\"订阅者二信号\");\n}];\n\n// 4.连接,激活信号\n[connect connect];\n```\n\n### RACScheduler\nRAC中的队列，用GCD封装的。\n\n### RACUnit\n表⽰stream不包含有意义的值,也就是看到这个，可以直接理解为nil.\n\n### RACEvent\n把数据包装成信号事件(signal event)。它主要通过RACSignal的-materialize来使用，然并卵。\n\n## ReactiveCocoa开发中常见用法。\n### 代替代理\nrac_signalForSelector：用于替代代理。\n### 代替KVO\nrac_valuesAndChangesForKeyPath：用于监听某个对象的属性改变。\n### 监听事件\nrac_signalForControlEvents：用于监听某个事件。\n### 代替通知\nrac_addObserverForName:用于监听某个通知。\n### 监听文本框文字改变\nrac_textSignal:只要文本框发出改变就会发出这个信号。\n### 处理当界面有多次请求时，需要都获取到数据时，才能展示界面\nrac_liftSelector:withSignalsFromArray:Signals:当传入的Signals(信号数组)，每一个signal都至少sendNext过一次，就会去触发第一个selector参数的方法。\n使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据。\n代码如下：\n```\n// 1.代替代理\n// 需求：自定义redView,监听红色view中按钮点击\n// 之前都是需要通过代理监听，给红色View添加一个代理属性，点击按钮的时候，通知代理做事情\n// rac_signalForSelector:把调用某个对象的方法的信息转换成信号，就要调用这个方法，就会发送信号。\n// 这里表示只要redV调用btnClick:,就会发出信号，订阅就好了。\n[[redV rac_signalForSelector:@selector(btnClick:)] subscribeNext:^(id x) {\n    NSLog(@\"点击红色按钮\");\n}];\n\n// 2.KVO\n// 把监听redV的center属性改变转换成信号，只要值改变就会发送信号\n// observer:可以传入nil\n[[redV rac_valuesAndChangesForKeyPath:@\"center\" options:NSKeyValueObservingOptionNew observer:nil] subscribeNext:^(id x) {\n    NSLog(@\"%@\",x);\n}];\n\n// 3.监听事件\n// 把按钮点击事件转换为信号，点击按钮，就会发送信号\n[[self.btn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) {\n    NSLog(@\"按钮被点击了\");\n}];\n\n// 4.代替通知\n// 把监听到的通知转换信号\n[[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIKeyboardWillShowNotification object:nil] subscribeNext:^(id x) {\n    NSLog(@\"键盘弹出\");\n}];\n\n// 5.监听文本框的文字改变\n[_textField.rac_textSignal subscribeNext:^(id x) {\n    NSLog(@\"文字改变了%@\",x);\n}];\n\n// 6.处理多个请求，都返回结果的时候，统一做处理.\nRACSignal *request1 = [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n\n// 发送请求1\n[subscriber sendNext:@\"发送请求1\"];\n    return nil;\n}];\n\nRACSignal *request2 = [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n    // 发送请求2\n    [subscriber sendNext:@\"发送请求2\"];\n    return nil;\n}];\n\n// 使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据。\n[self rac_liftSelector:@selector(updateUIWithR1:r2:) withSignalsFromArray:@[request1,request2]];\n}\n// 更新UI\n- (void)updateUIWithR1:(id)data r2:(id)data1\n{\n    NSLog(@\"更新UI%@  %@\",data,data1);\n}\n```\n\n## ReactiveCocoa常见宏\n\n### RAC(TARGET, [KEYPATH, [NIL_VALUE]])\n用于给某个对象的某个属性绑定。\n```\n// 只要文本框文字改变，就会修改label的文字\nRAC(self.labelView,text) = _textField.rac_textSignal;\n```\n\n### RACObserve(self, name)\n监听某个对象的某个属性,返回的是信号。\n```\n[RACObserve(self.view, center) subscribeNext:^(id x) {\n    NSLog(@\"%@\",x);\n}];\n```\n\n### @weakify(Obj)和@strongify(Obj)\n一般两个都是配套使用,在主头文件(ReactiveCocoa.h)中并没有导入，需要自己手动导入，RACEXTScope.h才可以使用。但是每次导入都非常麻烦，只需要在主头文件自己导入就好了。\n\n### RACTuplePack\n把数据包装成RACTuple（元组类）\n```\n// 把参数中的数据包装成元组\nRACTuple *tuple = RACTuplePack(@10,@20);\n```\n\n### RACTupleUnpack：把RACTuple（元组类）解包成对应的数据。\n```\n// 把参数中的数据包装成元组\nRACTuple *tuple = RACTuplePack(@\"abc\",@20);\n\n// 解包元组，会把元组的值，按顺序给参数里面的变量赋值\n// name = @\"abc\" age = @20\nRACTupleUnpack(NSString *name,NSNumber *age) = tuple;\n```\n\n原文链接：[最快让你上手ReactiveCocoa之基础篇](http://www.jianshu.com/p/87ef6720a096#)\n","source":"_posts/RAC学习笔记.md","raw":"---\ntitle: RAC学习笔记\ndate: 2017-05-20 10:31:47\ncategories: 笔记\ntags: [iOS,RAC]\ntoc: true\n---\n\nReactiveCocoa(RAC):是函数响应式编程(Functional Reactive Programming:FRP)框架，高聚合、低耦合思想。\n使用cocoapods导入时加上`use_frameworks!`\n\n## ReactiveCocoa常见类\n### RACSiganl:信号类(核心)\n一般表示将来有数据传递，只要有数据改变，信号内部接收到数据，就会马上发出数据。\n#### 注意：\n* 信号类(RACSiganl)，只是表示当数据改变时，信号内部会发出数据，它本身不具备发送信号的能力，而是交给内部一个订阅者去发出。\n<!--more-->\n* 默认一个信号都是冷信号，也就是值改变了，也不会触发，只有订阅了这个信号，这个信号才会变为热信号，值改变了才会触发。\n* 如何订阅信号：调用信号RACSignal的subscribeNext就能订阅。\n\n#### RACSiganl简单使用\n* 1.创建信号 \n```\n$ + (RACSignal *)createSignal:(RACDisposable * (^)(id<RACSubscriber> subscriber))didSubscribe\n```\n\n* 2.订阅信号,才会激活信号. \n```\n$ - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock\n```\n\n* 3.发送信号 \n```\n$ - (void)sendNext:(id)value\n```\n\n#### RACSignal底层实现\n* 1.创建信号，首先把didSubscribe保存到信号中，还不会触发。\n* 2.当信号被订阅，也就是调用signal的subscribeNext:nextBlock\n    + 2.1 subscribeNext内部会创建订阅者subscriber，并且把nextBlock保存到subscriber中。\n    + 2.2 subscribeNext内部会调用signal的didSubscribe\n* 3.siganl的didSubscribe中调用[subscriber sendNext:@1];\n    + 3.1 sendNext底层其实就是执行subscriber的nextBlock\n```\n// 1.创建信号\nRACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n\n    // block调用时刻：每当有订阅者订阅信号，就会调用block。\n    // 2.发送信号\n    [subscriber sendNext:@1];\n    // 如果不在发送数据，最好发送信号完成，内部会自动调用[RACDisposable disposable]取消订阅信号。\n    [subscriber sendCompleted];\n    return [RACDisposable disposableWithBlock:^{\n        // block调用时刻：当信号发送完成或者发送错误，就会自动执行这个block,取消订阅信号。\n        // 执行完Block后，当前信号就不在被订阅了。\n        NSLog(@\"信号被销毁\");\n    }];\n}];\n\n// 3.订阅信号,才会激活信号.\n[siganl subscribeNext:^(id x) {\n    // block调用时刻：每当有信号发出数据，就会调用block.\n    NSLog(@\"接收到数据:%@\",x);\n}];\n```\n\n### RACSubscriber\n表示订阅者的意思，用于发送信号，这是一个协议，不是一个类，只要遵守这个协议，并且实现方法才能成为订阅者。通过create创建的信号，都有一个订阅者，帮助他发送数据。\n\n### RACDisposable\n* 用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。\n* 使用场景:不想监听某个信号时，可以通过它主动取消订阅信号。\n\n### RACSubject\n* 信号提供者，自己可以充当信号，又能发送信号。\n* 使用场景:通常用来代替代理，有了它，就不必要定义代理了。\n* RACSubject:底层实现和RACSignal不一样。\n    + 1.调用subscribeNext订阅信号，只是把订阅者保存起来，并且订阅者的nextBlock已经赋值了。\n    + 2.调用sendNext发送信号，遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。\n* RACSubject使用步骤:\n    + 1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。\n    + 2.订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock\n    + 3.发送信号 sendNext:(id)value\n```\n// 1.创建信号\nRACSubject *subject = [RACSubject subject];\n\n// 2.订阅信号\n[subject subscribeNext:^(id x) {\n// block调用时刻：当信号发出新值，就会调用.\nNSLog(@\"第一个订阅者%@\",x);\n}];\n[subject subscribeNext:^(id x) {\n// block调用时刻：当信号发出新值，就会调用.\nNSLog(@\"第二个订阅者%@\",x);\n}];\n\n// 3.发送信号\n[subject sendNext:@\"1\"];\n\n```\n\n***RACSubject替换代理***\n需求:\n1.给当前控制器添加一个按钮，modal到另一个控制器界面\n2.另一个控制器view中有个按钮，点击按钮，通知当前控制器\n\n* 步骤一：在第二个控制器.h，添加一个RACSubject代替代理。\n```\n@interface TwoViewController : UIViewController\n@property (nonatomic, strong) RACSubject *delegateSignal;\n@end\n```\n\n* 步骤二：监听第二个控制器按钮点击\n```\n@implementation TwoViewController\n- (IBAction)notice:(id)sender {\n// 通知第一个控制器，告诉它，按钮被点了\n\n// 通知代理\n// 判断代理信号是否有值\nif (self.delegateSignal) {\n    // 有值，才需要通知\n    [self.delegateSignal sendNext:nil];\n    }\n}\n@end\n```\n\n* 步骤三：在第一个控制器中，监听跳转按钮，给第二个控制器的代理信号赋值，并且监听.\n```\n@implementation OneViewController \n- (IBAction)btnClick:(id)sender {\n    // 创建第二个控制器\n    TwoViewController *twoVc = [[TwoViewController alloc] init];\n    // 设置代理信号\n    twoVc.delegateSignal = [RACSubject subject];\n    // 订阅代理信号\n    [twoVc.delegateSignal subscribeNext:^(id x) {\n        NSLog(@\"点击了通知按钮\");\n    }];\n    // 跳转到第二个控制器\n    [self presentViewController:twoVc animated:YES completion:nil];\n}\n@end\n```\n\n### RACReplaySubject\n重复提供信号类，是RACSubject的子类。\nRACReplaySubject与RACSubject区别:\n* RACReplaySubject可以先发送信号，在订阅信号，RACSubject就不可以。\n* 使用场景一:如果一个信号每被订阅一次，就需要把之前的值重复发送一遍，使用重复提供信号类。\n* 使用场景二:可以设置capacity数量来限制缓存的value的数量,即只缓充最新的几个值。\nRACReplaySubject:底层实现和RACSubject不一样。\n* 1.调用sendNext发送信号，把值保存起来，然后遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。\n* 2.调用subscribeNext订阅信号，遍历保存的所有值，一个一个调用订阅者的nextBlock\n注意：如果想当一个信号被订阅，就重复播放之前所有值，需要先发送信号，在订阅信号。也就是先保存值，在订阅值。\nRACReplaySubject使用步骤:\n* 1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。\n* 2.可以先订阅信号，也可以先发送信号。\n    + 2.1 订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock\n    + 2.2 发送信号 sendNext:(id)value\n```\n// 1.创建信号\nRACReplaySubject *replaySubject = [RACReplaySubject subject];\n\n// 2.发送信号\n[replaySubject sendNext:@1];\n[replaySubject sendNext:@2];\n\n// 3.订阅信号\n[replaySubject subscribeNext:^(id x) {\n    NSLog(@\"第一个订阅者接收到的数据%@\",x);\n}];\n\n// 订阅信号\n[replaySubject subscribeNext:^(id x) {\n    NSLog(@\"第二个订阅者接收到的数据%@\",x);\n}];\n```\n\n### RACTuple\n元组类,类似NSArray,用来包装值.\n\n### RACSequence\nRAC中的集合类，用于代替NSArray,NSDictionary,可以使用它来快速遍历数组和字典。\n使用场景：字典转模型\nRACSequence和RACTuple简单使用\n```\n// 1.遍历数组\nNSArray *numbers = @[@1,@2,@3,@4];\n\n// 第一步: 把数组转换成集合RACSequence numbers.rac_sequence\n// 第二步: 把集合RACSequence转换RACSignal信号类,numbers.rac_sequence.signal\n// 第三步: 订阅信号，激活信号，会自动把集合中的所有值，遍历出来。\n[numbers.rac_sequence.signal subscribeNext:^(id x) {\n    NSLog(@\"%@\",x);\n}];\n\n// 2.遍历字典,遍历出来的键值对会包装成RACTuple(元组对象)\nNSDictionary *dict = @{@\"name\":@\"zs\",@\"age\":@18};\n[dict.rac_sequence.signal subscribeNext:^(RACTuple *x) {\n\n// 解包元组，会把元组的值，按顺序给参数里面的变量赋值\nRACTupleUnpack(NSString *key,NSString *value) = x;\n    // 相当于以下写法\n    // NSString *key = x[0];\n    // NSString *value = x[1];\n\n    NSLog(@\"%@ %@\",key,value);\n}];\n\n// 3.字典转模型\n// 3.1 OC写法\nNSString *filePath = [[NSBundle mainBundle] pathForResource:@\"flags.plist\" ofType:nil];\nNSArray *dictArr = [NSArray arrayWithContentsOfFile:filePath];\nNSMutableArray *items = [NSMutableArray array];\nfor (NSDictionary *dict in dictArr) {\n    FlagItem *item = [FlagItem flagWithDict:dict];\n    [items addObject:item];\n}\n\n// 3.2 RAC写法\nNSString *filePath = [[NSBundle mainBundle] pathForResource:@\"flags.plist\" ofType:nil];\nNSArray *dictArr = [NSArray arrayWithContentsOfFile:filePath];\nNSMutableArray *flags = [NSMutableArray array];\n_flags = flags;\n// rac_sequence注意点：调用subscribeNext，并不会马上执行nextBlock，而是会等一会。\n[dictArr.rac_sequence.signal subscribeNext:^(id x) {\n    // 运用RAC遍历字典，x：字典\n    FlagItem *item = [FlagItem flagWithDict:x];\n    [flags addObject:item];\n}];\nNSLog(@\"%@\",  NSStringFromCGRect([UIScreen mainScreen].bounds));\n\n\n// 3.3 RAC高级写法:\nNSString *filePath = [[NSBundle mainBundle] pathForResource:@\"flags.plist\" ofType:nil];\nNSArray *dictArr = [NSArray arrayWithContentsOfFile:filePath];\n// map:映射的意思，目的：把原始值value映射成一个新值\n// array: 把集合转换成数组\n// 底层实现：当信号被订阅，会遍历集合中的原始值，映射成新值，并且保存到新的数组里。\nNSArray *flags = [[dictArr.rac_sequence map:^id(id value) {\n    return [FlagItem flagWithDict:value];\n}] array];\n\n```\n\n### RACCommand\nRAC中用于处理事件的类，可以把事件如何处理,事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。\n使用场景:监听按钮点击，网络请求\n* RACCommand使用步骤:\n    + 1.创建命令 initWithSignalBlock:(RACSignal * (^)(id input))signalBlock\n    + 2.在signalBlock中，创建RACSignal，并且作为signalBlock的返回值\n    + 3.执行命令 - (RACSignal *)execute:(id)input\n\n* RACCommand使用注意\n    + 1.signalBlock必须要返回一个信号，不能传nil.\n    + 2.如果不想要传递信号，直接创建空的信号[RACSignal empty];\n    + 3.RACCommand中信号如果数据传递完，必须调用[subscriber sendCompleted]，这时命令才会执行完毕，否则永远处于执行中。\n    + 4.RACCommand需要被强引用，否则接收不到RACCommand中的信号，因此RACCommand中的信号是延迟发送的。\n\n* RACCommand设计思想：内部signalBlock为什么要返回一个信号，这个信号有什么用。\n    + 1.在RAC开发中，通常会把网络请求封装到RACCommand，直接执行某个RACCommand就能发送请求。\n    + 2.当RACCommand内部请求到数据的时候，需要把请求的数据传递给外界，这时候就需要通过signalBlock返回的信号传递了。\n\n* 如何拿到RACCommand中返回信号发出的数据。\n    + 1.RACCommand有个执行信号源executionSignals，这个是signal of signals(信号的信号),意思是信号发出的数据是信号，不是普通的类型。\n    + 2.订阅executionSignals就能拿到RACCommand中返回的信号，然后订阅signalBlock返回的信号，就能获取发出的值。\n\n* 五、监听当前命令是否正在执行executing\n\n* 六、使用场景,监听按钮点击，网络请求\n```\n// 1.创建命令\nRACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) {\n    NSLog(@\"执行命令\");\n    // 创建空信号,必须返回信号\n    // return [RACSignal empty];\n\n    // 2.创建信号,用来传递数据\n    return [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n        [subscriber sendNext:@\"请求数据\"];\n        // 注意：数据传递完，最好调用sendCompleted，这时命令才执行完毕。\n        [subscriber sendCompleted];\n        return nil;\n    }];\n}];\n\n// 强引用命令，不要被销毁，否则接收不到数据\n_conmmand = command;\n\n// 3.订阅RACCommand中的信号\n[command.executionSignals subscribeNext:^(id x) {\n    [x subscribeNext:^(id x) {\n    NSLog(@\"%@\",x);\n    }];\n}];\n\n// RAC高级用法\n// switchToLatest:用于signal of signals，获取signal of signals发出的最新信号,也就是可以直接拿到RACCommand中的信号\n[command.executionSignals.switchToLatest subscribeNext:^(id x) {\n    NSLog(@\"%@\",x);\n}];\n\n// 4.监听命令是否执行完毕,默认会来一次，可以直接跳过，skip表示跳过第一次信号。\n[[command.executing skip:1] subscribeNext:^(id x) {\n\n    if ([x boolValue] == YES) {\n    // 正在执行\n    NSLog(@\"正在执行\");\n    }else{\n    // 执行完成\n    NSLog(@\"执行完成\");\n    }\n}];\n\n// 5.执行命令\n[self.conmmand execute:@1];\n```\n\n### RACMulticastConnection\n用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。\n注意:RACMulticastConnection通过RACSignal的-publish或者-muticast:方法创建.\n* RACMulticastConnection使用步骤:\n    + 1.创建信号 + (RACSignal *)createSignal:(RACDisposable * (^)(id<RACSubscriber> subscriber))didSubscribe\n    + 2.创建连接 RACMulticastConnection *connect = [signal publish];\n    + 3.订阅信号,注意：订阅的不在是之前的信号，而是连接的信号。 [connect.signal subscribeNext:nextBlock]\n    + 4.连接 [connect connect]\n\n* RACMulticastConnection底层原理:\n    + 1.创建connect，connect.sourceSignal -> RACSignal(原始信号)  connect.signal -> RACSubject\n    + 2.订阅connect.signal，会调用RACSubject的subscribeNext，创建订阅者，而且把订阅者保存起来，不会执行block。\n    + 3.[connect connect]内部会订阅RACSignal(原始信号)，并且订阅者是RACSubject\n        - 3.1.订阅原始信号，就会调用原始信号中的didSubscribe\n        - 3.2 didSubscribe，拿到订阅者调用sendNext，其实是调用RACSubject的sendNext\n    + 4.RACSubject的sendNext,会遍历RACSubject所有订阅者发送信号。\n        - 4.1 因为刚刚第二步，都是在订阅RACSubject，因此会拿到第二步所有的订阅者，调用他们的nextBlock\n\n* 需求：假设在一个信号中发送请求，每次订阅一次都会发送请求，这样就会导致多次请求。\n解决：使用RACMulticastConnection就能解决.\n```\n// 1.创建请求信号\nRACSignal *signal = [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n    NSLog(@\"发送请求\");\n    return nil;\n}];\n// 2.订阅信号\n[signal subscribeNext:^(id x) {\n    NSLog(@\"接收数据\");\n}];\n// 2.订阅信号\n[signal subscribeNext:^(id x) {\n    NSLog(@\"接收数据\");\n}];\n\n// 3.运行结果，会执行两遍发送请求，也就是每次订阅都会发送一次请求\n```\n\n* RACMulticastConnection:解决重复请求问题\n```\n// 1.创建信号\nRACSignal *signal = [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n    NSLog(@\"发送请求\");\n    [subscriber sendNext:@1];\n    return nil;\n}];\n\n// 2.创建连接\nRACMulticastConnection *connect = [signal publish];\n\n// 3.订阅信号，\n// 注意：订阅信号，也不能激活信号，只是保存订阅者到数组，必须通过连接,当调用连接，就会一次性调用所有订阅者的sendNext:\n[connect.signal subscribeNext:^(id x) {\n    NSLog(@\"订阅者一信号\");\n}];\n\n[connect.signal subscribeNext:^(id x) {\n    NSLog(@\"订阅者二信号\");\n}];\n\n// 4.连接,激活信号\n[connect connect];\n```\n\n### RACScheduler\nRAC中的队列，用GCD封装的。\n\n### RACUnit\n表⽰stream不包含有意义的值,也就是看到这个，可以直接理解为nil.\n\n### RACEvent\n把数据包装成信号事件(signal event)。它主要通过RACSignal的-materialize来使用，然并卵。\n\n## ReactiveCocoa开发中常见用法。\n### 代替代理\nrac_signalForSelector：用于替代代理。\n### 代替KVO\nrac_valuesAndChangesForKeyPath：用于监听某个对象的属性改变。\n### 监听事件\nrac_signalForControlEvents：用于监听某个事件。\n### 代替通知\nrac_addObserverForName:用于监听某个通知。\n### 监听文本框文字改变\nrac_textSignal:只要文本框发出改变就会发出这个信号。\n### 处理当界面有多次请求时，需要都获取到数据时，才能展示界面\nrac_liftSelector:withSignalsFromArray:Signals:当传入的Signals(信号数组)，每一个signal都至少sendNext过一次，就会去触发第一个selector参数的方法。\n使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据。\n代码如下：\n```\n// 1.代替代理\n// 需求：自定义redView,监听红色view中按钮点击\n// 之前都是需要通过代理监听，给红色View添加一个代理属性，点击按钮的时候，通知代理做事情\n// rac_signalForSelector:把调用某个对象的方法的信息转换成信号，就要调用这个方法，就会发送信号。\n// 这里表示只要redV调用btnClick:,就会发出信号，订阅就好了。\n[[redV rac_signalForSelector:@selector(btnClick:)] subscribeNext:^(id x) {\n    NSLog(@\"点击红色按钮\");\n}];\n\n// 2.KVO\n// 把监听redV的center属性改变转换成信号，只要值改变就会发送信号\n// observer:可以传入nil\n[[redV rac_valuesAndChangesForKeyPath:@\"center\" options:NSKeyValueObservingOptionNew observer:nil] subscribeNext:^(id x) {\n    NSLog(@\"%@\",x);\n}];\n\n// 3.监听事件\n// 把按钮点击事件转换为信号，点击按钮，就会发送信号\n[[self.btn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) {\n    NSLog(@\"按钮被点击了\");\n}];\n\n// 4.代替通知\n// 把监听到的通知转换信号\n[[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIKeyboardWillShowNotification object:nil] subscribeNext:^(id x) {\n    NSLog(@\"键盘弹出\");\n}];\n\n// 5.监听文本框的文字改变\n[_textField.rac_textSignal subscribeNext:^(id x) {\n    NSLog(@\"文字改变了%@\",x);\n}];\n\n// 6.处理多个请求，都返回结果的时候，统一做处理.\nRACSignal *request1 = [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n\n// 发送请求1\n[subscriber sendNext:@\"发送请求1\"];\n    return nil;\n}];\n\nRACSignal *request2 = [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n    // 发送请求2\n    [subscriber sendNext:@\"发送请求2\"];\n    return nil;\n}];\n\n// 使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据。\n[self rac_liftSelector:@selector(updateUIWithR1:r2:) withSignalsFromArray:@[request1,request2]];\n}\n// 更新UI\n- (void)updateUIWithR1:(id)data r2:(id)data1\n{\n    NSLog(@\"更新UI%@  %@\",data,data1);\n}\n```\n\n## ReactiveCocoa常见宏\n\n### RAC(TARGET, [KEYPATH, [NIL_VALUE]])\n用于给某个对象的某个属性绑定。\n```\n// 只要文本框文字改变，就会修改label的文字\nRAC(self.labelView,text) = _textField.rac_textSignal;\n```\n\n### RACObserve(self, name)\n监听某个对象的某个属性,返回的是信号。\n```\n[RACObserve(self.view, center) subscribeNext:^(id x) {\n    NSLog(@\"%@\",x);\n}];\n```\n\n### @weakify(Obj)和@strongify(Obj)\n一般两个都是配套使用,在主头文件(ReactiveCocoa.h)中并没有导入，需要自己手动导入，RACEXTScope.h才可以使用。但是每次导入都非常麻烦，只需要在主头文件自己导入就好了。\n\n### RACTuplePack\n把数据包装成RACTuple（元组类）\n```\n// 把参数中的数据包装成元组\nRACTuple *tuple = RACTuplePack(@10,@20);\n```\n\n### RACTupleUnpack：把RACTuple（元组类）解包成对应的数据。\n```\n// 把参数中的数据包装成元组\nRACTuple *tuple = RACTuplePack(@\"abc\",@20);\n\n// 解包元组，会把元组的值，按顺序给参数里面的变量赋值\n// name = @\"abc\" age = @20\nRACTupleUnpack(NSString *name,NSNumber *age) = tuple;\n```\n\n原文链接：[最快让你上手ReactiveCocoa之基础篇](http://www.jianshu.com/p/87ef6720a096#)\n","slug":"RAC学习笔记","published":1,"updated":"2017-07-14T03:57:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj53c1dvn000zh3jj9a4uk7sr","content":"<p>ReactiveCocoa(RAC):是函数响应式编程(Functional Reactive Programming:FRP)框架，高聚合、低耦合思想。<br>使用cocoapods导入时加上<code>use_frameworks!</code></p>\n<h2 id=\"ReactiveCocoa常见类\"><a href=\"#ReactiveCocoa常见类\" class=\"headerlink\" title=\"ReactiveCocoa常见类\"></a>ReactiveCocoa常见类</h2><h3 id=\"RACSiganl-信号类-核心\"><a href=\"#RACSiganl-信号类-核心\" class=\"headerlink\" title=\"RACSiganl:信号类(核心)\"></a>RACSiganl:信号类(核心)</h3><p>一般表示将来有数据传递，只要有数据改变，信号内部接收到数据，就会马上发出数据。</p>\n<h4 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h4><ul>\n<li>信号类(RACSiganl)，只是表示当数据改变时，信号内部会发出数据，它本身不具备发送信号的能力，而是交给内部一个订阅者去发出。<a id=\"more\"></a></li>\n<li>默认一个信号都是冷信号，也就是值改变了，也不会触发，只有订阅了这个信号，这个信号才会变为热信号，值改变了才会触发。</li>\n<li>如何订阅信号：调用信号RACSignal的subscribeNext就能订阅。</li>\n</ul>\n<h4 id=\"RACSiganl简单使用\"><a href=\"#RACSiganl简单使用\" class=\"headerlink\" title=\"RACSiganl简单使用\"></a>RACSiganl简单使用</h4><ul>\n<li><p>1.创建信号 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ + (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe</div></pre></td></tr></table></figure>\n</li>\n<li><p>2.订阅信号,才会激活信号. </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock</div></pre></td></tr></table></figure>\n</li>\n<li><p>3.发送信号 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ - (void)sendNext:(id)value</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"RACSignal底层实现\"><a href=\"#RACSignal底层实现\" class=\"headerlink\" title=\"RACSignal底层实现\"></a>RACSignal底层实现</h4><ul>\n<li>1.创建信号，首先把didSubscribe保存到信号中，还不会触发。</li>\n<li>2.当信号被订阅，也就是调用signal的subscribeNext:nextBlock<ul>\n<li>2.1 subscribeNext内部会创建订阅者subscriber，并且把nextBlock保存到subscriber中。</li>\n<li>2.2 subscribeNext内部会调用signal的didSubscribe</li>\n</ul>\n</li>\n<li>3.siganl的didSubscribe中调用[subscriber sendNext:@1];<ul>\n<li>3.1 sendNext底层其实就是执行subscriber的nextBlock<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 1.创建信号</div><div class=\"line\">RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class=\"line\"></div><div class=\"line\">    // block调用时刻：每当有订阅者订阅信号，就会调用block。</div><div class=\"line\">    // 2.发送信号</div><div class=\"line\">    [subscriber sendNext:@1];</div><div class=\"line\">    // 如果不在发送数据，最好发送信号完成，内部会自动调用[RACDisposable disposable]取消订阅信号。</div><div class=\"line\">    [subscriber sendCompleted];</div><div class=\"line\">    return [RACDisposable disposableWithBlock:^&#123;</div><div class=\"line\">        // block调用时刻：当信号发送完成或者发送错误，就会自动执行这个block,取消订阅信号。</div><div class=\"line\">        // 执行完Block后，当前信号就不在被订阅了。</div><div class=\"line\">        NSLog(@&quot;信号被销毁&quot;);</div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">// 3.订阅信号,才会激活信号.</div><div class=\"line\">[siganl subscribeNext:^(id x) &#123;</div><div class=\"line\">    // block调用时刻：每当有信号发出数据，就会调用block.</div><div class=\"line\">    NSLog(@&quot;接收到数据:%@&quot;,x);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"RACSubscriber\"><a href=\"#RACSubscriber\" class=\"headerlink\" title=\"RACSubscriber\"></a>RACSubscriber</h3><p>表示订阅者的意思，用于发送信号，这是一个协议，不是一个类，只要遵守这个协议，并且实现方法才能成为订阅者。通过create创建的信号，都有一个订阅者，帮助他发送数据。</p>\n<h3 id=\"RACDisposable\"><a href=\"#RACDisposable\" class=\"headerlink\" title=\"RACDisposable\"></a>RACDisposable</h3><ul>\n<li>用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。</li>\n<li>使用场景:不想监听某个信号时，可以通过它主动取消订阅信号。</li>\n</ul>\n<h3 id=\"RACSubject\"><a href=\"#RACSubject\" class=\"headerlink\" title=\"RACSubject\"></a>RACSubject</h3><ul>\n<li>信号提供者，自己可以充当信号，又能发送信号。</li>\n<li>使用场景:通常用来代替代理，有了它，就不必要定义代理了。</li>\n<li>RACSubject:底层实现和RACSignal不一样。<ul>\n<li>1.调用subscribeNext订阅信号，只是把订阅者保存起来，并且订阅者的nextBlock已经赋值了。</li>\n<li>2.调用sendNext发送信号，遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。</li>\n</ul>\n</li>\n<li>RACSubject使用步骤:<ul>\n<li>1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。</li>\n<li>2.订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock</li>\n<li>3.发送信号 sendNext:(id)value<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 1.创建信号</div><div class=\"line\">RACSubject *subject = [RACSubject subject];</div><div class=\"line\"></div><div class=\"line\">// 2.订阅信号</div><div class=\"line\">[subject subscribeNext:^(id x) &#123;</div><div class=\"line\">// block调用时刻：当信号发出新值，就会调用.</div><div class=\"line\">NSLog(@&quot;第一个订阅者%@&quot;,x);</div><div class=\"line\">&#125;];</div><div class=\"line\">[subject subscribeNext:^(id x) &#123;</div><div class=\"line\">// block调用时刻：当信号发出新值，就会调用.</div><div class=\"line\">NSLog(@&quot;第二个订阅者%@&quot;,x);</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">// 3.发送信号</div><div class=\"line\">[subject sendNext:@&quot;1&quot;];</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong><em>RACSubject替换代理</em></strong><br>需求:<br>1.给当前控制器添加一个按钮，modal到另一个控制器界面<br>2.另一个控制器view中有个按钮，点击按钮，通知当前控制器</p>\n<ul>\n<li><p>步骤一：在第二个控制器.h，添加一个RACSubject代替代理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface TwoViewController : UIViewController</div><div class=\"line\">@property (nonatomic, strong) RACSubject *delegateSignal;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n</li>\n<li><p>步骤二：监听第二个控制器按钮点击</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">@implementation TwoViewController</div><div class=\"line\">- (IBAction)notice:(id)sender &#123;</div><div class=\"line\">// 通知第一个控制器，告诉它，按钮被点了</div><div class=\"line\"></div><div class=\"line\">// 通知代理</div><div class=\"line\">// 判断代理信号是否有值</div><div class=\"line\">if (self.delegateSignal) &#123;</div><div class=\"line\">    // 有值，才需要通知</div><div class=\"line\">    [self.delegateSignal sendNext:nil];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n</li>\n<li><p>步骤三：在第一个控制器中，监听跳转按钮，给第二个控制器的代理信号赋值，并且监听.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">@implementation OneViewController </div><div class=\"line\">- (IBAction)btnClick:(id)sender &#123;</div><div class=\"line\">    // 创建第二个控制器</div><div class=\"line\">    TwoViewController *twoVc = [[TwoViewController alloc] init];</div><div class=\"line\">    // 设置代理信号</div><div class=\"line\">    twoVc.delegateSignal = [RACSubject subject];</div><div class=\"line\">    // 订阅代理信号</div><div class=\"line\">    [twoVc.delegateSignal subscribeNext:^(id x) &#123;</div><div class=\"line\">        NSLog(@&quot;点击了通知按钮&quot;);</div><div class=\"line\">    &#125;];</div><div class=\"line\">    // 跳转到第二个控制器</div><div class=\"line\">    [self presentViewController:twoVc animated:YES completion:nil];</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"RACReplaySubject\"><a href=\"#RACReplaySubject\" class=\"headerlink\" title=\"RACReplaySubject\"></a>RACReplaySubject</h3><p>重复提供信号类，是RACSubject的子类。<br>RACReplaySubject与RACSubject区别:</p>\n<ul>\n<li>RACReplaySubject可以先发送信号，在订阅信号，RACSubject就不可以。</li>\n<li>使用场景一:如果一个信号每被订阅一次，就需要把之前的值重复发送一遍，使用重复提供信号类。</li>\n<li>使用场景二:可以设置capacity数量来限制缓存的value的数量,即只缓充最新的几个值。<br>RACReplaySubject:底层实现和RACSubject不一样。</li>\n<li>1.调用sendNext发送信号，把值保存起来，然后遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。</li>\n<li>2.调用subscribeNext订阅信号，遍历保存的所有值，一个一个调用订阅者的nextBlock<br>注意：如果想当一个信号被订阅，就重复播放之前所有值，需要先发送信号，在订阅信号。也就是先保存值，在订阅值。<br>RACReplaySubject使用步骤:</li>\n<li>1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。</li>\n<li>2.可以先订阅信号，也可以先发送信号。<ul>\n<li>2.1 订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock</li>\n<li>2.2 发送信号 sendNext:(id)value<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 1.创建信号</div><div class=\"line\">RACReplaySubject *replaySubject = [RACReplaySubject subject];</div><div class=\"line\"></div><div class=\"line\">// 2.发送信号</div><div class=\"line\">[replaySubject sendNext:@1];</div><div class=\"line\">[replaySubject sendNext:@2];</div><div class=\"line\"></div><div class=\"line\">// 3.订阅信号</div><div class=\"line\">[replaySubject subscribeNext:^(id x) &#123;</div><div class=\"line\">    NSLog(@&quot;第一个订阅者接收到的数据%@&quot;,x);</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">// 订阅信号</div><div class=\"line\">[replaySubject subscribeNext:^(id x) &#123;</div><div class=\"line\">    NSLog(@&quot;第二个订阅者接收到的数据%@&quot;,x);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"RACTuple\"><a href=\"#RACTuple\" class=\"headerlink\" title=\"RACTuple\"></a>RACTuple</h3><p>元组类,类似NSArray,用来包装值.</p>\n<h3 id=\"RACSequence\"><a href=\"#RACSequence\" class=\"headerlink\" title=\"RACSequence\"></a>RACSequence</h3><p>RAC中的集合类，用于代替NSArray,NSDictionary,可以使用它来快速遍历数组和字典。<br>使用场景：字典转模型<br>RACSequence和RACTuple简单使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 1.遍历数组</div><div class=\"line\">NSArray *numbers = @[@1,@2,@3,@4];</div><div class=\"line\"></div><div class=\"line\">// 第一步: 把数组转换成集合RACSequence numbers.rac_sequence</div><div class=\"line\">// 第二步: 把集合RACSequence转换RACSignal信号类,numbers.rac_sequence.signal</div><div class=\"line\">// 第三步: 订阅信号，激活信号，会自动把集合中的所有值，遍历出来。</div><div class=\"line\">[numbers.rac_sequence.signal subscribeNext:^(id x) &#123;</div><div class=\"line\">    NSLog(@&quot;%@&quot;,x);</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">// 2.遍历字典,遍历出来的键值对会包装成RACTuple(元组对象)</div><div class=\"line\">NSDictionary *dict = @&#123;@&quot;name&quot;:@&quot;zs&quot;,@&quot;age&quot;:@18&#125;;</div><div class=\"line\">[dict.rac_sequence.signal subscribeNext:^(RACTuple *x) &#123;</div><div class=\"line\"></div><div class=\"line\">// 解包元组，会把元组的值，按顺序给参数里面的变量赋值</div><div class=\"line\">RACTupleUnpack(NSString *key,NSString *value) = x;</div><div class=\"line\">    // 相当于以下写法</div><div class=\"line\">    // NSString *key = x[0];</div><div class=\"line\">    // NSString *value = x[1];</div><div class=\"line\"></div><div class=\"line\">    NSLog(@&quot;%@ %@&quot;,key,value);</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">// 3.字典转模型</div><div class=\"line\">// 3.1 OC写法</div><div class=\"line\">NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;flags.plist&quot; ofType:nil];</div><div class=\"line\">NSArray *dictArr = [NSArray arrayWithContentsOfFile:filePath];</div><div class=\"line\">NSMutableArray *items = [NSMutableArray array];</div><div class=\"line\">for (NSDictionary *dict in dictArr) &#123;</div><div class=\"line\">    FlagItem *item = [FlagItem flagWithDict:dict];</div><div class=\"line\">    [items addObject:item];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 3.2 RAC写法</div><div class=\"line\">NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;flags.plist&quot; ofType:nil];</div><div class=\"line\">NSArray *dictArr = [NSArray arrayWithContentsOfFile:filePath];</div><div class=\"line\">NSMutableArray *flags = [NSMutableArray array];</div><div class=\"line\">_flags = flags;</div><div class=\"line\">// rac_sequence注意点：调用subscribeNext，并不会马上执行nextBlock，而是会等一会。</div><div class=\"line\">[dictArr.rac_sequence.signal subscribeNext:^(id x) &#123;</div><div class=\"line\">    // 运用RAC遍历字典，x：字典</div><div class=\"line\">    FlagItem *item = [FlagItem flagWithDict:x];</div><div class=\"line\">    [flags addObject:item];</div><div class=\"line\">&#125;];</div><div class=\"line\">NSLog(@&quot;%@&quot;,  NSStringFromCGRect([UIScreen mainScreen].bounds));</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// 3.3 RAC高级写法:</div><div class=\"line\">NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;flags.plist&quot; ofType:nil];</div><div class=\"line\">NSArray *dictArr = [NSArray arrayWithContentsOfFile:filePath];</div><div class=\"line\">// map:映射的意思，目的：把原始值value映射成一个新值</div><div class=\"line\">// array: 把集合转换成数组</div><div class=\"line\">// 底层实现：当信号被订阅，会遍历集合中的原始值，映射成新值，并且保存到新的数组里。</div><div class=\"line\">NSArray *flags = [[dictArr.rac_sequence map:^id(id value) &#123;</div><div class=\"line\">    return [FlagItem flagWithDict:value];</div><div class=\"line\">&#125;] array];</div></pre></td></tr></table></figure></p>\n<h3 id=\"RACCommand\"><a href=\"#RACCommand\" class=\"headerlink\" title=\"RACCommand\"></a>RACCommand</h3><p>RAC中用于处理事件的类，可以把事件如何处理,事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。<br>使用场景:监听按钮点击，网络请求</p>\n<ul>\n<li><p>RACCommand使用步骤:</p>\n<ul>\n<li>1.创建命令 initWithSignalBlock:(RACSignal * (^)(id input))signalBlock</li>\n<li>2.在signalBlock中，创建RACSignal，并且作为signalBlock的返回值</li>\n<li>3.执行命令 - (RACSignal *)execute:(id)input</li>\n</ul>\n</li>\n<li><p>RACCommand使用注意</p>\n<ul>\n<li>1.signalBlock必须要返回一个信号，不能传nil.</li>\n<li>2.如果不想要传递信号，直接创建空的信号[RACSignal empty];</li>\n<li>3.RACCommand中信号如果数据传递完，必须调用[subscriber sendCompleted]，这时命令才会执行完毕，否则永远处于执行中。</li>\n<li>4.RACCommand需要被强引用，否则接收不到RACCommand中的信号，因此RACCommand中的信号是延迟发送的。</li>\n</ul>\n</li>\n<li><p>RACCommand设计思想：内部signalBlock为什么要返回一个信号，这个信号有什么用。</p>\n<ul>\n<li>1.在RAC开发中，通常会把网络请求封装到RACCommand，直接执行某个RACCommand就能发送请求。</li>\n<li>2.当RACCommand内部请求到数据的时候，需要把请求的数据传递给外界，这时候就需要通过signalBlock返回的信号传递了。</li>\n</ul>\n</li>\n<li><p>如何拿到RACCommand中返回信号发出的数据。</p>\n<ul>\n<li>1.RACCommand有个执行信号源executionSignals，这个是signal of signals(信号的信号),意思是信号发出的数据是信号，不是普通的类型。</li>\n<li>2.订阅executionSignals就能拿到RACCommand中返回的信号，然后订阅signalBlock返回的信号，就能获取发出的值。</li>\n</ul>\n</li>\n<li><p>五、监听当前命令是否正在执行executing</p>\n</li>\n<li><p>六、使用场景,监听按钮点击，网络请求</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 1.创建命令</div><div class=\"line\">RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) &#123;</div><div class=\"line\">    NSLog(@&quot;执行命令&quot;);</div><div class=\"line\">    // 创建空信号,必须返回信号</div><div class=\"line\">    // return [RACSignal empty];</div><div class=\"line\"></div><div class=\"line\">    // 2.创建信号,用来传递数据</div><div class=\"line\">    return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class=\"line\">        [subscriber sendNext:@&quot;请求数据&quot;];</div><div class=\"line\">        // 注意：数据传递完，最好调用sendCompleted，这时命令才执行完毕。</div><div class=\"line\">        [subscriber sendCompleted];</div><div class=\"line\">        return nil;</div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">// 强引用命令，不要被销毁，否则接收不到数据</div><div class=\"line\">_conmmand = command;</div><div class=\"line\"></div><div class=\"line\">// 3.订阅RACCommand中的信号</div><div class=\"line\">[command.executionSignals subscribeNext:^(id x) &#123;</div><div class=\"line\">    [x subscribeNext:^(id x) &#123;</div><div class=\"line\">    NSLog(@&quot;%@&quot;,x);</div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">// RAC高级用法</div><div class=\"line\">// switchToLatest:用于signal of signals，获取signal of signals发出的最新信号,也就是可以直接拿到RACCommand中的信号</div><div class=\"line\">[command.executionSignals.switchToLatest subscribeNext:^(id x) &#123;</div><div class=\"line\">    NSLog(@&quot;%@&quot;,x);</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">// 4.监听命令是否执行完毕,默认会来一次，可以直接跳过，skip表示跳过第一次信号。</div><div class=\"line\">[[command.executing skip:1] subscribeNext:^(id x) &#123;</div><div class=\"line\"></div><div class=\"line\">    if ([x boolValue] == YES) &#123;</div><div class=\"line\">    // 正在执行</div><div class=\"line\">    NSLog(@&quot;正在执行&quot;);</div><div class=\"line\">    &#125;else&#123;</div><div class=\"line\">    // 执行完成</div><div class=\"line\">    NSLog(@&quot;执行完成&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">// 5.执行命令</div><div class=\"line\">[self.conmmand execute:@1];</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"RACMulticastConnection\"><a href=\"#RACMulticastConnection\" class=\"headerlink\" title=\"RACMulticastConnection\"></a>RACMulticastConnection</h3><p>用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。<br>注意:RACMulticastConnection通过RACSignal的-publish或者-muticast:方法创建.</p>\n<ul>\n<li><p>RACMulticastConnection使用步骤:</p>\n<ul>\n<li>1.创建信号 + (RACSignal <em>)createSignal:(RACDisposable </em> (^)(id<racsubscriber> subscriber))didSubscribe</racsubscriber></li>\n<li>2.创建连接 RACMulticastConnection *connect = [signal publish];</li>\n<li>3.订阅信号,注意：订阅的不在是之前的信号，而是连接的信号。 [connect.signal subscribeNext:nextBlock]</li>\n<li>4.连接 [connect connect]</li>\n</ul>\n</li>\n<li><p>RACMulticastConnection底层原理:</p>\n<ul>\n<li>1.创建connect，connect.sourceSignal -&gt; RACSignal(原始信号)  connect.signal -&gt; RACSubject</li>\n<li>2.订阅connect.signal，会调用RACSubject的subscribeNext，创建订阅者，而且把订阅者保存起来，不会执行block。</li>\n<li>3.[connect connect]内部会订阅RACSignal(原始信号)，并且订阅者是RACSubject<ul>\n<li>3.1.订阅原始信号，就会调用原始信号中的didSubscribe</li>\n<li>3.2 didSubscribe，拿到订阅者调用sendNext，其实是调用RACSubject的sendNext</li>\n</ul>\n</li>\n<li>4.RACSubject的sendNext,会遍历RACSubject所有订阅者发送信号。<ul>\n<li>4.1 因为刚刚第二步，都是在订阅RACSubject，因此会拿到第二步所有的订阅者，调用他们的nextBlock</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>需求：假设在一个信号中发送请求，每次订阅一次都会发送请求，这样就会导致多次请求。<br>解决：使用RACMulticastConnection就能解决.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 1.创建请求信号</div><div class=\"line\">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class=\"line\">    NSLog(@&quot;发送请求&quot;);</div><div class=\"line\">    return nil;</div><div class=\"line\">&#125;];</div><div class=\"line\">// 2.订阅信号</div><div class=\"line\">[signal subscribeNext:^(id x) &#123;</div><div class=\"line\">    NSLog(@&quot;接收数据&quot;);</div><div class=\"line\">&#125;];</div><div class=\"line\">// 2.订阅信号</div><div class=\"line\">[signal subscribeNext:^(id x) &#123;</div><div class=\"line\">    NSLog(@&quot;接收数据&quot;);</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">// 3.运行结果，会执行两遍发送请求，也就是每次订阅都会发送一次请求</div></pre></td></tr></table></figure>\n</li>\n<li><p>RACMulticastConnection:解决重复请求问题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 1.创建信号</div><div class=\"line\">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class=\"line\">    NSLog(@&quot;发送请求&quot;);</div><div class=\"line\">    [subscriber sendNext:@1];</div><div class=\"line\">    return nil;</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">// 2.创建连接</div><div class=\"line\">RACMulticastConnection *connect = [signal publish];</div><div class=\"line\"></div><div class=\"line\">// 3.订阅信号，</div><div class=\"line\">// 注意：订阅信号，也不能激活信号，只是保存订阅者到数组，必须通过连接,当调用连接，就会一次性调用所有订阅者的sendNext:</div><div class=\"line\">[connect.signal subscribeNext:^(id x) &#123;</div><div class=\"line\">    NSLog(@&quot;订阅者一信号&quot;);</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">[connect.signal subscribeNext:^(id x) &#123;</div><div class=\"line\">    NSLog(@&quot;订阅者二信号&quot;);</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">// 4.连接,激活信号</div><div class=\"line\">[connect connect];</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"RACScheduler\"><a href=\"#RACScheduler\" class=\"headerlink\" title=\"RACScheduler\"></a>RACScheduler</h3><p>RAC中的队列，用GCD封装的。</p>\n<h3 id=\"RACUnit\"><a href=\"#RACUnit\" class=\"headerlink\" title=\"RACUnit\"></a>RACUnit</h3><p>表⽰stream不包含有意义的值,也就是看到这个，可以直接理解为nil.</p>\n<h3 id=\"RACEvent\"><a href=\"#RACEvent\" class=\"headerlink\" title=\"RACEvent\"></a>RACEvent</h3><p>把数据包装成信号事件(signal event)。它主要通过RACSignal的-materialize来使用，然并卵。</p>\n<h2 id=\"ReactiveCocoa开发中常见用法。\"><a href=\"#ReactiveCocoa开发中常见用法。\" class=\"headerlink\" title=\"ReactiveCocoa开发中常见用法。\"></a>ReactiveCocoa开发中常见用法。</h2><h3 id=\"代替代理\"><a href=\"#代替代理\" class=\"headerlink\" title=\"代替代理\"></a>代替代理</h3><p>rac_signalForSelector：用于替代代理。</p>\n<h3 id=\"代替KVO\"><a href=\"#代替KVO\" class=\"headerlink\" title=\"代替KVO\"></a>代替KVO</h3><p>rac_valuesAndChangesForKeyPath：用于监听某个对象的属性改变。</p>\n<h3 id=\"监听事件\"><a href=\"#监听事件\" class=\"headerlink\" title=\"监听事件\"></a>监听事件</h3><p>rac_signalForControlEvents：用于监听某个事件。</p>\n<h3 id=\"代替通知\"><a href=\"#代替通知\" class=\"headerlink\" title=\"代替通知\"></a>代替通知</h3><p>rac_addObserverForName:用于监听某个通知。</p>\n<h3 id=\"监听文本框文字改变\"><a href=\"#监听文本框文字改变\" class=\"headerlink\" title=\"监听文本框文字改变\"></a>监听文本框文字改变</h3><p>rac_textSignal:只要文本框发出改变就会发出这个信号。</p>\n<h3 id=\"处理当界面有多次请求时，需要都获取到数据时，才能展示界面\"><a href=\"#处理当界面有多次请求时，需要都获取到数据时，才能展示界面\" class=\"headerlink\" title=\"处理当界面有多次请求时，需要都获取到数据时，才能展示界面\"></a>处理当界面有多次请求时，需要都获取到数据时，才能展示界面</h3><p>rac_liftSelector:withSignalsFromArray:Signals:当传入的Signals(信号数组)，每一个signal都至少sendNext过一次，就会去触发第一个selector参数的方法。<br>使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据。<br>代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 1.代替代理</div><div class=\"line\">// 需求：自定义redView,监听红色view中按钮点击</div><div class=\"line\">// 之前都是需要通过代理监听，给红色View添加一个代理属性，点击按钮的时候，通知代理做事情</div><div class=\"line\">// rac_signalForSelector:把调用某个对象的方法的信息转换成信号，就要调用这个方法，就会发送信号。</div><div class=\"line\">// 这里表示只要redV调用btnClick:,就会发出信号，订阅就好了。</div><div class=\"line\">[[redV rac_signalForSelector:@selector(btnClick:)] subscribeNext:^(id x) &#123;</div><div class=\"line\">    NSLog(@&quot;点击红色按钮&quot;);</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">// 2.KVO</div><div class=\"line\">// 把监听redV的center属性改变转换成信号，只要值改变就会发送信号</div><div class=\"line\">// observer:可以传入nil</div><div class=\"line\">[[redV rac_valuesAndChangesForKeyPath:@&quot;center&quot; options:NSKeyValueObservingOptionNew observer:nil] subscribeNext:^(id x) &#123;</div><div class=\"line\">    NSLog(@&quot;%@&quot;,x);</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">// 3.监听事件</div><div class=\"line\">// 把按钮点击事件转换为信号，点击按钮，就会发送信号</div><div class=\"line\">[[self.btn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) &#123;</div><div class=\"line\">    NSLog(@&quot;按钮被点击了&quot;);</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">// 4.代替通知</div><div class=\"line\">// 把监听到的通知转换信号</div><div class=\"line\">[[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIKeyboardWillShowNotification object:nil] subscribeNext:^(id x) &#123;</div><div class=\"line\">    NSLog(@&quot;键盘弹出&quot;);</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">// 5.监听文本框的文字改变</div><div class=\"line\">[_textField.rac_textSignal subscribeNext:^(id x) &#123;</div><div class=\"line\">    NSLog(@&quot;文字改变了%@&quot;,x);</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">// 6.处理多个请求，都返回结果的时候，统一做处理.</div><div class=\"line\">RACSignal *request1 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class=\"line\"></div><div class=\"line\">// 发送请求1</div><div class=\"line\">[subscriber sendNext:@&quot;发送请求1&quot;];</div><div class=\"line\">    return nil;</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">RACSignal *request2 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class=\"line\">    // 发送请求2</div><div class=\"line\">    [subscriber sendNext:@&quot;发送请求2&quot;];</div><div class=\"line\">    return nil;</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">// 使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据。</div><div class=\"line\">[self rac_liftSelector:@selector(updateUIWithR1:r2:) withSignalsFromArray:@[request1,request2]];</div><div class=\"line\">&#125;</div><div class=\"line\">// 更新UI</div><div class=\"line\">- (void)updateUIWithR1:(id)data r2:(id)data1</div><div class=\"line\">&#123;</div><div class=\"line\">    NSLog(@&quot;更新UI%@  %@&quot;,data,data1);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"ReactiveCocoa常见宏\"><a href=\"#ReactiveCocoa常见宏\" class=\"headerlink\" title=\"ReactiveCocoa常见宏\"></a>ReactiveCocoa常见宏</h2><h3 id=\"RAC-TARGET-KEYPATH-NIL-VALUE\"><a href=\"#RAC-TARGET-KEYPATH-NIL-VALUE\" class=\"headerlink\" title=\"RAC(TARGET, [KEYPATH, [NIL_VALUE]])\"></a>RAC(TARGET, [KEYPATH, [NIL_VALUE]])</h3><p>用于给某个对象的某个属性绑定。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 只要文本框文字改变，就会修改label的文字</div><div class=\"line\">RAC(self.labelView,text) = _textField.rac_textSignal;</div></pre></td></tr></table></figure></p>\n<h3 id=\"RACObserve-self-name\"><a href=\"#RACObserve-self-name\" class=\"headerlink\" title=\"RACObserve(self, name)\"></a>RACObserve(self, name)</h3><p>监听某个对象的某个属性,返回的是信号。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[RACObserve(self.view, center) subscribeNext:^(id x) &#123;</div><div class=\"line\">    NSLog(@&quot;%@&quot;,x);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<h3 id=\"weakify-Obj-和-strongify-Obj\"><a href=\"#weakify-Obj-和-strongify-Obj\" class=\"headerlink\" title=\"@weakify(Obj)和@strongify(Obj)\"></a>@weakify(Obj)和@strongify(Obj)</h3><p>一般两个都是配套使用,在主头文件(ReactiveCocoa.h)中并没有导入，需要自己手动导入，RACEXTScope.h才可以使用。但是每次导入都非常麻烦，只需要在主头文件自己导入就好了。</p>\n<h3 id=\"RACTuplePack\"><a href=\"#RACTuplePack\" class=\"headerlink\" title=\"RACTuplePack\"></a>RACTuplePack</h3><p>把数据包装成RACTuple（元组类）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 把参数中的数据包装成元组</div><div class=\"line\">RACTuple *tuple = RACTuplePack(@10,@20);</div></pre></td></tr></table></figure></p>\n<h3 id=\"RACTupleUnpack：把RACTuple（元组类）解包成对应的数据。\"><a href=\"#RACTupleUnpack：把RACTuple（元组类）解包成对应的数据。\" class=\"headerlink\" title=\"RACTupleUnpack：把RACTuple（元组类）解包成对应的数据。\"></a>RACTupleUnpack：把RACTuple（元组类）解包成对应的数据。</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 把参数中的数据包装成元组</div><div class=\"line\">RACTuple *tuple = RACTuplePack(@&quot;abc&quot;,@20);</div><div class=\"line\"></div><div class=\"line\">// 解包元组，会把元组的值，按顺序给参数里面的变量赋值</div><div class=\"line\">// name = @&quot;abc&quot; age = @20</div><div class=\"line\">RACTupleUnpack(NSString *name,NSNumber *age) = tuple;</div></pre></td></tr></table></figure>\n<p>原文链接：<a href=\"http://www.jianshu.com/p/87ef6720a096#\" target=\"_blank\" rel=\"external\">最快让你上手ReactiveCocoa之基础篇</a></p>\n","site":{"data":{}},"excerpt":"<p>ReactiveCocoa(RAC):是函数响应式编程(Functional Reactive Programming:FRP)框架，高聚合、低耦合思想。<br>使用cocoapods导入时加上<code>use_frameworks!</code></p>\n<h2 id=\"ReactiveCocoa常见类\"><a href=\"#ReactiveCocoa常见类\" class=\"headerlink\" title=\"ReactiveCocoa常见类\"></a>ReactiveCocoa常见类</h2><h3 id=\"RACSiganl-信号类-核心\"><a href=\"#RACSiganl-信号类-核心\" class=\"headerlink\" title=\"RACSiganl:信号类(核心)\"></a>RACSiganl:信号类(核心)</h3><p>一般表示将来有数据传递，只要有数据改变，信号内部接收到数据，就会马上发出数据。</p>\n<h4 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h4><ul>\n<li>信号类(RACSiganl)，只是表示当数据改变时，信号内部会发出数据，它本身不具备发送信号的能力，而是交给内部一个订阅者去发出。","more":"</li>\n<li>默认一个信号都是冷信号，也就是值改变了，也不会触发，只有订阅了这个信号，这个信号才会变为热信号，值改变了才会触发。</li>\n<li>如何订阅信号：调用信号RACSignal的subscribeNext就能订阅。</li>\n</ul>\n<h4 id=\"RACSiganl简单使用\"><a href=\"#RACSiganl简单使用\" class=\"headerlink\" title=\"RACSiganl简单使用\"></a>RACSiganl简单使用</h4><ul>\n<li><p>1.创建信号 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ + (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe</div></pre></td></tr></table></figure>\n</li>\n<li><p>2.订阅信号,才会激活信号. </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock</div></pre></td></tr></table></figure>\n</li>\n<li><p>3.发送信号 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ - (void)sendNext:(id)value</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"RACSignal底层实现\"><a href=\"#RACSignal底层实现\" class=\"headerlink\" title=\"RACSignal底层实现\"></a>RACSignal底层实现</h4><ul>\n<li>1.创建信号，首先把didSubscribe保存到信号中，还不会触发。</li>\n<li>2.当信号被订阅，也就是调用signal的subscribeNext:nextBlock<ul>\n<li>2.1 subscribeNext内部会创建订阅者subscriber，并且把nextBlock保存到subscriber中。</li>\n<li>2.2 subscribeNext内部会调用signal的didSubscribe</li>\n</ul>\n</li>\n<li>3.siganl的didSubscribe中调用[subscriber sendNext:@1];<ul>\n<li>3.1 sendNext底层其实就是执行subscriber的nextBlock<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 1.创建信号</div><div class=\"line\">RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class=\"line\"></div><div class=\"line\">    // block调用时刻：每当有订阅者订阅信号，就会调用block。</div><div class=\"line\">    // 2.发送信号</div><div class=\"line\">    [subscriber sendNext:@1];</div><div class=\"line\">    // 如果不在发送数据，最好发送信号完成，内部会自动调用[RACDisposable disposable]取消订阅信号。</div><div class=\"line\">    [subscriber sendCompleted];</div><div class=\"line\">    return [RACDisposable disposableWithBlock:^&#123;</div><div class=\"line\">        // block调用时刻：当信号发送完成或者发送错误，就会自动执行这个block,取消订阅信号。</div><div class=\"line\">        // 执行完Block后，当前信号就不在被订阅了。</div><div class=\"line\">        NSLog(@&quot;信号被销毁&quot;);</div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">// 3.订阅信号,才会激活信号.</div><div class=\"line\">[siganl subscribeNext:^(id x) &#123;</div><div class=\"line\">    // block调用时刻：每当有信号发出数据，就会调用block.</div><div class=\"line\">    NSLog(@&quot;接收到数据:%@&quot;,x);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"RACSubscriber\"><a href=\"#RACSubscriber\" class=\"headerlink\" title=\"RACSubscriber\"></a>RACSubscriber</h3><p>表示订阅者的意思，用于发送信号，这是一个协议，不是一个类，只要遵守这个协议，并且实现方法才能成为订阅者。通过create创建的信号，都有一个订阅者，帮助他发送数据。</p>\n<h3 id=\"RACDisposable\"><a href=\"#RACDisposable\" class=\"headerlink\" title=\"RACDisposable\"></a>RACDisposable</h3><ul>\n<li>用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。</li>\n<li>使用场景:不想监听某个信号时，可以通过它主动取消订阅信号。</li>\n</ul>\n<h3 id=\"RACSubject\"><a href=\"#RACSubject\" class=\"headerlink\" title=\"RACSubject\"></a>RACSubject</h3><ul>\n<li>信号提供者，自己可以充当信号，又能发送信号。</li>\n<li>使用场景:通常用来代替代理，有了它，就不必要定义代理了。</li>\n<li>RACSubject:底层实现和RACSignal不一样。<ul>\n<li>1.调用subscribeNext订阅信号，只是把订阅者保存起来，并且订阅者的nextBlock已经赋值了。</li>\n<li>2.调用sendNext发送信号，遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。</li>\n</ul>\n</li>\n<li>RACSubject使用步骤:<ul>\n<li>1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。</li>\n<li>2.订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock</li>\n<li>3.发送信号 sendNext:(id)value<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 1.创建信号</div><div class=\"line\">RACSubject *subject = [RACSubject subject];</div><div class=\"line\"></div><div class=\"line\">// 2.订阅信号</div><div class=\"line\">[subject subscribeNext:^(id x) &#123;</div><div class=\"line\">// block调用时刻：当信号发出新值，就会调用.</div><div class=\"line\">NSLog(@&quot;第一个订阅者%@&quot;,x);</div><div class=\"line\">&#125;];</div><div class=\"line\">[subject subscribeNext:^(id x) &#123;</div><div class=\"line\">// block调用时刻：当信号发出新值，就会调用.</div><div class=\"line\">NSLog(@&quot;第二个订阅者%@&quot;,x);</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">// 3.发送信号</div><div class=\"line\">[subject sendNext:@&quot;1&quot;];</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong><em>RACSubject替换代理</em></strong><br>需求:<br>1.给当前控制器添加一个按钮，modal到另一个控制器界面<br>2.另一个控制器view中有个按钮，点击按钮，通知当前控制器</p>\n<ul>\n<li><p>步骤一：在第二个控制器.h，添加一个RACSubject代替代理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface TwoViewController : UIViewController</div><div class=\"line\">@property (nonatomic, strong) RACSubject *delegateSignal;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n</li>\n<li><p>步骤二：监听第二个控制器按钮点击</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">@implementation TwoViewController</div><div class=\"line\">- (IBAction)notice:(id)sender &#123;</div><div class=\"line\">// 通知第一个控制器，告诉它，按钮被点了</div><div class=\"line\"></div><div class=\"line\">// 通知代理</div><div class=\"line\">// 判断代理信号是否有值</div><div class=\"line\">if (self.delegateSignal) &#123;</div><div class=\"line\">    // 有值，才需要通知</div><div class=\"line\">    [self.delegateSignal sendNext:nil];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n</li>\n<li><p>步骤三：在第一个控制器中，监听跳转按钮，给第二个控制器的代理信号赋值，并且监听.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">@implementation OneViewController </div><div class=\"line\">- (IBAction)btnClick:(id)sender &#123;</div><div class=\"line\">    // 创建第二个控制器</div><div class=\"line\">    TwoViewController *twoVc = [[TwoViewController alloc] init];</div><div class=\"line\">    // 设置代理信号</div><div class=\"line\">    twoVc.delegateSignal = [RACSubject subject];</div><div class=\"line\">    // 订阅代理信号</div><div class=\"line\">    [twoVc.delegateSignal subscribeNext:^(id x) &#123;</div><div class=\"line\">        NSLog(@&quot;点击了通知按钮&quot;);</div><div class=\"line\">    &#125;];</div><div class=\"line\">    // 跳转到第二个控制器</div><div class=\"line\">    [self presentViewController:twoVc animated:YES completion:nil];</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"RACReplaySubject\"><a href=\"#RACReplaySubject\" class=\"headerlink\" title=\"RACReplaySubject\"></a>RACReplaySubject</h3><p>重复提供信号类，是RACSubject的子类。<br>RACReplaySubject与RACSubject区别:</p>\n<ul>\n<li>RACReplaySubject可以先发送信号，在订阅信号，RACSubject就不可以。</li>\n<li>使用场景一:如果一个信号每被订阅一次，就需要把之前的值重复发送一遍，使用重复提供信号类。</li>\n<li>使用场景二:可以设置capacity数量来限制缓存的value的数量,即只缓充最新的几个值。<br>RACReplaySubject:底层实现和RACSubject不一样。</li>\n<li>1.调用sendNext发送信号，把值保存起来，然后遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。</li>\n<li>2.调用subscribeNext订阅信号，遍历保存的所有值，一个一个调用订阅者的nextBlock<br>注意：如果想当一个信号被订阅，就重复播放之前所有值，需要先发送信号，在订阅信号。也就是先保存值，在订阅值。<br>RACReplaySubject使用步骤:</li>\n<li>1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。</li>\n<li>2.可以先订阅信号，也可以先发送信号。<ul>\n<li>2.1 订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock</li>\n<li>2.2 发送信号 sendNext:(id)value<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 1.创建信号</div><div class=\"line\">RACReplaySubject *replaySubject = [RACReplaySubject subject];</div><div class=\"line\"></div><div class=\"line\">// 2.发送信号</div><div class=\"line\">[replaySubject sendNext:@1];</div><div class=\"line\">[replaySubject sendNext:@2];</div><div class=\"line\"></div><div class=\"line\">// 3.订阅信号</div><div class=\"line\">[replaySubject subscribeNext:^(id x) &#123;</div><div class=\"line\">    NSLog(@&quot;第一个订阅者接收到的数据%@&quot;,x);</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">// 订阅信号</div><div class=\"line\">[replaySubject subscribeNext:^(id x) &#123;</div><div class=\"line\">    NSLog(@&quot;第二个订阅者接收到的数据%@&quot;,x);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"RACTuple\"><a href=\"#RACTuple\" class=\"headerlink\" title=\"RACTuple\"></a>RACTuple</h3><p>元组类,类似NSArray,用来包装值.</p>\n<h3 id=\"RACSequence\"><a href=\"#RACSequence\" class=\"headerlink\" title=\"RACSequence\"></a>RACSequence</h3><p>RAC中的集合类，用于代替NSArray,NSDictionary,可以使用它来快速遍历数组和字典。<br>使用场景：字典转模型<br>RACSequence和RACTuple简单使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 1.遍历数组</div><div class=\"line\">NSArray *numbers = @[@1,@2,@3,@4];</div><div class=\"line\"></div><div class=\"line\">// 第一步: 把数组转换成集合RACSequence numbers.rac_sequence</div><div class=\"line\">// 第二步: 把集合RACSequence转换RACSignal信号类,numbers.rac_sequence.signal</div><div class=\"line\">// 第三步: 订阅信号，激活信号，会自动把集合中的所有值，遍历出来。</div><div class=\"line\">[numbers.rac_sequence.signal subscribeNext:^(id x) &#123;</div><div class=\"line\">    NSLog(@&quot;%@&quot;,x);</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">// 2.遍历字典,遍历出来的键值对会包装成RACTuple(元组对象)</div><div class=\"line\">NSDictionary *dict = @&#123;@&quot;name&quot;:@&quot;zs&quot;,@&quot;age&quot;:@18&#125;;</div><div class=\"line\">[dict.rac_sequence.signal subscribeNext:^(RACTuple *x) &#123;</div><div class=\"line\"></div><div class=\"line\">// 解包元组，会把元组的值，按顺序给参数里面的变量赋值</div><div class=\"line\">RACTupleUnpack(NSString *key,NSString *value) = x;</div><div class=\"line\">    // 相当于以下写法</div><div class=\"line\">    // NSString *key = x[0];</div><div class=\"line\">    // NSString *value = x[1];</div><div class=\"line\"></div><div class=\"line\">    NSLog(@&quot;%@ %@&quot;,key,value);</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">// 3.字典转模型</div><div class=\"line\">// 3.1 OC写法</div><div class=\"line\">NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;flags.plist&quot; ofType:nil];</div><div class=\"line\">NSArray *dictArr = [NSArray arrayWithContentsOfFile:filePath];</div><div class=\"line\">NSMutableArray *items = [NSMutableArray array];</div><div class=\"line\">for (NSDictionary *dict in dictArr) &#123;</div><div class=\"line\">    FlagItem *item = [FlagItem flagWithDict:dict];</div><div class=\"line\">    [items addObject:item];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 3.2 RAC写法</div><div class=\"line\">NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;flags.plist&quot; ofType:nil];</div><div class=\"line\">NSArray *dictArr = [NSArray arrayWithContentsOfFile:filePath];</div><div class=\"line\">NSMutableArray *flags = [NSMutableArray array];</div><div class=\"line\">_flags = flags;</div><div class=\"line\">// rac_sequence注意点：调用subscribeNext，并不会马上执行nextBlock，而是会等一会。</div><div class=\"line\">[dictArr.rac_sequence.signal subscribeNext:^(id x) &#123;</div><div class=\"line\">    // 运用RAC遍历字典，x：字典</div><div class=\"line\">    FlagItem *item = [FlagItem flagWithDict:x];</div><div class=\"line\">    [flags addObject:item];</div><div class=\"line\">&#125;];</div><div class=\"line\">NSLog(@&quot;%@&quot;,  NSStringFromCGRect([UIScreen mainScreen].bounds));</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// 3.3 RAC高级写法:</div><div class=\"line\">NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;flags.plist&quot; ofType:nil];</div><div class=\"line\">NSArray *dictArr = [NSArray arrayWithContentsOfFile:filePath];</div><div class=\"line\">// map:映射的意思，目的：把原始值value映射成一个新值</div><div class=\"line\">// array: 把集合转换成数组</div><div class=\"line\">// 底层实现：当信号被订阅，会遍历集合中的原始值，映射成新值，并且保存到新的数组里。</div><div class=\"line\">NSArray *flags = [[dictArr.rac_sequence map:^id(id value) &#123;</div><div class=\"line\">    return [FlagItem flagWithDict:value];</div><div class=\"line\">&#125;] array];</div></pre></td></tr></table></figure></p>\n<h3 id=\"RACCommand\"><a href=\"#RACCommand\" class=\"headerlink\" title=\"RACCommand\"></a>RACCommand</h3><p>RAC中用于处理事件的类，可以把事件如何处理,事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。<br>使用场景:监听按钮点击，网络请求</p>\n<ul>\n<li><p>RACCommand使用步骤:</p>\n<ul>\n<li>1.创建命令 initWithSignalBlock:(RACSignal * (^)(id input))signalBlock</li>\n<li>2.在signalBlock中，创建RACSignal，并且作为signalBlock的返回值</li>\n<li>3.执行命令 - (RACSignal *)execute:(id)input</li>\n</ul>\n</li>\n<li><p>RACCommand使用注意</p>\n<ul>\n<li>1.signalBlock必须要返回一个信号，不能传nil.</li>\n<li>2.如果不想要传递信号，直接创建空的信号[RACSignal empty];</li>\n<li>3.RACCommand中信号如果数据传递完，必须调用[subscriber sendCompleted]，这时命令才会执行完毕，否则永远处于执行中。</li>\n<li>4.RACCommand需要被强引用，否则接收不到RACCommand中的信号，因此RACCommand中的信号是延迟发送的。</li>\n</ul>\n</li>\n<li><p>RACCommand设计思想：内部signalBlock为什么要返回一个信号，这个信号有什么用。</p>\n<ul>\n<li>1.在RAC开发中，通常会把网络请求封装到RACCommand，直接执行某个RACCommand就能发送请求。</li>\n<li>2.当RACCommand内部请求到数据的时候，需要把请求的数据传递给外界，这时候就需要通过signalBlock返回的信号传递了。</li>\n</ul>\n</li>\n<li><p>如何拿到RACCommand中返回信号发出的数据。</p>\n<ul>\n<li>1.RACCommand有个执行信号源executionSignals，这个是signal of signals(信号的信号),意思是信号发出的数据是信号，不是普通的类型。</li>\n<li>2.订阅executionSignals就能拿到RACCommand中返回的信号，然后订阅signalBlock返回的信号，就能获取发出的值。</li>\n</ul>\n</li>\n<li><p>五、监听当前命令是否正在执行executing</p>\n</li>\n<li><p>六、使用场景,监听按钮点击，网络请求</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 1.创建命令</div><div class=\"line\">RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) &#123;</div><div class=\"line\">    NSLog(@&quot;执行命令&quot;);</div><div class=\"line\">    // 创建空信号,必须返回信号</div><div class=\"line\">    // return [RACSignal empty];</div><div class=\"line\"></div><div class=\"line\">    // 2.创建信号,用来传递数据</div><div class=\"line\">    return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class=\"line\">        [subscriber sendNext:@&quot;请求数据&quot;];</div><div class=\"line\">        // 注意：数据传递完，最好调用sendCompleted，这时命令才执行完毕。</div><div class=\"line\">        [subscriber sendCompleted];</div><div class=\"line\">        return nil;</div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">// 强引用命令，不要被销毁，否则接收不到数据</div><div class=\"line\">_conmmand = command;</div><div class=\"line\"></div><div class=\"line\">// 3.订阅RACCommand中的信号</div><div class=\"line\">[command.executionSignals subscribeNext:^(id x) &#123;</div><div class=\"line\">    [x subscribeNext:^(id x) &#123;</div><div class=\"line\">    NSLog(@&quot;%@&quot;,x);</div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">// RAC高级用法</div><div class=\"line\">// switchToLatest:用于signal of signals，获取signal of signals发出的最新信号,也就是可以直接拿到RACCommand中的信号</div><div class=\"line\">[command.executionSignals.switchToLatest subscribeNext:^(id x) &#123;</div><div class=\"line\">    NSLog(@&quot;%@&quot;,x);</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">// 4.监听命令是否执行完毕,默认会来一次，可以直接跳过，skip表示跳过第一次信号。</div><div class=\"line\">[[command.executing skip:1] subscribeNext:^(id x) &#123;</div><div class=\"line\"></div><div class=\"line\">    if ([x boolValue] == YES) &#123;</div><div class=\"line\">    // 正在执行</div><div class=\"line\">    NSLog(@&quot;正在执行&quot;);</div><div class=\"line\">    &#125;else&#123;</div><div class=\"line\">    // 执行完成</div><div class=\"line\">    NSLog(@&quot;执行完成&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">// 5.执行命令</div><div class=\"line\">[self.conmmand execute:@1];</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"RACMulticastConnection\"><a href=\"#RACMulticastConnection\" class=\"headerlink\" title=\"RACMulticastConnection\"></a>RACMulticastConnection</h3><p>用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。<br>注意:RACMulticastConnection通过RACSignal的-publish或者-muticast:方法创建.</p>\n<ul>\n<li><p>RACMulticastConnection使用步骤:</p>\n<ul>\n<li>1.创建信号 + (RACSignal <em>)createSignal:(RACDisposable </em> (^)(id<racsubscriber> subscriber))didSubscribe</racsubscriber></li>\n<li>2.创建连接 RACMulticastConnection *connect = [signal publish];</li>\n<li>3.订阅信号,注意：订阅的不在是之前的信号，而是连接的信号。 [connect.signal subscribeNext:nextBlock]</li>\n<li>4.连接 [connect connect]</li>\n</ul>\n</li>\n<li><p>RACMulticastConnection底层原理:</p>\n<ul>\n<li>1.创建connect，connect.sourceSignal -&gt; RACSignal(原始信号)  connect.signal -&gt; RACSubject</li>\n<li>2.订阅connect.signal，会调用RACSubject的subscribeNext，创建订阅者，而且把订阅者保存起来，不会执行block。</li>\n<li>3.[connect connect]内部会订阅RACSignal(原始信号)，并且订阅者是RACSubject<ul>\n<li>3.1.订阅原始信号，就会调用原始信号中的didSubscribe</li>\n<li>3.2 didSubscribe，拿到订阅者调用sendNext，其实是调用RACSubject的sendNext</li>\n</ul>\n</li>\n<li>4.RACSubject的sendNext,会遍历RACSubject所有订阅者发送信号。<ul>\n<li>4.1 因为刚刚第二步，都是在订阅RACSubject，因此会拿到第二步所有的订阅者，调用他们的nextBlock</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>需求：假设在一个信号中发送请求，每次订阅一次都会发送请求，这样就会导致多次请求。<br>解决：使用RACMulticastConnection就能解决.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 1.创建请求信号</div><div class=\"line\">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class=\"line\">    NSLog(@&quot;发送请求&quot;);</div><div class=\"line\">    return nil;</div><div class=\"line\">&#125;];</div><div class=\"line\">// 2.订阅信号</div><div class=\"line\">[signal subscribeNext:^(id x) &#123;</div><div class=\"line\">    NSLog(@&quot;接收数据&quot;);</div><div class=\"line\">&#125;];</div><div class=\"line\">// 2.订阅信号</div><div class=\"line\">[signal subscribeNext:^(id x) &#123;</div><div class=\"line\">    NSLog(@&quot;接收数据&quot;);</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">// 3.运行结果，会执行两遍发送请求，也就是每次订阅都会发送一次请求</div></pre></td></tr></table></figure>\n</li>\n<li><p>RACMulticastConnection:解决重复请求问题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 1.创建信号</div><div class=\"line\">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class=\"line\">    NSLog(@&quot;发送请求&quot;);</div><div class=\"line\">    [subscriber sendNext:@1];</div><div class=\"line\">    return nil;</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">// 2.创建连接</div><div class=\"line\">RACMulticastConnection *connect = [signal publish];</div><div class=\"line\"></div><div class=\"line\">// 3.订阅信号，</div><div class=\"line\">// 注意：订阅信号，也不能激活信号，只是保存订阅者到数组，必须通过连接,当调用连接，就会一次性调用所有订阅者的sendNext:</div><div class=\"line\">[connect.signal subscribeNext:^(id x) &#123;</div><div class=\"line\">    NSLog(@&quot;订阅者一信号&quot;);</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">[connect.signal subscribeNext:^(id x) &#123;</div><div class=\"line\">    NSLog(@&quot;订阅者二信号&quot;);</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">// 4.连接,激活信号</div><div class=\"line\">[connect connect];</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"RACScheduler\"><a href=\"#RACScheduler\" class=\"headerlink\" title=\"RACScheduler\"></a>RACScheduler</h3><p>RAC中的队列，用GCD封装的。</p>\n<h3 id=\"RACUnit\"><a href=\"#RACUnit\" class=\"headerlink\" title=\"RACUnit\"></a>RACUnit</h3><p>表⽰stream不包含有意义的值,也就是看到这个，可以直接理解为nil.</p>\n<h3 id=\"RACEvent\"><a href=\"#RACEvent\" class=\"headerlink\" title=\"RACEvent\"></a>RACEvent</h3><p>把数据包装成信号事件(signal event)。它主要通过RACSignal的-materialize来使用，然并卵。</p>\n<h2 id=\"ReactiveCocoa开发中常见用法。\"><a href=\"#ReactiveCocoa开发中常见用法。\" class=\"headerlink\" title=\"ReactiveCocoa开发中常见用法。\"></a>ReactiveCocoa开发中常见用法。</h2><h3 id=\"代替代理\"><a href=\"#代替代理\" class=\"headerlink\" title=\"代替代理\"></a>代替代理</h3><p>rac_signalForSelector：用于替代代理。</p>\n<h3 id=\"代替KVO\"><a href=\"#代替KVO\" class=\"headerlink\" title=\"代替KVO\"></a>代替KVO</h3><p>rac_valuesAndChangesForKeyPath：用于监听某个对象的属性改变。</p>\n<h3 id=\"监听事件\"><a href=\"#监听事件\" class=\"headerlink\" title=\"监听事件\"></a>监听事件</h3><p>rac_signalForControlEvents：用于监听某个事件。</p>\n<h3 id=\"代替通知\"><a href=\"#代替通知\" class=\"headerlink\" title=\"代替通知\"></a>代替通知</h3><p>rac_addObserverForName:用于监听某个通知。</p>\n<h3 id=\"监听文本框文字改变\"><a href=\"#监听文本框文字改变\" class=\"headerlink\" title=\"监听文本框文字改变\"></a>监听文本框文字改变</h3><p>rac_textSignal:只要文本框发出改变就会发出这个信号。</p>\n<h3 id=\"处理当界面有多次请求时，需要都获取到数据时，才能展示界面\"><a href=\"#处理当界面有多次请求时，需要都获取到数据时，才能展示界面\" class=\"headerlink\" title=\"处理当界面有多次请求时，需要都获取到数据时，才能展示界面\"></a>处理当界面有多次请求时，需要都获取到数据时，才能展示界面</h3><p>rac_liftSelector:withSignalsFromArray:Signals:当传入的Signals(信号数组)，每一个signal都至少sendNext过一次，就会去触发第一个selector参数的方法。<br>使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据。<br>代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 1.代替代理</div><div class=\"line\">// 需求：自定义redView,监听红色view中按钮点击</div><div class=\"line\">// 之前都是需要通过代理监听，给红色View添加一个代理属性，点击按钮的时候，通知代理做事情</div><div class=\"line\">// rac_signalForSelector:把调用某个对象的方法的信息转换成信号，就要调用这个方法，就会发送信号。</div><div class=\"line\">// 这里表示只要redV调用btnClick:,就会发出信号，订阅就好了。</div><div class=\"line\">[[redV rac_signalForSelector:@selector(btnClick:)] subscribeNext:^(id x) &#123;</div><div class=\"line\">    NSLog(@&quot;点击红色按钮&quot;);</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">// 2.KVO</div><div class=\"line\">// 把监听redV的center属性改变转换成信号，只要值改变就会发送信号</div><div class=\"line\">// observer:可以传入nil</div><div class=\"line\">[[redV rac_valuesAndChangesForKeyPath:@&quot;center&quot; options:NSKeyValueObservingOptionNew observer:nil] subscribeNext:^(id x) &#123;</div><div class=\"line\">    NSLog(@&quot;%@&quot;,x);</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">// 3.监听事件</div><div class=\"line\">// 把按钮点击事件转换为信号，点击按钮，就会发送信号</div><div class=\"line\">[[self.btn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) &#123;</div><div class=\"line\">    NSLog(@&quot;按钮被点击了&quot;);</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">// 4.代替通知</div><div class=\"line\">// 把监听到的通知转换信号</div><div class=\"line\">[[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIKeyboardWillShowNotification object:nil] subscribeNext:^(id x) &#123;</div><div class=\"line\">    NSLog(@&quot;键盘弹出&quot;);</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">// 5.监听文本框的文字改变</div><div class=\"line\">[_textField.rac_textSignal subscribeNext:^(id x) &#123;</div><div class=\"line\">    NSLog(@&quot;文字改变了%@&quot;,x);</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">// 6.处理多个请求，都返回结果的时候，统一做处理.</div><div class=\"line\">RACSignal *request1 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class=\"line\"></div><div class=\"line\">// 发送请求1</div><div class=\"line\">[subscriber sendNext:@&quot;发送请求1&quot;];</div><div class=\"line\">    return nil;</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">RACSignal *request2 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class=\"line\">    // 发送请求2</div><div class=\"line\">    [subscriber sendNext:@&quot;发送请求2&quot;];</div><div class=\"line\">    return nil;</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">// 使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据。</div><div class=\"line\">[self rac_liftSelector:@selector(updateUIWithR1:r2:) withSignalsFromArray:@[request1,request2]];</div><div class=\"line\">&#125;</div><div class=\"line\">// 更新UI</div><div class=\"line\">- (void)updateUIWithR1:(id)data r2:(id)data1</div><div class=\"line\">&#123;</div><div class=\"line\">    NSLog(@&quot;更新UI%@  %@&quot;,data,data1);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"ReactiveCocoa常见宏\"><a href=\"#ReactiveCocoa常见宏\" class=\"headerlink\" title=\"ReactiveCocoa常见宏\"></a>ReactiveCocoa常见宏</h2><h3 id=\"RAC-TARGET-KEYPATH-NIL-VALUE\"><a href=\"#RAC-TARGET-KEYPATH-NIL-VALUE\" class=\"headerlink\" title=\"RAC(TARGET, [KEYPATH, [NIL_VALUE]])\"></a>RAC(TARGET, [KEYPATH, [NIL_VALUE]])</h3><p>用于给某个对象的某个属性绑定。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 只要文本框文字改变，就会修改label的文字</div><div class=\"line\">RAC(self.labelView,text) = _textField.rac_textSignal;</div></pre></td></tr></table></figure></p>\n<h3 id=\"RACObserve-self-name\"><a href=\"#RACObserve-self-name\" class=\"headerlink\" title=\"RACObserve(self, name)\"></a>RACObserve(self, name)</h3><p>监听某个对象的某个属性,返回的是信号。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[RACObserve(self.view, center) subscribeNext:^(id x) &#123;</div><div class=\"line\">    NSLog(@&quot;%@&quot;,x);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<h3 id=\"weakify-Obj-和-strongify-Obj\"><a href=\"#weakify-Obj-和-strongify-Obj\" class=\"headerlink\" title=\"@weakify(Obj)和@strongify(Obj)\"></a>@weakify(Obj)和@strongify(Obj)</h3><p>一般两个都是配套使用,在主头文件(ReactiveCocoa.h)中并没有导入，需要自己手动导入，RACEXTScope.h才可以使用。但是每次导入都非常麻烦，只需要在主头文件自己导入就好了。</p>\n<h3 id=\"RACTuplePack\"><a href=\"#RACTuplePack\" class=\"headerlink\" title=\"RACTuplePack\"></a>RACTuplePack</h3><p>把数据包装成RACTuple（元组类）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 把参数中的数据包装成元组</div><div class=\"line\">RACTuple *tuple = RACTuplePack(@10,@20);</div></pre></td></tr></table></figure></p>\n<h3 id=\"RACTupleUnpack：把RACTuple（元组类）解包成对应的数据。\"><a href=\"#RACTupleUnpack：把RACTuple（元组类）解包成对应的数据。\" class=\"headerlink\" title=\"RACTupleUnpack：把RACTuple（元组类）解包成对应的数据。\"></a>RACTupleUnpack：把RACTuple（元组类）解包成对应的数据。</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 把参数中的数据包装成元组</div><div class=\"line\">RACTuple *tuple = RACTuplePack(@&quot;abc&quot;,@20);</div><div class=\"line\"></div><div class=\"line\">// 解包元组，会把元组的值，按顺序给参数里面的变量赋值</div><div class=\"line\">// name = @&quot;abc&quot; age = @20</div><div class=\"line\">RACTupleUnpack(NSString *name,NSNumber *age) = tuple;</div></pre></td></tr></table></figure>\n<p>原文链接：<a href=\"http://www.jianshu.com/p/87ef6720a096#\" target=\"_blank\" rel=\"external\">最快让你上手ReactiveCocoa之基础篇</a></p>"},{"title":"ReactNative学习笔记","date":"2017-05-21T03:39:45.000Z","toc":true,"_content":"\n# 直接通过ReactNative方式创建项目\n## 安装\n必须安装：Xcode，Homebrew，node,npm\nnpm其实是Node.js的包管理工具,已经在Node.js安装的时候顺带装好了。\n可选：React Native的命令行工具,IDE(Atom/Nuclide/Webstorm/Sublime),watchman,Flow\n```\n//brew\nruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\nbrew -v\n//node\nbrew install node\n//React Native的命令行工具\nnpm install -g react-native-cli\n//watchman\nbrew install watchman\n//flow\nbrew install flow\n```\n\n<!--more-->\n## 创建项目\n```\n$ react-native init RNDemo\n```\n\n运行项目:使用命令行或Xcode\n```\n$ react-native run-ios\n$ react-native run-android\n\n......\n\nReact packager ready.\nLoading dependency graph, done.\n````\n\n运行项目时如果遇到`<React/RCTBundleURLProvider.h>” file not found`问题，可按如下方法试着解决：\n* 把项目里面的 node_modules 文件夹删除掉\n* npm install\n* react-native upgrade\n* clean,run\n\n# JavaScript基础\n(1){}表示定义一个对象\n(2)var,let,function,弱类型,typeof(),isNaN()\n数据类型：Boolean,null,undefined,Number,String,Symbol,Object\nfalse:false,undefined,NaN,null,\"\",0\n显式类型转换：parseInt()\n隐式类型转换：==,-,*,/\n数组：var a = [\"1\",\"2\",\"3\"]\n     var a = new Array(\"1\",\"2\",\"3\")\n     var a = Array(\"1\",\"2\",\"3\")\n字典：{}\n> JS:基于原型(所有对象均为实例,通过构造器函数来定义和创建一组对象) \n> OC：基于类\n(3)Promises(ES6)\nJS本身是单线程的语言，它要实现异步都是通过回调函数来实现的，JS中引入了Promises来处理异步和延迟操作。\n    promise有以下几种状态：\n    * pending，最初的状态\n    * fulfilled，执行成功\n    * rejected，执行出错\n    * settled，执行结束了，失败(rejected)或者成功(fulfilled)\n(4)箭头函数(ES6)\n```\n(s) => s.length 等同于 function(s){ return s.length }\n```\n\n普通函数.bind(this) 来把内部函数中的this绑定到了外部函数去。\n箭头函数里的this还是原来的this，不需要额外绑定。\n(5)模板字符串(ES6)\n```\nvar html = `公司名：${name}   \n简介：${desc}`;\n\n等同于\n\nvar tpl = '公司名：' + name + '\\n'+\n'简介：'+ desc;\n```\n\n# React基础\n## 组件（component）\n是React类的基类，进行视图展示。\n* 组件的属性(prop)：组件之前通过标签的属性来传递数据，由父组件传递给子组件(单向的属性传递)\n* 组件的状态(state)\n    + 每次调用setState时都会更新组件的状态，触发render函数进行渲染更新界面（render方法是被异步调用的，这可以保证同步的多个setState方法只会触发一次render）\n    + 组件自己不可以自己修改props（即：props可认为是只读的），只可由其他组件调用它时在外部修改\n* createClass：创建一个component\n* render()：返回的的 JSX 模板需要一个根元素包裹起来\n返回一个根的视图，用来渲染实际的Component可视部分\n* getInitialState()：只能在用React.createClass创建的时候使用\n在Component被加载之前调用一次，这个方法的返回值会被设置为this.state\n* getDefaultProps()：在Class 创建的时候，调用一次，这个方法在调用的时候，任何实例还没有被创建\n返回的任何Object 对象，在各个实例中是共享的\n\n## 组件的生命周期\n![组件生命周期](http://o8cfktdb3.bkt.clouddn.com/componentLifeCycle.png)\n\n(1)创建：getDefaultProps(ES6:defaultProps)->\n(2)实例化：getInitialState(ES6:constructor)->componentWillMount->render->componentDidMount->\n(3)运行更新阶段：\n    + 运行中->props改变->componentWillReceiveProps->\n    + 运行中->state改变->\nshouldComponentUpdate->\n    + false->运行中\n    + true->componentWillUpdate->render->componentDidUpdate->运行中\n(4)销毁阶段：Unmount(卸载)->componentWillUnmount\n\n|            生命周期           |            调用次数            | 能否使用 setSate()            |\n|------------------------------|------------------------------|------------------------------\n|defaultProps / getDefaultProps|         1(全局调用一次)       |否|\n|constructor / getInitialState | 1            |否|\n|componentWillMount            | 1            |是|\n|render                        | >=1          |否|\n|componentDidMount             | 1            |是|\n|componentWillReceiveProps     | >=0          |是|\n|shouldComponentUpdate         | >=0          |否|\n|componentWillUpdate           | >=0          |否|\n|componentDidUpdate            | >=0          |否|\n|componentWillUnmount          | 1            |否|\n\n(1)getDefaultProps(ES6:defaultProps):初始化一些默认的属性，一个控件可以利用this.props获取并初始化它的属性\n    + ES5:getDefaultProps:function(){},propTypes:{},\n    + ES6:static defaultProps={};static propTypes={};\n\n(2)constructor(props) / getInitialState():状态初始化\n    + ES5:getInitialState: function(){}\n    + ES6:constructor(props){}\n(3)componentWillMount():准备加载组件，业务初始化操作，也可以设置组件状态\n(4)render():渲染界面，返回JSX或其它组件来构成DOM，只能返回一个顶级元素\n(5)componentDidMount():组件加载成功并被成功渲染，一般会做一些网络请求等加载数据的操作\n\n(6)componentWillReceiveProps():组件接收到新的props会触发，可以调用setState()来完成对state的修改，nextProps 是即将被设置的属性，旧的属性还是可以通过 this.props 来获取\n(7)shouldComponentUpdate():返回布尔值（决定是否需要更新组件）\n(8)componentWillUpdate():shouldComponentUpdate返回true或者调用forceUpdate之后触发此方法，会把 nextProps 和 nextState 分别设置到 this.props 和 this.state 中，开始准备更新组件。不能使用 this.setState 来修改状态。\n(9)render()：再确定需要更新组件时，调用render，根据diff算法，渲染界面，生成需要更新的虚拟DOM数据。\n(10)componentDidUpdate():可以在这个方法中做DOM操作，首次render之后调用componentDidMount，其它render结束之后都是调用componentDidUpdate。\n(11)componentWillUnmount():组件从DOM中移除，可以做一些组件相关的清理工作，例如取消计时器、网络请求。\n```\n注意：绝对不要在componentWillUpdate和componentDidUpdate中调用this.setState方法，否则将导致无限循环调用。\n```\n\n## 组件更新的四种方式\n(1)首次Initial Render，即首次加载组件\n(2)调用this.setState\n(3)父组件发生更新\n(4)调用this.forceUpdate强制更新\n\n## statics\n定义Components可以调用的静态方法\n\n\n# RN与原生项目\n## 先创建iOS项目，再集成React Native到原生项目\n(1) 先通过Xcode创建项目\n(2) 在项目目录下创建一个reactivenative文件夹存放react native相关文件，再创建一个package.json文件，用于初始化react-native\npackage.json内容如下：\n```\n{\n\"name\": \"RNDemo\",\n\"version\": \"1.0.0\",\n\"private\": true,\n\"dependencies\": {\n\"react\": \"^15.6.1\",\n\"react-native\": \"^0.45.1\"\n}\n}\n```\n\n(3) 在reactivenative目录下执行命令\n```\n$ npm install\n```\n\n或者安装指定版本的react/react-native\n```\n$ npm install --save react-native@0.45.1\n$ npm install --save react@15.6.1\n```\n(4) 创建index.ios.js文件\n注意当前项目名称为`RNDemo`，修改为实际项目名称。\n```\n'use strict';\n\nvar React = require('react-native');  \nvar {  \nText,\nView\n} = React;\n\nvar styles = React.StyleSheet.create({  \ncontainer: {\nflex: 1,\nbackgroundColor: 'red'\n}\n});\n\nclass RNDemo extends React.Component {  \nrender() {\nreturn (\n<View style={styles.container}>\n<Text>This is a simple application.</Text>\n</View>\n)\n}\n}\n\nReact.AppRegistry.registerComponent('RNDemo', () => RNDemo);  \n```\n\n(5) Cocoapods集成react-native\n在工程目录下创建Podfile文件，内容如下：\n```\n# 请将:path后面的内容为node_modules文件夹路径。\nplateform :ios, '8.0'\ntarget \"RNDemo\" do\npod 'React', :path => './reactivenative/node_modules/react-native', :subspecs => [\n'Core',\n'RCTImage',\n'RCTNetwork',\n'RCTText',\n'RCTWebSocket',\n# 添加其他你想在工程中使用的依赖。\n]\nend\n```\n\n执行`pod install`即可\n如果出现如下问题：\n```\nThe dependency `React/Core (from `./reactivenative/node_modules/react-native`)` is not used in any concrete target.\n```\n\n在项目首尾请添加上target即可\n```\ntarget \"RNDemo\" do \nend\n```\n\n(6)添加react native应用\n创建一个ReactView视图文件\n```\n- (instancetype)initWithFrame:(CGRect)frame\n{\nif (self = [super initWithFrame:frame]) {\nNSString * strUrl = @\"http://localhost:8081/index.ios.bundle?platform=ios&dev=true\";\nNSURL * jsCodeLocation = [NSURL URLWithString:strUrl];\n\nRCTRootView * rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation\nmoduleName:@\"SimpleApp\"\ninitialProperties:nil\nlaunchOptions:nil];\n\n[self addSubview:rootView];\n\nrootView.frame = self.bounds;\n}\nreturn self;\n}\n```\n\nReactView.m 中通过 http://localhost:8081/index.ios.bundle?platform=ios&dev=true 加载bundle文件\n\n在ViewController中加载这个视图\n```\nReactView * reactView = [[ReactView alloc] initWithFrame:CGRectMake(0, 40, CGRectGetWidth(self.view.bounds), 100)];\n\n[self.view addSubview:reactView];\n```\n\n(7)启动开发服务器\n```\n$ cd reactivenative\n$ react-native start\n```\n\n(8)Info.list中修改NSAppTransportSecurity配置\n(9)在Xcode中运行项目，完成\n\n### 升级Xcode8后遇到的错误\nQ1:'React/RCTBundleURLProvider.h' file not found\nA1:进入react native所在目录，将node_modules文件夹删除，执行\n```\n$ npm install\n$ react-native upgrade\n```\n\nclean，重新运行\n\nQ2:RCTSCrollView.m 中_refreshControl找不到\nA2:在@implementation RCTCustomScrollView下添加如下代码：\n```\n@implementation RCTCustomScrollView\n{\nRCTRefreshControl *_refreshControl;\n}\n```\n\nQ3:控制台不断输出`[] nw_connection_get_connected_socket_block_invoke 710 Connection has no connected handler`\nA3:edit scheme->arguments->Environment Variables->添加Name: \"OS_ACTIVITY_MODE\", Value:\"disable\"\n\n## 原生和React Native之间的通信方式\n主要包括三部分：\n* 属性\n* 原生模块\n* 原生UI组件封装\n\n### 属性\n原生给JS传数据，主要依靠属性。\n(1)原生->React Native 传递属性\ninitialProperties必须是NSDictionary的一个实例。这一字典参数会在内部被转化为一个可供JS组件调用的JSON对象。\n(2)原生->React Native 更新属性\nRCTRootView同样提供了一个可读写的属性appProperties,可以通过componentWillMount访问新的属性值。\n* 更新必须在主线程中进行，读取则可以在任何线程中进行。\n* 更新属性时并不能做到只更新一部分属性。建议自己封装一个函数来构造属性。\n(3)React Native->原生\n宏RCT_CUSTOM_VIEW_PROPERTY\n\n### 原生模块\n原生模块是JS中也可以使用的Objective-C类。一个“原生模块”就是一个实现了“RCTBridgeModule”协议的Objective-C类。\n\n### 原生UI组件封装\n\n\n## FlexBox\n1.flexDirection:row|row-reverse|column|column-reverse\n2.flexWrap:wrap|no-wrap\n3.justifyContent:flex-start|flex-end|center|space-between|space-around\n4.alignItems:flex-start|flex-end|center|stretch\n5.alignSelf:auto|flex-start|flex-end|center|stretch\n6.flex:子控件在主轴中占据几等分\n\n## props,state\nprops:在父组件中指定，而且一经指定，在整个组件的生命周期中都不再改变。\nstate:constructor中声明(ES6)，在setState中修改数据\n定义state:\n```\nthis.state = {\nnum:1,\n};\n```\n\n修改state:\n```\nthis.setState({\nnum : number\n})\n```\n\n## 父子组件传值\n1.父传子\n(1)props:this.props.name\n(2)ref:this.refs.son.receiveMsg(\"msg\")\n2.子传父\n(1)方法回调\n父组件：定义一个处理接收到值的方法，把这个方法传递给子组件，并且绑定this\n子组件：通过this.props拿到这个方法调用\n3.无关联组件间传值\n(1)通知:组件1传值给组件2\n组件1：\n```\n<Text onPress={()=>{\nDeviceEventEmitter.emit('NotificationName',123);\n}}></Text>\n```\n\n组件2：\n```\nthis.lister = DeviceEventEmitter.addListener('NotificationName',(value)=>{\nthis.setState({\nvalue:value\n});\n})\n```\n\n## 组件生命周期\n实例化\n1.constructor:初始化state（只调用一次）\n2.componentWillMount:即将加载组件调用，render前（只调用一次）\n3.render:渲染组件\n4.componentDidMount:组件加载完成调用，render后（只调用一次）\n运行\n5.componentWillReceiveProps:props改变调用\n6.shouldComponentUpdate:props/state改变调用，可控制是否刷新界面\n7.componentWillUpdate:组件即将更新调用（调用this.setState会循环）\n8.render\n9.componentDidUpdate:组件更新完成（调用this.setState会循环）\n销毁\n10.componentWillUnmount:组件即将销毁，可移除观察者，清空数据等\n\n## propTypes\n必须要用static修饰，否则无效\nstatic：用来定义类方法或者类属性，定义类的方法和属性，生成的对象就自动有这样的属性了。\n1.类型检查：当传入错误的属性值，会报警告，但是不会报错\n>\n# 数组类型\nPropTypes.array\n\n# 布尔类型\nPropTypes.bool\n\n# 函数类型\nPropTypes.func\n\n# 数值类型\nPropTypes.number\n\n# 对象类型\nPropTypes.object\n\n# 字符串类型\nPropTypes.string\n\n# 规定prop为必传字段\nPropTypes.func.isRequired\n\n# prop可为任意类型\nPropTypes.any.isRequired\n>\n\n```\n// 定义属性\nstatic propTypes = {\n    name:PropTypes.string,\n    age:PropTypes.number\n}\n```\n\n2.设置初始化值\n```\nstatic defaultProps = {\n    name:'xiaoming',\n    age:20\n}\n```\n\n## 基本组件\n1.View\n2.TouchableOpacity\n默认点击区域是所有子控件的区域,因为默认一个组件的尺寸由子控件决定\n* 点击事件：onPress|onLongPress|onPressIn|onPressOut\n* disabled:true|false\n3.Text\n* numberOfLines\n* selectable:true|false 是否允许长按选择文本\n* suppressHighlighting:true|false 是否允许按下时有灰色阴影\n* onPress:文字点击事件\n\n\n## ListView\n1.创建数据源，给数据源设置数据\n使用state保存数据源\n* 不分组使用：cloneWithRows\n* 分组使用：cloneWithRowsAndSections\n```\nvar dataSource = new ListView.DataSource({rowHasChanged: (r1, r2) => r1 !== r2});\nthis.state = {\nds: dataSource.cloneWithRows(['row 1', 'row 2']),\n};\n```\n\n```\nvar dataSource = new ListView.DataSource({\nrowHasChanged:(r1,r2)=>r1 !== r2,\nsectionHeaderHasChanged:(s1,s2)=>s1 !== s2\n});\nvar sectionData = {};\nthis.state = {\nds : dataSource.cloneWithRowsAndSections(sectionData)\n};\n```\n\n2.实现数据源方法\n```\n<ListView dataSource={this.state.ds}\nrenderRow={this._renderRow.bind(this)}\nrenderSectionHeader={this._renderSectionHeader.bind(this)}\n//renderSeparator={this._renderSeparator.bind(this)}\n/>\n\n_renderRow(rowData, sectionID, rowID, highlightRow) {\nreturn (\n<View>\n<Text>{rowData}</Text>\n</View>\n);\n}\n//如果是组视图，设置组数据\n_renderSectionHeader(sectionData, sectionID) {\nreturn (\n<View>\n<Text>{sectionID}</Text>\n</View>\n)\n}\n```\n\n## 导航Navigator\n如果找不到Navigator，安装Navigator所在的库：\n```\nnpm install react-native-deprecated-custom-components --save\n//yarn add react-native-deprecated-custom-components\n```\n\n项目导入：\n```\nimport {Navigator} from 'react-native-deprecated-custom-components'\n```\n\n\n\n\n\n参考链接：[React Native开发](http://www.lcode.org/【react-native开发】react-native-for-android环境配置以及第一个实例/)\n[React Native 简介与入门](http://www.jianshu.com/p/5b185df2d11a)\n[reactnative集成到原生ios项目](http://www.tuicool.com/articles/BfInEv)\n[袁峥-系列](http://www.jianshu.com/p/504a26d094b2)\n\n","source":"_posts/ReactNative学习笔记.md","raw":"---\ntitle: ReactNative学习笔记\ndate: 2017-05-21 11:39:45\ncategories: 笔记\ntags: [iOS,ReactNative]\ntoc: true\n---\n\n# 直接通过ReactNative方式创建项目\n## 安装\n必须安装：Xcode，Homebrew，node,npm\nnpm其实是Node.js的包管理工具,已经在Node.js安装的时候顺带装好了。\n可选：React Native的命令行工具,IDE(Atom/Nuclide/Webstorm/Sublime),watchman,Flow\n```\n//brew\nruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\nbrew -v\n//node\nbrew install node\n//React Native的命令行工具\nnpm install -g react-native-cli\n//watchman\nbrew install watchman\n//flow\nbrew install flow\n```\n\n<!--more-->\n## 创建项目\n```\n$ react-native init RNDemo\n```\n\n运行项目:使用命令行或Xcode\n```\n$ react-native run-ios\n$ react-native run-android\n\n......\n\nReact packager ready.\nLoading dependency graph, done.\n````\n\n运行项目时如果遇到`<React/RCTBundleURLProvider.h>” file not found`问题，可按如下方法试着解决：\n* 把项目里面的 node_modules 文件夹删除掉\n* npm install\n* react-native upgrade\n* clean,run\n\n# JavaScript基础\n(1){}表示定义一个对象\n(2)var,let,function,弱类型,typeof(),isNaN()\n数据类型：Boolean,null,undefined,Number,String,Symbol,Object\nfalse:false,undefined,NaN,null,\"\",0\n显式类型转换：parseInt()\n隐式类型转换：==,-,*,/\n数组：var a = [\"1\",\"2\",\"3\"]\n     var a = new Array(\"1\",\"2\",\"3\")\n     var a = Array(\"1\",\"2\",\"3\")\n字典：{}\n> JS:基于原型(所有对象均为实例,通过构造器函数来定义和创建一组对象) \n> OC：基于类\n(3)Promises(ES6)\nJS本身是单线程的语言，它要实现异步都是通过回调函数来实现的，JS中引入了Promises来处理异步和延迟操作。\n    promise有以下几种状态：\n    * pending，最初的状态\n    * fulfilled，执行成功\n    * rejected，执行出错\n    * settled，执行结束了，失败(rejected)或者成功(fulfilled)\n(4)箭头函数(ES6)\n```\n(s) => s.length 等同于 function(s){ return s.length }\n```\n\n普通函数.bind(this) 来把内部函数中的this绑定到了外部函数去。\n箭头函数里的this还是原来的this，不需要额外绑定。\n(5)模板字符串(ES6)\n```\nvar html = `公司名：${name}   \n简介：${desc}`;\n\n等同于\n\nvar tpl = '公司名：' + name + '\\n'+\n'简介：'+ desc;\n```\n\n# React基础\n## 组件（component）\n是React类的基类，进行视图展示。\n* 组件的属性(prop)：组件之前通过标签的属性来传递数据，由父组件传递给子组件(单向的属性传递)\n* 组件的状态(state)\n    + 每次调用setState时都会更新组件的状态，触发render函数进行渲染更新界面（render方法是被异步调用的，这可以保证同步的多个setState方法只会触发一次render）\n    + 组件自己不可以自己修改props（即：props可认为是只读的），只可由其他组件调用它时在外部修改\n* createClass：创建一个component\n* render()：返回的的 JSX 模板需要一个根元素包裹起来\n返回一个根的视图，用来渲染实际的Component可视部分\n* getInitialState()：只能在用React.createClass创建的时候使用\n在Component被加载之前调用一次，这个方法的返回值会被设置为this.state\n* getDefaultProps()：在Class 创建的时候，调用一次，这个方法在调用的时候，任何实例还没有被创建\n返回的任何Object 对象，在各个实例中是共享的\n\n## 组件的生命周期\n![组件生命周期](http://o8cfktdb3.bkt.clouddn.com/componentLifeCycle.png)\n\n(1)创建：getDefaultProps(ES6:defaultProps)->\n(2)实例化：getInitialState(ES6:constructor)->componentWillMount->render->componentDidMount->\n(3)运行更新阶段：\n    + 运行中->props改变->componentWillReceiveProps->\n    + 运行中->state改变->\nshouldComponentUpdate->\n    + false->运行中\n    + true->componentWillUpdate->render->componentDidUpdate->运行中\n(4)销毁阶段：Unmount(卸载)->componentWillUnmount\n\n|            生命周期           |            调用次数            | 能否使用 setSate()            |\n|------------------------------|------------------------------|------------------------------\n|defaultProps / getDefaultProps|         1(全局调用一次)       |否|\n|constructor / getInitialState | 1            |否|\n|componentWillMount            | 1            |是|\n|render                        | >=1          |否|\n|componentDidMount             | 1            |是|\n|componentWillReceiveProps     | >=0          |是|\n|shouldComponentUpdate         | >=0          |否|\n|componentWillUpdate           | >=0          |否|\n|componentDidUpdate            | >=0          |否|\n|componentWillUnmount          | 1            |否|\n\n(1)getDefaultProps(ES6:defaultProps):初始化一些默认的属性，一个控件可以利用this.props获取并初始化它的属性\n    + ES5:getDefaultProps:function(){},propTypes:{},\n    + ES6:static defaultProps={};static propTypes={};\n\n(2)constructor(props) / getInitialState():状态初始化\n    + ES5:getInitialState: function(){}\n    + ES6:constructor(props){}\n(3)componentWillMount():准备加载组件，业务初始化操作，也可以设置组件状态\n(4)render():渲染界面，返回JSX或其它组件来构成DOM，只能返回一个顶级元素\n(5)componentDidMount():组件加载成功并被成功渲染，一般会做一些网络请求等加载数据的操作\n\n(6)componentWillReceiveProps():组件接收到新的props会触发，可以调用setState()来完成对state的修改，nextProps 是即将被设置的属性，旧的属性还是可以通过 this.props 来获取\n(7)shouldComponentUpdate():返回布尔值（决定是否需要更新组件）\n(8)componentWillUpdate():shouldComponentUpdate返回true或者调用forceUpdate之后触发此方法，会把 nextProps 和 nextState 分别设置到 this.props 和 this.state 中，开始准备更新组件。不能使用 this.setState 来修改状态。\n(9)render()：再确定需要更新组件时，调用render，根据diff算法，渲染界面，生成需要更新的虚拟DOM数据。\n(10)componentDidUpdate():可以在这个方法中做DOM操作，首次render之后调用componentDidMount，其它render结束之后都是调用componentDidUpdate。\n(11)componentWillUnmount():组件从DOM中移除，可以做一些组件相关的清理工作，例如取消计时器、网络请求。\n```\n注意：绝对不要在componentWillUpdate和componentDidUpdate中调用this.setState方法，否则将导致无限循环调用。\n```\n\n## 组件更新的四种方式\n(1)首次Initial Render，即首次加载组件\n(2)调用this.setState\n(3)父组件发生更新\n(4)调用this.forceUpdate强制更新\n\n## statics\n定义Components可以调用的静态方法\n\n\n# RN与原生项目\n## 先创建iOS项目，再集成React Native到原生项目\n(1) 先通过Xcode创建项目\n(2) 在项目目录下创建一个reactivenative文件夹存放react native相关文件，再创建一个package.json文件，用于初始化react-native\npackage.json内容如下：\n```\n{\n\"name\": \"RNDemo\",\n\"version\": \"1.0.0\",\n\"private\": true,\n\"dependencies\": {\n\"react\": \"^15.6.1\",\n\"react-native\": \"^0.45.1\"\n}\n}\n```\n\n(3) 在reactivenative目录下执行命令\n```\n$ npm install\n```\n\n或者安装指定版本的react/react-native\n```\n$ npm install --save react-native@0.45.1\n$ npm install --save react@15.6.1\n```\n(4) 创建index.ios.js文件\n注意当前项目名称为`RNDemo`，修改为实际项目名称。\n```\n'use strict';\n\nvar React = require('react-native');  \nvar {  \nText,\nView\n} = React;\n\nvar styles = React.StyleSheet.create({  \ncontainer: {\nflex: 1,\nbackgroundColor: 'red'\n}\n});\n\nclass RNDemo extends React.Component {  \nrender() {\nreturn (\n<View style={styles.container}>\n<Text>This is a simple application.</Text>\n</View>\n)\n}\n}\n\nReact.AppRegistry.registerComponent('RNDemo', () => RNDemo);  \n```\n\n(5) Cocoapods集成react-native\n在工程目录下创建Podfile文件，内容如下：\n```\n# 请将:path后面的内容为node_modules文件夹路径。\nplateform :ios, '8.0'\ntarget \"RNDemo\" do\npod 'React', :path => './reactivenative/node_modules/react-native', :subspecs => [\n'Core',\n'RCTImage',\n'RCTNetwork',\n'RCTText',\n'RCTWebSocket',\n# 添加其他你想在工程中使用的依赖。\n]\nend\n```\n\n执行`pod install`即可\n如果出现如下问题：\n```\nThe dependency `React/Core (from `./reactivenative/node_modules/react-native`)` is not used in any concrete target.\n```\n\n在项目首尾请添加上target即可\n```\ntarget \"RNDemo\" do \nend\n```\n\n(6)添加react native应用\n创建一个ReactView视图文件\n```\n- (instancetype)initWithFrame:(CGRect)frame\n{\nif (self = [super initWithFrame:frame]) {\nNSString * strUrl = @\"http://localhost:8081/index.ios.bundle?platform=ios&dev=true\";\nNSURL * jsCodeLocation = [NSURL URLWithString:strUrl];\n\nRCTRootView * rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation\nmoduleName:@\"SimpleApp\"\ninitialProperties:nil\nlaunchOptions:nil];\n\n[self addSubview:rootView];\n\nrootView.frame = self.bounds;\n}\nreturn self;\n}\n```\n\nReactView.m 中通过 http://localhost:8081/index.ios.bundle?platform=ios&dev=true 加载bundle文件\n\n在ViewController中加载这个视图\n```\nReactView * reactView = [[ReactView alloc] initWithFrame:CGRectMake(0, 40, CGRectGetWidth(self.view.bounds), 100)];\n\n[self.view addSubview:reactView];\n```\n\n(7)启动开发服务器\n```\n$ cd reactivenative\n$ react-native start\n```\n\n(8)Info.list中修改NSAppTransportSecurity配置\n(9)在Xcode中运行项目，完成\n\n### 升级Xcode8后遇到的错误\nQ1:'React/RCTBundleURLProvider.h' file not found\nA1:进入react native所在目录，将node_modules文件夹删除，执行\n```\n$ npm install\n$ react-native upgrade\n```\n\nclean，重新运行\n\nQ2:RCTSCrollView.m 中_refreshControl找不到\nA2:在@implementation RCTCustomScrollView下添加如下代码：\n```\n@implementation RCTCustomScrollView\n{\nRCTRefreshControl *_refreshControl;\n}\n```\n\nQ3:控制台不断输出`[] nw_connection_get_connected_socket_block_invoke 710 Connection has no connected handler`\nA3:edit scheme->arguments->Environment Variables->添加Name: \"OS_ACTIVITY_MODE\", Value:\"disable\"\n\n## 原生和React Native之间的通信方式\n主要包括三部分：\n* 属性\n* 原生模块\n* 原生UI组件封装\n\n### 属性\n原生给JS传数据，主要依靠属性。\n(1)原生->React Native 传递属性\ninitialProperties必须是NSDictionary的一个实例。这一字典参数会在内部被转化为一个可供JS组件调用的JSON对象。\n(2)原生->React Native 更新属性\nRCTRootView同样提供了一个可读写的属性appProperties,可以通过componentWillMount访问新的属性值。\n* 更新必须在主线程中进行，读取则可以在任何线程中进行。\n* 更新属性时并不能做到只更新一部分属性。建议自己封装一个函数来构造属性。\n(3)React Native->原生\n宏RCT_CUSTOM_VIEW_PROPERTY\n\n### 原生模块\n原生模块是JS中也可以使用的Objective-C类。一个“原生模块”就是一个实现了“RCTBridgeModule”协议的Objective-C类。\n\n### 原生UI组件封装\n\n\n## FlexBox\n1.flexDirection:row|row-reverse|column|column-reverse\n2.flexWrap:wrap|no-wrap\n3.justifyContent:flex-start|flex-end|center|space-between|space-around\n4.alignItems:flex-start|flex-end|center|stretch\n5.alignSelf:auto|flex-start|flex-end|center|stretch\n6.flex:子控件在主轴中占据几等分\n\n## props,state\nprops:在父组件中指定，而且一经指定，在整个组件的生命周期中都不再改变。\nstate:constructor中声明(ES6)，在setState中修改数据\n定义state:\n```\nthis.state = {\nnum:1,\n};\n```\n\n修改state:\n```\nthis.setState({\nnum : number\n})\n```\n\n## 父子组件传值\n1.父传子\n(1)props:this.props.name\n(2)ref:this.refs.son.receiveMsg(\"msg\")\n2.子传父\n(1)方法回调\n父组件：定义一个处理接收到值的方法，把这个方法传递给子组件，并且绑定this\n子组件：通过this.props拿到这个方法调用\n3.无关联组件间传值\n(1)通知:组件1传值给组件2\n组件1：\n```\n<Text onPress={()=>{\nDeviceEventEmitter.emit('NotificationName',123);\n}}></Text>\n```\n\n组件2：\n```\nthis.lister = DeviceEventEmitter.addListener('NotificationName',(value)=>{\nthis.setState({\nvalue:value\n});\n})\n```\n\n## 组件生命周期\n实例化\n1.constructor:初始化state（只调用一次）\n2.componentWillMount:即将加载组件调用，render前（只调用一次）\n3.render:渲染组件\n4.componentDidMount:组件加载完成调用，render后（只调用一次）\n运行\n5.componentWillReceiveProps:props改变调用\n6.shouldComponentUpdate:props/state改变调用，可控制是否刷新界面\n7.componentWillUpdate:组件即将更新调用（调用this.setState会循环）\n8.render\n9.componentDidUpdate:组件更新完成（调用this.setState会循环）\n销毁\n10.componentWillUnmount:组件即将销毁，可移除观察者，清空数据等\n\n## propTypes\n必须要用static修饰，否则无效\nstatic：用来定义类方法或者类属性，定义类的方法和属性，生成的对象就自动有这样的属性了。\n1.类型检查：当传入错误的属性值，会报警告，但是不会报错\n>\n# 数组类型\nPropTypes.array\n\n# 布尔类型\nPropTypes.bool\n\n# 函数类型\nPropTypes.func\n\n# 数值类型\nPropTypes.number\n\n# 对象类型\nPropTypes.object\n\n# 字符串类型\nPropTypes.string\n\n# 规定prop为必传字段\nPropTypes.func.isRequired\n\n# prop可为任意类型\nPropTypes.any.isRequired\n>\n\n```\n// 定义属性\nstatic propTypes = {\n    name:PropTypes.string,\n    age:PropTypes.number\n}\n```\n\n2.设置初始化值\n```\nstatic defaultProps = {\n    name:'xiaoming',\n    age:20\n}\n```\n\n## 基本组件\n1.View\n2.TouchableOpacity\n默认点击区域是所有子控件的区域,因为默认一个组件的尺寸由子控件决定\n* 点击事件：onPress|onLongPress|onPressIn|onPressOut\n* disabled:true|false\n3.Text\n* numberOfLines\n* selectable:true|false 是否允许长按选择文本\n* suppressHighlighting:true|false 是否允许按下时有灰色阴影\n* onPress:文字点击事件\n\n\n## ListView\n1.创建数据源，给数据源设置数据\n使用state保存数据源\n* 不分组使用：cloneWithRows\n* 分组使用：cloneWithRowsAndSections\n```\nvar dataSource = new ListView.DataSource({rowHasChanged: (r1, r2) => r1 !== r2});\nthis.state = {\nds: dataSource.cloneWithRows(['row 1', 'row 2']),\n};\n```\n\n```\nvar dataSource = new ListView.DataSource({\nrowHasChanged:(r1,r2)=>r1 !== r2,\nsectionHeaderHasChanged:(s1,s2)=>s1 !== s2\n});\nvar sectionData = {};\nthis.state = {\nds : dataSource.cloneWithRowsAndSections(sectionData)\n};\n```\n\n2.实现数据源方法\n```\n<ListView dataSource={this.state.ds}\nrenderRow={this._renderRow.bind(this)}\nrenderSectionHeader={this._renderSectionHeader.bind(this)}\n//renderSeparator={this._renderSeparator.bind(this)}\n/>\n\n_renderRow(rowData, sectionID, rowID, highlightRow) {\nreturn (\n<View>\n<Text>{rowData}</Text>\n</View>\n);\n}\n//如果是组视图，设置组数据\n_renderSectionHeader(sectionData, sectionID) {\nreturn (\n<View>\n<Text>{sectionID}</Text>\n</View>\n)\n}\n```\n\n## 导航Navigator\n如果找不到Navigator，安装Navigator所在的库：\n```\nnpm install react-native-deprecated-custom-components --save\n//yarn add react-native-deprecated-custom-components\n```\n\n项目导入：\n```\nimport {Navigator} from 'react-native-deprecated-custom-components'\n```\n\n\n\n\n\n参考链接：[React Native开发](http://www.lcode.org/【react-native开发】react-native-for-android环境配置以及第一个实例/)\n[React Native 简介与入门](http://www.jianshu.com/p/5b185df2d11a)\n[reactnative集成到原生ios项目](http://www.tuicool.com/articles/BfInEv)\n[袁峥-系列](http://www.jianshu.com/p/504a26d094b2)\n\n","slug":"ReactNative学习笔记","published":1,"updated":"2017-07-14T03:57:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj53c1dvo0013h3jjtkyim1t7","content":"<h1 id=\"直接通过ReactNative方式创建项目\"><a href=\"#直接通过ReactNative方式创建项目\" class=\"headerlink\" title=\"直接通过ReactNative方式创建项目\"></a>直接通过ReactNative方式创建项目</h1><h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>必须安装：Xcode，Homebrew，node,npm<br>npm其实是Node.js的包管理工具,已经在Node.js安装的时候顺带装好了。<br>可选：React Native的命令行工具,IDE(Atom/Nuclide/Webstorm/Sublime),watchman,Flow<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">//brew</div><div class=\"line\">ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</div><div class=\"line\">brew -v</div><div class=\"line\">//node</div><div class=\"line\">brew install node</div><div class=\"line\">//React Native的命令行工具</div><div class=\"line\">npm install -g react-native-cli</div><div class=\"line\">//watchman</div><div class=\"line\">brew install watchman</div><div class=\"line\">//flow</div><div class=\"line\">brew install flow</div></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<h2 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ react-native init RNDemo</div></pre></td></tr></table></figure>\n<p>运行项目:使用命令行或Xcode<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ react-native run-ios</div><div class=\"line\">$ react-native run-android</div><div class=\"line\"></div><div class=\"line\">......</div><div class=\"line\"></div><div class=\"line\">React packager ready.</div><div class=\"line\">Loading dependency graph, done.</div><div class=\"line\">`</div></pre></td></tr></table></figure></p>\n<p>运行项目时如果遇到<code>&lt;React/RCTBundleURLProvider.h&gt;” file not found</code>问题，可按如下方法试着解决：</p>\n<ul>\n<li>把项目里面的 node_modules 文件夹删除掉</li>\n<li>npm install</li>\n<li>react-native upgrade</li>\n<li>clean,run</li>\n</ul>\n<h1 id=\"JavaScript基础\"><a href=\"#JavaScript基础\" class=\"headerlink\" title=\"JavaScript基础\"></a>JavaScript基础</h1><p>(1){}表示定义一个对象<br>(2)var,let,function,弱类型,typeof(),isNaN()<br>数据类型：Boolean,null,undefined,Number,String,Symbol,Object<br>false:false,undefined,NaN,null,””,0<br>显式类型转换：parseInt()<br>隐式类型转换：==,-,*,/<br>数组：var a = [“1”,”2”,”3”]<br>     var a = new Array(“1”,”2”,”3”)<br>     var a = Array(“1”,”2”,”3”)<br>字典：{}</p>\n<blockquote>\n<p>JS:基于原型(所有对象均为实例,通过构造器函数来定义和创建一组对象)<br>OC：基于类<br>(3)Promises(ES6)<br>JS本身是单线程的语言，它要实现异步都是通过回调函数来实现的，JS中引入了Promises来处理异步和延迟操作。<br>    promise有以下几种状态：</p>\n<pre><code>* pending，最初的状态\n* fulfilled，执行成功\n* rejected，执行出错\n* settled，执行结束了，失败(rejected)或者成功(fulfilled)\n</code></pre><p>(4)箭头函数(ES6)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(s) =&gt; s.length 等同于 function(s)&#123; return s.length &#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>普通函数.bind(this) 来把内部函数中的this绑定到了外部函数去。<br>箭头函数里的this还是原来的this，不需要额外绑定。<br>(5)模板字符串(ES6)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">var html = `公司名：$&#123;name&#125;   </div><div class=\"line\">简介：$&#123;desc&#125;`;</div><div class=\"line\"></div><div class=\"line\">等同于</div><div class=\"line\"></div><div class=\"line\">var tpl = &apos;公司名：&apos; + name + &apos;\\n&apos;+</div><div class=\"line\">&apos;简介：&apos;+ desc;</div></pre></td></tr></table></figure></p>\n<h1 id=\"React基础\"><a href=\"#React基础\" class=\"headerlink\" title=\"React基础\"></a>React基础</h1><h2 id=\"组件（component）\"><a href=\"#组件（component）\" class=\"headerlink\" title=\"组件（component）\"></a>组件（component）</h2><p>是React类的基类，进行视图展示。</p>\n<ul>\n<li>组件的属性(prop)：组件之前通过标签的属性来传递数据，由父组件传递给子组件(单向的属性传递)</li>\n<li>组件的状态(state)<ul>\n<li>每次调用setState时都会更新组件的状态，触发render函数进行渲染更新界面（render方法是被异步调用的，这可以保证同步的多个setState方法只会触发一次render）</li>\n<li>组件自己不可以自己修改props（即：props可认为是只读的），只可由其他组件调用它时在外部修改</li>\n</ul>\n</li>\n<li>createClass：创建一个component</li>\n<li>render()：返回的的 JSX 模板需要一个根元素包裹起来<br>返回一个根的视图，用来渲染实际的Component可视部分</li>\n<li>getInitialState()：只能在用React.createClass创建的时候使用<br>在Component被加载之前调用一次，这个方法的返回值会被设置为this.state</li>\n<li>getDefaultProps()：在Class 创建的时候，调用一次，这个方法在调用的时候，任何实例还没有被创建<br>返回的任何Object 对象，在各个实例中是共享的</li>\n</ul>\n<h2 id=\"组件的生命周期\"><a href=\"#组件的生命周期\" class=\"headerlink\" title=\"组件的生命周期\"></a>组件的生命周期</h2><p><img src=\"http://o8cfktdb3.bkt.clouddn.com/componentLifeCycle.png\" alt=\"组件生命周期\"></p>\n<p>(1)创建：getDefaultProps(ES6:defaultProps)-&gt;<br>(2)实例化：getInitialState(ES6:constructor)-&gt;componentWillMount-&gt;render-&gt;componentDidMount-&gt;<br>(3)运行更新阶段：</p>\n<pre><code>+ 运行中-&gt;props改变-&gt;componentWillReceiveProps-&gt;\n+ 运行中-&gt;state改变-&gt;\n</code></pre><p>shouldComponentUpdate-&gt;</p>\n<pre><code>+ false-&gt;运行中\n+ true-&gt;componentWillUpdate-&gt;render-&gt;componentDidUpdate-&gt;运行中\n</code></pre><p>(4)销毁阶段：Unmount(卸载)-&gt;componentWillUnmount</p>\n<table>\n<thead>\n<tr>\n<th>生命周期</th>\n<th>调用次数</th>\n<th>能否使用 setSate()</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>defaultProps / getDefaultProps</td>\n<td>1(全局调用一次)</td>\n<td>否</td>\n</tr>\n<tr>\n<td>constructor / getInitialState</td>\n<td>1</td>\n<td>否</td>\n</tr>\n<tr>\n<td>componentWillMount</td>\n<td>1</td>\n<td>是</td>\n</tr>\n<tr>\n<td>render</td>\n<td>&gt;=1</td>\n<td>否</td>\n</tr>\n<tr>\n<td>componentDidMount</td>\n<td>1</td>\n<td>是</td>\n</tr>\n<tr>\n<td>componentWillReceiveProps</td>\n<td>&gt;=0</td>\n<td>是</td>\n</tr>\n<tr>\n<td>shouldComponentUpdate</td>\n<td>&gt;=0</td>\n<td>否</td>\n</tr>\n<tr>\n<td>componentWillUpdate</td>\n<td>&gt;=0</td>\n<td>否</td>\n</tr>\n<tr>\n<td>componentDidUpdate</td>\n<td>&gt;=0</td>\n<td>否</td>\n</tr>\n<tr>\n<td>componentWillUnmount</td>\n<td>1</td>\n<td>否</td>\n</tr>\n</tbody>\n</table>\n<p>(1)getDefaultProps(ES6:defaultProps):初始化一些默认的属性，一个控件可以利用this.props获取并初始化它的属性</p>\n<pre><code>+ ES5:getDefaultProps:function(){},propTypes:{},\n+ ES6:static defaultProps={};static propTypes={};\n</code></pre><p>(2)constructor(props) / getInitialState():状态初始化</p>\n<pre><code>+ ES5:getInitialState: function(){}\n+ ES6:constructor(props){}\n</code></pre><p>(3)componentWillMount():准备加载组件，业务初始化操作，也可以设置组件状态<br>(4)render():渲染界面，返回JSX或其它组件来构成DOM，只能返回一个顶级元素<br>(5)componentDidMount():组件加载成功并被成功渲染，一般会做一些网络请求等加载数据的操作</p>\n<p>(6)componentWillReceiveProps():组件接收到新的props会触发，可以调用setState()来完成对state的修改，nextProps 是即将被设置的属性，旧的属性还是可以通过 this.props 来获取<br>(7)shouldComponentUpdate():返回布尔值（决定是否需要更新组件）<br>(8)componentWillUpdate():shouldComponentUpdate返回true或者调用forceUpdate之后触发此方法，会把 nextProps 和 nextState 分别设置到 this.props 和 this.state 中，开始准备更新组件。不能使用 this.setState 来修改状态。<br>(9)render()：再确定需要更新组件时，调用render，根据diff算法，渲染界面，生成需要更新的虚拟DOM数据。<br>(10)componentDidUpdate():可以在这个方法中做DOM操作，首次render之后调用componentDidMount，其它render结束之后都是调用componentDidUpdate。<br>(11)componentWillUnmount():组件从DOM中移除，可以做一些组件相关的清理工作，例如取消计时器、网络请求。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">注意：绝对不要在componentWillUpdate和componentDidUpdate中调用this.setState方法，否则将导致无限循环调用。</div></pre></td></tr></table></figure></p>\n<h2 id=\"组件更新的四种方式\"><a href=\"#组件更新的四种方式\" class=\"headerlink\" title=\"组件更新的四种方式\"></a>组件更新的四种方式</h2><p>(1)首次Initial Render，即首次加载组件<br>(2)调用this.setState<br>(3)父组件发生更新<br>(4)调用this.forceUpdate强制更新</p>\n<h2 id=\"statics\"><a href=\"#statics\" class=\"headerlink\" title=\"statics\"></a>statics</h2><p>定义Components可以调用的静态方法</p>\n<h1 id=\"RN与原生项目\"><a href=\"#RN与原生项目\" class=\"headerlink\" title=\"RN与原生项目\"></a>RN与原生项目</h1><h2 id=\"先创建iOS项目，再集成React-Native到原生项目\"><a href=\"#先创建iOS项目，再集成React-Native到原生项目\" class=\"headerlink\" title=\"先创建iOS项目，再集成React Native到原生项目\"></a>先创建iOS项目，再集成React Native到原生项目</h2><p>(1) 先通过Xcode创建项目<br>(2) 在项目目录下创建一个reactivenative文件夹存放react native相关文件，再创建一个package.json文件，用于初始化react-native<br>package.json内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">&quot;name&quot;: &quot;RNDemo&quot;,</div><div class=\"line\">&quot;version&quot;: &quot;1.0.0&quot;,</div><div class=\"line\">&quot;private&quot;: true,</div><div class=\"line\">&quot;dependencies&quot;: &#123;</div><div class=\"line\">&quot;react&quot;: &quot;^15.6.1&quot;,</div><div class=\"line\">&quot;react-native&quot;: &quot;^0.45.1&quot;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>(3) 在reactivenative目录下执行命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install</div></pre></td></tr></table></figure></p>\n<p>或者安装指定版本的react/react-native<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install --save react-native@0.45.1</div><div class=\"line\">$ npm install --save react@15.6.1</div></pre></td></tr></table></figure></p>\n<p>(4) 创建index.ios.js文件<br>注意当前项目名称为<code>RNDemo</code>，修改为实际项目名称。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">&apos;use strict&apos;;</div><div class=\"line\"></div><div class=\"line\">var React = require(&apos;react-native&apos;);  </div><div class=\"line\">var &#123;  </div><div class=\"line\">Text,</div><div class=\"line\">View</div><div class=\"line\">&#125; = React;</div><div class=\"line\"></div><div class=\"line\">var styles = React.StyleSheet.create(&#123;  </div><div class=\"line\">container: &#123;</div><div class=\"line\">flex: 1,</div><div class=\"line\">backgroundColor: &apos;red&apos;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">class RNDemo extends React.Component &#123;  </div><div class=\"line\">render() &#123;</div><div class=\"line\">return (</div><div class=\"line\">&lt;View style=&#123;styles.container&#125;&gt;</div><div class=\"line\">&lt;Text&gt;This is a simple application.&lt;/Text&gt;</div><div class=\"line\">&lt;/View&gt;</div><div class=\"line\">)</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">React.AppRegistry.registerComponent(&apos;RNDemo&apos;, () =&gt; RNDemo);</div></pre></td></tr></table></figure></p>\n<p>(5) Cocoapods集成react-native<br>在工程目录下创建Podfile文件，内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 请将:path后面的内容为node_modules文件夹路径。</div><div class=\"line\">plateform :ios, &apos;8.0&apos;</div><div class=\"line\">target &quot;RNDemo&quot; do</div><div class=\"line\">pod &apos;React&apos;, :path =&gt; &apos;./reactivenative/node_modules/react-native&apos;, :subspecs =&gt; [</div><div class=\"line\">&apos;Core&apos;,</div><div class=\"line\">&apos;RCTImage&apos;,</div><div class=\"line\">&apos;RCTNetwork&apos;,</div><div class=\"line\">&apos;RCTText&apos;,</div><div class=\"line\">&apos;RCTWebSocket&apos;,</div><div class=\"line\"># 添加其他你想在工程中使用的依赖。</div><div class=\"line\">]</div><div class=\"line\">end</div></pre></td></tr></table></figure></p>\n<p>执行<code>pod install</code>即可<br>如果出现如下问题：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">The dependency `React/Core (from `./reactivenative/node_modules/react-native`)` is not used in any concrete target.</div></pre></td></tr></table></figure></p>\n<p>在项目首尾请添加上target即可<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">target &quot;RNDemo&quot; do </div><div class=\"line\">end</div></pre></td></tr></table></figure></p>\n<p>(6)添加react native应用<br>创建一个ReactView视图文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (instancetype)initWithFrame:(CGRect)frame</div><div class=\"line\">&#123;</div><div class=\"line\">if (self = [super initWithFrame:frame]) &#123;</div><div class=\"line\">NSString * strUrl = @&quot;http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true&quot;;</div><div class=\"line\">NSURL * jsCodeLocation = [NSURL URLWithString:strUrl];</div><div class=\"line\"></div><div class=\"line\">RCTRootView * rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation</div><div class=\"line\">moduleName:@&quot;SimpleApp&quot;</div><div class=\"line\">initialProperties:nil</div><div class=\"line\">launchOptions:nil];</div><div class=\"line\"></div><div class=\"line\">[self addSubview:rootView];</div><div class=\"line\"></div><div class=\"line\">rootView.frame = self.bounds;</div><div class=\"line\">&#125;</div><div class=\"line\">return self;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>ReactView.m 中通过 <a href=\"http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true\" target=\"_blank\" rel=\"external\">http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true</a> 加载bundle文件</p>\n<p>在ViewController中加载这个视图<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">ReactView * reactView = [[ReactView alloc] initWithFrame:CGRectMake(0, 40, CGRectGetWidth(self.view.bounds), 100)];</div><div class=\"line\"></div><div class=\"line\">[self.view addSubview:reactView];</div></pre></td></tr></table></figure></p>\n<p>(7)启动开发服务器<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd reactivenative</div><div class=\"line\">$ react-native start</div></pre></td></tr></table></figure></p>\n<p>(8)Info.list中修改NSAppTransportSecurity配置<br>(9)在Xcode中运行项目，完成</p>\n<h3 id=\"升级Xcode8后遇到的错误\"><a href=\"#升级Xcode8后遇到的错误\" class=\"headerlink\" title=\"升级Xcode8后遇到的错误\"></a>升级Xcode8后遇到的错误</h3><p>Q1:’React/RCTBundleURLProvider.h’ file not found<br>A1:进入react native所在目录，将node_modules文件夹删除，执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install</div><div class=\"line\">$ react-native upgrade</div></pre></td></tr></table></figure></p>\n<p>clean，重新运行</p>\n<p>Q2:RCTSCrollView.m 中_refreshControl找不到<br>A2:在@implementation RCTCustomScrollView下添加如下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">@implementation RCTCustomScrollView</div><div class=\"line\">&#123;</div><div class=\"line\">RCTRefreshControl *_refreshControl;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Q3:控制台不断输出<code>[] nw_connection_get_connected_socket_block_invoke 710 Connection has no connected handler</code><br>A3:edit scheme-&gt;arguments-&gt;Environment Variables-&gt;添加Name: “OS_ACTIVITY_MODE”, Value:”disable”</p>\n<h2 id=\"原生和React-Native之间的通信方式\"><a href=\"#原生和React-Native之间的通信方式\" class=\"headerlink\" title=\"原生和React Native之间的通信方式\"></a>原生和React Native之间的通信方式</h2><p>主要包括三部分：</p>\n<ul>\n<li>属性</li>\n<li>原生模块</li>\n<li>原生UI组件封装</li>\n</ul>\n<h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><p>原生给JS传数据，主要依靠属性。<br>(1)原生-&gt;React Native 传递属性<br>initialProperties必须是NSDictionary的一个实例。这一字典参数会在内部被转化为一个可供JS组件调用的JSON对象。<br>(2)原生-&gt;React Native 更新属性<br>RCTRootView同样提供了一个可读写的属性appProperties,可以通过componentWillMount访问新的属性值。</p>\n<ul>\n<li>更新必须在主线程中进行，读取则可以在任何线程中进行。</li>\n<li>更新属性时并不能做到只更新一部分属性。建议自己封装一个函数来构造属性。<br>(3)React Native-&gt;原生<br>宏RCT_CUSTOM_VIEW_PROPERTY</li>\n</ul>\n<h3 id=\"原生模块\"><a href=\"#原生模块\" class=\"headerlink\" title=\"原生模块\"></a>原生模块</h3><p>原生模块是JS中也可以使用的Objective-C类。一个“原生模块”就是一个实现了“RCTBridgeModule”协议的Objective-C类。</p>\n<h3 id=\"原生UI组件封装\"><a href=\"#原生UI组件封装\" class=\"headerlink\" title=\"原生UI组件封装\"></a>原生UI组件封装</h3><h2 id=\"FlexBox\"><a href=\"#FlexBox\" class=\"headerlink\" title=\"FlexBox\"></a>FlexBox</h2><p>1.flexDirection:row|row-reverse|column|column-reverse<br>2.flexWrap:wrap|no-wrap<br>3.justifyContent:flex-start|flex-end|center|space-between|space-around<br>4.alignItems:flex-start|flex-end|center|stretch<br>5.alignSelf:auto|flex-start|flex-end|center|stretch<br>6.flex:子控件在主轴中占据几等分</p>\n<h2 id=\"props-state\"><a href=\"#props-state\" class=\"headerlink\" title=\"props,state\"></a>props,state</h2><p>props:在父组件中指定，而且一经指定，在整个组件的生命周期中都不再改变。<br>state:constructor中声明(ES6)，在setState中修改数据<br>定义state:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">this.state = &#123;</div><div class=\"line\">num:1,</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>修改state:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">this.setState(&#123;</div><div class=\"line\">num : number</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<h2 id=\"父子组件传值\"><a href=\"#父子组件传值\" class=\"headerlink\" title=\"父子组件传值\"></a>父子组件传值</h2><p>1.父传子<br>(1)props:this.props.name<br>(2)ref:this.refs.son.receiveMsg(“msg”)<br>2.子传父<br>(1)方法回调<br>父组件：定义一个处理接收到值的方法，把这个方法传递给子组件，并且绑定this<br>子组件：通过this.props拿到这个方法调用<br>3.无关联组件间传值<br>(1)通知:组件1传值给组件2<br>组件1：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;Text onPress=&#123;()=&gt;&#123;</div><div class=\"line\">DeviceEventEmitter.emit(&apos;NotificationName&apos;,123);</div><div class=\"line\">&#125;&#125;&gt;&lt;/Text&gt;</div></pre></td></tr></table></figure></p>\n<p>组件2：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">this.lister = DeviceEventEmitter.addListener(&apos;NotificationName&apos;,(value)=&gt;&#123;</div><div class=\"line\">this.setState(&#123;</div><div class=\"line\">value:value</div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<h2 id=\"组件生命周期\"><a href=\"#组件生命周期\" class=\"headerlink\" title=\"组件生命周期\"></a>组件生命周期</h2><p>实例化<br>1.constructor:初始化state（只调用一次）<br>2.componentWillMount:即将加载组件调用，render前（只调用一次）<br>3.render:渲染组件<br>4.componentDidMount:组件加载完成调用，render后（只调用一次）<br>运行<br>5.componentWillReceiveProps:props改变调用<br>6.shouldComponentUpdate:props/state改变调用，可控制是否刷新界面<br>7.componentWillUpdate:组件即将更新调用（调用this.setState会循环）<br>8.render<br>9.componentDidUpdate:组件更新完成（调用this.setState会循环）<br>销毁<br>10.componentWillUnmount:组件即将销毁，可移除观察者，清空数据等</p>\n<h2 id=\"propTypes\"><a href=\"#propTypes\" class=\"headerlink\" title=\"propTypes\"></a>propTypes</h2><p>必须要用static修饰，否则无效<br>static：用来定义类方法或者类属性，定义类的方法和属性，生成的对象就自动有这样的属性了。<br>1.类型检查：当传入错误的属性值，会报警告，但是不会报错<br>&gt;</p>\n<h1 id=\"数组类型\"><a href=\"#数组类型\" class=\"headerlink\" title=\"数组类型\"></a>数组类型</h1><p>PropTypes.array</p>\n<h1 id=\"布尔类型\"><a href=\"#布尔类型\" class=\"headerlink\" title=\"布尔类型\"></a>布尔类型</h1><p>PropTypes.bool</p>\n<h1 id=\"函数类型\"><a href=\"#函数类型\" class=\"headerlink\" title=\"函数类型\"></a>函数类型</h1><p>PropTypes.func</p>\n<h1 id=\"数值类型\"><a href=\"#数值类型\" class=\"headerlink\" title=\"数值类型\"></a>数值类型</h1><p>PropTypes.number</p>\n<h1 id=\"对象类型\"><a href=\"#对象类型\" class=\"headerlink\" title=\"对象类型\"></a>对象类型</h1><p>PropTypes.object</p>\n<h1 id=\"字符串类型\"><a href=\"#字符串类型\" class=\"headerlink\" title=\"字符串类型\"></a>字符串类型</h1><p>PropTypes.string</p>\n<h1 id=\"规定prop为必传字段\"><a href=\"#规定prop为必传字段\" class=\"headerlink\" title=\"规定prop为必传字段\"></a>规定prop为必传字段</h1><p>PropTypes.func.isRequired</p>\n<h1 id=\"prop可为任意类型\"><a href=\"#prop可为任意类型\" class=\"headerlink\" title=\"prop可为任意类型\"></a>prop可为任意类型</h1><p>PropTypes.any.isRequired<br>&gt;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 定义属性</div><div class=\"line\">static propTypes = &#123;</div><div class=\"line\">    name:PropTypes.string,</div><div class=\"line\">    age:PropTypes.number</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>2.设置初始化值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">static defaultProps = &#123;</div><div class=\"line\">    name:&apos;xiaoming&apos;,</div><div class=\"line\">    age:20</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"基本组件\"><a href=\"#基本组件\" class=\"headerlink\" title=\"基本组件\"></a>基本组件</h2><p>1.View<br>2.TouchableOpacity<br>默认点击区域是所有子控件的区域,因为默认一个组件的尺寸由子控件决定</p>\n<ul>\n<li>点击事件：onPress|onLongPress|onPressIn|onPressOut</li>\n<li>disabled:true|false<br>3.Text</li>\n<li>numberOfLines</li>\n<li>selectable:true|false 是否允许长按选择文本</li>\n<li>suppressHighlighting:true|false 是否允许按下时有灰色阴影</li>\n<li>onPress:文字点击事件</li>\n</ul>\n<h2 id=\"ListView\"><a href=\"#ListView\" class=\"headerlink\" title=\"ListView\"></a>ListView</h2><p>1.创建数据源，给数据源设置数据<br>使用state保存数据源</p>\n<ul>\n<li>不分组使用：cloneWithRows</li>\n<li>分组使用：cloneWithRowsAndSections<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var dataSource = new ListView.DataSource(&#123;rowHasChanged: (r1, r2) =&gt; r1 !== r2&#125;);</div><div class=\"line\">this.state = &#123;</div><div class=\"line\">ds: dataSource.cloneWithRows([&apos;row 1&apos;, &apos;row 2&apos;]),</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var dataSource = new ListView.DataSource(&#123;</div><div class=\"line\">rowHasChanged:(r1,r2)=&gt;r1 !== r2,</div><div class=\"line\">sectionHeaderHasChanged:(s1,s2)=&gt;s1 !== s2</div><div class=\"line\">&#125;);</div><div class=\"line\">var sectionData = &#123;&#125;;</div><div class=\"line\">this.state = &#123;</div><div class=\"line\">ds : dataSource.cloneWithRowsAndSections(sectionData)</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>2.实现数据源方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;ListView dataSource=&#123;this.state.ds&#125;</div><div class=\"line\">renderRow=&#123;this._renderRow.bind(this)&#125;</div><div class=\"line\">renderSectionHeader=&#123;this._renderSectionHeader.bind(this)&#125;</div><div class=\"line\">//renderSeparator=&#123;this._renderSeparator.bind(this)&#125;</div><div class=\"line\">/&gt;</div><div class=\"line\"></div><div class=\"line\">_renderRow(rowData, sectionID, rowID, highlightRow) &#123;</div><div class=\"line\">return (</div><div class=\"line\">&lt;View&gt;</div><div class=\"line\">&lt;Text&gt;&#123;rowData&#125;&lt;/Text&gt;</div><div class=\"line\">&lt;/View&gt;</div><div class=\"line\">);</div><div class=\"line\">&#125;</div><div class=\"line\">//如果是组视图，设置组数据</div><div class=\"line\">_renderSectionHeader(sectionData, sectionID) &#123;</div><div class=\"line\">return (</div><div class=\"line\">&lt;View&gt;</div><div class=\"line\">&lt;Text&gt;&#123;sectionID&#125;&lt;/Text&gt;</div><div class=\"line\">&lt;/View&gt;</div><div class=\"line\">)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"导航Navigator\"><a href=\"#导航Navigator\" class=\"headerlink\" title=\"导航Navigator\"></a>导航Navigator</h2><p>如果找不到Navigator，安装Navigator所在的库：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install react-native-deprecated-custom-components --save</div><div class=\"line\">//yarn add react-native-deprecated-custom-components</div></pre></td></tr></table></figure></p>\n<p>项目导入：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">import &#123;Navigator&#125; from &apos;react-native-deprecated-custom-components&apos;</div></pre></td></tr></table></figure></p>\n<p>参考链接：<a href=\"http://www.lcode.org/【react-native开发】react-native-for-android环境配置以及第一个实例/\" target=\"_blank\" rel=\"external\">React Native开发</a><br><a href=\"http://www.jianshu.com/p/5b185df2d11a\" target=\"_blank\" rel=\"external\">React Native 简介与入门</a><br><a href=\"http://www.tuicool.com/articles/BfInEv\" target=\"_blank\" rel=\"external\">reactnative集成到原生ios项目</a><br><a href=\"http://www.jianshu.com/p/504a26d094b2\" target=\"_blank\" rel=\"external\">袁峥-系列</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"直接通过ReactNative方式创建项目\"><a href=\"#直接通过ReactNative方式创建项目\" class=\"headerlink\" title=\"直接通过ReactNative方式创建项目\"></a>直接通过ReactNative方式创建项目</h1><h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>必须安装：Xcode，Homebrew，node,npm<br>npm其实是Node.js的包管理工具,已经在Node.js安装的时候顺带装好了。<br>可选：React Native的命令行工具,IDE(Atom/Nuclide/Webstorm/Sublime),watchman,Flow<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">//brew</div><div class=\"line\">ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</div><div class=\"line\">brew -v</div><div class=\"line\">//node</div><div class=\"line\">brew install node</div><div class=\"line\">//React Native的命令行工具</div><div class=\"line\">npm install -g react-native-cli</div><div class=\"line\">//watchman</div><div class=\"line\">brew install watchman</div><div class=\"line\">//flow</div><div class=\"line\">brew install flow</div></pre></td></tr></table></figure></p>","more":"<h2 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ react-native init RNDemo</div></pre></td></tr></table></figure>\n<p>运行项目:使用命令行或Xcode<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ react-native run-ios</div><div class=\"line\">$ react-native run-android</div><div class=\"line\"></div><div class=\"line\">......</div><div class=\"line\"></div><div class=\"line\">React packager ready.</div><div class=\"line\">Loading dependency graph, done.</div><div class=\"line\">`</div></pre></td></tr></table></figure></p>\n<p>运行项目时如果遇到<code>&lt;React/RCTBundleURLProvider.h&gt;” file not found</code>问题，可按如下方法试着解决：</p>\n<ul>\n<li>把项目里面的 node_modules 文件夹删除掉</li>\n<li>npm install</li>\n<li>react-native upgrade</li>\n<li>clean,run</li>\n</ul>\n<h1 id=\"JavaScript基础\"><a href=\"#JavaScript基础\" class=\"headerlink\" title=\"JavaScript基础\"></a>JavaScript基础</h1><p>(1){}表示定义一个对象<br>(2)var,let,function,弱类型,typeof(),isNaN()<br>数据类型：Boolean,null,undefined,Number,String,Symbol,Object<br>false:false,undefined,NaN,null,””,0<br>显式类型转换：parseInt()<br>隐式类型转换：==,-,*,/<br>数组：var a = [“1”,”2”,”3”]<br>     var a = new Array(“1”,”2”,”3”)<br>     var a = Array(“1”,”2”,”3”)<br>字典：{}</p>\n<blockquote>\n<p>JS:基于原型(所有对象均为实例,通过构造器函数来定义和创建一组对象)<br>OC：基于类<br>(3)Promises(ES6)<br>JS本身是单线程的语言，它要实现异步都是通过回调函数来实现的，JS中引入了Promises来处理异步和延迟操作。<br>    promise有以下几种状态：</p>\n<pre><code>* pending，最初的状态\n* fulfilled，执行成功\n* rejected，执行出错\n* settled，执行结束了，失败(rejected)或者成功(fulfilled)\n</code></pre><p>(4)箭头函数(ES6)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(s) =&gt; s.length 等同于 function(s)&#123; return s.length &#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>普通函数.bind(this) 来把内部函数中的this绑定到了外部函数去。<br>箭头函数里的this还是原来的this，不需要额外绑定。<br>(5)模板字符串(ES6)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">var html = `公司名：$&#123;name&#125;   </div><div class=\"line\">简介：$&#123;desc&#125;`;</div><div class=\"line\"></div><div class=\"line\">等同于</div><div class=\"line\"></div><div class=\"line\">var tpl = &apos;公司名：&apos; + name + &apos;\\n&apos;+</div><div class=\"line\">&apos;简介：&apos;+ desc;</div></pre></td></tr></table></figure></p>\n<h1 id=\"React基础\"><a href=\"#React基础\" class=\"headerlink\" title=\"React基础\"></a>React基础</h1><h2 id=\"组件（component）\"><a href=\"#组件（component）\" class=\"headerlink\" title=\"组件（component）\"></a>组件（component）</h2><p>是React类的基类，进行视图展示。</p>\n<ul>\n<li>组件的属性(prop)：组件之前通过标签的属性来传递数据，由父组件传递给子组件(单向的属性传递)</li>\n<li>组件的状态(state)<ul>\n<li>每次调用setState时都会更新组件的状态，触发render函数进行渲染更新界面（render方法是被异步调用的，这可以保证同步的多个setState方法只会触发一次render）</li>\n<li>组件自己不可以自己修改props（即：props可认为是只读的），只可由其他组件调用它时在外部修改</li>\n</ul>\n</li>\n<li>createClass：创建一个component</li>\n<li>render()：返回的的 JSX 模板需要一个根元素包裹起来<br>返回一个根的视图，用来渲染实际的Component可视部分</li>\n<li>getInitialState()：只能在用React.createClass创建的时候使用<br>在Component被加载之前调用一次，这个方法的返回值会被设置为this.state</li>\n<li>getDefaultProps()：在Class 创建的时候，调用一次，这个方法在调用的时候，任何实例还没有被创建<br>返回的任何Object 对象，在各个实例中是共享的</li>\n</ul>\n<h2 id=\"组件的生命周期\"><a href=\"#组件的生命周期\" class=\"headerlink\" title=\"组件的生命周期\"></a>组件的生命周期</h2><p><img src=\"http://o8cfktdb3.bkt.clouddn.com/componentLifeCycle.png\" alt=\"组件生命周期\"></p>\n<p>(1)创建：getDefaultProps(ES6:defaultProps)-&gt;<br>(2)实例化：getInitialState(ES6:constructor)-&gt;componentWillMount-&gt;render-&gt;componentDidMount-&gt;<br>(3)运行更新阶段：</p>\n<pre><code>+ 运行中-&gt;props改变-&gt;componentWillReceiveProps-&gt;\n+ 运行中-&gt;state改变-&gt;\n</code></pre><p>shouldComponentUpdate-&gt;</p>\n<pre><code>+ false-&gt;运行中\n+ true-&gt;componentWillUpdate-&gt;render-&gt;componentDidUpdate-&gt;运行中\n</code></pre><p>(4)销毁阶段：Unmount(卸载)-&gt;componentWillUnmount</p>\n<table>\n<thead>\n<tr>\n<th>生命周期</th>\n<th>调用次数</th>\n<th>能否使用 setSate()</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>defaultProps / getDefaultProps</td>\n<td>1(全局调用一次)</td>\n<td>否</td>\n</tr>\n<tr>\n<td>constructor / getInitialState</td>\n<td>1</td>\n<td>否</td>\n</tr>\n<tr>\n<td>componentWillMount</td>\n<td>1</td>\n<td>是</td>\n</tr>\n<tr>\n<td>render</td>\n<td>&gt;=1</td>\n<td>否</td>\n</tr>\n<tr>\n<td>componentDidMount</td>\n<td>1</td>\n<td>是</td>\n</tr>\n<tr>\n<td>componentWillReceiveProps</td>\n<td>&gt;=0</td>\n<td>是</td>\n</tr>\n<tr>\n<td>shouldComponentUpdate</td>\n<td>&gt;=0</td>\n<td>否</td>\n</tr>\n<tr>\n<td>componentWillUpdate</td>\n<td>&gt;=0</td>\n<td>否</td>\n</tr>\n<tr>\n<td>componentDidUpdate</td>\n<td>&gt;=0</td>\n<td>否</td>\n</tr>\n<tr>\n<td>componentWillUnmount</td>\n<td>1</td>\n<td>否</td>\n</tr>\n</tbody>\n</table>\n<p>(1)getDefaultProps(ES6:defaultProps):初始化一些默认的属性，一个控件可以利用this.props获取并初始化它的属性</p>\n<pre><code>+ ES5:getDefaultProps:function(){},propTypes:{},\n+ ES6:static defaultProps={};static propTypes={};\n</code></pre><p>(2)constructor(props) / getInitialState():状态初始化</p>\n<pre><code>+ ES5:getInitialState: function(){}\n+ ES6:constructor(props){}\n</code></pre><p>(3)componentWillMount():准备加载组件，业务初始化操作，也可以设置组件状态<br>(4)render():渲染界面，返回JSX或其它组件来构成DOM，只能返回一个顶级元素<br>(5)componentDidMount():组件加载成功并被成功渲染，一般会做一些网络请求等加载数据的操作</p>\n<p>(6)componentWillReceiveProps():组件接收到新的props会触发，可以调用setState()来完成对state的修改，nextProps 是即将被设置的属性，旧的属性还是可以通过 this.props 来获取<br>(7)shouldComponentUpdate():返回布尔值（决定是否需要更新组件）<br>(8)componentWillUpdate():shouldComponentUpdate返回true或者调用forceUpdate之后触发此方法，会把 nextProps 和 nextState 分别设置到 this.props 和 this.state 中，开始准备更新组件。不能使用 this.setState 来修改状态。<br>(9)render()：再确定需要更新组件时，调用render，根据diff算法，渲染界面，生成需要更新的虚拟DOM数据。<br>(10)componentDidUpdate():可以在这个方法中做DOM操作，首次render之后调用componentDidMount，其它render结束之后都是调用componentDidUpdate。<br>(11)componentWillUnmount():组件从DOM中移除，可以做一些组件相关的清理工作，例如取消计时器、网络请求。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">注意：绝对不要在componentWillUpdate和componentDidUpdate中调用this.setState方法，否则将导致无限循环调用。</div></pre></td></tr></table></figure></p>\n<h2 id=\"组件更新的四种方式\"><a href=\"#组件更新的四种方式\" class=\"headerlink\" title=\"组件更新的四种方式\"></a>组件更新的四种方式</h2><p>(1)首次Initial Render，即首次加载组件<br>(2)调用this.setState<br>(3)父组件发生更新<br>(4)调用this.forceUpdate强制更新</p>\n<h2 id=\"statics\"><a href=\"#statics\" class=\"headerlink\" title=\"statics\"></a>statics</h2><p>定义Components可以调用的静态方法</p>\n<h1 id=\"RN与原生项目\"><a href=\"#RN与原生项目\" class=\"headerlink\" title=\"RN与原生项目\"></a>RN与原生项目</h1><h2 id=\"先创建iOS项目，再集成React-Native到原生项目\"><a href=\"#先创建iOS项目，再集成React-Native到原生项目\" class=\"headerlink\" title=\"先创建iOS项目，再集成React Native到原生项目\"></a>先创建iOS项目，再集成React Native到原生项目</h2><p>(1) 先通过Xcode创建项目<br>(2) 在项目目录下创建一个reactivenative文件夹存放react native相关文件，再创建一个package.json文件，用于初始化react-native<br>package.json内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">&quot;name&quot;: &quot;RNDemo&quot;,</div><div class=\"line\">&quot;version&quot;: &quot;1.0.0&quot;,</div><div class=\"line\">&quot;private&quot;: true,</div><div class=\"line\">&quot;dependencies&quot;: &#123;</div><div class=\"line\">&quot;react&quot;: &quot;^15.6.1&quot;,</div><div class=\"line\">&quot;react-native&quot;: &quot;^0.45.1&quot;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>(3) 在reactivenative目录下执行命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install</div></pre></td></tr></table></figure></p>\n<p>或者安装指定版本的react/react-native<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install --save react-native@0.45.1</div><div class=\"line\">$ npm install --save react@15.6.1</div></pre></td></tr></table></figure></p>\n<p>(4) 创建index.ios.js文件<br>注意当前项目名称为<code>RNDemo</code>，修改为实际项目名称。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">&apos;use strict&apos;;</div><div class=\"line\"></div><div class=\"line\">var React = require(&apos;react-native&apos;);  </div><div class=\"line\">var &#123;  </div><div class=\"line\">Text,</div><div class=\"line\">View</div><div class=\"line\">&#125; = React;</div><div class=\"line\"></div><div class=\"line\">var styles = React.StyleSheet.create(&#123;  </div><div class=\"line\">container: &#123;</div><div class=\"line\">flex: 1,</div><div class=\"line\">backgroundColor: &apos;red&apos;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">class RNDemo extends React.Component &#123;  </div><div class=\"line\">render() &#123;</div><div class=\"line\">return (</div><div class=\"line\">&lt;View style=&#123;styles.container&#125;&gt;</div><div class=\"line\">&lt;Text&gt;This is a simple application.&lt;/Text&gt;</div><div class=\"line\">&lt;/View&gt;</div><div class=\"line\">)</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">React.AppRegistry.registerComponent(&apos;RNDemo&apos;, () =&gt; RNDemo);</div></pre></td></tr></table></figure></p>\n<p>(5) Cocoapods集成react-native<br>在工程目录下创建Podfile文件，内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 请将:path后面的内容为node_modules文件夹路径。</div><div class=\"line\">plateform :ios, &apos;8.0&apos;</div><div class=\"line\">target &quot;RNDemo&quot; do</div><div class=\"line\">pod &apos;React&apos;, :path =&gt; &apos;./reactivenative/node_modules/react-native&apos;, :subspecs =&gt; [</div><div class=\"line\">&apos;Core&apos;,</div><div class=\"line\">&apos;RCTImage&apos;,</div><div class=\"line\">&apos;RCTNetwork&apos;,</div><div class=\"line\">&apos;RCTText&apos;,</div><div class=\"line\">&apos;RCTWebSocket&apos;,</div><div class=\"line\"># 添加其他你想在工程中使用的依赖。</div><div class=\"line\">]</div><div class=\"line\">end</div></pre></td></tr></table></figure></p>\n<p>执行<code>pod install</code>即可<br>如果出现如下问题：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">The dependency `React/Core (from `./reactivenative/node_modules/react-native`)` is not used in any concrete target.</div></pre></td></tr></table></figure></p>\n<p>在项目首尾请添加上target即可<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">target &quot;RNDemo&quot; do </div><div class=\"line\">end</div></pre></td></tr></table></figure></p>\n<p>(6)添加react native应用<br>创建一个ReactView视图文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (instancetype)initWithFrame:(CGRect)frame</div><div class=\"line\">&#123;</div><div class=\"line\">if (self = [super initWithFrame:frame]) &#123;</div><div class=\"line\">NSString * strUrl = @&quot;http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true&quot;;</div><div class=\"line\">NSURL * jsCodeLocation = [NSURL URLWithString:strUrl];</div><div class=\"line\"></div><div class=\"line\">RCTRootView * rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation</div><div class=\"line\">moduleName:@&quot;SimpleApp&quot;</div><div class=\"line\">initialProperties:nil</div><div class=\"line\">launchOptions:nil];</div><div class=\"line\"></div><div class=\"line\">[self addSubview:rootView];</div><div class=\"line\"></div><div class=\"line\">rootView.frame = self.bounds;</div><div class=\"line\">&#125;</div><div class=\"line\">return self;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>ReactView.m 中通过 <a href=\"http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true\" target=\"_blank\" rel=\"external\">http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true</a> 加载bundle文件</p>\n<p>在ViewController中加载这个视图<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">ReactView * reactView = [[ReactView alloc] initWithFrame:CGRectMake(0, 40, CGRectGetWidth(self.view.bounds), 100)];</div><div class=\"line\"></div><div class=\"line\">[self.view addSubview:reactView];</div></pre></td></tr></table></figure></p>\n<p>(7)启动开发服务器<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd reactivenative</div><div class=\"line\">$ react-native start</div></pre></td></tr></table></figure></p>\n<p>(8)Info.list中修改NSAppTransportSecurity配置<br>(9)在Xcode中运行项目，完成</p>\n<h3 id=\"升级Xcode8后遇到的错误\"><a href=\"#升级Xcode8后遇到的错误\" class=\"headerlink\" title=\"升级Xcode8后遇到的错误\"></a>升级Xcode8后遇到的错误</h3><p>Q1:’React/RCTBundleURLProvider.h’ file not found<br>A1:进入react native所在目录，将node_modules文件夹删除，执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install</div><div class=\"line\">$ react-native upgrade</div></pre></td></tr></table></figure></p>\n<p>clean，重新运行</p>\n<p>Q2:RCTSCrollView.m 中_refreshControl找不到<br>A2:在@implementation RCTCustomScrollView下添加如下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">@implementation RCTCustomScrollView</div><div class=\"line\">&#123;</div><div class=\"line\">RCTRefreshControl *_refreshControl;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Q3:控制台不断输出<code>[] nw_connection_get_connected_socket_block_invoke 710 Connection has no connected handler</code><br>A3:edit scheme-&gt;arguments-&gt;Environment Variables-&gt;添加Name: “OS_ACTIVITY_MODE”, Value:”disable”</p>\n<h2 id=\"原生和React-Native之间的通信方式\"><a href=\"#原生和React-Native之间的通信方式\" class=\"headerlink\" title=\"原生和React Native之间的通信方式\"></a>原生和React Native之间的通信方式</h2><p>主要包括三部分：</p>\n<ul>\n<li>属性</li>\n<li>原生模块</li>\n<li>原生UI组件封装</li>\n</ul>\n<h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><p>原生给JS传数据，主要依靠属性。<br>(1)原生-&gt;React Native 传递属性<br>initialProperties必须是NSDictionary的一个实例。这一字典参数会在内部被转化为一个可供JS组件调用的JSON对象。<br>(2)原生-&gt;React Native 更新属性<br>RCTRootView同样提供了一个可读写的属性appProperties,可以通过componentWillMount访问新的属性值。</p>\n<ul>\n<li>更新必须在主线程中进行，读取则可以在任何线程中进行。</li>\n<li>更新属性时并不能做到只更新一部分属性。建议自己封装一个函数来构造属性。<br>(3)React Native-&gt;原生<br>宏RCT_CUSTOM_VIEW_PROPERTY</li>\n</ul>\n<h3 id=\"原生模块\"><a href=\"#原生模块\" class=\"headerlink\" title=\"原生模块\"></a>原生模块</h3><p>原生模块是JS中也可以使用的Objective-C类。一个“原生模块”就是一个实现了“RCTBridgeModule”协议的Objective-C类。</p>\n<h3 id=\"原生UI组件封装\"><a href=\"#原生UI组件封装\" class=\"headerlink\" title=\"原生UI组件封装\"></a>原生UI组件封装</h3><h2 id=\"FlexBox\"><a href=\"#FlexBox\" class=\"headerlink\" title=\"FlexBox\"></a>FlexBox</h2><p>1.flexDirection:row|row-reverse|column|column-reverse<br>2.flexWrap:wrap|no-wrap<br>3.justifyContent:flex-start|flex-end|center|space-between|space-around<br>4.alignItems:flex-start|flex-end|center|stretch<br>5.alignSelf:auto|flex-start|flex-end|center|stretch<br>6.flex:子控件在主轴中占据几等分</p>\n<h2 id=\"props-state\"><a href=\"#props-state\" class=\"headerlink\" title=\"props,state\"></a>props,state</h2><p>props:在父组件中指定，而且一经指定，在整个组件的生命周期中都不再改变。<br>state:constructor中声明(ES6)，在setState中修改数据<br>定义state:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">this.state = &#123;</div><div class=\"line\">num:1,</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>修改state:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">this.setState(&#123;</div><div class=\"line\">num : number</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<h2 id=\"父子组件传值\"><a href=\"#父子组件传值\" class=\"headerlink\" title=\"父子组件传值\"></a>父子组件传值</h2><p>1.父传子<br>(1)props:this.props.name<br>(2)ref:this.refs.son.receiveMsg(“msg”)<br>2.子传父<br>(1)方法回调<br>父组件：定义一个处理接收到值的方法，把这个方法传递给子组件，并且绑定this<br>子组件：通过this.props拿到这个方法调用<br>3.无关联组件间传值<br>(1)通知:组件1传值给组件2<br>组件1：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;Text onPress=&#123;()=&gt;&#123;</div><div class=\"line\">DeviceEventEmitter.emit(&apos;NotificationName&apos;,123);</div><div class=\"line\">&#125;&#125;&gt;&lt;/Text&gt;</div></pre></td></tr></table></figure></p>\n<p>组件2：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">this.lister = DeviceEventEmitter.addListener(&apos;NotificationName&apos;,(value)=&gt;&#123;</div><div class=\"line\">this.setState(&#123;</div><div class=\"line\">value:value</div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<h2 id=\"组件生命周期\"><a href=\"#组件生命周期\" class=\"headerlink\" title=\"组件生命周期\"></a>组件生命周期</h2><p>实例化<br>1.constructor:初始化state（只调用一次）<br>2.componentWillMount:即将加载组件调用，render前（只调用一次）<br>3.render:渲染组件<br>4.componentDidMount:组件加载完成调用，render后（只调用一次）<br>运行<br>5.componentWillReceiveProps:props改变调用<br>6.shouldComponentUpdate:props/state改变调用，可控制是否刷新界面<br>7.componentWillUpdate:组件即将更新调用（调用this.setState会循环）<br>8.render<br>9.componentDidUpdate:组件更新完成（调用this.setState会循环）<br>销毁<br>10.componentWillUnmount:组件即将销毁，可移除观察者，清空数据等</p>\n<h2 id=\"propTypes\"><a href=\"#propTypes\" class=\"headerlink\" title=\"propTypes\"></a>propTypes</h2><p>必须要用static修饰，否则无效<br>static：用来定义类方法或者类属性，定义类的方法和属性，生成的对象就自动有这样的属性了。<br>1.类型检查：当传入错误的属性值，会报警告，但是不会报错<br>&gt;</p>\n<h1 id=\"数组类型\"><a href=\"#数组类型\" class=\"headerlink\" title=\"数组类型\"></a>数组类型</h1><p>PropTypes.array</p>\n<h1 id=\"布尔类型\"><a href=\"#布尔类型\" class=\"headerlink\" title=\"布尔类型\"></a>布尔类型</h1><p>PropTypes.bool</p>\n<h1 id=\"函数类型\"><a href=\"#函数类型\" class=\"headerlink\" title=\"函数类型\"></a>函数类型</h1><p>PropTypes.func</p>\n<h1 id=\"数值类型\"><a href=\"#数值类型\" class=\"headerlink\" title=\"数值类型\"></a>数值类型</h1><p>PropTypes.number</p>\n<h1 id=\"对象类型\"><a href=\"#对象类型\" class=\"headerlink\" title=\"对象类型\"></a>对象类型</h1><p>PropTypes.object</p>\n<h1 id=\"字符串类型\"><a href=\"#字符串类型\" class=\"headerlink\" title=\"字符串类型\"></a>字符串类型</h1><p>PropTypes.string</p>\n<h1 id=\"规定prop为必传字段\"><a href=\"#规定prop为必传字段\" class=\"headerlink\" title=\"规定prop为必传字段\"></a>规定prop为必传字段</h1><p>PropTypes.func.isRequired</p>\n<h1 id=\"prop可为任意类型\"><a href=\"#prop可为任意类型\" class=\"headerlink\" title=\"prop可为任意类型\"></a>prop可为任意类型</h1><p>PropTypes.any.isRequired<br>&gt;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 定义属性</div><div class=\"line\">static propTypes = &#123;</div><div class=\"line\">    name:PropTypes.string,</div><div class=\"line\">    age:PropTypes.number</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>2.设置初始化值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">static defaultProps = &#123;</div><div class=\"line\">    name:&apos;xiaoming&apos;,</div><div class=\"line\">    age:20</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"基本组件\"><a href=\"#基本组件\" class=\"headerlink\" title=\"基本组件\"></a>基本组件</h2><p>1.View<br>2.TouchableOpacity<br>默认点击区域是所有子控件的区域,因为默认一个组件的尺寸由子控件决定</p>\n<ul>\n<li>点击事件：onPress|onLongPress|onPressIn|onPressOut</li>\n<li>disabled:true|false<br>3.Text</li>\n<li>numberOfLines</li>\n<li>selectable:true|false 是否允许长按选择文本</li>\n<li>suppressHighlighting:true|false 是否允许按下时有灰色阴影</li>\n<li>onPress:文字点击事件</li>\n</ul>\n<h2 id=\"ListView\"><a href=\"#ListView\" class=\"headerlink\" title=\"ListView\"></a>ListView</h2><p>1.创建数据源，给数据源设置数据<br>使用state保存数据源</p>\n<ul>\n<li>不分组使用：cloneWithRows</li>\n<li>分组使用：cloneWithRowsAndSections<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var dataSource = new ListView.DataSource(&#123;rowHasChanged: (r1, r2) =&gt; r1 !== r2&#125;);</div><div class=\"line\">this.state = &#123;</div><div class=\"line\">ds: dataSource.cloneWithRows([&apos;row 1&apos;, &apos;row 2&apos;]),</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var dataSource = new ListView.DataSource(&#123;</div><div class=\"line\">rowHasChanged:(r1,r2)=&gt;r1 !== r2,</div><div class=\"line\">sectionHeaderHasChanged:(s1,s2)=&gt;s1 !== s2</div><div class=\"line\">&#125;);</div><div class=\"line\">var sectionData = &#123;&#125;;</div><div class=\"line\">this.state = &#123;</div><div class=\"line\">ds : dataSource.cloneWithRowsAndSections(sectionData)</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>2.实现数据源方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;ListView dataSource=&#123;this.state.ds&#125;</div><div class=\"line\">renderRow=&#123;this._renderRow.bind(this)&#125;</div><div class=\"line\">renderSectionHeader=&#123;this._renderSectionHeader.bind(this)&#125;</div><div class=\"line\">//renderSeparator=&#123;this._renderSeparator.bind(this)&#125;</div><div class=\"line\">/&gt;</div><div class=\"line\"></div><div class=\"line\">_renderRow(rowData, sectionID, rowID, highlightRow) &#123;</div><div class=\"line\">return (</div><div class=\"line\">&lt;View&gt;</div><div class=\"line\">&lt;Text&gt;&#123;rowData&#125;&lt;/Text&gt;</div><div class=\"line\">&lt;/View&gt;</div><div class=\"line\">);</div><div class=\"line\">&#125;</div><div class=\"line\">//如果是组视图，设置组数据</div><div class=\"line\">_renderSectionHeader(sectionData, sectionID) &#123;</div><div class=\"line\">return (</div><div class=\"line\">&lt;View&gt;</div><div class=\"line\">&lt;Text&gt;&#123;sectionID&#125;&lt;/Text&gt;</div><div class=\"line\">&lt;/View&gt;</div><div class=\"line\">)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"导航Navigator\"><a href=\"#导航Navigator\" class=\"headerlink\" title=\"导航Navigator\"></a>导航Navigator</h2><p>如果找不到Navigator，安装Navigator所在的库：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install react-native-deprecated-custom-components --save</div><div class=\"line\">//yarn add react-native-deprecated-custom-components</div></pre></td></tr></table></figure></p>\n<p>项目导入：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">import &#123;Navigator&#125; from &apos;react-native-deprecated-custom-components&apos;</div></pre></td></tr></table></figure></p>\n<p>参考链接：<a href=\"http://www.lcode.org/【react-native开发】react-native-for-android环境配置以及第一个实例/\" target=\"_blank\" rel=\"external\">React Native开发</a><br><a href=\"http://www.jianshu.com/p/5b185df2d11a\" target=\"_blank\" rel=\"external\">React Native 简介与入门</a><br><a href=\"http://www.tuicool.com/articles/BfInEv\" target=\"_blank\" rel=\"external\">reactnative集成到原生ios项目</a><br><a href=\"http://www.jianshu.com/p/504a26d094b2\" target=\"_blank\" rel=\"external\">袁峥-系列</a></p>"},{"title":"Swift学习笔记","date":"2017-01-01T09:13:04.000Z","_content":"\n待补充\n","source":"_posts/Swift学习笔记.md","raw":"---\ntitle: Swift学习笔记\ndate: 2017-01-01 17:13:04\ncategories: 笔记\ntags: [Swift]\n---\n\n待补充\n","slug":"Swift学习笔记","published":1,"updated":"2017-07-14T03:57:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj53c1dvr0017h3jjzuyl23ac","content":"<p>待补充</p>\n","site":{"data":{}},"excerpt":"","more":"<p>待补充</p>\n"},{"title":"github上使用SSH和gitignore","date":"2017-03-03T08:52:02.000Z","_content":"\n### 1.使用SSH\n``` \n$ cd ~/.ssh\n$ ssh-keygen -t rsa -C \"your email address\"\n$ cat ~/.ssh/id_rsa.pub\n$ ssh -T git@github.com  （github） \n$ ssh -T git@git.oschina.net  (oschina)\n$ Welcome to Git@OSC, nickname!\n```\n\n### 2.gitignore\n<!--more-->\n``` \ncd /Users/apple/Desktop/code\ngit clone git地址\ncp gitignore路径 .gitignore\ngit add .\ngit commit -m \"添加 gitignore\"\ngit push\n```\n\n注意：\"cp gitignore路径 .gitignore\"一定要加\".gitignore\"。\n","source":"_posts/github上使用SSH和gitignore.md","raw":"---\ntitle: github上使用SSH和gitignore\ndate: 2017-03-03 16:52:02\ncategories: 笔记\ntags: [github,SSH,gitignore]\n---\n\n### 1.使用SSH\n``` \n$ cd ~/.ssh\n$ ssh-keygen -t rsa -C \"your email address\"\n$ cat ~/.ssh/id_rsa.pub\n$ ssh -T git@github.com  （github） \n$ ssh -T git@git.oschina.net  (oschina)\n$ Welcome to Git@OSC, nickname!\n```\n\n### 2.gitignore\n<!--more-->\n``` \ncd /Users/apple/Desktop/code\ngit clone git地址\ncp gitignore路径 .gitignore\ngit add .\ngit commit -m \"添加 gitignore\"\ngit push\n```\n\n注意：\"cp gitignore路径 .gitignore\"一定要加\".gitignore\"。\n","slug":"github上使用SSH和gitignore","published":1,"updated":"2017-07-14T03:57:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj53c1dvs001ah3jjiaclz600","content":"<h3 id=\"1-使用SSH\"><a href=\"#1-使用SSH\" class=\"headerlink\" title=\"1.使用SSH\"></a>1.使用SSH</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd ~/.ssh</div><div class=\"line\">$ ssh-keygen -t rsa -C &quot;your email address&quot;</div><div class=\"line\">$ cat ~/.ssh/id_rsa.pub</div><div class=\"line\">$ ssh -T git@github.com  （github） </div><div class=\"line\">$ ssh -T git@git.oschina.net  (oschina)</div><div class=\"line\">$ Welcome to Git@OSC, nickname!</div></pre></td></tr></table></figure>\n<h3 id=\"2-gitignore\"><a href=\"#2-gitignore\" class=\"headerlink\" title=\"2.gitignore\"></a>2.gitignore</h3><a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd /Users/apple/Desktop/code</div><div class=\"line\">git clone git地址</div><div class=\"line\">cp gitignore路径 .gitignore</div><div class=\"line\">git add .</div><div class=\"line\">git commit -m &quot;添加 gitignore&quot;</div><div class=\"line\">git push</div></pre></td></tr></table></figure>\n<p>注意：”cp gitignore路径 .gitignore”一定要加”.gitignore”。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-使用SSH\"><a href=\"#1-使用SSH\" class=\"headerlink\" title=\"1.使用SSH\"></a>1.使用SSH</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd ~/.ssh</div><div class=\"line\">$ ssh-keygen -t rsa -C &quot;your email address&quot;</div><div class=\"line\">$ cat ~/.ssh/id_rsa.pub</div><div class=\"line\">$ ssh -T git@github.com  （github） </div><div class=\"line\">$ ssh -T git@git.oschina.net  (oschina)</div><div class=\"line\">$ Welcome to Git@OSC, nickname!</div></pre></td></tr></table></figure>\n<h3 id=\"2-gitignore\"><a href=\"#2-gitignore\" class=\"headerlink\" title=\"2.gitignore\"></a>2.gitignore</h3>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd /Users/apple/Desktop/code</div><div class=\"line\">git clone git地址</div><div class=\"line\">cp gitignore路径 .gitignore</div><div class=\"line\">git add .</div><div class=\"line\">git commit -m &quot;添加 gitignore&quot;</div><div class=\"line\">git push</div></pre></td></tr></table></figure>\n<p>注意：”cp gitignore路径 .gitignore”一定要加”.gitignore”。</p>"},{"title":"git学习笔记","date":"2017-03-03T02:49:42.000Z","toc":true,"_content":"\n## 初始化仓库\n> $ git init\n\n## 提交代码\n> $ git add .\n> $ git commit -m “”\n\n<!--more-->\n## 查看状态\n> $ git status\n\n## 查看修改\n> $ git diff\n``` \n-change something\n+change\n```\n> $ git diff > 1.diff\n将diff修改写到1.diff文件中\n\n## 查看提交历史\n> $ git log\n\n``` \ncommit acbcfcfa48c89deb725aae9e03a68a2f5abaa1d4\nAuthor: gcl <155@163.com>\nDate:   Tue Feb 7 14:30:11 2017 +0800\n\nchange 2\n\ncommit 99f733644454644d90b8ee39c6737dc283c78cec\nAuthor: gcl <155@163.com>\nDate:   Tue Feb 7 14:27:55 2017 +0800\n\nchange readme.txt\n\ncommit 58110376e350d36c8df095b17ff2ecb44906eae2\nAuthor: gcl <155@163.com>\nDate:   Tue Feb 7 14:25:17 2017 +0800\n\nadd readme.txt\n```\n### 简化版本信息\n> $ git log --pretty=oneline \n``` \nacbcfcfa48c89deb725aae9e03a68a2f5abaa1d4 change 2\n99f733644454644d90b8ee39c6737dc283c78cec change readme.txt\n58110376e350d36c8df095b17ff2ecb44906eae2 add readme.txt\n```\n\n### 查看命令历史\n> $ git reflog\n``` \nacbcfcf HEAD@{0}: reset: moving to acbcfcfa4\n99f7336 HEAD@{1}: reset: moving to HEAD^\nacbcfcf HEAD@{2}: commit: change 2\n99f7336 HEAD@{3}: commit: change readme.txt\n5811037 HEAD@{4}: commit (initial): add readme.txt\n```\n\n## 回退版本\nHEAD指向当前版本，`HEAD^`是上一版本，`HEAD^^`是上上版本，`HEAD~100`是上100个版本\n`--hard`是强制抹除修改，未提交的修改会丢失。\t\ngit reset --hard ***慎重使用***\n`--mixed`是保存修改，相当于重新提交。\n### 回到上一版本\n> $ git reset --hard HEAD^  \n\n### 回到某一历史\n> $ git reset --hard commitid\n\n## 工作区与暂存区\n* `respository文件夹`：工作区\n* `.git`：版本库，包含了stage（暂存区），分支master，指针HEAD\n* `git add`是把文件修改放到了暂存区，`git commit`把暂存区的内容提交到了分支，没有提交到暂存区的修改是不会被提交到分支的\n提交的事件线：`工作区->git add->暂存区->git commit->分支`\n\n## 撤销修改\n`git管理的是修改，而不是文件`\n* 清空工作区的修改，回到最近一次git commit或git add时的状态（用版本库的版本替换工作区的版本）：git checkout -- readme.txt （注意：git checkout 是切换分支命令）\n* 撤销add后，commit前在暂存区的修改，将暂存区的修改放回工作区：git reset HEAD readme.txt（注意：reset可以回退版本，还可以撤销add到暂存区的内容，回退到工作区，如果要撤销在工作区的修改，可以再次checkout -- file）\n* 撤销commit之后，push之前：版本回退，git reset\n* git push：无法撤销\n\n## 删除文件\n### 确定删除\n>git rm filename\n>git commit\n\n### 撤销删除，找回文件\n>git checkout -- filename\n注意：`git checkout`是使用版本库中的最新版本替换工作区的版本，即撤销git add/rm之前的修改\n\n## 远程仓库\n* 本地库master与远程库origin关联，origin为远程库的默认叫法\n> $ git remote add origin git@github.com:XXX/learngit.git（XXX为你的github账户名）\n* 将本地库中的所有内容推送到远程库中，加上-u将本地master分支和远程origin分支关联起来，以后推送就可以直接使用git push简化命令\n> $ git push -u origin master\n* 以后推送使用以下命令\n> $ git push origin master\n* 把远程库克隆到本地,使用https速度慢，而且每次都要输入口令\n> $ git clone ssh或https\n* push与pull\n    + push：本地 --> 远程，如果本地超前远程，需要push\n    + pull：本地 <-- 远程，如果本地落后远程，需要pull \n\n## 分支管理\n`HEAD指向当前分支--master分支，master指向最新提交`\n### 创建分支\n* 创建分支  \n将当前分支中的所有文件拷贝到新分支\n> $ git branch second\n* 切换到分支  \n> $ git checkout second\n* 创建+切换到分支  \n> $ git checkout -b second\n* 查看当前分支  \n> $ git branch\n\n### 合并分支\n* 合并指定分支到当前分支(主分支)  \n> $ git branch master\n> $ git merge second\n* 撤销合并操作  \n> $ git reset\n* 合并模式  \n    + ”fast forward”模式：合并分支默认使用”fast forward”模式，删除分支会丢掉分支信息，合并后看不出做过合并\n    + 普通模式：禁用”fast forward” 使用普通模式，合并后的历史可以看出曾经做过合并，在merge时生成一个新的commit。\n    禁用”fast forward”并且加上了commit描述：\n    > $ git merge --no-ff -m \"merge with no-ff\" second\n* 如果出现冲突:git status->修改冲突->git add->git commit\n\n* git rebase origin master\n如果出现冲突:git status->修改冲突->git add->`git rebase --continue`\n\n### 查看分支\n> $ git log  \n* 查看分支合并图\n> $ git log --graph\n> $ git log --graph --pretty=oneline --abbrev-commit\n\n### 删除分支\n> $ git branch -d second\n> $ git branch -D second：强行删除一个没有合并过的分支\n> $ git push origin --delete second 删除远程分支\n\n### 分支管理策略  \n本地分支：master，dev，bug，feature\n远程分支：origin，dev\n![“插入图片”](http://o8cfktdb3.bkt.clouddn.com/branch.png) \n\n### 解决冲突\n+ 查看冲突\n> $ git status\n+ 查看分支合并图 git log --graph\n> $ git log --graph --pretty=oneline --abbrev-commit\n+ 解决冲突\n合并分支发生冲突后，解决冲突步骤：查看冲突->修改->提交->合并完成\n\n### bug分支\n将当前无法提交到现场先保存起来，使工作区恢复clean状态，修复bug后，再将保存的东西解开\n* 将工作现场先保存起来：git stash\n* 查看保存现场记录：git stash list\n* 恢复工作线程\n    + git stash apply ：stash内容不删除，需要使用git stash drop手动删除\n    + git stash pop：恢复的同时将stash的内容删除\n    + git stash apply stash@{0}：有多个stah时，指定恢复到某个stash\n\n### feature分支\n新添加功能时创建feature分支，开发完成合并到主分支，最好在开发新功能时为每一个新功能创建一个分支\n\n### 多人协作\n#### 查看远程库\n* 查看远程库的信息\n> $ git remote\n* 查看远程分支详细信息\n> $ git remote -v\n\n#### 推送分支\n将本地某个分支中的所有提交推送到远程库\n> $ git push origin master\n一般只推送master和dev分支，其他可以在本地放着\n\n#### 抓取分支\n创建本地dev分支：\n> $ git checkout -b dev origin/dev\n* git pull提示“no tracking information”,设置dev和origin/dev的链接：\n> $ git branch --set-upstream dev origin/dev\n> $ git pull\n> $ git add/commit/push\n\n* 注意：如果git pull时提示“no tracking information”，则需要指定本地master/dev分支与远程origin/dev分支的链接后，才能pull\n> $ git branch --set-upstream dev origin/dev  已弃用\n> $ git branch --set-upstream-to=origin/dev dev  最新用法\n\n#### 多⼈人协作的⼯工作模式:\n（1）git push origin branch-name\n（2）如果推送失败,则因为远程分⽀支⽐比你的本地更新,需要先⽤用git pull试图合并; \n（3）如果合并有冲突,则解决冲突,并在本地提交; \n（4）没有冲突或者解决掉冲突后,再⽤用git push origin branch-name推送就能成功! \n\n## 标签\n### 添加标签\n* 添加标签\n> $ git tag v1.0\n* 补加标签\n> $ git log --pretty=oneline --abbrev-commit\n> $ git tag v0.9 commitid\n* 添加说明\n用`-a`指定标签名，`-m`指定说明文字：\n> $ git tag -a v0.1 -m \"version 0.1 released\" 3628164\n* 私钥签名标签\n> $ git tag -s v0.2 -m \"signed version 0.2 released\" fec145a\n\n### 查看标签\n* 查看所有标签\n> $ git tag\n* 查看标签信息\n> $ git show v0.9\n`注意，标签不是按时间顺序列出，而是按字母排序的。`\n\n### 推送标签\n* 推送某一标签\n> $ git push origin v1.0\n* 推送本地所有未推送标签\n> $ git push origin --tags\n\n### 删除标签\n* 删除本地标签\n> $ git tag -d v1.0\n* 删除远程标签\n    + 需要先删除本地标签：\n> $ git tag -d v1.0\n    + 推送到远程：\n> $ git push origin :refs/tags/v1.0\n\n## github使用\n### SSH  \n``` \n$ ssh-keygen -t rsa -C \"xxxxx@xxxxx.com\"\n# Creates a new ssh key using the provided email\n# Generating public/private rsa key pair...\n$ cat ~/.ssh/id_rsa.pub\n# ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC6eNtGpNGwstc.... \n将public key添加\n$ ssh -T git@github.com （github）\nssh -T git@git.oschina.net (oschina)\nWelcome to Git@OSC, yourname! \n```\n### 为开源仓库贡献代码\n#### fork\n在GitHub上，可以任意Fork开源仓库\n#### 提交修改\n自己拥有Fork后的仓库的读写权限，从自己帐号克隆仓库，然后提交到自己的仓库\n#### pull request\n请求官方接受修改\n\n## 自定义git\n### 配置用户名和email  \n如果遇到以下问题：\n``` \n*** Please tell me who you are.\n\nRun\n\ngit config --global user.email \"you@example.com\"\ngit config --global user.name \"Your Name\"\n\nto set your account's default identity.\nOmit --global to set the identity only in this repository.\n\n>>>fatal: unable to auto-detect email address (got 'xxx@xxx.(none)')\n```\n需要配置`用户名`和`邮箱`：\n> $ git config --global user.name \"Your Name\"\n> $ git config --global user.email \"email@example.com\"\n\n### 给git命令添加颜色\n> $ git config --global color.ui true\n\n### 忽略特殊文件  \n+ 忽略文件的原则\n    * 忽略操作系统自动生成的文件，比如缩略图等；\n    * 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；\n    * 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。\n+ 强制添加被忽略的文件\n> $ git add -f App.class \n\n查看想添加的文件被.gitignore中的哪条规则忽略了  \n\n> $ git check-ignore -v App.class \n\n注意：.gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理\n\n### 配置别名\n> $ git config --global alias.st status\n> $ git config --global alias.co checkout\n> $ git config --global alias.ci commit\n> $ git config --global alias.br branch\n> $ git config --global alias.unstage 'reset HEAD'\n> $ git config --global alias.last 'log -1' \n> $ git config --global alias.lg \"log --color --graph --\n\n注意：`--global`是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用\n\n### 配置文件\n每个仓库的Git配置文件都放在.git/config文件中，查看配置文件\n> $ cat .git/config\n```\n[core]\nrepositoryformatversion = 0\nfilemode = false\nbare = false\nlogallrefupdates = true\nsymlinks = false\nignorecase = true\nhideDotFiles = dotGitOnly\n[remote \"origin\"]\nurl = git@xxx\nfetch = +refs/heads/*:refs/remotes/origin/*\n[branch \"master\"]\nremote = origin\nmerge = refs/heads/master\n```\n\n> $ cat ~/gitconfig\n```\n[user]\nemail = xxx\nname = xxx\n[color]\nui = true\n[alias]\nst = status\nco = checkout\nbr = branch\n[gui]\nencoding = gbk\n\n```\n\n要删除别名，直接把对应的行删掉即可\n改错了，可以删掉文件重新通过命令配置\n\n## 自己搭建git服务器\n（1）安装git\nsudo apt-get install git\n（2）创建一个git用户，用来运行git服务\nsudo adduser git\n（3）创建证书登录\n收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个\n（4）初始化Git仓库\nsudo chown -R git:git sample.git\n（5）禁用shell登录\n出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：\ngit:x:1001:1001:,,,:/home/git:/bin/bash\n改为：\n　git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell\n这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。\n（6）克隆远程仓库\ngit clone git@server:/srv/sample.git\n（7）要方便管理公钥，用Gitosis；\n　　要像SVN那样变态地控制权限，用Gitolite。\n\n## git命令汇总\ngit init \n\ngit add \ngit commit \ngit rm\ngit status\n\ngit diff \ngit log (--pretty=oneling)\ngit reflog\n\ngit checkout -- filename\ngit reset HEAD filename\ngit reset --hard HEAD^(commitid)\n\ngit add remote origin git/https\ngit push/pull/clone\n\ngit branch second\ngit checkout second\ngit checkout -b second\ngit branch\ngit branch -d second\ngit log --graph --pretty=oneline --abbrev-commit\n\ngit stash\ngit stash list\ngit stash apply\ngit stash drop\ngit stash pop\ngit stash apply stash@{0}\n\ngit remote -v\ngit checkout -b dev origin/dev\ngit branch --set-upstream-to=origin/dev dev \ngit pull\n\ngit tag name\ngit tag tagname commitid\ngit tag -a tagname -m \"description\"\ngit tag \ngit show tagname\ngit push origin tagname\ngit push origin --tags\ngit tag -d tagname\ngit push origin :refs/tags/tagname\n\nssh-keygen -t rsa -C \"xxxxx@xxxxx.com\"\ncat ~/.ssh/id_rsa.pub\nssh -T git@github.com （github）\n\ngit add -f App.class\n\ngit config user.name “username”\ngit config user.email “email”\ngit config --global alias.st status\n\n## 附Unix命令\n（1）创建文件夹：mkdir\n（2）跳到指定路径：cd\n（3）查看当前完整路径：pwd\n（4）查看当前路径下的所有文件及文件夹：ls\n（5）cat：可以显示文件内容，但是不能编辑\n（6）touch：如果文件存在，使用touch指令可更改这个文件或目录的日期时间，包括存取时间和更改时间； \n如果文件不存在，touch指令会在当前目录下新建一个空白文件\n（7）vi/vim：打开文件后可以编辑\n（8）echo：输出\n\n[Git的官方网站](http://git-scm.com)\n\n本文为阅读廖雪峰的官方网站中的git教程的学习笔记，仅为自己的一点学习记录，原文写的非常好，作者很厉害，有兴趣的朋友可以阅读原文：[廖雪峰的官方网站的git教程](http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000 \"廖雪峰的官方网站的git教程\")\n","source":"_posts/git学习笔记.md","raw":"---\ntitle: git学习笔记\ndate: 2017-03-03 10:49:42\ncategories: 笔记\ntags: [Git]\ntoc: true\n---\n\n## 初始化仓库\n> $ git init\n\n## 提交代码\n> $ git add .\n> $ git commit -m “”\n\n<!--more-->\n## 查看状态\n> $ git status\n\n## 查看修改\n> $ git diff\n``` \n-change something\n+change\n```\n> $ git diff > 1.diff\n将diff修改写到1.diff文件中\n\n## 查看提交历史\n> $ git log\n\n``` \ncommit acbcfcfa48c89deb725aae9e03a68a2f5abaa1d4\nAuthor: gcl <155@163.com>\nDate:   Tue Feb 7 14:30:11 2017 +0800\n\nchange 2\n\ncommit 99f733644454644d90b8ee39c6737dc283c78cec\nAuthor: gcl <155@163.com>\nDate:   Tue Feb 7 14:27:55 2017 +0800\n\nchange readme.txt\n\ncommit 58110376e350d36c8df095b17ff2ecb44906eae2\nAuthor: gcl <155@163.com>\nDate:   Tue Feb 7 14:25:17 2017 +0800\n\nadd readme.txt\n```\n### 简化版本信息\n> $ git log --pretty=oneline \n``` \nacbcfcfa48c89deb725aae9e03a68a2f5abaa1d4 change 2\n99f733644454644d90b8ee39c6737dc283c78cec change readme.txt\n58110376e350d36c8df095b17ff2ecb44906eae2 add readme.txt\n```\n\n### 查看命令历史\n> $ git reflog\n``` \nacbcfcf HEAD@{0}: reset: moving to acbcfcfa4\n99f7336 HEAD@{1}: reset: moving to HEAD^\nacbcfcf HEAD@{2}: commit: change 2\n99f7336 HEAD@{3}: commit: change readme.txt\n5811037 HEAD@{4}: commit (initial): add readme.txt\n```\n\n## 回退版本\nHEAD指向当前版本，`HEAD^`是上一版本，`HEAD^^`是上上版本，`HEAD~100`是上100个版本\n`--hard`是强制抹除修改，未提交的修改会丢失。\t\ngit reset --hard ***慎重使用***\n`--mixed`是保存修改，相当于重新提交。\n### 回到上一版本\n> $ git reset --hard HEAD^  \n\n### 回到某一历史\n> $ git reset --hard commitid\n\n## 工作区与暂存区\n* `respository文件夹`：工作区\n* `.git`：版本库，包含了stage（暂存区），分支master，指针HEAD\n* `git add`是把文件修改放到了暂存区，`git commit`把暂存区的内容提交到了分支，没有提交到暂存区的修改是不会被提交到分支的\n提交的事件线：`工作区->git add->暂存区->git commit->分支`\n\n## 撤销修改\n`git管理的是修改，而不是文件`\n* 清空工作区的修改，回到最近一次git commit或git add时的状态（用版本库的版本替换工作区的版本）：git checkout -- readme.txt （注意：git checkout 是切换分支命令）\n* 撤销add后，commit前在暂存区的修改，将暂存区的修改放回工作区：git reset HEAD readme.txt（注意：reset可以回退版本，还可以撤销add到暂存区的内容，回退到工作区，如果要撤销在工作区的修改，可以再次checkout -- file）\n* 撤销commit之后，push之前：版本回退，git reset\n* git push：无法撤销\n\n## 删除文件\n### 确定删除\n>git rm filename\n>git commit\n\n### 撤销删除，找回文件\n>git checkout -- filename\n注意：`git checkout`是使用版本库中的最新版本替换工作区的版本，即撤销git add/rm之前的修改\n\n## 远程仓库\n* 本地库master与远程库origin关联，origin为远程库的默认叫法\n> $ git remote add origin git@github.com:XXX/learngit.git（XXX为你的github账户名）\n* 将本地库中的所有内容推送到远程库中，加上-u将本地master分支和远程origin分支关联起来，以后推送就可以直接使用git push简化命令\n> $ git push -u origin master\n* 以后推送使用以下命令\n> $ git push origin master\n* 把远程库克隆到本地,使用https速度慢，而且每次都要输入口令\n> $ git clone ssh或https\n* push与pull\n    + push：本地 --> 远程，如果本地超前远程，需要push\n    + pull：本地 <-- 远程，如果本地落后远程，需要pull \n\n## 分支管理\n`HEAD指向当前分支--master分支，master指向最新提交`\n### 创建分支\n* 创建分支  \n将当前分支中的所有文件拷贝到新分支\n> $ git branch second\n* 切换到分支  \n> $ git checkout second\n* 创建+切换到分支  \n> $ git checkout -b second\n* 查看当前分支  \n> $ git branch\n\n### 合并分支\n* 合并指定分支到当前分支(主分支)  \n> $ git branch master\n> $ git merge second\n* 撤销合并操作  \n> $ git reset\n* 合并模式  \n    + ”fast forward”模式：合并分支默认使用”fast forward”模式，删除分支会丢掉分支信息，合并后看不出做过合并\n    + 普通模式：禁用”fast forward” 使用普通模式，合并后的历史可以看出曾经做过合并，在merge时生成一个新的commit。\n    禁用”fast forward”并且加上了commit描述：\n    > $ git merge --no-ff -m \"merge with no-ff\" second\n* 如果出现冲突:git status->修改冲突->git add->git commit\n\n* git rebase origin master\n如果出现冲突:git status->修改冲突->git add->`git rebase --continue`\n\n### 查看分支\n> $ git log  \n* 查看分支合并图\n> $ git log --graph\n> $ git log --graph --pretty=oneline --abbrev-commit\n\n### 删除分支\n> $ git branch -d second\n> $ git branch -D second：强行删除一个没有合并过的分支\n> $ git push origin --delete second 删除远程分支\n\n### 分支管理策略  \n本地分支：master，dev，bug，feature\n远程分支：origin，dev\n![“插入图片”](http://o8cfktdb3.bkt.clouddn.com/branch.png) \n\n### 解决冲突\n+ 查看冲突\n> $ git status\n+ 查看分支合并图 git log --graph\n> $ git log --graph --pretty=oneline --abbrev-commit\n+ 解决冲突\n合并分支发生冲突后，解决冲突步骤：查看冲突->修改->提交->合并完成\n\n### bug分支\n将当前无法提交到现场先保存起来，使工作区恢复clean状态，修复bug后，再将保存的东西解开\n* 将工作现场先保存起来：git stash\n* 查看保存现场记录：git stash list\n* 恢复工作线程\n    + git stash apply ：stash内容不删除，需要使用git stash drop手动删除\n    + git stash pop：恢复的同时将stash的内容删除\n    + git stash apply stash@{0}：有多个stah时，指定恢复到某个stash\n\n### feature分支\n新添加功能时创建feature分支，开发完成合并到主分支，最好在开发新功能时为每一个新功能创建一个分支\n\n### 多人协作\n#### 查看远程库\n* 查看远程库的信息\n> $ git remote\n* 查看远程分支详细信息\n> $ git remote -v\n\n#### 推送分支\n将本地某个分支中的所有提交推送到远程库\n> $ git push origin master\n一般只推送master和dev分支，其他可以在本地放着\n\n#### 抓取分支\n创建本地dev分支：\n> $ git checkout -b dev origin/dev\n* git pull提示“no tracking information”,设置dev和origin/dev的链接：\n> $ git branch --set-upstream dev origin/dev\n> $ git pull\n> $ git add/commit/push\n\n* 注意：如果git pull时提示“no tracking information”，则需要指定本地master/dev分支与远程origin/dev分支的链接后，才能pull\n> $ git branch --set-upstream dev origin/dev  已弃用\n> $ git branch --set-upstream-to=origin/dev dev  最新用法\n\n#### 多⼈人协作的⼯工作模式:\n（1）git push origin branch-name\n（2）如果推送失败,则因为远程分⽀支⽐比你的本地更新,需要先⽤用git pull试图合并; \n（3）如果合并有冲突,则解决冲突,并在本地提交; \n（4）没有冲突或者解决掉冲突后,再⽤用git push origin branch-name推送就能成功! \n\n## 标签\n### 添加标签\n* 添加标签\n> $ git tag v1.0\n* 补加标签\n> $ git log --pretty=oneline --abbrev-commit\n> $ git tag v0.9 commitid\n* 添加说明\n用`-a`指定标签名，`-m`指定说明文字：\n> $ git tag -a v0.1 -m \"version 0.1 released\" 3628164\n* 私钥签名标签\n> $ git tag -s v0.2 -m \"signed version 0.2 released\" fec145a\n\n### 查看标签\n* 查看所有标签\n> $ git tag\n* 查看标签信息\n> $ git show v0.9\n`注意，标签不是按时间顺序列出，而是按字母排序的。`\n\n### 推送标签\n* 推送某一标签\n> $ git push origin v1.0\n* 推送本地所有未推送标签\n> $ git push origin --tags\n\n### 删除标签\n* 删除本地标签\n> $ git tag -d v1.0\n* 删除远程标签\n    + 需要先删除本地标签：\n> $ git tag -d v1.0\n    + 推送到远程：\n> $ git push origin :refs/tags/v1.0\n\n## github使用\n### SSH  \n``` \n$ ssh-keygen -t rsa -C \"xxxxx@xxxxx.com\"\n# Creates a new ssh key using the provided email\n# Generating public/private rsa key pair...\n$ cat ~/.ssh/id_rsa.pub\n# ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC6eNtGpNGwstc.... \n将public key添加\n$ ssh -T git@github.com （github）\nssh -T git@git.oschina.net (oschina)\nWelcome to Git@OSC, yourname! \n```\n### 为开源仓库贡献代码\n#### fork\n在GitHub上，可以任意Fork开源仓库\n#### 提交修改\n自己拥有Fork后的仓库的读写权限，从自己帐号克隆仓库，然后提交到自己的仓库\n#### pull request\n请求官方接受修改\n\n## 自定义git\n### 配置用户名和email  \n如果遇到以下问题：\n``` \n*** Please tell me who you are.\n\nRun\n\ngit config --global user.email \"you@example.com\"\ngit config --global user.name \"Your Name\"\n\nto set your account's default identity.\nOmit --global to set the identity only in this repository.\n\n>>>fatal: unable to auto-detect email address (got 'xxx@xxx.(none)')\n```\n需要配置`用户名`和`邮箱`：\n> $ git config --global user.name \"Your Name\"\n> $ git config --global user.email \"email@example.com\"\n\n### 给git命令添加颜色\n> $ git config --global color.ui true\n\n### 忽略特殊文件  \n+ 忽略文件的原则\n    * 忽略操作系统自动生成的文件，比如缩略图等；\n    * 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；\n    * 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。\n+ 强制添加被忽略的文件\n> $ git add -f App.class \n\n查看想添加的文件被.gitignore中的哪条规则忽略了  \n\n> $ git check-ignore -v App.class \n\n注意：.gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理\n\n### 配置别名\n> $ git config --global alias.st status\n> $ git config --global alias.co checkout\n> $ git config --global alias.ci commit\n> $ git config --global alias.br branch\n> $ git config --global alias.unstage 'reset HEAD'\n> $ git config --global alias.last 'log -1' \n> $ git config --global alias.lg \"log --color --graph --\n\n注意：`--global`是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用\n\n### 配置文件\n每个仓库的Git配置文件都放在.git/config文件中，查看配置文件\n> $ cat .git/config\n```\n[core]\nrepositoryformatversion = 0\nfilemode = false\nbare = false\nlogallrefupdates = true\nsymlinks = false\nignorecase = true\nhideDotFiles = dotGitOnly\n[remote \"origin\"]\nurl = git@xxx\nfetch = +refs/heads/*:refs/remotes/origin/*\n[branch \"master\"]\nremote = origin\nmerge = refs/heads/master\n```\n\n> $ cat ~/gitconfig\n```\n[user]\nemail = xxx\nname = xxx\n[color]\nui = true\n[alias]\nst = status\nco = checkout\nbr = branch\n[gui]\nencoding = gbk\n\n```\n\n要删除别名，直接把对应的行删掉即可\n改错了，可以删掉文件重新通过命令配置\n\n## 自己搭建git服务器\n（1）安装git\nsudo apt-get install git\n（2）创建一个git用户，用来运行git服务\nsudo adduser git\n（3）创建证书登录\n收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个\n（4）初始化Git仓库\nsudo chown -R git:git sample.git\n（5）禁用shell登录\n出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：\ngit:x:1001:1001:,,,:/home/git:/bin/bash\n改为：\n　git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell\n这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。\n（6）克隆远程仓库\ngit clone git@server:/srv/sample.git\n（7）要方便管理公钥，用Gitosis；\n　　要像SVN那样变态地控制权限，用Gitolite。\n\n## git命令汇总\ngit init \n\ngit add \ngit commit \ngit rm\ngit status\n\ngit diff \ngit log (--pretty=oneling)\ngit reflog\n\ngit checkout -- filename\ngit reset HEAD filename\ngit reset --hard HEAD^(commitid)\n\ngit add remote origin git/https\ngit push/pull/clone\n\ngit branch second\ngit checkout second\ngit checkout -b second\ngit branch\ngit branch -d second\ngit log --graph --pretty=oneline --abbrev-commit\n\ngit stash\ngit stash list\ngit stash apply\ngit stash drop\ngit stash pop\ngit stash apply stash@{0}\n\ngit remote -v\ngit checkout -b dev origin/dev\ngit branch --set-upstream-to=origin/dev dev \ngit pull\n\ngit tag name\ngit tag tagname commitid\ngit tag -a tagname -m \"description\"\ngit tag \ngit show tagname\ngit push origin tagname\ngit push origin --tags\ngit tag -d tagname\ngit push origin :refs/tags/tagname\n\nssh-keygen -t rsa -C \"xxxxx@xxxxx.com\"\ncat ~/.ssh/id_rsa.pub\nssh -T git@github.com （github）\n\ngit add -f App.class\n\ngit config user.name “username”\ngit config user.email “email”\ngit config --global alias.st status\n\n## 附Unix命令\n（1）创建文件夹：mkdir\n（2）跳到指定路径：cd\n（3）查看当前完整路径：pwd\n（4）查看当前路径下的所有文件及文件夹：ls\n（5）cat：可以显示文件内容，但是不能编辑\n（6）touch：如果文件存在，使用touch指令可更改这个文件或目录的日期时间，包括存取时间和更改时间； \n如果文件不存在，touch指令会在当前目录下新建一个空白文件\n（7）vi/vim：打开文件后可以编辑\n（8）echo：输出\n\n[Git的官方网站](http://git-scm.com)\n\n本文为阅读廖雪峰的官方网站中的git教程的学习笔记，仅为自己的一点学习记录，原文写的非常好，作者很厉害，有兴趣的朋友可以阅读原文：[廖雪峰的官方网站的git教程](http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000 \"廖雪峰的官方网站的git教程\")\n","slug":"git学习笔记","published":1,"updated":"2017-07-14T03:57:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj53c1dvu001ch3jjpb38948x","content":"<h2 id=\"初始化仓库\"><a href=\"#初始化仓库\" class=\"headerlink\" title=\"初始化仓库\"></a>初始化仓库</h2><blockquote>\n<p>$ git init</p>\n</blockquote>\n<h2 id=\"提交代码\"><a href=\"#提交代码\" class=\"headerlink\" title=\"提交代码\"></a>提交代码</h2><blockquote>\n<p>$ git add .<br>$ git commit -m “”</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"查看状态\"><a href=\"#查看状态\" class=\"headerlink\" title=\"查看状态\"></a>查看状态</h2><blockquote>\n<p>$ git status</p>\n</blockquote>\n<h2 id=\"查看修改\"><a href=\"#查看修改\" class=\"headerlink\" title=\"查看修改\"></a>查看修改</h2><blockquote>\n<p>$ git diff<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">-change something</div><div class=\"line\">+change</div></pre></td></tr></table></figure></p>\n<p>$ git diff &gt; 1.diff<br>将diff修改写到1.diff文件中</p>\n</blockquote>\n<h2 id=\"查看提交历史\"><a href=\"#查看提交历史\" class=\"headerlink\" title=\"查看提交历史\"></a>查看提交历史</h2><blockquote>\n<p>$ git log</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">commit acbcfcfa48c89deb725aae9e03a68a2f5abaa1d4</div><div class=\"line\">Author: gcl &lt;155@163.com&gt;</div><div class=\"line\">Date:   Tue Feb 7 14:30:11 2017 +0800</div><div class=\"line\"></div><div class=\"line\">change 2</div><div class=\"line\"></div><div class=\"line\">commit 99f733644454644d90b8ee39c6737dc283c78cec</div><div class=\"line\">Author: gcl &lt;155@163.com&gt;</div><div class=\"line\">Date:   Tue Feb 7 14:27:55 2017 +0800</div><div class=\"line\"></div><div class=\"line\">change readme.txt</div><div class=\"line\"></div><div class=\"line\">commit 58110376e350d36c8df095b17ff2ecb44906eae2</div><div class=\"line\">Author: gcl &lt;155@163.com&gt;</div><div class=\"line\">Date:   Tue Feb 7 14:25:17 2017 +0800</div><div class=\"line\"></div><div class=\"line\">add readme.txt</div></pre></td></tr></table></figure>\n<h3 id=\"简化版本信息\"><a href=\"#简化版本信息\" class=\"headerlink\" title=\"简化版本信息\"></a>简化版本信息</h3><blockquote>\n<p>$ git log –pretty=oneline<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">acbcfcfa48c89deb725aae9e03a68a2f5abaa1d4 change 2</div><div class=\"line\">99f733644454644d90b8ee39c6737dc283c78cec change readme.txt</div><div class=\"line\">58110376e350d36c8df095b17ff2ecb44906eae2 add readme.txt</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"查看命令历史\"><a href=\"#查看命令历史\" class=\"headerlink\" title=\"查看命令历史\"></a>查看命令历史</h3><blockquote>\n<p>$ git reflog<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">acbcfcf HEAD@&#123;0&#125;: reset: moving to acbcfcfa4</div><div class=\"line\">99f7336 HEAD@&#123;1&#125;: reset: moving to HEAD^</div><div class=\"line\">acbcfcf HEAD@&#123;2&#125;: commit: change 2</div><div class=\"line\">99f7336 HEAD@&#123;3&#125;: commit: change readme.txt</div><div class=\"line\">5811037 HEAD@&#123;4&#125;: commit (initial): add readme.txt</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h2 id=\"回退版本\"><a href=\"#回退版本\" class=\"headerlink\" title=\"回退版本\"></a>回退版本</h2><p>HEAD指向当前版本，<code>HEAD^</code>是上一版本，<code>HEAD^^</code>是上上版本，<code>HEAD~100</code>是上100个版本<br><code>--hard</code>是强制抹除修改，未提交的修改会丢失。<br>git reset –hard <strong><em>慎重使用</em></strong><br><code>--mixed</code>是保存修改，相当于重新提交。</p>\n<h3 id=\"回到上一版本\"><a href=\"#回到上一版本\" class=\"headerlink\" title=\"回到上一版本\"></a>回到上一版本</h3><blockquote>\n<p>$ git reset –hard HEAD^  </p>\n</blockquote>\n<h3 id=\"回到某一历史\"><a href=\"#回到某一历史\" class=\"headerlink\" title=\"回到某一历史\"></a>回到某一历史</h3><blockquote>\n<p>$ git reset –hard commitid</p>\n</blockquote>\n<h2 id=\"工作区与暂存区\"><a href=\"#工作区与暂存区\" class=\"headerlink\" title=\"工作区与暂存区\"></a>工作区与暂存区</h2><ul>\n<li><code>respository文件夹</code>：工作区</li>\n<li><code>.git</code>：版本库，包含了stage（暂存区），分支master，指针HEAD</li>\n<li><code>git add</code>是把文件修改放到了暂存区，<code>git commit</code>把暂存区的内容提交到了分支，没有提交到暂存区的修改是不会被提交到分支的<br>提交的事件线：<code>工作区-&gt;git add-&gt;暂存区-&gt;git commit-&gt;分支</code></li>\n</ul>\n<h2 id=\"撤销修改\"><a href=\"#撤销修改\" class=\"headerlink\" title=\"撤销修改\"></a>撤销修改</h2><p><code>git管理的是修改，而不是文件</code></p>\n<ul>\n<li>清空工作区的修改，回到最近一次git commit或git add时的状态（用版本库的版本替换工作区的版本）：git checkout – readme.txt （注意：git checkout 是切换分支命令）</li>\n<li>撤销add后，commit前在暂存区的修改，将暂存区的修改放回工作区：git reset HEAD readme.txt（注意：reset可以回退版本，还可以撤销add到暂存区的内容，回退到工作区，如果要撤销在工作区的修改，可以再次checkout – file）</li>\n<li>撤销commit之后，push之前：版本回退，git reset</li>\n<li>git push：无法撤销</li>\n</ul>\n<h2 id=\"删除文件\"><a href=\"#删除文件\" class=\"headerlink\" title=\"删除文件\"></a>删除文件</h2><h3 id=\"确定删除\"><a href=\"#确定删除\" class=\"headerlink\" title=\"确定删除\"></a>确定删除</h3><blockquote>\n<p>git rm filename<br>git commit</p>\n</blockquote>\n<h3 id=\"撤销删除，找回文件\"><a href=\"#撤销删除，找回文件\" class=\"headerlink\" title=\"撤销删除，找回文件\"></a>撤销删除，找回文件</h3><blockquote>\n<p>git checkout – filename<br>注意：<code>git checkout</code>是使用版本库中的最新版本替换工作区的版本，即撤销git add/rm之前的修改</p>\n</blockquote>\n<h2 id=\"远程仓库\"><a href=\"#远程仓库\" class=\"headerlink\" title=\"远程仓库\"></a>远程仓库</h2><ul>\n<li>本地库master与远程库origin关联，origin为远程库的默认叫法<blockquote>\n<p>$ git remote add origin git@github.com:XXX/learngit.git（XXX为你的github账户名）</p>\n</blockquote>\n</li>\n<li>将本地库中的所有内容推送到远程库中，加上-u将本地master分支和远程origin分支关联起来，以后推送就可以直接使用git push简化命令<blockquote>\n<p>$ git push -u origin master</p>\n</blockquote>\n</li>\n<li>以后推送使用以下命令<blockquote>\n<p>$ git push origin master</p>\n</blockquote>\n</li>\n<li>把远程库克隆到本地,使用https速度慢，而且每次都要输入口令<blockquote>\n<p>$ git clone ssh或https</p>\n</blockquote>\n</li>\n<li>push与pull<ul>\n<li>push：本地 –&gt; 远程，如果本地超前远程，需要push</li>\n<li>pull：本地 &lt;– 远程，如果本地落后远程，需要pull </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"分支管理\"><a href=\"#分支管理\" class=\"headerlink\" title=\"分支管理\"></a>分支管理</h2><p><code>HEAD指向当前分支--master分支，master指向最新提交</code></p>\n<h3 id=\"创建分支\"><a href=\"#创建分支\" class=\"headerlink\" title=\"创建分支\"></a>创建分支</h3><ul>\n<li>创建分支<br>将当前分支中的所有文件拷贝到新分支<blockquote>\n<p>$ git branch second</p>\n</blockquote>\n</li>\n<li>切换到分支  <blockquote>\n<p>$ git checkout second</p>\n</blockquote>\n</li>\n<li>创建+切换到分支  <blockquote>\n<p>$ git checkout -b second</p>\n</blockquote>\n</li>\n<li>查看当前分支  <blockquote>\n<p>$ git branch</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"合并分支\"><a href=\"#合并分支\" class=\"headerlink\" title=\"合并分支\"></a>合并分支</h3><ul>\n<li>合并指定分支到当前分支(主分支)  <blockquote>\n<p>$ git branch master<br>$ git merge second</p>\n</blockquote>\n</li>\n<li>撤销合并操作  <blockquote>\n<p>$ git reset</p>\n</blockquote>\n</li>\n<li>合并模式  <ul>\n<li>”fast forward”模式：合并分支默认使用”fast forward”模式，删除分支会丢掉分支信息，合并后看不出做过合并</li>\n<li>普通模式：禁用”fast forward” 使用普通模式，合并后的历史可以看出曾经做过合并，在merge时生成一个新的commit。<br>禁用”fast forward”并且加上了commit描述：<blockquote>\n<p>$ git merge –no-ff -m “merge with no-ff” second</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>如果出现冲突:git status-&gt;修改冲突-&gt;git add-&gt;git commit</p>\n</li>\n<li><p>git rebase origin master<br>如果出现冲突:git status-&gt;修改冲突-&gt;git add-&gt;<code>git rebase --continue</code></p>\n</li>\n</ul>\n<h3 id=\"查看分支\"><a href=\"#查看分支\" class=\"headerlink\" title=\"查看分支\"></a>查看分支</h3><blockquote>\n<p>$ git log  </p>\n<ul>\n<li>查看分支合并图<br>$ git log –graph<br>$ git log –graph –pretty=oneline –abbrev-commit</li>\n</ul>\n</blockquote>\n<h3 id=\"删除分支\"><a href=\"#删除分支\" class=\"headerlink\" title=\"删除分支\"></a>删除分支</h3><blockquote>\n<p>$ git branch -d second<br>$ git branch -D second：强行删除一个没有合并过的分支<br>$ git push origin –delete second 删除远程分支</p>\n</blockquote>\n<h3 id=\"分支管理策略\"><a href=\"#分支管理策略\" class=\"headerlink\" title=\"分支管理策略\"></a>分支管理策略</h3><p>本地分支：master，dev，bug，feature<br>远程分支：origin，dev<br><img src=\"http://o8cfktdb3.bkt.clouddn.com/branch.png\" alt=\"“插入图片”\"> </p>\n<h3 id=\"解决冲突\"><a href=\"#解决冲突\" class=\"headerlink\" title=\"解决冲突\"></a>解决冲突</h3><ul>\n<li>查看冲突<blockquote>\n<p>$ git status</p>\n</blockquote>\n</li>\n<li>查看分支合并图 git log –graph<blockquote>\n<p>$ git log –graph –pretty=oneline –abbrev-commit</p>\n</blockquote>\n</li>\n<li>解决冲突<br>合并分支发生冲突后，解决冲突步骤：查看冲突-&gt;修改-&gt;提交-&gt;合并完成</li>\n</ul>\n<h3 id=\"bug分支\"><a href=\"#bug分支\" class=\"headerlink\" title=\"bug分支\"></a>bug分支</h3><p>将当前无法提交到现场先保存起来，使工作区恢复clean状态，修复bug后，再将保存的东西解开</p>\n<ul>\n<li>将工作现场先保存起来：git stash</li>\n<li>查看保存现场记录：git stash list</li>\n<li>恢复工作线程<ul>\n<li>git stash apply ：stash内容不删除，需要使用git stash drop手动删除</li>\n<li>git stash pop：恢复的同时将stash的内容删除</li>\n<li>git stash apply stash@{0}：有多个stah时，指定恢复到某个stash</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"feature分支\"><a href=\"#feature分支\" class=\"headerlink\" title=\"feature分支\"></a>feature分支</h3><p>新添加功能时创建feature分支，开发完成合并到主分支，最好在开发新功能时为每一个新功能创建一个分支</p>\n<h3 id=\"多人协作\"><a href=\"#多人协作\" class=\"headerlink\" title=\"多人协作\"></a>多人协作</h3><h4 id=\"查看远程库\"><a href=\"#查看远程库\" class=\"headerlink\" title=\"查看远程库\"></a>查看远程库</h4><ul>\n<li>查看远程库的信息<blockquote>\n<p>$ git remote</p>\n</blockquote>\n</li>\n<li>查看远程分支详细信息<blockquote>\n<p>$ git remote -v</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"推送分支\"><a href=\"#推送分支\" class=\"headerlink\" title=\"推送分支\"></a>推送分支</h4><p>将本地某个分支中的所有提交推送到远程库</p>\n<blockquote>\n<p>$ git push origin master<br>一般只推送master和dev分支，其他可以在本地放着</p>\n</blockquote>\n<h4 id=\"抓取分支\"><a href=\"#抓取分支\" class=\"headerlink\" title=\"抓取分支\"></a>抓取分支</h4><p>创建本地dev分支：</p>\n<blockquote>\n<p>$ git checkout -b dev origin/dev</p>\n<ul>\n<li>git pull提示“no tracking information”,设置dev和origin/dev的链接：<br>$ git branch –set-upstream dev origin/dev<br>$ git pull<br>$ git add/commit/push</li>\n</ul>\n</blockquote>\n<ul>\n<li>注意：如果git pull时提示“no tracking information”，则需要指定本地master/dev分支与远程origin/dev分支的链接后，才能pull<blockquote>\n<p>$ git branch –set-upstream dev origin/dev  已弃用<br>$ git branch –set-upstream-to=origin/dev dev  最新用法</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"多⼈人协作的⼯工作模式\"><a href=\"#多⼈人协作的⼯工作模式\" class=\"headerlink\" title=\"多⼈人协作的⼯工作模式:\"></a>多⼈人协作的⼯工作模式:</h4><p>（1）git push origin branch-name<br>（2）如果推送失败,则因为远程分⽀支⽐比你的本地更新,需要先⽤用git pull试图合并;<br>（3）如果合并有冲突,则解决冲突,并在本地提交;<br>（4）没有冲突或者解决掉冲突后,再⽤用git push origin branch-name推送就能成功! </p>\n<h2 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h2><h3 id=\"添加标签\"><a href=\"#添加标签\" class=\"headerlink\" title=\"添加标签\"></a>添加标签</h3><ul>\n<li>添加标签<blockquote>\n<p>$ git tag v1.0</p>\n</blockquote>\n</li>\n<li>补加标签<blockquote>\n<p>$ git log –pretty=oneline –abbrev-commit<br>$ git tag v0.9 commitid</p>\n</blockquote>\n</li>\n<li>添加说明<br>用<code>-a</code>指定标签名，<code>-m</code>指定说明文字：<blockquote>\n<p>$ git tag -a v0.1 -m “version 0.1 released” 3628164</p>\n</blockquote>\n</li>\n<li>私钥签名标签<blockquote>\n<p>$ git tag -s v0.2 -m “signed version 0.2 released” fec145a</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"查看标签\"><a href=\"#查看标签\" class=\"headerlink\" title=\"查看标签\"></a>查看标签</h3><ul>\n<li>查看所有标签<blockquote>\n<p>$ git tag</p>\n</blockquote>\n</li>\n<li>查看标签信息<blockquote>\n<p>$ git show v0.9<br><code>注意，标签不是按时间顺序列出，而是按字母排序的。</code></p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"推送标签\"><a href=\"#推送标签\" class=\"headerlink\" title=\"推送标签\"></a>推送标签</h3><ul>\n<li>推送某一标签<blockquote>\n<p>$ git push origin v1.0</p>\n</blockquote>\n</li>\n<li>推送本地所有未推送标签<blockquote>\n<p>$ git push origin –tags</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"删除标签\"><a href=\"#删除标签\" class=\"headerlink\" title=\"删除标签\"></a>删除标签</h3><ul>\n<li>删除本地标签<blockquote>\n<p>$ git tag -d v1.0</p>\n</blockquote>\n</li>\n<li>删除远程标签<ul>\n<li>需要先删除本地标签：<blockquote>\n<p>$ git tag -d v1.0</p>\n</blockquote>\n</li>\n<li>推送到远程：<blockquote>\n<p>$ git push origin :refs/tags/v1.0</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"github使用\"><a href=\"#github使用\" class=\"headerlink\" title=\"github使用\"></a>github使用</h2><h3 id=\"SSH\"><a href=\"#SSH\" class=\"headerlink\" title=\"SSH\"></a>SSH</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ ssh-keygen -t rsa -C &quot;xxxxx@xxxxx.com&quot;</div><div class=\"line\"># Creates a new ssh key using the provided email</div><div class=\"line\"># Generating public/private rsa key pair...</div><div class=\"line\">$ cat ~/.ssh/id_rsa.pub</div><div class=\"line\"># ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC6eNtGpNGwstc.... </div><div class=\"line\">将public key添加</div><div class=\"line\">$ ssh -T git@github.com （github）</div><div class=\"line\">ssh -T git@git.oschina.net (oschina)</div><div class=\"line\">Welcome to Git@OSC, yourname!</div></pre></td></tr></table></figure>\n<h3 id=\"为开源仓库贡献代码\"><a href=\"#为开源仓库贡献代码\" class=\"headerlink\" title=\"为开源仓库贡献代码\"></a>为开源仓库贡献代码</h3><h4 id=\"fork\"><a href=\"#fork\" class=\"headerlink\" title=\"fork\"></a>fork</h4><p>在GitHub上，可以任意Fork开源仓库</p>\n<h4 id=\"提交修改\"><a href=\"#提交修改\" class=\"headerlink\" title=\"提交修改\"></a>提交修改</h4><p>自己拥有Fork后的仓库的读写权限，从自己帐号克隆仓库，然后提交到自己的仓库</p>\n<h4 id=\"pull-request\"><a href=\"#pull-request\" class=\"headerlink\" title=\"pull request\"></a>pull request</h4><p>请求官方接受修改</p>\n<h2 id=\"自定义git\"><a href=\"#自定义git\" class=\"headerlink\" title=\"自定义git\"></a>自定义git</h2><h3 id=\"配置用户名和email\"><a href=\"#配置用户名和email\" class=\"headerlink\" title=\"配置用户名和email\"></a>配置用户名和email</h3><p>如果遇到以下问题：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">*** Please tell me who you are.</div><div class=\"line\"></div><div class=\"line\">Run</div><div class=\"line\"></div><div class=\"line\">git config --global user.email &quot;you@example.com&quot;</div><div class=\"line\">git config --global user.name &quot;Your Name&quot;</div><div class=\"line\"></div><div class=\"line\">to set your account&apos;s default identity.</div><div class=\"line\">Omit --global to set the identity only in this repository.</div><div class=\"line\"></div><div class=\"line\">&gt;&gt;&gt;fatal: unable to auto-detect email address (got &apos;xxx@xxx.(none)&apos;)</div></pre></td></tr></table></figure></p>\n<p>需要配置<code>用户名</code>和<code>邮箱</code>：</p>\n<blockquote>\n<p>$ git config –global user.name “Your Name”<br>$ git config –global user.email “email@example.com”</p>\n</blockquote>\n<h3 id=\"给git命令添加颜色\"><a href=\"#给git命令添加颜色\" class=\"headerlink\" title=\"给git命令添加颜色\"></a>给git命令添加颜色</h3><blockquote>\n<p>$ git config –global color.ui true</p>\n</blockquote>\n<h3 id=\"忽略特殊文件\"><a href=\"#忽略特殊文件\" class=\"headerlink\" title=\"忽略特殊文件\"></a>忽略特殊文件</h3><ul>\n<li>忽略文件的原则<ul>\n<li>忽略操作系统自动生成的文件，比如缩略图等；</li>\n<li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；</li>\n<li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li>\n</ul>\n</li>\n<li>强制添加被忽略的文件<blockquote>\n<p>$ git add -f App.class </p>\n</blockquote>\n</li>\n</ul>\n<p>查看想添加的文件被.gitignore中的哪条规则忽略了  </p>\n<blockquote>\n<p>$ git check-ignore -v App.class </p>\n</blockquote>\n<p>注意：.gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理</p>\n<h3 id=\"配置别名\"><a href=\"#配置别名\" class=\"headerlink\" title=\"配置别名\"></a>配置别名</h3><blockquote>\n<p>$ git config –global alias.st status<br>$ git config –global alias.co checkout<br>$ git config –global alias.ci commit<br>$ git config –global alias.br branch<br>$ git config –global alias.unstage ‘reset HEAD’<br>$ git config –global alias.last ‘log -1’<br>$ git config –global alias.lg “log –color –graph –</p>\n</blockquote>\n<p>注意：<code>--global</code>是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用</p>\n<h3 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h3><p>每个仓库的Git配置文件都放在.git/config文件中，查看配置文件</p>\n<blockquote>\n<p>$ cat .git/config<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">[core]</div><div class=\"line\">repositoryformatversion = 0</div><div class=\"line\">filemode = false</div><div class=\"line\">bare = false</div><div class=\"line\">logallrefupdates = true</div><div class=\"line\">symlinks = false</div><div class=\"line\">ignorecase = true</div><div class=\"line\">hideDotFiles = dotGitOnly</div><div class=\"line\">[remote &quot;origin&quot;]</div><div class=\"line\">url = git@xxx</div><div class=\"line\">fetch = +refs/heads/*:refs/remotes/origin/*</div><div class=\"line\">[branch &quot;master&quot;]</div><div class=\"line\">remote = origin</div><div class=\"line\">merge = refs/heads/master</div></pre></td></tr></table></figure></p>\n<p>$ cat ~/gitconfig<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">[user]</div><div class=\"line\">email = xxx</div><div class=\"line\">name = xxx</div><div class=\"line\">[color]</div><div class=\"line\">ui = true</div><div class=\"line\">[alias]</div><div class=\"line\">st = status</div><div class=\"line\">co = checkout</div><div class=\"line\">br = branch</div><div class=\"line\">[gui]</div><div class=\"line\">encoding = gbk</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>要删除别名，直接把对应的行删掉即可<br>改错了，可以删掉文件重新通过命令配置</p>\n<h2 id=\"自己搭建git服务器\"><a href=\"#自己搭建git服务器\" class=\"headerlink\" title=\"自己搭建git服务器\"></a>自己搭建git服务器</h2><p>（1）安装git<br>sudo apt-get install git<br>（2）创建一个git用户，用来运行git服务<br>sudo adduser git<br>（3）创建证书登录<br>收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个<br>（4）初始化Git仓库<br>sudo chown -R git:git sample.git<br>（5）禁用shell登录<br>出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：<br>git:x:1001:1001:,,,:/home/git:/bin/bash<br>改为：<br>　git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell<br>这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。<br>（6）克隆远程仓库<br>git clone git@server:/srv/sample.git<br>（7）要方便管理公钥，用Gitosis；<br>　　要像SVN那样变态地控制权限，用Gitolite。</p>\n<h2 id=\"git命令汇总\"><a href=\"#git命令汇总\" class=\"headerlink\" title=\"git命令汇总\"></a>git命令汇总</h2><p>git init </p>\n<p>git add<br>git commit<br>git rm<br>git status</p>\n<p>git diff<br>git log (–pretty=oneling)<br>git reflog</p>\n<p>git checkout – filename<br>git reset HEAD filename<br>git reset –hard HEAD^(commitid)</p>\n<p>git add remote origin git/https<br>git push/pull/clone</p>\n<p>git branch second<br>git checkout second<br>git checkout -b second<br>git branch<br>git branch -d second<br>git log –graph –pretty=oneline –abbrev-commit</p>\n<p>git stash<br>git stash list<br>git stash apply<br>git stash drop<br>git stash pop<br>git stash apply stash@{0}</p>\n<p>git remote -v<br>git checkout -b dev origin/dev<br>git branch –set-upstream-to=origin/dev dev<br>git pull</p>\n<p>git tag name<br>git tag tagname commitid<br>git tag -a tagname -m “description”<br>git tag<br>git show tagname<br>git push origin tagname<br>git push origin –tags<br>git tag -d tagname<br>git push origin :refs/tags/tagname</p>\n<p>ssh-keygen -t rsa -C “xxxxx@xxxxx.com”<br>cat ~/.ssh/id_rsa.pub<br>ssh -T git@github.com （github）</p>\n<p>git add -f App.class</p>\n<p>git config user.name “username”<br>git config user.email “email”<br>git config –global alias.st status</p>\n<h2 id=\"附Unix命令\"><a href=\"#附Unix命令\" class=\"headerlink\" title=\"附Unix命令\"></a>附Unix命令</h2><p>（1）创建文件夹：mkdir<br>（2）跳到指定路径：cd<br>（3）查看当前完整路径：pwd<br>（4）查看当前路径下的所有文件及文件夹：ls<br>（5）cat：可以显示文件内容，但是不能编辑<br>（6）touch：如果文件存在，使用touch指令可更改这个文件或目录的日期时间，包括存取时间和更改时间；<br>如果文件不存在，touch指令会在当前目录下新建一个空白文件<br>（7）vi/vim：打开文件后可以编辑<br>（8）echo：输出</p>\n<p><a href=\"http://git-scm.com\" target=\"_blank\" rel=\"external\">Git的官方网站</a></p>\n<p>本文为阅读廖雪峰的官方网站中的git教程的学习笔记，仅为自己的一点学习记录，原文写的非常好，作者很厉害，有兴趣的朋友可以阅读原文：<a href=\"http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\" title=\"廖雪峰的官方网站的git教程\" target=\"_blank\" rel=\"external\">廖雪峰的官方网站的git教程</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"初始化仓库\"><a href=\"#初始化仓库\" class=\"headerlink\" title=\"初始化仓库\"></a>初始化仓库</h2><blockquote>\n<p>$ git init</p>\n</blockquote>\n<h2 id=\"提交代码\"><a href=\"#提交代码\" class=\"headerlink\" title=\"提交代码\"></a>提交代码</h2><blockquote>\n<p>$ git add .<br>$ git commit -m “”</p>\n</blockquote>","more":"<h2 id=\"查看状态\"><a href=\"#查看状态\" class=\"headerlink\" title=\"查看状态\"></a>查看状态</h2><blockquote>\n<p>$ git status</p>\n</blockquote>\n<h2 id=\"查看修改\"><a href=\"#查看修改\" class=\"headerlink\" title=\"查看修改\"></a>查看修改</h2><blockquote>\n<p>$ git diff<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">-change something</div><div class=\"line\">+change</div></pre></td></tr></table></figure></p>\n<p>$ git diff &gt; 1.diff<br>将diff修改写到1.diff文件中</p>\n</blockquote>\n<h2 id=\"查看提交历史\"><a href=\"#查看提交历史\" class=\"headerlink\" title=\"查看提交历史\"></a>查看提交历史</h2><blockquote>\n<p>$ git log</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">commit acbcfcfa48c89deb725aae9e03a68a2f5abaa1d4</div><div class=\"line\">Author: gcl &lt;155@163.com&gt;</div><div class=\"line\">Date:   Tue Feb 7 14:30:11 2017 +0800</div><div class=\"line\"></div><div class=\"line\">change 2</div><div class=\"line\"></div><div class=\"line\">commit 99f733644454644d90b8ee39c6737dc283c78cec</div><div class=\"line\">Author: gcl &lt;155@163.com&gt;</div><div class=\"line\">Date:   Tue Feb 7 14:27:55 2017 +0800</div><div class=\"line\"></div><div class=\"line\">change readme.txt</div><div class=\"line\"></div><div class=\"line\">commit 58110376e350d36c8df095b17ff2ecb44906eae2</div><div class=\"line\">Author: gcl &lt;155@163.com&gt;</div><div class=\"line\">Date:   Tue Feb 7 14:25:17 2017 +0800</div><div class=\"line\"></div><div class=\"line\">add readme.txt</div></pre></td></tr></table></figure>\n<h3 id=\"简化版本信息\"><a href=\"#简化版本信息\" class=\"headerlink\" title=\"简化版本信息\"></a>简化版本信息</h3><blockquote>\n<p>$ git log –pretty=oneline<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">acbcfcfa48c89deb725aae9e03a68a2f5abaa1d4 change 2</div><div class=\"line\">99f733644454644d90b8ee39c6737dc283c78cec change readme.txt</div><div class=\"line\">58110376e350d36c8df095b17ff2ecb44906eae2 add readme.txt</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"查看命令历史\"><a href=\"#查看命令历史\" class=\"headerlink\" title=\"查看命令历史\"></a>查看命令历史</h3><blockquote>\n<p>$ git reflog<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">acbcfcf HEAD@&#123;0&#125;: reset: moving to acbcfcfa4</div><div class=\"line\">99f7336 HEAD@&#123;1&#125;: reset: moving to HEAD^</div><div class=\"line\">acbcfcf HEAD@&#123;2&#125;: commit: change 2</div><div class=\"line\">99f7336 HEAD@&#123;3&#125;: commit: change readme.txt</div><div class=\"line\">5811037 HEAD@&#123;4&#125;: commit (initial): add readme.txt</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h2 id=\"回退版本\"><a href=\"#回退版本\" class=\"headerlink\" title=\"回退版本\"></a>回退版本</h2><p>HEAD指向当前版本，<code>HEAD^</code>是上一版本，<code>HEAD^^</code>是上上版本，<code>HEAD~100</code>是上100个版本<br><code>--hard</code>是强制抹除修改，未提交的修改会丢失。<br>git reset –hard <strong><em>慎重使用</em></strong><br><code>--mixed</code>是保存修改，相当于重新提交。</p>\n<h3 id=\"回到上一版本\"><a href=\"#回到上一版本\" class=\"headerlink\" title=\"回到上一版本\"></a>回到上一版本</h3><blockquote>\n<p>$ git reset –hard HEAD^  </p>\n</blockquote>\n<h3 id=\"回到某一历史\"><a href=\"#回到某一历史\" class=\"headerlink\" title=\"回到某一历史\"></a>回到某一历史</h3><blockquote>\n<p>$ git reset –hard commitid</p>\n</blockquote>\n<h2 id=\"工作区与暂存区\"><a href=\"#工作区与暂存区\" class=\"headerlink\" title=\"工作区与暂存区\"></a>工作区与暂存区</h2><ul>\n<li><code>respository文件夹</code>：工作区</li>\n<li><code>.git</code>：版本库，包含了stage（暂存区），分支master，指针HEAD</li>\n<li><code>git add</code>是把文件修改放到了暂存区，<code>git commit</code>把暂存区的内容提交到了分支，没有提交到暂存区的修改是不会被提交到分支的<br>提交的事件线：<code>工作区-&gt;git add-&gt;暂存区-&gt;git commit-&gt;分支</code></li>\n</ul>\n<h2 id=\"撤销修改\"><a href=\"#撤销修改\" class=\"headerlink\" title=\"撤销修改\"></a>撤销修改</h2><p><code>git管理的是修改，而不是文件</code></p>\n<ul>\n<li>清空工作区的修改，回到最近一次git commit或git add时的状态（用版本库的版本替换工作区的版本）：git checkout – readme.txt （注意：git checkout 是切换分支命令）</li>\n<li>撤销add后，commit前在暂存区的修改，将暂存区的修改放回工作区：git reset HEAD readme.txt（注意：reset可以回退版本，还可以撤销add到暂存区的内容，回退到工作区，如果要撤销在工作区的修改，可以再次checkout – file）</li>\n<li>撤销commit之后，push之前：版本回退，git reset</li>\n<li>git push：无法撤销</li>\n</ul>\n<h2 id=\"删除文件\"><a href=\"#删除文件\" class=\"headerlink\" title=\"删除文件\"></a>删除文件</h2><h3 id=\"确定删除\"><a href=\"#确定删除\" class=\"headerlink\" title=\"确定删除\"></a>确定删除</h3><blockquote>\n<p>git rm filename<br>git commit</p>\n</blockquote>\n<h3 id=\"撤销删除，找回文件\"><a href=\"#撤销删除，找回文件\" class=\"headerlink\" title=\"撤销删除，找回文件\"></a>撤销删除，找回文件</h3><blockquote>\n<p>git checkout – filename<br>注意：<code>git checkout</code>是使用版本库中的最新版本替换工作区的版本，即撤销git add/rm之前的修改</p>\n</blockquote>\n<h2 id=\"远程仓库\"><a href=\"#远程仓库\" class=\"headerlink\" title=\"远程仓库\"></a>远程仓库</h2><ul>\n<li>本地库master与远程库origin关联，origin为远程库的默认叫法<blockquote>\n<p>$ git remote add origin git@github.com:XXX/learngit.git（XXX为你的github账户名）</p>\n</blockquote>\n</li>\n<li>将本地库中的所有内容推送到远程库中，加上-u将本地master分支和远程origin分支关联起来，以后推送就可以直接使用git push简化命令<blockquote>\n<p>$ git push -u origin master</p>\n</blockquote>\n</li>\n<li>以后推送使用以下命令<blockquote>\n<p>$ git push origin master</p>\n</blockquote>\n</li>\n<li>把远程库克隆到本地,使用https速度慢，而且每次都要输入口令<blockquote>\n<p>$ git clone ssh或https</p>\n</blockquote>\n</li>\n<li>push与pull<ul>\n<li>push：本地 –&gt; 远程，如果本地超前远程，需要push</li>\n<li>pull：本地 &lt;– 远程，如果本地落后远程，需要pull </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"分支管理\"><a href=\"#分支管理\" class=\"headerlink\" title=\"分支管理\"></a>分支管理</h2><p><code>HEAD指向当前分支--master分支，master指向最新提交</code></p>\n<h3 id=\"创建分支\"><a href=\"#创建分支\" class=\"headerlink\" title=\"创建分支\"></a>创建分支</h3><ul>\n<li>创建分支<br>将当前分支中的所有文件拷贝到新分支<blockquote>\n<p>$ git branch second</p>\n</blockquote>\n</li>\n<li>切换到分支  <blockquote>\n<p>$ git checkout second</p>\n</blockquote>\n</li>\n<li>创建+切换到分支  <blockquote>\n<p>$ git checkout -b second</p>\n</blockquote>\n</li>\n<li>查看当前分支  <blockquote>\n<p>$ git branch</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"合并分支\"><a href=\"#合并分支\" class=\"headerlink\" title=\"合并分支\"></a>合并分支</h3><ul>\n<li>合并指定分支到当前分支(主分支)  <blockquote>\n<p>$ git branch master<br>$ git merge second</p>\n</blockquote>\n</li>\n<li>撤销合并操作  <blockquote>\n<p>$ git reset</p>\n</blockquote>\n</li>\n<li>合并模式  <ul>\n<li>”fast forward”模式：合并分支默认使用”fast forward”模式，删除分支会丢掉分支信息，合并后看不出做过合并</li>\n<li>普通模式：禁用”fast forward” 使用普通模式，合并后的历史可以看出曾经做过合并，在merge时生成一个新的commit。<br>禁用”fast forward”并且加上了commit描述：<blockquote>\n<p>$ git merge –no-ff -m “merge with no-ff” second</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>如果出现冲突:git status-&gt;修改冲突-&gt;git add-&gt;git commit</p>\n</li>\n<li><p>git rebase origin master<br>如果出现冲突:git status-&gt;修改冲突-&gt;git add-&gt;<code>git rebase --continue</code></p>\n</li>\n</ul>\n<h3 id=\"查看分支\"><a href=\"#查看分支\" class=\"headerlink\" title=\"查看分支\"></a>查看分支</h3><blockquote>\n<p>$ git log  </p>\n<ul>\n<li>查看分支合并图<br>$ git log –graph<br>$ git log –graph –pretty=oneline –abbrev-commit</li>\n</ul>\n</blockquote>\n<h3 id=\"删除分支\"><a href=\"#删除分支\" class=\"headerlink\" title=\"删除分支\"></a>删除分支</h3><blockquote>\n<p>$ git branch -d second<br>$ git branch -D second：强行删除一个没有合并过的分支<br>$ git push origin –delete second 删除远程分支</p>\n</blockquote>\n<h3 id=\"分支管理策略\"><a href=\"#分支管理策略\" class=\"headerlink\" title=\"分支管理策略\"></a>分支管理策略</h3><p>本地分支：master，dev，bug，feature<br>远程分支：origin，dev<br><img src=\"http://o8cfktdb3.bkt.clouddn.com/branch.png\" alt=\"“插入图片”\"> </p>\n<h3 id=\"解决冲突\"><a href=\"#解决冲突\" class=\"headerlink\" title=\"解决冲突\"></a>解决冲突</h3><ul>\n<li>查看冲突<blockquote>\n<p>$ git status</p>\n</blockquote>\n</li>\n<li>查看分支合并图 git log –graph<blockquote>\n<p>$ git log –graph –pretty=oneline –abbrev-commit</p>\n</blockquote>\n</li>\n<li>解决冲突<br>合并分支发生冲突后，解决冲突步骤：查看冲突-&gt;修改-&gt;提交-&gt;合并完成</li>\n</ul>\n<h3 id=\"bug分支\"><a href=\"#bug分支\" class=\"headerlink\" title=\"bug分支\"></a>bug分支</h3><p>将当前无法提交到现场先保存起来，使工作区恢复clean状态，修复bug后，再将保存的东西解开</p>\n<ul>\n<li>将工作现场先保存起来：git stash</li>\n<li>查看保存现场记录：git stash list</li>\n<li>恢复工作线程<ul>\n<li>git stash apply ：stash内容不删除，需要使用git stash drop手动删除</li>\n<li>git stash pop：恢复的同时将stash的内容删除</li>\n<li>git stash apply stash@{0}：有多个stah时，指定恢复到某个stash</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"feature分支\"><a href=\"#feature分支\" class=\"headerlink\" title=\"feature分支\"></a>feature分支</h3><p>新添加功能时创建feature分支，开发完成合并到主分支，最好在开发新功能时为每一个新功能创建一个分支</p>\n<h3 id=\"多人协作\"><a href=\"#多人协作\" class=\"headerlink\" title=\"多人协作\"></a>多人协作</h3><h4 id=\"查看远程库\"><a href=\"#查看远程库\" class=\"headerlink\" title=\"查看远程库\"></a>查看远程库</h4><ul>\n<li>查看远程库的信息<blockquote>\n<p>$ git remote</p>\n</blockquote>\n</li>\n<li>查看远程分支详细信息<blockquote>\n<p>$ git remote -v</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"推送分支\"><a href=\"#推送分支\" class=\"headerlink\" title=\"推送分支\"></a>推送分支</h4><p>将本地某个分支中的所有提交推送到远程库</p>\n<blockquote>\n<p>$ git push origin master<br>一般只推送master和dev分支，其他可以在本地放着</p>\n</blockquote>\n<h4 id=\"抓取分支\"><a href=\"#抓取分支\" class=\"headerlink\" title=\"抓取分支\"></a>抓取分支</h4><p>创建本地dev分支：</p>\n<blockquote>\n<p>$ git checkout -b dev origin/dev</p>\n<ul>\n<li>git pull提示“no tracking information”,设置dev和origin/dev的链接：<br>$ git branch –set-upstream dev origin/dev<br>$ git pull<br>$ git add/commit/push</li>\n</ul>\n</blockquote>\n<ul>\n<li>注意：如果git pull时提示“no tracking information”，则需要指定本地master/dev分支与远程origin/dev分支的链接后，才能pull<blockquote>\n<p>$ git branch –set-upstream dev origin/dev  已弃用<br>$ git branch –set-upstream-to=origin/dev dev  最新用法</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"多⼈人协作的⼯工作模式\"><a href=\"#多⼈人协作的⼯工作模式\" class=\"headerlink\" title=\"多⼈人协作的⼯工作模式:\"></a>多⼈人协作的⼯工作模式:</h4><p>（1）git push origin branch-name<br>（2）如果推送失败,则因为远程分⽀支⽐比你的本地更新,需要先⽤用git pull试图合并;<br>（3）如果合并有冲突,则解决冲突,并在本地提交;<br>（4）没有冲突或者解决掉冲突后,再⽤用git push origin branch-name推送就能成功! </p>\n<h2 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h2><h3 id=\"添加标签\"><a href=\"#添加标签\" class=\"headerlink\" title=\"添加标签\"></a>添加标签</h3><ul>\n<li>添加标签<blockquote>\n<p>$ git tag v1.0</p>\n</blockquote>\n</li>\n<li>补加标签<blockquote>\n<p>$ git log –pretty=oneline –abbrev-commit<br>$ git tag v0.9 commitid</p>\n</blockquote>\n</li>\n<li>添加说明<br>用<code>-a</code>指定标签名，<code>-m</code>指定说明文字：<blockquote>\n<p>$ git tag -a v0.1 -m “version 0.1 released” 3628164</p>\n</blockquote>\n</li>\n<li>私钥签名标签<blockquote>\n<p>$ git tag -s v0.2 -m “signed version 0.2 released” fec145a</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"查看标签\"><a href=\"#查看标签\" class=\"headerlink\" title=\"查看标签\"></a>查看标签</h3><ul>\n<li>查看所有标签<blockquote>\n<p>$ git tag</p>\n</blockquote>\n</li>\n<li>查看标签信息<blockquote>\n<p>$ git show v0.9<br><code>注意，标签不是按时间顺序列出，而是按字母排序的。</code></p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"推送标签\"><a href=\"#推送标签\" class=\"headerlink\" title=\"推送标签\"></a>推送标签</h3><ul>\n<li>推送某一标签<blockquote>\n<p>$ git push origin v1.0</p>\n</blockquote>\n</li>\n<li>推送本地所有未推送标签<blockquote>\n<p>$ git push origin –tags</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"删除标签\"><a href=\"#删除标签\" class=\"headerlink\" title=\"删除标签\"></a>删除标签</h3><ul>\n<li>删除本地标签<blockquote>\n<p>$ git tag -d v1.0</p>\n</blockquote>\n</li>\n<li>删除远程标签<ul>\n<li>需要先删除本地标签：<blockquote>\n<p>$ git tag -d v1.0</p>\n</blockquote>\n</li>\n<li>推送到远程：<blockquote>\n<p>$ git push origin :refs/tags/v1.0</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"github使用\"><a href=\"#github使用\" class=\"headerlink\" title=\"github使用\"></a>github使用</h2><h3 id=\"SSH\"><a href=\"#SSH\" class=\"headerlink\" title=\"SSH\"></a>SSH</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ ssh-keygen -t rsa -C &quot;xxxxx@xxxxx.com&quot;</div><div class=\"line\"># Creates a new ssh key using the provided email</div><div class=\"line\"># Generating public/private rsa key pair...</div><div class=\"line\">$ cat ~/.ssh/id_rsa.pub</div><div class=\"line\"># ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC6eNtGpNGwstc.... </div><div class=\"line\">将public key添加</div><div class=\"line\">$ ssh -T git@github.com （github）</div><div class=\"line\">ssh -T git@git.oschina.net (oschina)</div><div class=\"line\">Welcome to Git@OSC, yourname!</div></pre></td></tr></table></figure>\n<h3 id=\"为开源仓库贡献代码\"><a href=\"#为开源仓库贡献代码\" class=\"headerlink\" title=\"为开源仓库贡献代码\"></a>为开源仓库贡献代码</h3><h4 id=\"fork\"><a href=\"#fork\" class=\"headerlink\" title=\"fork\"></a>fork</h4><p>在GitHub上，可以任意Fork开源仓库</p>\n<h4 id=\"提交修改\"><a href=\"#提交修改\" class=\"headerlink\" title=\"提交修改\"></a>提交修改</h4><p>自己拥有Fork后的仓库的读写权限，从自己帐号克隆仓库，然后提交到自己的仓库</p>\n<h4 id=\"pull-request\"><a href=\"#pull-request\" class=\"headerlink\" title=\"pull request\"></a>pull request</h4><p>请求官方接受修改</p>\n<h2 id=\"自定义git\"><a href=\"#自定义git\" class=\"headerlink\" title=\"自定义git\"></a>自定义git</h2><h3 id=\"配置用户名和email\"><a href=\"#配置用户名和email\" class=\"headerlink\" title=\"配置用户名和email\"></a>配置用户名和email</h3><p>如果遇到以下问题：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">*** Please tell me who you are.</div><div class=\"line\"></div><div class=\"line\">Run</div><div class=\"line\"></div><div class=\"line\">git config --global user.email &quot;you@example.com&quot;</div><div class=\"line\">git config --global user.name &quot;Your Name&quot;</div><div class=\"line\"></div><div class=\"line\">to set your account&apos;s default identity.</div><div class=\"line\">Omit --global to set the identity only in this repository.</div><div class=\"line\"></div><div class=\"line\">&gt;&gt;&gt;fatal: unable to auto-detect email address (got &apos;xxx@xxx.(none)&apos;)</div></pre></td></tr></table></figure></p>\n<p>需要配置<code>用户名</code>和<code>邮箱</code>：</p>\n<blockquote>\n<p>$ git config –global user.name “Your Name”<br>$ git config –global user.email “email@example.com”</p>\n</blockquote>\n<h3 id=\"给git命令添加颜色\"><a href=\"#给git命令添加颜色\" class=\"headerlink\" title=\"给git命令添加颜色\"></a>给git命令添加颜色</h3><blockquote>\n<p>$ git config –global color.ui true</p>\n</blockquote>\n<h3 id=\"忽略特殊文件\"><a href=\"#忽略特殊文件\" class=\"headerlink\" title=\"忽略特殊文件\"></a>忽略特殊文件</h3><ul>\n<li>忽略文件的原则<ul>\n<li>忽略操作系统自动生成的文件，比如缩略图等；</li>\n<li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；</li>\n<li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li>\n</ul>\n</li>\n<li>强制添加被忽略的文件<blockquote>\n<p>$ git add -f App.class </p>\n</blockquote>\n</li>\n</ul>\n<p>查看想添加的文件被.gitignore中的哪条规则忽略了  </p>\n<blockquote>\n<p>$ git check-ignore -v App.class </p>\n</blockquote>\n<p>注意：.gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理</p>\n<h3 id=\"配置别名\"><a href=\"#配置别名\" class=\"headerlink\" title=\"配置别名\"></a>配置别名</h3><blockquote>\n<p>$ git config –global alias.st status<br>$ git config –global alias.co checkout<br>$ git config –global alias.ci commit<br>$ git config –global alias.br branch<br>$ git config –global alias.unstage ‘reset HEAD’<br>$ git config –global alias.last ‘log -1’<br>$ git config –global alias.lg “log –color –graph –</p>\n</blockquote>\n<p>注意：<code>--global</code>是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用</p>\n<h3 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h3><p>每个仓库的Git配置文件都放在.git/config文件中，查看配置文件</p>\n<blockquote>\n<p>$ cat .git/config<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">[core]</div><div class=\"line\">repositoryformatversion = 0</div><div class=\"line\">filemode = false</div><div class=\"line\">bare = false</div><div class=\"line\">logallrefupdates = true</div><div class=\"line\">symlinks = false</div><div class=\"line\">ignorecase = true</div><div class=\"line\">hideDotFiles = dotGitOnly</div><div class=\"line\">[remote &quot;origin&quot;]</div><div class=\"line\">url = git@xxx</div><div class=\"line\">fetch = +refs/heads/*:refs/remotes/origin/*</div><div class=\"line\">[branch &quot;master&quot;]</div><div class=\"line\">remote = origin</div><div class=\"line\">merge = refs/heads/master</div></pre></td></tr></table></figure></p>\n<p>$ cat ~/gitconfig<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">[user]</div><div class=\"line\">email = xxx</div><div class=\"line\">name = xxx</div><div class=\"line\">[color]</div><div class=\"line\">ui = true</div><div class=\"line\">[alias]</div><div class=\"line\">st = status</div><div class=\"line\">co = checkout</div><div class=\"line\">br = branch</div><div class=\"line\">[gui]</div><div class=\"line\">encoding = gbk</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>要删除别名，直接把对应的行删掉即可<br>改错了，可以删掉文件重新通过命令配置</p>\n<h2 id=\"自己搭建git服务器\"><a href=\"#自己搭建git服务器\" class=\"headerlink\" title=\"自己搭建git服务器\"></a>自己搭建git服务器</h2><p>（1）安装git<br>sudo apt-get install git<br>（2）创建一个git用户，用来运行git服务<br>sudo adduser git<br>（3）创建证书登录<br>收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个<br>（4）初始化Git仓库<br>sudo chown -R git:git sample.git<br>（5）禁用shell登录<br>出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：<br>git:x:1001:1001:,,,:/home/git:/bin/bash<br>改为：<br>　git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell<br>这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。<br>（6）克隆远程仓库<br>git clone git@server:/srv/sample.git<br>（7）要方便管理公钥，用Gitosis；<br>　　要像SVN那样变态地控制权限，用Gitolite。</p>\n<h2 id=\"git命令汇总\"><a href=\"#git命令汇总\" class=\"headerlink\" title=\"git命令汇总\"></a>git命令汇总</h2><p>git init </p>\n<p>git add<br>git commit<br>git rm<br>git status</p>\n<p>git diff<br>git log (–pretty=oneling)<br>git reflog</p>\n<p>git checkout – filename<br>git reset HEAD filename<br>git reset –hard HEAD^(commitid)</p>\n<p>git add remote origin git/https<br>git push/pull/clone</p>\n<p>git branch second<br>git checkout second<br>git checkout -b second<br>git branch<br>git branch -d second<br>git log –graph –pretty=oneline –abbrev-commit</p>\n<p>git stash<br>git stash list<br>git stash apply<br>git stash drop<br>git stash pop<br>git stash apply stash@{0}</p>\n<p>git remote -v<br>git checkout -b dev origin/dev<br>git branch –set-upstream-to=origin/dev dev<br>git pull</p>\n<p>git tag name<br>git tag tagname commitid<br>git tag -a tagname -m “description”<br>git tag<br>git show tagname<br>git push origin tagname<br>git push origin –tags<br>git tag -d tagname<br>git push origin :refs/tags/tagname</p>\n<p>ssh-keygen -t rsa -C “xxxxx@xxxxx.com”<br>cat ~/.ssh/id_rsa.pub<br>ssh -T git@github.com （github）</p>\n<p>git add -f App.class</p>\n<p>git config user.name “username”<br>git config user.email “email”<br>git config –global alias.st status</p>\n<h2 id=\"附Unix命令\"><a href=\"#附Unix命令\" class=\"headerlink\" title=\"附Unix命令\"></a>附Unix命令</h2><p>（1）创建文件夹：mkdir<br>（2）跳到指定路径：cd<br>（3）查看当前完整路径：pwd<br>（4）查看当前路径下的所有文件及文件夹：ls<br>（5）cat：可以显示文件内容，但是不能编辑<br>（6）touch：如果文件存在，使用touch指令可更改这个文件或目录的日期时间，包括存取时间和更改时间；<br>如果文件不存在，touch指令会在当前目录下新建一个空白文件<br>（7）vi/vim：打开文件后可以编辑<br>（8）echo：输出</p>\n<p><a href=\"http://git-scm.com\" target=\"_blank\" rel=\"external\">Git的官方网站</a></p>\n<p>本文为阅读廖雪峰的官方网站中的git教程的学习笔记，仅为自己的一点学习记录，原文写的非常好，作者很厉害，有兴趣的朋友可以阅读原文：<a href=\"http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\" title=\"廖雪峰的官方网站的git教程\" target=\"_blank\" rel=\"external\">廖雪峰的官方网站的git教程</a></p>"},{"title":"hexo创建个人博客记录","date":"2017-02-18T08:43:01.000Z","keywords":null,"_content":"\n## 常见命令\n###  1.安装hexo\n``` \n$ sudo npm install -g hexo\n```\n\n###  2.初始化\n``` \n$ hexo init\n```\n<!--more-->\n###  3.生成静态页面\n``` \n$ hexo generate（hexo g也可以）\n```\n\n###  4.启动本地服务，进行文章预览调试,浏览器输入http://localhost:4000即可\n``` \n$ hexo server（hexo s也可以）\n```\n\n###  5.发布配置\n``` \n$ hexo deploy（hexo d也可以）\n```\n\n每次部署的步骤，可按以下三步来进行: `hexo clean`，`hexo generate`，`hexo deploy`，或者 `hexo d -g`\n\n###  6.新建文章\n``` \n$ hexo new\"postName\" \n```\n\n###  7.新建页面\n``` \n$ hexo new page\"pageName\" \n```\n\n### 8.添加统计数据\n在themes/yilia/layout/_partial/footer.ejs文件`<style>`上添加以下代码：\n```\n<script async src=\"//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\">\n```\n\n`<style>`下添加以下代码：\n```\n本站总访问量<span id=\"busuanzi_value_site_pv\"></span>次\n本站访客数<span id=\"busuanzi_value_site_uv\"></span>人次\n本文总阅读量<span id=\"busuanzi_value_page_pv\"></span>次\n```\n\n## hexo填坑历程\n(1)坑一：hexo命令找不到\n```\nERROR Local hexo not found in E:\\blog\nERROR Try running: 'npm install hexo --save'\n```\n\n解决：按照提示输入`npm install hexo --save`，如果不可以，可能是：\n因为安装包中有些内容在墙外，所以可以换淘宝源，或者用\n> $ npm install -g hexo-cli --no-optional(**很重要**)\n有时候只写`npm install --no-optional`也不行，只能以上命令\n\n如果还是不可以，可能是由于：\n.gitignore文件里面忽略了node_modules文件夹，所以这个文件夹没有更新上去。所以用npm重新安装即可，输入以下命令：\n```\ncd ...\\blog\nnpm install\nhexo server\n```\n\n(2)坑二：ERROR Deployer not found: git\n> $ npm install hexo-deployer-git --save \n然后重新 deploy 即可\n\n(3)坑三：hexo deploy成功，但是页面不显示\n解决：\n到仓库下的settings下修改GitHub Pages，source选择master分支，显示 `Your site is published at https://XXX.github.io/`即可\n\n(4)坑四：\n```\nfatal: Not a git repository (or any of the parent directories): .git\nFATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html\nError: fatal: Not a git repository (or any of the parent directories): .git\n```\n\n解决：\n检查_config.yml文件deploy的配置如下：\n```\ntype: git\nrepo: https://github.com/XXX/XXX.github.io.git\n```\n\n如果还是不可以，请看下一解决方案。\n\n(5)坑五：Permission to  XXX.github.io.git denied \n解决：\n```\n$ git config --global user.name \"yourname\"\n$ git config --global user.email \"youremail\"\n```\n\n如果以上做完还是出不来，删掉根目录下的文件夹：.deploy_git，重新deploy就可以了。 \n","source":"_posts/hexo创建个人博客记录.md","raw":"---\ntitle: hexo创建个人博客记录\ndate: 2017-02-18 16:43:01\ncategories: 笔记\ntags: [hexo,个人博客]\nkeywords: \n---\n\n## 常见命令\n###  1.安装hexo\n``` \n$ sudo npm install -g hexo\n```\n\n###  2.初始化\n``` \n$ hexo init\n```\n<!--more-->\n###  3.生成静态页面\n``` \n$ hexo generate（hexo g也可以）\n```\n\n###  4.启动本地服务，进行文章预览调试,浏览器输入http://localhost:4000即可\n``` \n$ hexo server（hexo s也可以）\n```\n\n###  5.发布配置\n``` \n$ hexo deploy（hexo d也可以）\n```\n\n每次部署的步骤，可按以下三步来进行: `hexo clean`，`hexo generate`，`hexo deploy`，或者 `hexo d -g`\n\n###  6.新建文章\n``` \n$ hexo new\"postName\" \n```\n\n###  7.新建页面\n``` \n$ hexo new page\"pageName\" \n```\n\n### 8.添加统计数据\n在themes/yilia/layout/_partial/footer.ejs文件`<style>`上添加以下代码：\n```\n<script async src=\"//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\">\n```\n\n`<style>`下添加以下代码：\n```\n本站总访问量<span id=\"busuanzi_value_site_pv\"></span>次\n本站访客数<span id=\"busuanzi_value_site_uv\"></span>人次\n本文总阅读量<span id=\"busuanzi_value_page_pv\"></span>次\n```\n\n## hexo填坑历程\n(1)坑一：hexo命令找不到\n```\nERROR Local hexo not found in E:\\blog\nERROR Try running: 'npm install hexo --save'\n```\n\n解决：按照提示输入`npm install hexo --save`，如果不可以，可能是：\n因为安装包中有些内容在墙外，所以可以换淘宝源，或者用\n> $ npm install -g hexo-cli --no-optional(**很重要**)\n有时候只写`npm install --no-optional`也不行，只能以上命令\n\n如果还是不可以，可能是由于：\n.gitignore文件里面忽略了node_modules文件夹，所以这个文件夹没有更新上去。所以用npm重新安装即可，输入以下命令：\n```\ncd ...\\blog\nnpm install\nhexo server\n```\n\n(2)坑二：ERROR Deployer not found: git\n> $ npm install hexo-deployer-git --save \n然后重新 deploy 即可\n\n(3)坑三：hexo deploy成功，但是页面不显示\n解决：\n到仓库下的settings下修改GitHub Pages，source选择master分支，显示 `Your site is published at https://XXX.github.io/`即可\n\n(4)坑四：\n```\nfatal: Not a git repository (or any of the parent directories): .git\nFATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html\nError: fatal: Not a git repository (or any of the parent directories): .git\n```\n\n解决：\n检查_config.yml文件deploy的配置如下：\n```\ntype: git\nrepo: https://github.com/XXX/XXX.github.io.git\n```\n\n如果还是不可以，请看下一解决方案。\n\n(5)坑五：Permission to  XXX.github.io.git denied \n解决：\n```\n$ git config --global user.name \"yourname\"\n$ git config --global user.email \"youremail\"\n```\n\n如果以上做完还是出不来，删掉根目录下的文件夹：.deploy_git，重新deploy就可以了。 \n","slug":"hexo创建个人博客记录","published":1,"updated":"2017-07-14T03:57:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj53c1dvx001fh3jjb7d4u3ud","content":"<h2 id=\"常见命令\"><a href=\"#常见命令\" class=\"headerlink\" title=\"常见命令\"></a>常见命令</h2><h3 id=\"1-安装hexo\"><a href=\"#1-安装hexo\" class=\"headerlink\" title=\"1.安装hexo\"></a>1.安装hexo</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo npm install -g hexo</div></pre></td></tr></table></figure>\n<h3 id=\"2-初始化\"><a href=\"#2-初始化\" class=\"headerlink\" title=\"2.初始化\"></a>2.初始化</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo init</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h3 id=\"3-生成静态页面\"><a href=\"#3-生成静态页面\" class=\"headerlink\" title=\"3.生成静态页面\"></a>3.生成静态页面</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate（hexo g也可以）</div></pre></td></tr></table></figure>\n<h3 id=\"4-启动本地服务，进行文章预览调试-浏览器输入http-localhost-4000即可\"><a href=\"#4-启动本地服务，进行文章预览调试-浏览器输入http-localhost-4000即可\" class=\"headerlink\" title=\"4.启动本地服务，进行文章预览调试,浏览器输入http://localhost:4000即可\"></a>4.启动本地服务，进行文章预览调试,浏览器输入<a href=\"http://localhost:4000即可\" target=\"_blank\" rel=\"external\">http://localhost:4000即可</a></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server（hexo s也可以）</div></pre></td></tr></table></figure>\n<h3 id=\"5-发布配置\"><a href=\"#5-发布配置\" class=\"headerlink\" title=\"5.发布配置\"></a>5.发布配置</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy（hexo d也可以）</div></pre></td></tr></table></figure>\n<p>每次部署的步骤，可按以下三步来进行: <code>hexo clean</code>，<code>hexo generate</code>，<code>hexo deploy</code>，或者 <code>hexo d -g</code></p>\n<h3 id=\"6-新建文章\"><a href=\"#6-新建文章\" class=\"headerlink\" title=\"6.新建文章\"></a>6.新建文章</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new&quot;postName&quot;</div></pre></td></tr></table></figure>\n<h3 id=\"7-新建页面\"><a href=\"#7-新建页面\" class=\"headerlink\" title=\"7.新建页面\"></a>7.新建页面</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new page&quot;pageName&quot;</div></pre></td></tr></table></figure>\n<h3 id=\"8-添加统计数据\"><a href=\"#8-添加统计数据\" class=\"headerlink\" title=\"8.添加统计数据\"></a>8.添加统计数据</h3><p>在themes/yilia/layout/_partial/footer.ejs文件<code>&lt;style&gt;</code>上添加以下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;</div></pre></td></tr></table></figure></p>\n<p><code>&lt;style&gt;</code>下添加以下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次</div><div class=\"line\">本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次</div><div class=\"line\">本文总阅读量&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次</div></pre></td></tr></table></figure></p>\n<h2 id=\"hexo填坑历程\"><a href=\"#hexo填坑历程\" class=\"headerlink\" title=\"hexo填坑历程\"></a>hexo填坑历程</h2><p>(1)坑一：hexo命令找不到<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">ERROR Local hexo not found in E:\\blog</div><div class=\"line\">ERROR Try running: &apos;npm install hexo --save&apos;</div></pre></td></tr></table></figure></p>\n<p>解决：按照提示输入<code>npm install hexo --save</code>，如果不可以，可能是：<br>因为安装包中有些内容在墙外，所以可以换淘宝源，或者用</p>\n<blockquote>\n<p>$ npm install -g hexo-cli –no-optional(<strong>很重要</strong>)<br>有时候只写<code>npm install --no-optional</code>也不行，只能以上命令</p>\n</blockquote>\n<p>如果还是不可以，可能是由于：<br>.gitignore文件里面忽略了node_modules文件夹，所以这个文件夹没有更新上去。所以用npm重新安装即可，输入以下命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd ...\\blog</div><div class=\"line\">npm install</div><div class=\"line\">hexo server</div></pre></td></tr></table></figure></p>\n<p>(2)坑二：ERROR Deployer not found: git</p>\n<blockquote>\n<p>$ npm install hexo-deployer-git –save<br>然后重新 deploy 即可</p>\n</blockquote>\n<p>(3)坑三：hexo deploy成功，但是页面不显示<br>解决：<br>到仓库下的settings下修改GitHub Pages，source选择master分支，显示 <code>Your site is published at https://XXX.github.io/</code>即可</p>\n<p>(4)坑四：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">fatal: Not a git repository (or any of the parent directories): .git</div><div class=\"line\">FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</div><div class=\"line\">Error: fatal: Not a git repository (or any of the parent directories): .git</div></pre></td></tr></table></figure></p>\n<p>解决：<br>检查_config.yml文件deploy的配置如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">type: git</div><div class=\"line\">repo: https://github.com/XXX/XXX.github.io.git</div></pre></td></tr></table></figure></p>\n<p>如果还是不可以，请看下一解决方案。</p>\n<p>(5)坑五：Permission to  XXX.github.io.git denied<br>解决：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git config --global user.name &quot;yourname&quot;</div><div class=\"line\">$ git config --global user.email &quot;youremail&quot;</div></pre></td></tr></table></figure></p>\n<p>如果以上做完还是出不来，删掉根目录下的文件夹：.deploy_git，重新deploy就可以了。 </p>\n","site":{"data":{}},"excerpt":"<h2 id=\"常见命令\"><a href=\"#常见命令\" class=\"headerlink\" title=\"常见命令\"></a>常见命令</h2><h3 id=\"1-安装hexo\"><a href=\"#1-安装hexo\" class=\"headerlink\" title=\"1.安装hexo\"></a>1.安装hexo</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo npm install -g hexo</div></pre></td></tr></table></figure>\n<h3 id=\"2-初始化\"><a href=\"#2-初始化\" class=\"headerlink\" title=\"2.初始化\"></a>2.初始化</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo init</div></pre></td></tr></table></figure>","more":"<h3 id=\"3-生成静态页面\"><a href=\"#3-生成静态页面\" class=\"headerlink\" title=\"3.生成静态页面\"></a>3.生成静态页面</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate（hexo g也可以）</div></pre></td></tr></table></figure>\n<h3 id=\"4-启动本地服务，进行文章预览调试-浏览器输入http-localhost-4000即可\"><a href=\"#4-启动本地服务，进行文章预览调试-浏览器输入http-localhost-4000即可\" class=\"headerlink\" title=\"4.启动本地服务，进行文章预览调试,浏览器输入http://localhost:4000即可\"></a>4.启动本地服务，进行文章预览调试,浏览器输入<a href=\"http://localhost:4000即可\" target=\"_blank\" rel=\"external\">http://localhost:4000即可</a></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server（hexo s也可以）</div></pre></td></tr></table></figure>\n<h3 id=\"5-发布配置\"><a href=\"#5-发布配置\" class=\"headerlink\" title=\"5.发布配置\"></a>5.发布配置</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy（hexo d也可以）</div></pre></td></tr></table></figure>\n<p>每次部署的步骤，可按以下三步来进行: <code>hexo clean</code>，<code>hexo generate</code>，<code>hexo deploy</code>，或者 <code>hexo d -g</code></p>\n<h3 id=\"6-新建文章\"><a href=\"#6-新建文章\" class=\"headerlink\" title=\"6.新建文章\"></a>6.新建文章</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new&quot;postName&quot;</div></pre></td></tr></table></figure>\n<h3 id=\"7-新建页面\"><a href=\"#7-新建页面\" class=\"headerlink\" title=\"7.新建页面\"></a>7.新建页面</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new page&quot;pageName&quot;</div></pre></td></tr></table></figure>\n<h3 id=\"8-添加统计数据\"><a href=\"#8-添加统计数据\" class=\"headerlink\" title=\"8.添加统计数据\"></a>8.添加统计数据</h3><p>在themes/yilia/layout/_partial/footer.ejs文件<code>&lt;style&gt;</code>上添加以下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;</div></pre></td></tr></table></figure></p>\n<p><code>&lt;style&gt;</code>下添加以下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次</div><div class=\"line\">本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次</div><div class=\"line\">本文总阅读量&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次</div></pre></td></tr></table></figure></p>\n<h2 id=\"hexo填坑历程\"><a href=\"#hexo填坑历程\" class=\"headerlink\" title=\"hexo填坑历程\"></a>hexo填坑历程</h2><p>(1)坑一：hexo命令找不到<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">ERROR Local hexo not found in E:\\blog</div><div class=\"line\">ERROR Try running: &apos;npm install hexo --save&apos;</div></pre></td></tr></table></figure></p>\n<p>解决：按照提示输入<code>npm install hexo --save</code>，如果不可以，可能是：<br>因为安装包中有些内容在墙外，所以可以换淘宝源，或者用</p>\n<blockquote>\n<p>$ npm install -g hexo-cli –no-optional(<strong>很重要</strong>)<br>有时候只写<code>npm install --no-optional</code>也不行，只能以上命令</p>\n</blockquote>\n<p>如果还是不可以，可能是由于：<br>.gitignore文件里面忽略了node_modules文件夹，所以这个文件夹没有更新上去。所以用npm重新安装即可，输入以下命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd ...\\blog</div><div class=\"line\">npm install</div><div class=\"line\">hexo server</div></pre></td></tr></table></figure></p>\n<p>(2)坑二：ERROR Deployer not found: git</p>\n<blockquote>\n<p>$ npm install hexo-deployer-git –save<br>然后重新 deploy 即可</p>\n</blockquote>\n<p>(3)坑三：hexo deploy成功，但是页面不显示<br>解决：<br>到仓库下的settings下修改GitHub Pages，source选择master分支，显示 <code>Your site is published at https://XXX.github.io/</code>即可</p>\n<p>(4)坑四：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">fatal: Not a git repository (or any of the parent directories): .git</div><div class=\"line\">FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</div><div class=\"line\">Error: fatal: Not a git repository (or any of the parent directories): .git</div></pre></td></tr></table></figure></p>\n<p>解决：<br>检查_config.yml文件deploy的配置如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">type: git</div><div class=\"line\">repo: https://github.com/XXX/XXX.github.io.git</div></pre></td></tr></table></figure></p>\n<p>如果还是不可以，请看下一解决方案。</p>\n<p>(5)坑五：Permission to  XXX.github.io.git denied<br>解决：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git config --global user.name &quot;yourname&quot;</div><div class=\"line\">$ git config --global user.email &quot;youremail&quot;</div></pre></td></tr></table></figure></p>\n<p>如果以上做完还是出不来，删掉根目录下的文件夹：.deploy_git，重新deploy就可以了。 </p>"},{"title":"iBeacon学习笔记","date":"2017-07-03T03:05:55.000Z","_content":"","source":"_posts/iBeacon学习笔记.md","raw":"---\ntitle: iBeacon学习笔记\ndate: 2017-07-03 11:05:55\ncategories: 笔记\ntags: [iBeacon]\n---\n","slug":"iBeacon学习笔记","published":1,"updated":"2017-07-14T03:57:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj53c1dvz001ih3jjbzlhkarv","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"iOS IM学习笔记","date":"2017-04-22T03:19:11.000Z","_content":"\n客户端需要做如下4件事：\n* 1.客户端调用 socket(...) 创建socket；\n* 2.客户端调用 connect(...) 向服务器发起连接请求以建立连接；\n* 3.客户端与服务器建立连接之后，就可以通过send(...)/receive(...)向客户端发送或从客户端接收数据；\n* 4.客户端调用 close 关闭 socket；\n<!--more-->\n\n服务端需要做如下5件事：\n* 1.服务器调用 socket(...) 创建socket；\n* 2.服务器调用 listen(...) 设置缓冲区；\n* 3.服务器通过 accept(...)接受客户端请求建立连接；\n* 4.服务器与客户端建立连接之后，就可以通过 send(...)/receive(...)向客户端发送或从客户端接收数据；\n* 5.服务器调用 close 关闭 socket；\n\n可以通过以下几种方式实现：\n* 1.系统socket\n* 2.基于Scoket原生：代表框架 CocoaAsyncSocket\n* 3.基于WebScoket：代表框架 SocketRocket。(npm install ws)\n* 4.MQTTKit：MQTTClient(npm install mosca)\n* 5.XMPP\n* 6.私有协议：基于WebScoket或者Scoket原生进行封装（高效，省流量，安全性高）\n其中MQTT和XMPP为聊天协议，它们是最上层的协议，而WebScoket是传输通讯协议。\n\nXMPP常用对象：\nXMPPStream：xmpp基础服务类\nXMPPRoster：好友列表类\nXMPPRosterCoreDataStorage：好友列表（用户账号）在core data中的操作类\nXMPPvCardCoreDataStorage：好友名片（昵称，签名，性别，年龄等信息）在core data中的操作类\nXMPPvCardTemp：好友名片实体类，从数据库里取出来的都是它\nxmppvCardAvatarModule：好友头像\nXMPPReconnect：如果失去连接,自动重连\nXMPPRoom：提供多用户聊天支持\nXMPPPubSub：发布订阅\n\n代码传送门：[IMWithSocket](https://github.com/guchunli/IMWithSocket)\n\n参考原文：[iOS即时通讯，从入门到“放弃”？](http://www.cocoachina.com/ios/20170110/18544.html)\n[iOS - XMPP 的使用](http://www.cnblogs.com/QianChia/p/6411914.html#_label3)\n","source":"_posts/iOS-IM学习笔记.md","raw":"---\ntitle: iOS IM学习笔记\ndate: 2017-04-22 11:19:11\ncategories: 笔记\ntags: [iOS,IM,socket]\n---\n\n客户端需要做如下4件事：\n* 1.客户端调用 socket(...) 创建socket；\n* 2.客户端调用 connect(...) 向服务器发起连接请求以建立连接；\n* 3.客户端与服务器建立连接之后，就可以通过send(...)/receive(...)向客户端发送或从客户端接收数据；\n* 4.客户端调用 close 关闭 socket；\n<!--more-->\n\n服务端需要做如下5件事：\n* 1.服务器调用 socket(...) 创建socket；\n* 2.服务器调用 listen(...) 设置缓冲区；\n* 3.服务器通过 accept(...)接受客户端请求建立连接；\n* 4.服务器与客户端建立连接之后，就可以通过 send(...)/receive(...)向客户端发送或从客户端接收数据；\n* 5.服务器调用 close 关闭 socket；\n\n可以通过以下几种方式实现：\n* 1.系统socket\n* 2.基于Scoket原生：代表框架 CocoaAsyncSocket\n* 3.基于WebScoket：代表框架 SocketRocket。(npm install ws)\n* 4.MQTTKit：MQTTClient(npm install mosca)\n* 5.XMPP\n* 6.私有协议：基于WebScoket或者Scoket原生进行封装（高效，省流量，安全性高）\n其中MQTT和XMPP为聊天协议，它们是最上层的协议，而WebScoket是传输通讯协议。\n\nXMPP常用对象：\nXMPPStream：xmpp基础服务类\nXMPPRoster：好友列表类\nXMPPRosterCoreDataStorage：好友列表（用户账号）在core data中的操作类\nXMPPvCardCoreDataStorage：好友名片（昵称，签名，性别，年龄等信息）在core data中的操作类\nXMPPvCardTemp：好友名片实体类，从数据库里取出来的都是它\nxmppvCardAvatarModule：好友头像\nXMPPReconnect：如果失去连接,自动重连\nXMPPRoom：提供多用户聊天支持\nXMPPPubSub：发布订阅\n\n代码传送门：[IMWithSocket](https://github.com/guchunli/IMWithSocket)\n\n参考原文：[iOS即时通讯，从入门到“放弃”？](http://www.cocoachina.com/ios/20170110/18544.html)\n[iOS - XMPP 的使用](http://www.cnblogs.com/QianChia/p/6411914.html#_label3)\n","slug":"iOS-IM学习笔记","published":1,"updated":"2017-07-14T03:57:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj53c1dw1001mh3jjfju3ndt5","content":"<p>客户端需要做如下4件事：</p>\n<ul>\n<li>1.客户端调用 socket(…) 创建socket；</li>\n<li>2.客户端调用 connect(…) 向服务器发起连接请求以建立连接；</li>\n<li>3.客户端与服务器建立连接之后，就可以通过send(…)/receive(…)向客户端发送或从客户端接收数据；</li>\n<li>4.客户端调用 close 关闭 socket；<a id=\"more\"></a>\n</li>\n</ul>\n<p>服务端需要做如下5件事：</p>\n<ul>\n<li>1.服务器调用 socket(…) 创建socket；</li>\n<li>2.服务器调用 listen(…) 设置缓冲区；</li>\n<li>3.服务器通过 accept(…)接受客户端请求建立连接；</li>\n<li>4.服务器与客户端建立连接之后，就可以通过 send(…)/receive(…)向客户端发送或从客户端接收数据；</li>\n<li>5.服务器调用 close 关闭 socket；</li>\n</ul>\n<p>可以通过以下几种方式实现：</p>\n<ul>\n<li>1.系统socket</li>\n<li>2.基于Scoket原生：代表框架 CocoaAsyncSocket</li>\n<li>3.基于WebScoket：代表框架 SocketRocket。(npm install ws)</li>\n<li>4.MQTTKit：MQTTClient(npm install mosca)</li>\n<li>5.XMPP</li>\n<li>6.私有协议：基于WebScoket或者Scoket原生进行封装（高效，省流量，安全性高）<br>其中MQTT和XMPP为聊天协议，它们是最上层的协议，而WebScoket是传输通讯协议。</li>\n</ul>\n<p>XMPP常用对象：<br>XMPPStream：xmpp基础服务类<br>XMPPRoster：好友列表类<br>XMPPRosterCoreDataStorage：好友列表（用户账号）在core data中的操作类<br>XMPPvCardCoreDataStorage：好友名片（昵称，签名，性别，年龄等信息）在core data中的操作类<br>XMPPvCardTemp：好友名片实体类，从数据库里取出来的都是它<br>xmppvCardAvatarModule：好友头像<br>XMPPReconnect：如果失去连接,自动重连<br>XMPPRoom：提供多用户聊天支持<br>XMPPPubSub：发布订阅</p>\n<p>代码传送门：<a href=\"https://github.com/guchunli/IMWithSocket\" target=\"_blank\" rel=\"external\">IMWithSocket</a></p>\n<p>参考原文：<a href=\"http://www.cocoachina.com/ios/20170110/18544.html\" target=\"_blank\" rel=\"external\">iOS即时通讯，从入门到“放弃”？</a><br><a href=\"http://www.cnblogs.com/QianChia/p/6411914.html#_label3\" target=\"_blank\" rel=\"external\">iOS - XMPP 的使用</a></p>\n","site":{"data":{}},"excerpt":"<p>客户端需要做如下4件事：</p>\n<ul>\n<li>1.客户端调用 socket(…) 创建socket；</li>\n<li>2.客户端调用 connect(…) 向服务器发起连接请求以建立连接；</li>\n<li>3.客户端与服务器建立连接之后，就可以通过send(…)/receive(…)向客户端发送或从客户端接收数据；</li>\n<li>4.客户端调用 close 关闭 socket；","more":"</li>\n</ul>\n<p>服务端需要做如下5件事：</p>\n<ul>\n<li>1.服务器调用 socket(…) 创建socket；</li>\n<li>2.服务器调用 listen(…) 设置缓冲区；</li>\n<li>3.服务器通过 accept(…)接受客户端请求建立连接；</li>\n<li>4.服务器与客户端建立连接之后，就可以通过 send(…)/receive(…)向客户端发送或从客户端接收数据；</li>\n<li>5.服务器调用 close 关闭 socket；</li>\n</ul>\n<p>可以通过以下几种方式实现：</p>\n<ul>\n<li>1.系统socket</li>\n<li>2.基于Scoket原生：代表框架 CocoaAsyncSocket</li>\n<li>3.基于WebScoket：代表框架 SocketRocket。(npm install ws)</li>\n<li>4.MQTTKit：MQTTClient(npm install mosca)</li>\n<li>5.XMPP</li>\n<li>6.私有协议：基于WebScoket或者Scoket原生进行封装（高效，省流量，安全性高）<br>其中MQTT和XMPP为聊天协议，它们是最上层的协议，而WebScoket是传输通讯协议。</li>\n</ul>\n<p>XMPP常用对象：<br>XMPPStream：xmpp基础服务类<br>XMPPRoster：好友列表类<br>XMPPRosterCoreDataStorage：好友列表（用户账号）在core data中的操作类<br>XMPPvCardCoreDataStorage：好友名片（昵称，签名，性别，年龄等信息）在core data中的操作类<br>XMPPvCardTemp：好友名片实体类，从数据库里取出来的都是它<br>xmppvCardAvatarModule：好友头像<br>XMPPReconnect：如果失去连接,自动重连<br>XMPPRoom：提供多用户聊天支持<br>XMPPPubSub：发布订阅</p>\n<p>代码传送门：<a href=\"https://github.com/guchunli/IMWithSocket\" target=\"_blank\" rel=\"external\">IMWithSocket</a></p>\n<p>参考原文：<a href=\"http://www.cocoachina.com/ios/20170110/18544.html\" target=\"_blank\" rel=\"external\">iOS即时通讯，从入门到“放弃”？</a><br><a href=\"http://www.cnblogs.com/QianChia/p/6411914.html#_label3\" target=\"_blank\" rel=\"external\">iOS - XMPP 的使用</a></p>"},{"title":"iOS runtime学习笔记","date":"2017-03-22T03:39:18.000Z","_content":"\nObjective-C 是一门动态语言，它把很多静态语言在编译和链接时做的事情放到了运行时去处理，它在运行时实现了对类、方法、成员变量、属性等信息的管理机制。\n\n## 运行时的类与对象\n<!--more-->\n类与对象相关的函数\n```\nconst char *class_getName(Class cls)，获取指定类的类名。\nBOOL class_isMetaClass(Class cls)，判断指定类是否是一个元类。\nClass class_getSuperclass(Class cls)，获取指定类的父类。\nClass class_setSuperclass(Class cls, Class newSuper)，设定指定类的父类。\nint class_getVersion(Class cls)，获取指定类的版本信息。\nvoid class_setVersion(Class cls, int version)，设定指定类的版本信息。\nsize_t class_getInstanceSize(Class cls)，获取实例大小。\nIvar class_getInstanceVariable(Class cls, const char *name)，获取指定名字的实例变量。\nIvar class_getClassVariable(Class cls, const char *name)，获取指定名字的类变量。\nIvar *class_copyIvarList(Class cls, unsigned int *outCount)，获取类的成员变量列表的拷贝。调用后需要自己 free()。\nMethod class_getInstanceMethod(Class cls, SEL name)，获取指定名字的实例方法。\nMethod class_getClassMethod(Class cls, SEL name)，获取指定名字的类方法。\nIMP class_getMethodImplementation(Class cls, SEL name)，获取指定名字的方法实现。\nBOOL class_respondsToSelector(Class cls, SEL sel)，类是否响应指定的方法。\nMethod *class_copyMethodList(Class cls, unsigned int *outCount)，获取方法列表的拷贝。调用后需要自己 free()。\nBOOL class_conformsToProtocol(Class cls, Protocol *protocol)，类是否遵循指定的协议。\nProtocol * __unsafe_unretained *class_copyProtocolList(Class cls, unsigned int *outCount)，获取协议列表的拷贝。调用后需要自己 free()。\nobjc_property_t class_getProperty(Class cls, const char *name)，获取指定名字的属性。\nobjc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)，获取类的属性列表。调用后需要自己 free()。\nBOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)，为类添加方法。\nIMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types)，替代类的方法。\nBOOL class_addIvar(Class cls, const char *name, size_t size, uint8_t alignment, const char *types)，给指定的类添加成员变量。这个函数只能在 objc_allocateClassPair() 和 objc_registerClassPair() 之间调用，并且不能为一个已经存在的类添加成员变量。\nBOOL class_addProtocol(Class cls, Protocol *protocol)，为类添加协议。\nBOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)，为类添加属性。\nvoid class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)，替代类的属性。\nid class_createInstance(Class cls, size_t extraBytes)，创建指定类的实例。\nid objc_constructInstance(Class cls, void *bytes)，在指定的位置创建类的实例。\nvoid *objc_destructInstance(id obj)，销毁实例。\nClass objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)，创建类和元类。\nvoid objc_registerClassPair(Class cls)，注册类到 Runtime。\nvoid objc_disposeClassPair(Class cls)，销毁类和对应的元类。\n```\n\n* 类是元类的实例。\n* isa，在大多面向对象的语言中，都有类和对象的概念，其中，对象是类的实例，是通过类定义的结构生成出来的。而在 Objective-C 中，类本身也是一个对象，类作为对象时的 isa 指针指向的是元类(Meta Class)。\n* object_getClass() 可以获得当前对象 isa\n\n* `#pragma clang diagnostic...`代码，这是用于忽略编译器对于未声明的 @selector 的 warning。因为我们的代码中我们需要动态的为一个类创建方法，所以必然不会事先声明。\n* `class_addMethod()` 函数的最后一个参数 types 是描述方法返回值和参数列表的字符串，我们的代码中的用到的 i@:@ 四个字符分别对应着：返回值 int32_t、参数 id self、参数 SEL _cmd、参数 NSDictionary *dic。这个其实就是类型编码(Type Encoding)的概念。在 Objective-C 中，为了协助 Runtime 系统，编译器会将每个方法的返回值和参数列表编码为一个字符串，这个字符串会与方法对应的 selector 关联。更详细的知识可以查阅 Type Encodings。\n* 使用 `objc_registerClassPair()` 函数需要注意，你不能注册已经注册过的类。\n* 使用 `objc_disposeClassPair()` 函数需要注意，如果一个类的实例和子类还存在时，不要去销毁一个类。\n\n## 运行时的成员变量与属性\n成员变量和属性相关的函数\n```\nIvar class_getClassVariable(Class cls, const char *name)，返回指定类的指定名字的成员变量。\nIvar *class_copyIvarList(Class cls, unsigned int *outCount)，返回指定类的成员变量列表。调用后需要自己 free()。\nBOOL class_addIvar(Class cls, const char *name, size_t size, uint8_t alignment, const char *types)，给指定的类添加成员变量。这个函数只能在 objc_allocateClassPair() 和 objc_registerClassPair() 之间调用，并且不能为一个已经存在的类添加成员变量。\nid object_getIvar(id obj, Ivar ivar)，获得对象的指定成员变量的值。速度比 object_getInstanceVariable() 快。\nvoid object_setIvar(id obj, Ivar ivar, id value)，设置对象指定成员变量的值。速度比 object_setInstanceVariable() 快。\nIvar object_getInstanceVariable(id obj, const char *name, void **outValue)，获取指定名字的成员变量的值。\nIvar object_setInstanceVariable(id obj, const char *name, void *value)，设置指定名字成员变量的值。\nconst char *ivar_getName(Ivar v)，获取成员变量名。\nconst char *ivar_getTypeEncoding(Ivar v)，获取成员变量的类型编码。\nptrdiff_t ivar_getOffset(Ivar v)，获取成员变量的偏移量。\nobjc_property_t class_getProperty(Class cls, const char *name), 获取指定类指定名字的属性。\nobjc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount), 获取指定类的属性列表。调用后需要自己 free()。\nBOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)， 给指定的类添加属性。\nvoid class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)，替代指定类的属性。\nconst char *property_getName(objc_property_t property)，获取属性名。\nconst char *property_getAttributes(objc_property_t property)，获取属性特性描述。\nobjc_property_attribute_t *property_copyAttributeList(objc_property_t property, unsigned int *outCount)，获取属性特性列表。调用后需要自己 free()。\nchar *property_copyAttributeValue(objc_property_t property, const char *attributeName)，获取属性特性值。调用后需要自己 free()。\n```\n\n* IMP 其实就是 implementation 的缩写，表示方法实现的代码块地址\n* 我们不能用 class_addIvar() 函数为一个已经存在的类添加 Ivar。并且 class_addIvar() 只能在 objc_allocateClassPair() 和 objc_registerClassPair() 之间调用。\n* 添加一个属性及对应的成员变量后，我们还能通过 [obj valueForKey:@\"propertyName\"]; 获得属性值。\n\n## 运行时的消息分发\n```id objc_msgSend(id self, SEL op, ...)，消息分发。(objc/message.h)\nid method_invoke(id receiver, Method m, ...);，调用指定方法的实现。\nvoid method_invoke_stret(id receiver, Method m, ...);，调用返回一个数据结构的方法的实现。\nSEL method_getName(Method m);，获取方法名。\nIMP method_getImplementation(Method m);，返回方法的实现。\nconst char * method_getTypeEncoding(Method m);，获取描述方法参数和返回值类型的字符串。\nchar * method_copyReturnType(Method m);，获取方法的返回值类型的字符串。\nchar * method_copyArgumentType(Method m, unsigned int index);，获取方法的指定位置参数的类型字符串。\nvoid method_getReturnType(Method m, char *dst, size_t dst_len);，通过引用返回方法的返回值类型字符串。\nunsigned int method_getNumberOfArguments(Method m);，返回方法的参数的个数。\nvoid method_getArgumentType(Method m, unsigned int index, char *dst, size_t dst_len);，通过引用返回方法指定位置参数的类型字符串。\nstruct objc_method_description * method_getDescription(Method m);，返回指定方法的方法描述结构体。\nIMP method_setImplementation(Method m, IMP imp);，设置方法的实现。注意该函数返回值是方法之前的实现。\nvoid method_exchangeImplementations(Method m1, Method m2);，交换两个方法的实现。\nconst char * sel_getName(SEL sel);，返回给定选择器指定的方法的名称。\nSEL sel_registerName(const char *str);，在Objective-C Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器。\nSEL sel_getUid(const char *str);，在Objective-C Runtime系统中注册一个方法。\nBOOL sel_isEqual(SEL lhs, SEL rhs);，比较两个选择器。\n```\n\n消息转发机制基本上分为三个步骤：\n第一步：动态方法解析。\n未知的方法被截获，程序不会崩溃\n```\n#import <objc/runtime.h>\n- (void)viewDidLoad {\n[super viewDidLoad];\n[self performSelector:@selector(unknownMethod)];\n}\nvoid dealWithExceptionForUnknownMethod(id self, SEL _cmd) {\nNSLog(@\"%@, %p\", self, _cmd); // Print: <ViewController: 0x7ff96be33e60>, 0x1078259fc\n}\n+ (BOOL)resolveInstanceMethod:(SEL)sel {\nNSString *selectorString = NSStringFromSelector(sel);\nif ([selectorString isEqualToString:@\"unknownMethod\"]) {\nclass_addMethod(self.class, @selector(unknownMethod), (IMP) dealWithExceptionForUnknownMethod, \"v@:\");\n}\nreturn [super resolveInstanceMethod:sel];\n}\n```\n\n第二步：备用接收者。\n如果在第一步还是无法处理消息，则 Runtime 会继续调以下方法：\n```\n- (id)forwardingTargetForSelector:(SEL)aSelector\n```\n\n这一步适用于当我们只想将消息转发到另一个能处理该消息的对象上的情况，它无法进一步对消息进行处理，比如：操作消息的参数和返回值。\n\n第三步：完整转发。\n如果第二步：备用接收者还是未能处理好消息，那么接下来只有启用完整的消息转发机制了，这时候会调用以下方法：\n```\n- (void)forwardInvocation:(NSInvocation *)anInvocation\n```\n\n运行时系统会在这一步给消息接收者最后一次机会将消息转发给其它对象。\n另外还有一个重要的问题是我们必须重写下面方法：\n```\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector\n```\n\n如果不在以上所述的三个步骤中处理未知消息，到了 NSObject 那则会引发一个异常。\n\n代码：[RuntimeDemo](https://github.com/guchunli/RuntimeDemo)\n\n转自：[Objective-C 的 Runtime](http://www.samirchen.com/objective-c-runtime/)\n","source":"_posts/iOS-runtime学习笔记.md","raw":"---\ntitle: iOS runtime学习笔记\ndate: 2017-03-22 11:39:18\ncategories: 笔记\ntags: [iOS,runtime]\n---\n\nObjective-C 是一门动态语言，它把很多静态语言在编译和链接时做的事情放到了运行时去处理，它在运行时实现了对类、方法、成员变量、属性等信息的管理机制。\n\n## 运行时的类与对象\n<!--more-->\n类与对象相关的函数\n```\nconst char *class_getName(Class cls)，获取指定类的类名。\nBOOL class_isMetaClass(Class cls)，判断指定类是否是一个元类。\nClass class_getSuperclass(Class cls)，获取指定类的父类。\nClass class_setSuperclass(Class cls, Class newSuper)，设定指定类的父类。\nint class_getVersion(Class cls)，获取指定类的版本信息。\nvoid class_setVersion(Class cls, int version)，设定指定类的版本信息。\nsize_t class_getInstanceSize(Class cls)，获取实例大小。\nIvar class_getInstanceVariable(Class cls, const char *name)，获取指定名字的实例变量。\nIvar class_getClassVariable(Class cls, const char *name)，获取指定名字的类变量。\nIvar *class_copyIvarList(Class cls, unsigned int *outCount)，获取类的成员变量列表的拷贝。调用后需要自己 free()。\nMethod class_getInstanceMethod(Class cls, SEL name)，获取指定名字的实例方法。\nMethod class_getClassMethod(Class cls, SEL name)，获取指定名字的类方法。\nIMP class_getMethodImplementation(Class cls, SEL name)，获取指定名字的方法实现。\nBOOL class_respondsToSelector(Class cls, SEL sel)，类是否响应指定的方法。\nMethod *class_copyMethodList(Class cls, unsigned int *outCount)，获取方法列表的拷贝。调用后需要自己 free()。\nBOOL class_conformsToProtocol(Class cls, Protocol *protocol)，类是否遵循指定的协议。\nProtocol * __unsafe_unretained *class_copyProtocolList(Class cls, unsigned int *outCount)，获取协议列表的拷贝。调用后需要自己 free()。\nobjc_property_t class_getProperty(Class cls, const char *name)，获取指定名字的属性。\nobjc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)，获取类的属性列表。调用后需要自己 free()。\nBOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)，为类添加方法。\nIMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types)，替代类的方法。\nBOOL class_addIvar(Class cls, const char *name, size_t size, uint8_t alignment, const char *types)，给指定的类添加成员变量。这个函数只能在 objc_allocateClassPair() 和 objc_registerClassPair() 之间调用，并且不能为一个已经存在的类添加成员变量。\nBOOL class_addProtocol(Class cls, Protocol *protocol)，为类添加协议。\nBOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)，为类添加属性。\nvoid class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)，替代类的属性。\nid class_createInstance(Class cls, size_t extraBytes)，创建指定类的实例。\nid objc_constructInstance(Class cls, void *bytes)，在指定的位置创建类的实例。\nvoid *objc_destructInstance(id obj)，销毁实例。\nClass objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)，创建类和元类。\nvoid objc_registerClassPair(Class cls)，注册类到 Runtime。\nvoid objc_disposeClassPair(Class cls)，销毁类和对应的元类。\n```\n\n* 类是元类的实例。\n* isa，在大多面向对象的语言中，都有类和对象的概念，其中，对象是类的实例，是通过类定义的结构生成出来的。而在 Objective-C 中，类本身也是一个对象，类作为对象时的 isa 指针指向的是元类(Meta Class)。\n* object_getClass() 可以获得当前对象 isa\n\n* `#pragma clang diagnostic...`代码，这是用于忽略编译器对于未声明的 @selector 的 warning。因为我们的代码中我们需要动态的为一个类创建方法，所以必然不会事先声明。\n* `class_addMethod()` 函数的最后一个参数 types 是描述方法返回值和参数列表的字符串，我们的代码中的用到的 i@:@ 四个字符分别对应着：返回值 int32_t、参数 id self、参数 SEL _cmd、参数 NSDictionary *dic。这个其实就是类型编码(Type Encoding)的概念。在 Objective-C 中，为了协助 Runtime 系统，编译器会将每个方法的返回值和参数列表编码为一个字符串，这个字符串会与方法对应的 selector 关联。更详细的知识可以查阅 Type Encodings。\n* 使用 `objc_registerClassPair()` 函数需要注意，你不能注册已经注册过的类。\n* 使用 `objc_disposeClassPair()` 函数需要注意，如果一个类的实例和子类还存在时，不要去销毁一个类。\n\n## 运行时的成员变量与属性\n成员变量和属性相关的函数\n```\nIvar class_getClassVariable(Class cls, const char *name)，返回指定类的指定名字的成员变量。\nIvar *class_copyIvarList(Class cls, unsigned int *outCount)，返回指定类的成员变量列表。调用后需要自己 free()。\nBOOL class_addIvar(Class cls, const char *name, size_t size, uint8_t alignment, const char *types)，给指定的类添加成员变量。这个函数只能在 objc_allocateClassPair() 和 objc_registerClassPair() 之间调用，并且不能为一个已经存在的类添加成员变量。\nid object_getIvar(id obj, Ivar ivar)，获得对象的指定成员变量的值。速度比 object_getInstanceVariable() 快。\nvoid object_setIvar(id obj, Ivar ivar, id value)，设置对象指定成员变量的值。速度比 object_setInstanceVariable() 快。\nIvar object_getInstanceVariable(id obj, const char *name, void **outValue)，获取指定名字的成员变量的值。\nIvar object_setInstanceVariable(id obj, const char *name, void *value)，设置指定名字成员变量的值。\nconst char *ivar_getName(Ivar v)，获取成员变量名。\nconst char *ivar_getTypeEncoding(Ivar v)，获取成员变量的类型编码。\nptrdiff_t ivar_getOffset(Ivar v)，获取成员变量的偏移量。\nobjc_property_t class_getProperty(Class cls, const char *name), 获取指定类指定名字的属性。\nobjc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount), 获取指定类的属性列表。调用后需要自己 free()。\nBOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)， 给指定的类添加属性。\nvoid class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)，替代指定类的属性。\nconst char *property_getName(objc_property_t property)，获取属性名。\nconst char *property_getAttributes(objc_property_t property)，获取属性特性描述。\nobjc_property_attribute_t *property_copyAttributeList(objc_property_t property, unsigned int *outCount)，获取属性特性列表。调用后需要自己 free()。\nchar *property_copyAttributeValue(objc_property_t property, const char *attributeName)，获取属性特性值。调用后需要自己 free()。\n```\n\n* IMP 其实就是 implementation 的缩写，表示方法实现的代码块地址\n* 我们不能用 class_addIvar() 函数为一个已经存在的类添加 Ivar。并且 class_addIvar() 只能在 objc_allocateClassPair() 和 objc_registerClassPair() 之间调用。\n* 添加一个属性及对应的成员变量后，我们还能通过 [obj valueForKey:@\"propertyName\"]; 获得属性值。\n\n## 运行时的消息分发\n```id objc_msgSend(id self, SEL op, ...)，消息分发。(objc/message.h)\nid method_invoke(id receiver, Method m, ...);，调用指定方法的实现。\nvoid method_invoke_stret(id receiver, Method m, ...);，调用返回一个数据结构的方法的实现。\nSEL method_getName(Method m);，获取方法名。\nIMP method_getImplementation(Method m);，返回方法的实现。\nconst char * method_getTypeEncoding(Method m);，获取描述方法参数和返回值类型的字符串。\nchar * method_copyReturnType(Method m);，获取方法的返回值类型的字符串。\nchar * method_copyArgumentType(Method m, unsigned int index);，获取方法的指定位置参数的类型字符串。\nvoid method_getReturnType(Method m, char *dst, size_t dst_len);，通过引用返回方法的返回值类型字符串。\nunsigned int method_getNumberOfArguments(Method m);，返回方法的参数的个数。\nvoid method_getArgumentType(Method m, unsigned int index, char *dst, size_t dst_len);，通过引用返回方法指定位置参数的类型字符串。\nstruct objc_method_description * method_getDescription(Method m);，返回指定方法的方法描述结构体。\nIMP method_setImplementation(Method m, IMP imp);，设置方法的实现。注意该函数返回值是方法之前的实现。\nvoid method_exchangeImplementations(Method m1, Method m2);，交换两个方法的实现。\nconst char * sel_getName(SEL sel);，返回给定选择器指定的方法的名称。\nSEL sel_registerName(const char *str);，在Objective-C Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器。\nSEL sel_getUid(const char *str);，在Objective-C Runtime系统中注册一个方法。\nBOOL sel_isEqual(SEL lhs, SEL rhs);，比较两个选择器。\n```\n\n消息转发机制基本上分为三个步骤：\n第一步：动态方法解析。\n未知的方法被截获，程序不会崩溃\n```\n#import <objc/runtime.h>\n- (void)viewDidLoad {\n[super viewDidLoad];\n[self performSelector:@selector(unknownMethod)];\n}\nvoid dealWithExceptionForUnknownMethod(id self, SEL _cmd) {\nNSLog(@\"%@, %p\", self, _cmd); // Print: <ViewController: 0x7ff96be33e60>, 0x1078259fc\n}\n+ (BOOL)resolveInstanceMethod:(SEL)sel {\nNSString *selectorString = NSStringFromSelector(sel);\nif ([selectorString isEqualToString:@\"unknownMethod\"]) {\nclass_addMethod(self.class, @selector(unknownMethod), (IMP) dealWithExceptionForUnknownMethod, \"v@:\");\n}\nreturn [super resolveInstanceMethod:sel];\n}\n```\n\n第二步：备用接收者。\n如果在第一步还是无法处理消息，则 Runtime 会继续调以下方法：\n```\n- (id)forwardingTargetForSelector:(SEL)aSelector\n```\n\n这一步适用于当我们只想将消息转发到另一个能处理该消息的对象上的情况，它无法进一步对消息进行处理，比如：操作消息的参数和返回值。\n\n第三步：完整转发。\n如果第二步：备用接收者还是未能处理好消息，那么接下来只有启用完整的消息转发机制了，这时候会调用以下方法：\n```\n- (void)forwardInvocation:(NSInvocation *)anInvocation\n```\n\n运行时系统会在这一步给消息接收者最后一次机会将消息转发给其它对象。\n另外还有一个重要的问题是我们必须重写下面方法：\n```\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector\n```\n\n如果不在以上所述的三个步骤中处理未知消息，到了 NSObject 那则会引发一个异常。\n\n代码：[RuntimeDemo](https://github.com/guchunli/RuntimeDemo)\n\n转自：[Objective-C 的 Runtime](http://www.samirchen.com/objective-c-runtime/)\n","slug":"iOS-runtime学习笔记","published":1,"updated":"2017-07-14T03:57:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj53c1dw3001oh3jjvg2yfimo","content":"<p>Objective-C 是一门动态语言，它把很多静态语言在编译和链接时做的事情放到了运行时去处理，它在运行时实现了对类、方法、成员变量、属性等信息的管理机制。</p>\n<h2 id=\"运行时的类与对象\"><a href=\"#运行时的类与对象\" class=\"headerlink\" title=\"运行时的类与对象\"></a>运行时的类与对象</h2><a id=\"more\"></a>\n<p>类与对象相关的函数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">const char *class_getName(Class cls)，获取指定类的类名。</div><div class=\"line\">BOOL class_isMetaClass(Class cls)，判断指定类是否是一个元类。</div><div class=\"line\">Class class_getSuperclass(Class cls)，获取指定类的父类。</div><div class=\"line\">Class class_setSuperclass(Class cls, Class newSuper)，设定指定类的父类。</div><div class=\"line\">int class_getVersion(Class cls)，获取指定类的版本信息。</div><div class=\"line\">void class_setVersion(Class cls, int version)，设定指定类的版本信息。</div><div class=\"line\">size_t class_getInstanceSize(Class cls)，获取实例大小。</div><div class=\"line\">Ivar class_getInstanceVariable(Class cls, const char *name)，获取指定名字的实例变量。</div><div class=\"line\">Ivar class_getClassVariable(Class cls, const char *name)，获取指定名字的类变量。</div><div class=\"line\">Ivar *class_copyIvarList(Class cls, unsigned int *outCount)，获取类的成员变量列表的拷贝。调用后需要自己 free()。</div><div class=\"line\">Method class_getInstanceMethod(Class cls, SEL name)，获取指定名字的实例方法。</div><div class=\"line\">Method class_getClassMethod(Class cls, SEL name)，获取指定名字的类方法。</div><div class=\"line\">IMP class_getMethodImplementation(Class cls, SEL name)，获取指定名字的方法实现。</div><div class=\"line\">BOOL class_respondsToSelector(Class cls, SEL sel)，类是否响应指定的方法。</div><div class=\"line\">Method *class_copyMethodList(Class cls, unsigned int *outCount)，获取方法列表的拷贝。调用后需要自己 free()。</div><div class=\"line\">BOOL class_conformsToProtocol(Class cls, Protocol *protocol)，类是否遵循指定的协议。</div><div class=\"line\">Protocol * __unsafe_unretained *class_copyProtocolList(Class cls, unsigned int *outCount)，获取协议列表的拷贝。调用后需要自己 free()。</div><div class=\"line\">objc_property_t class_getProperty(Class cls, const char *name)，获取指定名字的属性。</div><div class=\"line\">objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)，获取类的属性列表。调用后需要自己 free()。</div><div class=\"line\">BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)，为类添加方法。</div><div class=\"line\">IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types)，替代类的方法。</div><div class=\"line\">BOOL class_addIvar(Class cls, const char *name, size_t size, uint8_t alignment, const char *types)，给指定的类添加成员变量。这个函数只能在 objc_allocateClassPair() 和 objc_registerClassPair() 之间调用，并且不能为一个已经存在的类添加成员变量。</div><div class=\"line\">BOOL class_addProtocol(Class cls, Protocol *protocol)，为类添加协议。</div><div class=\"line\">BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)，为类添加属性。</div><div class=\"line\">void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)，替代类的属性。</div><div class=\"line\">id class_createInstance(Class cls, size_t extraBytes)，创建指定类的实例。</div><div class=\"line\">id objc_constructInstance(Class cls, void *bytes)，在指定的位置创建类的实例。</div><div class=\"line\">void *objc_destructInstance(id obj)，销毁实例。</div><div class=\"line\">Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)，创建类和元类。</div><div class=\"line\">void objc_registerClassPair(Class cls)，注册类到 Runtime。</div><div class=\"line\">void objc_disposeClassPair(Class cls)，销毁类和对应的元类。</div></pre></td></tr></table></figure></p>\n<ul>\n<li>类是元类的实例。</li>\n<li>isa，在大多面向对象的语言中，都有类和对象的概念，其中，对象是类的实例，是通过类定义的结构生成出来的。而在 Objective-C 中，类本身也是一个对象，类作为对象时的 isa 指针指向的是元类(Meta Class)。</li>\n<li><p>object_getClass() 可以获得当前对象 isa</p>\n</li>\n<li><p><code>#pragma clang diagnostic...</code>代码，这是用于忽略编译器对于未声明的 @selector 的 warning。因为我们的代码中我们需要动态的为一个类创建方法，所以必然不会事先声明。</p>\n</li>\n<li><code>class_addMethod()</code> 函数的最后一个参数 types 是描述方法返回值和参数列表的字符串，我们的代码中的用到的 i@:@ 四个字符分别对应着：返回值 int32_t、参数 id self、参数 SEL _cmd、参数 NSDictionary *dic。这个其实就是类型编码(Type Encoding)的概念。在 Objective-C 中，为了协助 Runtime 系统，编译器会将每个方法的返回值和参数列表编码为一个字符串，这个字符串会与方法对应的 selector 关联。更详细的知识可以查阅 Type Encodings。</li>\n<li>使用 <code>objc_registerClassPair()</code> 函数需要注意，你不能注册已经注册过的类。</li>\n<li>使用 <code>objc_disposeClassPair()</code> 函数需要注意，如果一个类的实例和子类还存在时，不要去销毁一个类。</li>\n</ul>\n<h2 id=\"运行时的成员变量与属性\"><a href=\"#运行时的成员变量与属性\" class=\"headerlink\" title=\"运行时的成员变量与属性\"></a>运行时的成员变量与属性</h2><p>成员变量和属性相关的函数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">Ivar class_getClassVariable(Class cls, const char *name)，返回指定类的指定名字的成员变量。</div><div class=\"line\">Ivar *class_copyIvarList(Class cls, unsigned int *outCount)，返回指定类的成员变量列表。调用后需要自己 free()。</div><div class=\"line\">BOOL class_addIvar(Class cls, const char *name, size_t size, uint8_t alignment, const char *types)，给指定的类添加成员变量。这个函数只能在 objc_allocateClassPair() 和 objc_registerClassPair() 之间调用，并且不能为一个已经存在的类添加成员变量。</div><div class=\"line\">id object_getIvar(id obj, Ivar ivar)，获得对象的指定成员变量的值。速度比 object_getInstanceVariable() 快。</div><div class=\"line\">void object_setIvar(id obj, Ivar ivar, id value)，设置对象指定成员变量的值。速度比 object_setInstanceVariable() 快。</div><div class=\"line\">Ivar object_getInstanceVariable(id obj, const char *name, void **outValue)，获取指定名字的成员变量的值。</div><div class=\"line\">Ivar object_setInstanceVariable(id obj, const char *name, void *value)，设置指定名字成员变量的值。</div><div class=\"line\">const char *ivar_getName(Ivar v)，获取成员变量名。</div><div class=\"line\">const char *ivar_getTypeEncoding(Ivar v)，获取成员变量的类型编码。</div><div class=\"line\">ptrdiff_t ivar_getOffset(Ivar v)，获取成员变量的偏移量。</div><div class=\"line\">objc_property_t class_getProperty(Class cls, const char *name), 获取指定类指定名字的属性。</div><div class=\"line\">objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount), 获取指定类的属性列表。调用后需要自己 free()。</div><div class=\"line\">BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)， 给指定的类添加属性。</div><div class=\"line\">void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)，替代指定类的属性。</div><div class=\"line\">const char *property_getName(objc_property_t property)，获取属性名。</div><div class=\"line\">const char *property_getAttributes(objc_property_t property)，获取属性特性描述。</div><div class=\"line\">objc_property_attribute_t *property_copyAttributeList(objc_property_t property, unsigned int *outCount)，获取属性特性列表。调用后需要自己 free()。</div><div class=\"line\">char *property_copyAttributeValue(objc_property_t property, const char *attributeName)，获取属性特性值。调用后需要自己 free()。</div></pre></td></tr></table></figure></p>\n<ul>\n<li>IMP 其实就是 implementation 的缩写，表示方法实现的代码块地址</li>\n<li>我们不能用 class_addIvar() 函数为一个已经存在的类添加 Ivar。并且 class_addIvar() 只能在 objc_allocateClassPair() 和 objc_registerClassPair() 之间调用。</li>\n<li>添加一个属性及对应的成员变量后，我们还能通过 [obj valueForKey:@”propertyName”]; 获得属性值。</li>\n</ul>\n<h2 id=\"运行时的消息分发\"><a href=\"#运行时的消息分发\" class=\"headerlink\" title=\"运行时的消息分发\"></a>运行时的消息分发</h2><figure class=\"highlight plain\"><figcaption><span>objc_msgSend(id self, SEL op, ...)，消息分发。(objc/message.h)</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">id method_invoke(id receiver, Method m, ...);，调用指定方法的实现。</div><div class=\"line\">void method_invoke_stret(id receiver, Method m, ...);，调用返回一个数据结构的方法的实现。</div><div class=\"line\">SEL method_getName(Method m);，获取方法名。</div><div class=\"line\">IMP method_getImplementation(Method m);，返回方法的实现。</div><div class=\"line\">const char * method_getTypeEncoding(Method m);，获取描述方法参数和返回值类型的字符串。</div><div class=\"line\">char * method_copyReturnType(Method m);，获取方法的返回值类型的字符串。</div><div class=\"line\">char * method_copyArgumentType(Method m, unsigned int index);，获取方法的指定位置参数的类型字符串。</div><div class=\"line\">void method_getReturnType(Method m, char *dst, size_t dst_len);，通过引用返回方法的返回值类型字符串。</div><div class=\"line\">unsigned int method_getNumberOfArguments(Method m);，返回方法的参数的个数。</div><div class=\"line\">void method_getArgumentType(Method m, unsigned int index, char *dst, size_t dst_len);，通过引用返回方法指定位置参数的类型字符串。</div><div class=\"line\">struct objc_method_description * method_getDescription(Method m);，返回指定方法的方法描述结构体。</div><div class=\"line\">IMP method_setImplementation(Method m, IMP imp);，设置方法的实现。注意该函数返回值是方法之前的实现。</div><div class=\"line\">void method_exchangeImplementations(Method m1, Method m2);，交换两个方法的实现。</div><div class=\"line\">const char * sel_getName(SEL sel);，返回给定选择器指定的方法的名称。</div><div class=\"line\">SEL sel_registerName(const char *str);，在Objective-C Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器。</div><div class=\"line\">SEL sel_getUid(const char *str);，在Objective-C Runtime系统中注册一个方法。</div><div class=\"line\">BOOL sel_isEqual(SEL lhs, SEL rhs);，比较两个选择器。</div></pre></td></tr></table></figure>\n<p>消息转发机制基本上分为三个步骤：<br>第一步：动态方法解析。<br>未知的方法被截获，程序不会崩溃<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &lt;objc/runtime.h&gt;</div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">[super viewDidLoad];</div><div class=\"line\">[self performSelector:@selector(unknownMethod)];</div><div class=\"line\">&#125;</div><div class=\"line\">void dealWithExceptionForUnknownMethod(id self, SEL _cmd) &#123;</div><div class=\"line\">NSLog(@&quot;%@, %p&quot;, self, _cmd); // Print: &lt;ViewController: 0x7ff96be33e60&gt;, 0x1078259fc</div><div class=\"line\">&#125;</div><div class=\"line\">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</div><div class=\"line\">NSString *selectorString = NSStringFromSelector(sel);</div><div class=\"line\">if ([selectorString isEqualToString:@&quot;unknownMethod&quot;]) &#123;</div><div class=\"line\">class_addMethod(self.class, @selector(unknownMethod), (IMP) dealWithExceptionForUnknownMethod, &quot;v@:&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">return [super resolveInstanceMethod:sel];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>第二步：备用接收者。<br>如果在第一步还是无法处理消息，则 Runtime 会继续调以下方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (id)forwardingTargetForSelector:(SEL)aSelector</div></pre></td></tr></table></figure></p>\n<p>这一步适用于当我们只想将消息转发到另一个能处理该消息的对象上的情况，它无法进一步对消息进行处理，比如：操作消息的参数和返回值。</p>\n<p>第三步：完整转发。<br>如果第二步：备用接收者还是未能处理好消息，那么接下来只有启用完整的消息转发机制了，这时候会调用以下方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)forwardInvocation:(NSInvocation *)anInvocation</div></pre></td></tr></table></figure></p>\n<p>运行时系统会在这一步给消息接收者最后一次机会将消息转发给其它对象。<br>另外还有一个重要的问题是我们必须重写下面方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</div></pre></td></tr></table></figure></p>\n<p>如果不在以上所述的三个步骤中处理未知消息，到了 NSObject 那则会引发一个异常。</p>\n<p>代码：<a href=\"https://github.com/guchunli/RuntimeDemo\" target=\"_blank\" rel=\"external\">RuntimeDemo</a></p>\n<p>转自：<a href=\"http://www.samirchen.com/objective-c-runtime/\" target=\"_blank\" rel=\"external\">Objective-C 的 Runtime</a></p>\n","site":{"data":{}},"excerpt":"<p>Objective-C 是一门动态语言，它把很多静态语言在编译和链接时做的事情放到了运行时去处理，它在运行时实现了对类、方法、成员变量、属性等信息的管理机制。</p>\n<h2 id=\"运行时的类与对象\"><a href=\"#运行时的类与对象\" class=\"headerlink\" title=\"运行时的类与对象\"></a>运行时的类与对象</h2>","more":"<p>类与对象相关的函数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">const char *class_getName(Class cls)，获取指定类的类名。</div><div class=\"line\">BOOL class_isMetaClass(Class cls)，判断指定类是否是一个元类。</div><div class=\"line\">Class class_getSuperclass(Class cls)，获取指定类的父类。</div><div class=\"line\">Class class_setSuperclass(Class cls, Class newSuper)，设定指定类的父类。</div><div class=\"line\">int class_getVersion(Class cls)，获取指定类的版本信息。</div><div class=\"line\">void class_setVersion(Class cls, int version)，设定指定类的版本信息。</div><div class=\"line\">size_t class_getInstanceSize(Class cls)，获取实例大小。</div><div class=\"line\">Ivar class_getInstanceVariable(Class cls, const char *name)，获取指定名字的实例变量。</div><div class=\"line\">Ivar class_getClassVariable(Class cls, const char *name)，获取指定名字的类变量。</div><div class=\"line\">Ivar *class_copyIvarList(Class cls, unsigned int *outCount)，获取类的成员变量列表的拷贝。调用后需要自己 free()。</div><div class=\"line\">Method class_getInstanceMethod(Class cls, SEL name)，获取指定名字的实例方法。</div><div class=\"line\">Method class_getClassMethod(Class cls, SEL name)，获取指定名字的类方法。</div><div class=\"line\">IMP class_getMethodImplementation(Class cls, SEL name)，获取指定名字的方法实现。</div><div class=\"line\">BOOL class_respondsToSelector(Class cls, SEL sel)，类是否响应指定的方法。</div><div class=\"line\">Method *class_copyMethodList(Class cls, unsigned int *outCount)，获取方法列表的拷贝。调用后需要自己 free()。</div><div class=\"line\">BOOL class_conformsToProtocol(Class cls, Protocol *protocol)，类是否遵循指定的协议。</div><div class=\"line\">Protocol * __unsafe_unretained *class_copyProtocolList(Class cls, unsigned int *outCount)，获取协议列表的拷贝。调用后需要自己 free()。</div><div class=\"line\">objc_property_t class_getProperty(Class cls, const char *name)，获取指定名字的属性。</div><div class=\"line\">objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)，获取类的属性列表。调用后需要自己 free()。</div><div class=\"line\">BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)，为类添加方法。</div><div class=\"line\">IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types)，替代类的方法。</div><div class=\"line\">BOOL class_addIvar(Class cls, const char *name, size_t size, uint8_t alignment, const char *types)，给指定的类添加成员变量。这个函数只能在 objc_allocateClassPair() 和 objc_registerClassPair() 之间调用，并且不能为一个已经存在的类添加成员变量。</div><div class=\"line\">BOOL class_addProtocol(Class cls, Protocol *protocol)，为类添加协议。</div><div class=\"line\">BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)，为类添加属性。</div><div class=\"line\">void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)，替代类的属性。</div><div class=\"line\">id class_createInstance(Class cls, size_t extraBytes)，创建指定类的实例。</div><div class=\"line\">id objc_constructInstance(Class cls, void *bytes)，在指定的位置创建类的实例。</div><div class=\"line\">void *objc_destructInstance(id obj)，销毁实例。</div><div class=\"line\">Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)，创建类和元类。</div><div class=\"line\">void objc_registerClassPair(Class cls)，注册类到 Runtime。</div><div class=\"line\">void objc_disposeClassPair(Class cls)，销毁类和对应的元类。</div></pre></td></tr></table></figure></p>\n<ul>\n<li>类是元类的实例。</li>\n<li>isa，在大多面向对象的语言中，都有类和对象的概念，其中，对象是类的实例，是通过类定义的结构生成出来的。而在 Objective-C 中，类本身也是一个对象，类作为对象时的 isa 指针指向的是元类(Meta Class)。</li>\n<li><p>object_getClass() 可以获得当前对象 isa</p>\n</li>\n<li><p><code>#pragma clang diagnostic...</code>代码，这是用于忽略编译器对于未声明的 @selector 的 warning。因为我们的代码中我们需要动态的为一个类创建方法，所以必然不会事先声明。</p>\n</li>\n<li><code>class_addMethod()</code> 函数的最后一个参数 types 是描述方法返回值和参数列表的字符串，我们的代码中的用到的 i@:@ 四个字符分别对应着：返回值 int32_t、参数 id self、参数 SEL _cmd、参数 NSDictionary *dic。这个其实就是类型编码(Type Encoding)的概念。在 Objective-C 中，为了协助 Runtime 系统，编译器会将每个方法的返回值和参数列表编码为一个字符串，这个字符串会与方法对应的 selector 关联。更详细的知识可以查阅 Type Encodings。</li>\n<li>使用 <code>objc_registerClassPair()</code> 函数需要注意，你不能注册已经注册过的类。</li>\n<li>使用 <code>objc_disposeClassPair()</code> 函数需要注意，如果一个类的实例和子类还存在时，不要去销毁一个类。</li>\n</ul>\n<h2 id=\"运行时的成员变量与属性\"><a href=\"#运行时的成员变量与属性\" class=\"headerlink\" title=\"运行时的成员变量与属性\"></a>运行时的成员变量与属性</h2><p>成员变量和属性相关的函数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">Ivar class_getClassVariable(Class cls, const char *name)，返回指定类的指定名字的成员变量。</div><div class=\"line\">Ivar *class_copyIvarList(Class cls, unsigned int *outCount)，返回指定类的成员变量列表。调用后需要自己 free()。</div><div class=\"line\">BOOL class_addIvar(Class cls, const char *name, size_t size, uint8_t alignment, const char *types)，给指定的类添加成员变量。这个函数只能在 objc_allocateClassPair() 和 objc_registerClassPair() 之间调用，并且不能为一个已经存在的类添加成员变量。</div><div class=\"line\">id object_getIvar(id obj, Ivar ivar)，获得对象的指定成员变量的值。速度比 object_getInstanceVariable() 快。</div><div class=\"line\">void object_setIvar(id obj, Ivar ivar, id value)，设置对象指定成员变量的值。速度比 object_setInstanceVariable() 快。</div><div class=\"line\">Ivar object_getInstanceVariable(id obj, const char *name, void **outValue)，获取指定名字的成员变量的值。</div><div class=\"line\">Ivar object_setInstanceVariable(id obj, const char *name, void *value)，设置指定名字成员变量的值。</div><div class=\"line\">const char *ivar_getName(Ivar v)，获取成员变量名。</div><div class=\"line\">const char *ivar_getTypeEncoding(Ivar v)，获取成员变量的类型编码。</div><div class=\"line\">ptrdiff_t ivar_getOffset(Ivar v)，获取成员变量的偏移量。</div><div class=\"line\">objc_property_t class_getProperty(Class cls, const char *name), 获取指定类指定名字的属性。</div><div class=\"line\">objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount), 获取指定类的属性列表。调用后需要自己 free()。</div><div class=\"line\">BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)， 给指定的类添加属性。</div><div class=\"line\">void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)，替代指定类的属性。</div><div class=\"line\">const char *property_getName(objc_property_t property)，获取属性名。</div><div class=\"line\">const char *property_getAttributes(objc_property_t property)，获取属性特性描述。</div><div class=\"line\">objc_property_attribute_t *property_copyAttributeList(objc_property_t property, unsigned int *outCount)，获取属性特性列表。调用后需要自己 free()。</div><div class=\"line\">char *property_copyAttributeValue(objc_property_t property, const char *attributeName)，获取属性特性值。调用后需要自己 free()。</div></pre></td></tr></table></figure></p>\n<ul>\n<li>IMP 其实就是 implementation 的缩写，表示方法实现的代码块地址</li>\n<li>我们不能用 class_addIvar() 函数为一个已经存在的类添加 Ivar。并且 class_addIvar() 只能在 objc_allocateClassPair() 和 objc_registerClassPair() 之间调用。</li>\n<li>添加一个属性及对应的成员变量后，我们还能通过 [obj valueForKey:@”propertyName”]; 获得属性值。</li>\n</ul>\n<h2 id=\"运行时的消息分发\"><a href=\"#运行时的消息分发\" class=\"headerlink\" title=\"运行时的消息分发\"></a>运行时的消息分发</h2><figure class=\"highlight plain\"><figcaption><span>objc_msgSend(id self, SEL op, ...)，消息分发。(objc/message.h)</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">id method_invoke(id receiver, Method m, ...);，调用指定方法的实现。</div><div class=\"line\">void method_invoke_stret(id receiver, Method m, ...);，调用返回一个数据结构的方法的实现。</div><div class=\"line\">SEL method_getName(Method m);，获取方法名。</div><div class=\"line\">IMP method_getImplementation(Method m);，返回方法的实现。</div><div class=\"line\">const char * method_getTypeEncoding(Method m);，获取描述方法参数和返回值类型的字符串。</div><div class=\"line\">char * method_copyReturnType(Method m);，获取方法的返回值类型的字符串。</div><div class=\"line\">char * method_copyArgumentType(Method m, unsigned int index);，获取方法的指定位置参数的类型字符串。</div><div class=\"line\">void method_getReturnType(Method m, char *dst, size_t dst_len);，通过引用返回方法的返回值类型字符串。</div><div class=\"line\">unsigned int method_getNumberOfArguments(Method m);，返回方法的参数的个数。</div><div class=\"line\">void method_getArgumentType(Method m, unsigned int index, char *dst, size_t dst_len);，通过引用返回方法指定位置参数的类型字符串。</div><div class=\"line\">struct objc_method_description * method_getDescription(Method m);，返回指定方法的方法描述结构体。</div><div class=\"line\">IMP method_setImplementation(Method m, IMP imp);，设置方法的实现。注意该函数返回值是方法之前的实现。</div><div class=\"line\">void method_exchangeImplementations(Method m1, Method m2);，交换两个方法的实现。</div><div class=\"line\">const char * sel_getName(SEL sel);，返回给定选择器指定的方法的名称。</div><div class=\"line\">SEL sel_registerName(const char *str);，在Objective-C Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器。</div><div class=\"line\">SEL sel_getUid(const char *str);，在Objective-C Runtime系统中注册一个方法。</div><div class=\"line\">BOOL sel_isEqual(SEL lhs, SEL rhs);，比较两个选择器。</div></pre></td></tr></table></figure>\n<p>消息转发机制基本上分为三个步骤：<br>第一步：动态方法解析。<br>未知的方法被截获，程序不会崩溃<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &lt;objc/runtime.h&gt;</div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">[super viewDidLoad];</div><div class=\"line\">[self performSelector:@selector(unknownMethod)];</div><div class=\"line\">&#125;</div><div class=\"line\">void dealWithExceptionForUnknownMethod(id self, SEL _cmd) &#123;</div><div class=\"line\">NSLog(@&quot;%@, %p&quot;, self, _cmd); // Print: &lt;ViewController: 0x7ff96be33e60&gt;, 0x1078259fc</div><div class=\"line\">&#125;</div><div class=\"line\">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</div><div class=\"line\">NSString *selectorString = NSStringFromSelector(sel);</div><div class=\"line\">if ([selectorString isEqualToString:@&quot;unknownMethod&quot;]) &#123;</div><div class=\"line\">class_addMethod(self.class, @selector(unknownMethod), (IMP) dealWithExceptionForUnknownMethod, &quot;v@:&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">return [super resolveInstanceMethod:sel];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>第二步：备用接收者。<br>如果在第一步还是无法处理消息，则 Runtime 会继续调以下方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (id)forwardingTargetForSelector:(SEL)aSelector</div></pre></td></tr></table></figure></p>\n<p>这一步适用于当我们只想将消息转发到另一个能处理该消息的对象上的情况，它无法进一步对消息进行处理，比如：操作消息的参数和返回值。</p>\n<p>第三步：完整转发。<br>如果第二步：备用接收者还是未能处理好消息，那么接下来只有启用完整的消息转发机制了，这时候会调用以下方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)forwardInvocation:(NSInvocation *)anInvocation</div></pre></td></tr></table></figure></p>\n<p>运行时系统会在这一步给消息接收者最后一次机会将消息转发给其它对象。<br>另外还有一个重要的问题是我们必须重写下面方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</div></pre></td></tr></table></figure></p>\n<p>如果不在以上所述的三个步骤中处理未知消息，到了 NSObject 那则会引发一个异常。</p>\n<p>代码：<a href=\"https://github.com/guchunli/RuntimeDemo\" target=\"_blank\" rel=\"external\">RuntimeDemo</a></p>\n<p>转自：<a href=\"http://www.samirchen.com/objective-c-runtime/\" target=\"_blank\" rel=\"external\">Objective-C 的 Runtime</a></p>"},{"title":"iOS使定时器NSTimer在程序进入后台仍然运行的方法","date":"2017-07-05T08:16:46.000Z","_content":"\n1.Info.plist中，`Required background modes`添加`App plays audio or streams audio/video using AirPlay`\n2.`- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions`中添加以下代码：\n<!--more-->\n```\nNSError *setCategoryErr = nil;\nNSError *activationErr  = nil;\n[[AVAudioSession sharedInstance]\nsetCategory: AVAudioSessionCategoryPlayback\nerror: &setCategoryErr];\n[[AVAudioSession sharedInstance]\nsetActive: YES\nerror: &activationErr];\nself.window.backgroundColor = [UIColor whiteColor];\n[self.window makeKeyAndVisible];\n```\n\n3.程序进入后台进行以下操作\n```\n- (void)applicationDidEnterBackground:(UIApplication *)application {\n\n    UIApplication* app = [UIApplication sharedApplication];\n    __block UIBackgroundTaskIdentifier bgTask;\n\n    /*注册一个后台任务，告诉系统我们需要向系统借一些事件*/\n    bgTask = [app beginBackgroundTaskWithExpirationHandler:^{\n        dispatch_async(dispatch_get_main_queue(), ^{\n            if (bgTask != UIBackgroundTaskInvalid)\n            {\n            /*销毁后台任务标识符*/\n            /*不管有没有完成，结束background_task任务*/\n            bgTask = UIBackgroundTaskInvalid;\n            }\n        });\n    }];\n\n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n        dispatch_async(dispatch_get_main_queue(), ^{\n            if (bgTask != UIBackgroundTaskInvalid)\n            {\n            /*销毁后台任务标识符*/\n            /*不管有没有完成，结束background_task任务*/\n            bgTask = UIBackgroundTaskInvalid;\n            }\n        });\n    });\n}\n```\n\n","source":"_posts/iOS使定时器NSTimer在程序进入后台仍然运行的方法.md","raw":"---\ntitle: iOS使定时器NSTimer在程序进入后台仍然运行的方法\ndate: 2017-07-05 16:16:46\ncategories: 笔记\ntags: [iOS,NSTimer,后台]\n---\n\n1.Info.plist中，`Required background modes`添加`App plays audio or streams audio/video using AirPlay`\n2.`- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions`中添加以下代码：\n<!--more-->\n```\nNSError *setCategoryErr = nil;\nNSError *activationErr  = nil;\n[[AVAudioSession sharedInstance]\nsetCategory: AVAudioSessionCategoryPlayback\nerror: &setCategoryErr];\n[[AVAudioSession sharedInstance]\nsetActive: YES\nerror: &activationErr];\nself.window.backgroundColor = [UIColor whiteColor];\n[self.window makeKeyAndVisible];\n```\n\n3.程序进入后台进行以下操作\n```\n- (void)applicationDidEnterBackground:(UIApplication *)application {\n\n    UIApplication* app = [UIApplication sharedApplication];\n    __block UIBackgroundTaskIdentifier bgTask;\n\n    /*注册一个后台任务，告诉系统我们需要向系统借一些事件*/\n    bgTask = [app beginBackgroundTaskWithExpirationHandler:^{\n        dispatch_async(dispatch_get_main_queue(), ^{\n            if (bgTask != UIBackgroundTaskInvalid)\n            {\n            /*销毁后台任务标识符*/\n            /*不管有没有完成，结束background_task任务*/\n            bgTask = UIBackgroundTaskInvalid;\n            }\n        });\n    }];\n\n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n        dispatch_async(dispatch_get_main_queue(), ^{\n            if (bgTask != UIBackgroundTaskInvalid)\n            {\n            /*销毁后台任务标识符*/\n            /*不管有没有完成，结束background_task任务*/\n            bgTask = UIBackgroundTaskInvalid;\n            }\n        });\n    });\n}\n```\n\n","slug":"iOS使定时器NSTimer在程序进入后台仍然运行的方法","published":1,"updated":"2017-07-14T03:57:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj53c1dw5001rh3jj5c312ofk","content":"<p>1.Info.plist中，<code>Required background modes</code>添加<code>App plays audio or streams audio/video using AirPlay</code><br>2.<code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</code>中添加以下代码：<br><a id=\"more\"></a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSError *setCategoryErr = nil;</div><div class=\"line\">NSError *activationErr  = nil;</div><div class=\"line\">[[AVAudioSession sharedInstance]</div><div class=\"line\">setCategory: AVAudioSessionCategoryPlayback</div><div class=\"line\">error: &amp;setCategoryErr];</div><div class=\"line\">[[AVAudioSession sharedInstance]</div><div class=\"line\">setActive: YES</div><div class=\"line\">error: &amp;activationErr];</div><div class=\"line\">self.window.backgroundColor = [UIColor whiteColor];</div><div class=\"line\">[self.window makeKeyAndVisible];</div></pre></td></tr></table></figure></p>\n<p>3.程序进入后台进行以下操作<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)applicationDidEnterBackground:(UIApplication *)application &#123;</div><div class=\"line\"></div><div class=\"line\">    UIApplication* app = [UIApplication sharedApplication];</div><div class=\"line\">    __block UIBackgroundTaskIdentifier bgTask;</div><div class=\"line\"></div><div class=\"line\">    /*注册一个后台任务，告诉系统我们需要向系统借一些事件*/</div><div class=\"line\">    bgTask = [app beginBackgroundTaskWithExpirationHandler:^&#123;</div><div class=\"line\">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">            if (bgTask != UIBackgroundTaskInvalid)</div><div class=\"line\">            &#123;</div><div class=\"line\">            /*销毁后台任务标识符*/</div><div class=\"line\">            /*不管有没有完成，结束background_task任务*/</div><div class=\"line\">            bgTask = UIBackgroundTaskInvalid;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class=\"line\">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">            if (bgTask != UIBackgroundTaskInvalid)</div><div class=\"line\">            &#123;</div><div class=\"line\">            /*销毁后台任务标识符*/</div><div class=\"line\">            /*不管有没有完成，结束background_task任务*/</div><div class=\"line\">            bgTask = UIBackgroundTaskInvalid;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>1.Info.plist中，<code>Required background modes</code>添加<code>App plays audio or streams audio/video using AirPlay</code><br>2.<code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</code>中添加以下代码：<br>","more":"<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSError *setCategoryErr = nil;</div><div class=\"line\">NSError *activationErr  = nil;</div><div class=\"line\">[[AVAudioSession sharedInstance]</div><div class=\"line\">setCategory: AVAudioSessionCategoryPlayback</div><div class=\"line\">error: &amp;setCategoryErr];</div><div class=\"line\">[[AVAudioSession sharedInstance]</div><div class=\"line\">setActive: YES</div><div class=\"line\">error: &amp;activationErr];</div><div class=\"line\">self.window.backgroundColor = [UIColor whiteColor];</div><div class=\"line\">[self.window makeKeyAndVisible];</div></pre></td></tr></table></figure></p>\n<p>3.程序进入后台进行以下操作<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)applicationDidEnterBackground:(UIApplication *)application &#123;</div><div class=\"line\"></div><div class=\"line\">    UIApplication* app = [UIApplication sharedApplication];</div><div class=\"line\">    __block UIBackgroundTaskIdentifier bgTask;</div><div class=\"line\"></div><div class=\"line\">    /*注册一个后台任务，告诉系统我们需要向系统借一些事件*/</div><div class=\"line\">    bgTask = [app beginBackgroundTaskWithExpirationHandler:^&#123;</div><div class=\"line\">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">            if (bgTask != UIBackgroundTaskInvalid)</div><div class=\"line\">            &#123;</div><div class=\"line\">            /*销毁后台任务标识符*/</div><div class=\"line\">            /*不管有没有完成，结束background_task任务*/</div><div class=\"line\">            bgTask = UIBackgroundTaskInvalid;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class=\"line\">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">            if (bgTask != UIBackgroundTaskInvalid)</div><div class=\"line\">            &#123;</div><div class=\"line\">            /*销毁后台任务标识符*/</div><div class=\"line\">            /*不管有没有完成，结束background_task任务*/</div><div class=\"line\">            bgTask = UIBackgroundTaskInvalid;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>"},{"title":"iOS动画笔记","date":"2017-07-05T07:15:27.000Z","_content":"\n\n","source":"_posts/iOS动画笔记.md","raw":"---\ntitle: iOS动画笔记\ndate: 2017-07-05 15:15:27\ncategories: 笔记\ntags: [iOS,动画]\n---\n\n\n","slug":"iOS动画笔记","published":1,"updated":"2017-07-14T03:57:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj53c1dw5001th3jjs6lkjyki","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"iOS国际化学习笔记","date":"2017-01-01T02:30:38.000Z","_content":"\n待补充\n","source":"_posts/iOS国际化学习笔记.md","raw":"---\ntitle: iOS国际化学习笔记\ndate: 2017-01-01 10:30:38\ncategories: 笔记\ntags: [iOS,国际化]\n---\n\n待补充\n","slug":"iOS国际化学习笔记","published":1,"updated":"2017-07-14T03:57:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj53c1dw7001vh3jjnaic4lv8","content":"<p>待补充</p>\n","site":{"data":{}},"excerpt":"","more":"<p>待补充</p>\n"},{"title":"iOS单元测试学习笔记","date":"2017-04-09T06:16:58.000Z","_content":"\n1.新建项目时注意勾选`Unit Tests`,`UI Tests`\n如果忘记勾选，File-->new-->target-->iOS-->Cocoa Unit Testing Bundle/Cocoa UI Testing Bundle 添加\n2.setUp是每个测试方法调用前执行，tearDown是每个测试方法调用后执行\n3.测试方法必须testXXX的格式，且不能有参数\n4.测试方法的执行顺序是字典序排序,cmd + U进行单元测试，这个快捷键是全部测试，在代码左侧就是平常打断点的地方，有个菱形按钮是单独测试这个方法\n<!--more-->\n5.iOS9的http安全问题：现在进行异步请求的网络测试，由于测试方法主线程执行完就会结束，所以需要设置一下，否则没法查看异步返回结果。在方法结束前设置等待，调回回来的时候再让它继续执行。\n```\n//waitForExpectationsWithTimeout是等待时间，超过了就不再等待往下执行。\n#define WAIT do {\\\n[self expectationForNotification:@\"RSBaseTest\" object:nil handler:nil];\\\n[self waitForExpectationsWithTimeout:30 handler:nil];\\\n} while (0);\n\n#define NOTIFY \\\n[[NSNotificationCenter defaultCenter]postNotificationName:@\"RSBaseTest\" object:nil];\n```\n\n## 常用的断言测试函数\nXCTFail(format…)  //生成一个失败的测试；\nXCTAssertNil(a1, format...)  //为空判断，a1为空时通过，反之不通过；\nXCTAssertNotNil(a1, format…) //不为空判断，a1不为空时通过，反之不通过；\nXCTAssert(expression, format...) //当expression求值为TRUE时通过；\nXCTAssertTrue(expression, format...) //当expression求值为TRUE时通过；\nXCTAssertFalse(expression, format...)  //当expression求值为False时通过；\nXCTAssertEqualObjects(a1, a2, format...)  //判断相等，[a1 isEqual:a2]值为TRUE时通过，其中一个不为空时，不通过；\nXCTAssertNotEqualObjects(a1, a2, format...)  //判断不等，[a1 isEqual:a2]值为False时通过；\nXCTAssertEqual(a1, a2, format...)  //判断相等（当a1和a2是 C语言标量、结构体或联合体时使用,实际测试发现NSString也可以）；\nXCTAssertNotEqual(a1, a2, format...)  //判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；\nXCTAssertEqualWithAccuracy(a1, a2, accuracy, format...)  //判断相等，（double或float类型）提供一个误差范围，当在误差范围（+/-accuracy）以内相等时通过测试；\nXCTAssertNotEqualWithAccuracy(a1, a2, accuracy, format...)   //判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试；\nXCTAssertThrows(expression, format...)  //异常测试，当expression发生异常时通过；反之不通过；\nXCTAssertThrowsSpecific(expression, specificException, format...)  //异常测试，当expression发生specificException异常时通过；反之发生其他异常或不发生异常均不通过；\nXCTAssertThrowsSpecificNamed(expression, specificException, exception_name, format...)  //异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过；\nXCTAssertNoThrow(expression, format…)  //异常测试，当expression没有发生异常时通过测试；\nXCTAssertNoThrowSpecific(expression, specificException, format...)  //异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过；\nXCTAssertNoThrowSpecificNamed(expression, specificException, exception_name, format...)  //异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过\n\n示例代码：\n```\n// XCTFail(format…)  //生成一个失败的测试；\n//        XCTFail(@\"Fail\");\n\n// XCTAssertNil(a1, format...) 为空判断， a1 为空时通过，反之不通过；\n//        XCTAssertNil(@\"not nil string\", @\"string must be nil\");\n\n// XCTAssertNotNil(a1, format…) 不为空判断，a1不为空时通过，反之不通过；\nXCTAssertNotNil(@\"not nil string\", @\"string can not be nil\");\n\n\n// XCTAssert(expression, format...) 当expression求值为TRUE时通过；\n//        XCTAssert((2 > 2), @\"expression must be true\");\n\n// XCTAssertTrue(expression, format...) 当expression求值为TRUE时通过；\nXCTAssertTrue(1, @\"Can not be zero\");\n\n// XCTAssertFalse(expression, format...) 当expression求值为False时通过；\nXCTAssertFalse((2 < 2), @\"expression must be false\");\n\n// XCTAssertEqualObjects(a1, a2, format...) 判断相等， [a1 isEqual:a2] 值为TRUE时通过，其中一个不为空时，不通过；\n//    XCTAssertEqualObjects(@\"1\", @\"1\", @\"[a1 isEqual:a2] should return YES\");\n//    XCTAssertEqualObjects(@\"1\", @\"2\", @\"[a1 isEqual:a2] should return YES\");\n\n//     XCTAssertNotEqualObjects(a1, a2, format...) 判断不等， [a1 isEqual:a2] 值为False时通过，\n//    XCTAssertNotEqualObjects(@\"1\", @\"1\", @\"[a1 isEqual:a2] should return NO\");\n//    XCTAssertNotEqualObjects(@\"1\", @\"2\", @\"[a1 isEqual:a2] should return NO\");\n\n// XCTAssertEqual(a1, a2, format...) 判断相等（当a1和a2是 C语言标量、结构体或联合体时使用,实际测试发现NSString也可以）；\n// 1.比较基本数据类型变量\n//    XCTAssertEqual(1, 2, @\"a1 = a2 shoud be true\"); // 无法通过测试\n//    XCTAssertEqual(1, 1, @\"a1 = a2 shoud be true\"); // 通过测试\n\n// 2.比较NSString对象\n//    NSString *str1 = @\"1\";\n//    NSString *str2 = @\"1\";\n//    NSString *str3 = str1;\n//    XCTAssertEqual(str1, str2, @\"a1 and a2 should point to the same object\"); // 通过测试\n//    XCTAssertEqual(str1, str3, @\"a1 and a2 should point to the same object\"); // 通过测试\n\n// 3.比较NSArray对象\n//    NSArray *array1 = @[@1];\n//    NSArray *array2 = @[@1];\n//    NSArray *array3 = array1;\n//    XCTAssertEqual(array1, array2, @\"a1 and a2 should point to the same object\"); // 无法通过测试\n//    XCTAssertEqual(array1, array3, @\"a1 and a2 should point to the same object\"); // 通过测试\n\n// XCTAssertNotEqual(a1, a2, format...) 判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；\n\n// XCTAssertEqualWithAccuracy(a1, a2, accuracy, format...) 判断相等，（double或float类型）提供一个误差范围，当在误差范围（+/- accuracy ）以内相等时通过测试；\n//    XCTAssertEqualWithAccuracy(1.0f, 1.5f, 0.25f, @\"a1 = a2 in accuracy should return YES\");\n\n// XCTAssertNotEqualWithAccuracy(a1, a2, accuracy, format...) 判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试；\n//    XCTAssertNotEqualWithAccuracy(1.0f, 1.5f, 0.25f, @\"a1 = a2 in accuracy should return NO\");\n\n// XCTAssertThrows(expression, format...) 异常测试，当expression发生异常时通过；反之不通过；（很变态）\n\n// XCTAssertThrowsSpecific(expression, specificException, format...) 异常测试，当expression发生 specificException 异常时通过；反之发生其他异常或不发生异常均不通过；\n\n// XCTAssertThrowsSpecificNamed(expression, specificException, exception_name, format...) 异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过；\n\n// XCTAssertNoThrow(expression, format…) 异常测试，当expression没有发生异常时通过测试；\n\n// XCTAssertNoThrowSpecific(expression, specificException, format...)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过；\n\n// XCTAssertNoThrowSpecificNamed(expression, specificException, exception_name, format...) 异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过\n```\n\n转自：[iOS单元测试(作用及入门提升)](http://www.jianshu.com/p/8bbec078cabe)\n(http://www.jianshu.com/p/009844a0b9ed)\n","source":"_posts/iOS单元测试学习笔记.md","raw":"---\ntitle: iOS单元测试学习笔记\ndate: 2017-04-09 14:16:58\ncategories: 笔记\ntags: [iOS,test]\n---\n\n1.新建项目时注意勾选`Unit Tests`,`UI Tests`\n如果忘记勾选，File-->new-->target-->iOS-->Cocoa Unit Testing Bundle/Cocoa UI Testing Bundle 添加\n2.setUp是每个测试方法调用前执行，tearDown是每个测试方法调用后执行\n3.测试方法必须testXXX的格式，且不能有参数\n4.测试方法的执行顺序是字典序排序,cmd + U进行单元测试，这个快捷键是全部测试，在代码左侧就是平常打断点的地方，有个菱形按钮是单独测试这个方法\n<!--more-->\n5.iOS9的http安全问题：现在进行异步请求的网络测试，由于测试方法主线程执行完就会结束，所以需要设置一下，否则没法查看异步返回结果。在方法结束前设置等待，调回回来的时候再让它继续执行。\n```\n//waitForExpectationsWithTimeout是等待时间，超过了就不再等待往下执行。\n#define WAIT do {\\\n[self expectationForNotification:@\"RSBaseTest\" object:nil handler:nil];\\\n[self waitForExpectationsWithTimeout:30 handler:nil];\\\n} while (0);\n\n#define NOTIFY \\\n[[NSNotificationCenter defaultCenter]postNotificationName:@\"RSBaseTest\" object:nil];\n```\n\n## 常用的断言测试函数\nXCTFail(format…)  //生成一个失败的测试；\nXCTAssertNil(a1, format...)  //为空判断，a1为空时通过，反之不通过；\nXCTAssertNotNil(a1, format…) //不为空判断，a1不为空时通过，反之不通过；\nXCTAssert(expression, format...) //当expression求值为TRUE时通过；\nXCTAssertTrue(expression, format...) //当expression求值为TRUE时通过；\nXCTAssertFalse(expression, format...)  //当expression求值为False时通过；\nXCTAssertEqualObjects(a1, a2, format...)  //判断相等，[a1 isEqual:a2]值为TRUE时通过，其中一个不为空时，不通过；\nXCTAssertNotEqualObjects(a1, a2, format...)  //判断不等，[a1 isEqual:a2]值为False时通过；\nXCTAssertEqual(a1, a2, format...)  //判断相等（当a1和a2是 C语言标量、结构体或联合体时使用,实际测试发现NSString也可以）；\nXCTAssertNotEqual(a1, a2, format...)  //判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；\nXCTAssertEqualWithAccuracy(a1, a2, accuracy, format...)  //判断相等，（double或float类型）提供一个误差范围，当在误差范围（+/-accuracy）以内相等时通过测试；\nXCTAssertNotEqualWithAccuracy(a1, a2, accuracy, format...)   //判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试；\nXCTAssertThrows(expression, format...)  //异常测试，当expression发生异常时通过；反之不通过；\nXCTAssertThrowsSpecific(expression, specificException, format...)  //异常测试，当expression发生specificException异常时通过；反之发生其他异常或不发生异常均不通过；\nXCTAssertThrowsSpecificNamed(expression, specificException, exception_name, format...)  //异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过；\nXCTAssertNoThrow(expression, format…)  //异常测试，当expression没有发生异常时通过测试；\nXCTAssertNoThrowSpecific(expression, specificException, format...)  //异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过；\nXCTAssertNoThrowSpecificNamed(expression, specificException, exception_name, format...)  //异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过\n\n示例代码：\n```\n// XCTFail(format…)  //生成一个失败的测试；\n//        XCTFail(@\"Fail\");\n\n// XCTAssertNil(a1, format...) 为空判断， a1 为空时通过，反之不通过；\n//        XCTAssertNil(@\"not nil string\", @\"string must be nil\");\n\n// XCTAssertNotNil(a1, format…) 不为空判断，a1不为空时通过，反之不通过；\nXCTAssertNotNil(@\"not nil string\", @\"string can not be nil\");\n\n\n// XCTAssert(expression, format...) 当expression求值为TRUE时通过；\n//        XCTAssert((2 > 2), @\"expression must be true\");\n\n// XCTAssertTrue(expression, format...) 当expression求值为TRUE时通过；\nXCTAssertTrue(1, @\"Can not be zero\");\n\n// XCTAssertFalse(expression, format...) 当expression求值为False时通过；\nXCTAssertFalse((2 < 2), @\"expression must be false\");\n\n// XCTAssertEqualObjects(a1, a2, format...) 判断相等， [a1 isEqual:a2] 值为TRUE时通过，其中一个不为空时，不通过；\n//    XCTAssertEqualObjects(@\"1\", @\"1\", @\"[a1 isEqual:a2] should return YES\");\n//    XCTAssertEqualObjects(@\"1\", @\"2\", @\"[a1 isEqual:a2] should return YES\");\n\n//     XCTAssertNotEqualObjects(a1, a2, format...) 判断不等， [a1 isEqual:a2] 值为False时通过，\n//    XCTAssertNotEqualObjects(@\"1\", @\"1\", @\"[a1 isEqual:a2] should return NO\");\n//    XCTAssertNotEqualObjects(@\"1\", @\"2\", @\"[a1 isEqual:a2] should return NO\");\n\n// XCTAssertEqual(a1, a2, format...) 判断相等（当a1和a2是 C语言标量、结构体或联合体时使用,实际测试发现NSString也可以）；\n// 1.比较基本数据类型变量\n//    XCTAssertEqual(1, 2, @\"a1 = a2 shoud be true\"); // 无法通过测试\n//    XCTAssertEqual(1, 1, @\"a1 = a2 shoud be true\"); // 通过测试\n\n// 2.比较NSString对象\n//    NSString *str1 = @\"1\";\n//    NSString *str2 = @\"1\";\n//    NSString *str3 = str1;\n//    XCTAssertEqual(str1, str2, @\"a1 and a2 should point to the same object\"); // 通过测试\n//    XCTAssertEqual(str1, str3, @\"a1 and a2 should point to the same object\"); // 通过测试\n\n// 3.比较NSArray对象\n//    NSArray *array1 = @[@1];\n//    NSArray *array2 = @[@1];\n//    NSArray *array3 = array1;\n//    XCTAssertEqual(array1, array2, @\"a1 and a2 should point to the same object\"); // 无法通过测试\n//    XCTAssertEqual(array1, array3, @\"a1 and a2 should point to the same object\"); // 通过测试\n\n// XCTAssertNotEqual(a1, a2, format...) 判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；\n\n// XCTAssertEqualWithAccuracy(a1, a2, accuracy, format...) 判断相等，（double或float类型）提供一个误差范围，当在误差范围（+/- accuracy ）以内相等时通过测试；\n//    XCTAssertEqualWithAccuracy(1.0f, 1.5f, 0.25f, @\"a1 = a2 in accuracy should return YES\");\n\n// XCTAssertNotEqualWithAccuracy(a1, a2, accuracy, format...) 判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试；\n//    XCTAssertNotEqualWithAccuracy(1.0f, 1.5f, 0.25f, @\"a1 = a2 in accuracy should return NO\");\n\n// XCTAssertThrows(expression, format...) 异常测试，当expression发生异常时通过；反之不通过；（很变态）\n\n// XCTAssertThrowsSpecific(expression, specificException, format...) 异常测试，当expression发生 specificException 异常时通过；反之发生其他异常或不发生异常均不通过；\n\n// XCTAssertThrowsSpecificNamed(expression, specificException, exception_name, format...) 异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过；\n\n// XCTAssertNoThrow(expression, format…) 异常测试，当expression没有发生异常时通过测试；\n\n// XCTAssertNoThrowSpecific(expression, specificException, format...)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过；\n\n// XCTAssertNoThrowSpecificNamed(expression, specificException, exception_name, format...) 异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过\n```\n\n转自：[iOS单元测试(作用及入门提升)](http://www.jianshu.com/p/8bbec078cabe)\n(http://www.jianshu.com/p/009844a0b9ed)\n","slug":"iOS单元测试学习笔记","published":1,"updated":"2017-07-14T03:57:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj53c1dw9001zh3jjzkg5t5iy","content":"<p>1.新建项目时注意勾选<code>Unit Tests</code>,<code>UI Tests</code><br>如果忘记勾选，File–&gt;new–&gt;target–&gt;iOS–&gt;Cocoa Unit Testing Bundle/Cocoa UI Testing Bundle 添加<br>2.setUp是每个测试方法调用前执行，tearDown是每个测试方法调用后执行<br>3.测试方法必须testXXX的格式，且不能有参数<br>4.测试方法的执行顺序是字典序排序,cmd + U进行单元测试，这个快捷键是全部测试，在代码左侧就是平常打断点的地方，有个菱形按钮是单独测试这个方法<br><a id=\"more\"></a><br>5.iOS9的http安全问题：现在进行异步请求的网络测试，由于测试方法主线程执行完就会结束，所以需要设置一下，否则没法查看异步返回结果。在方法结束前设置等待，调回回来的时候再让它继续执行。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">//waitForExpectationsWithTimeout是等待时间，超过了就不再等待往下执行。</div><div class=\"line\">#define WAIT do &#123;\\</div><div class=\"line\">[self expectationForNotification:@&quot;RSBaseTest&quot; object:nil handler:nil];\\</div><div class=\"line\">[self waitForExpectationsWithTimeout:30 handler:nil];\\</div><div class=\"line\">&#125; while (0);</div><div class=\"line\"></div><div class=\"line\">#define NOTIFY \\</div><div class=\"line\">[[NSNotificationCenter defaultCenter]postNotificationName:@&quot;RSBaseTest&quot; object:nil];</div></pre></td></tr></table></figure></p>\n<h2 id=\"常用的断言测试函数\"><a href=\"#常用的断言测试函数\" class=\"headerlink\" title=\"常用的断言测试函数\"></a>常用的断言测试函数</h2><p>XCTFail(format…)  //生成一个失败的测试；<br>XCTAssertNil(a1, format…)  //为空判断，a1为空时通过，反之不通过；<br>XCTAssertNotNil(a1, format…) //不为空判断，a1不为空时通过，反之不通过；<br>XCTAssert(expression, format…) //当expression求值为TRUE时通过；<br>XCTAssertTrue(expression, format…) //当expression求值为TRUE时通过；<br>XCTAssertFalse(expression, format…)  //当expression求值为False时通过；<br>XCTAssertEqualObjects(a1, a2, format…)  //判断相等，[a1 isEqual:a2]值为TRUE时通过，其中一个不为空时，不通过；<br>XCTAssertNotEqualObjects(a1, a2, format…)  //判断不等，[a1 isEqual:a2]值为False时通过；<br>XCTAssertEqual(a1, a2, format…)  //判断相等（当a1和a2是 C语言标量、结构体或联合体时使用,实际测试发现NSString也可以）；<br>XCTAssertNotEqual(a1, a2, format…)  //判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；<br>XCTAssertEqualWithAccuracy(a1, a2, accuracy, format…)  //判断相等，（double或float类型）提供一个误差范围，当在误差范围（+/-accuracy）以内相等时通过测试；<br>XCTAssertNotEqualWithAccuracy(a1, a2, accuracy, format…)   //判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试；<br>XCTAssertThrows(expression, format…)  //异常测试，当expression发生异常时通过；反之不通过；<br>XCTAssertThrowsSpecific(expression, specificException, format…)  //异常测试，当expression发生specificException异常时通过；反之发生其他异常或不发生异常均不通过；<br>XCTAssertThrowsSpecificNamed(expression, specificException, exception_name, format…)  //异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过；<br>XCTAssertNoThrow(expression, format…)  //异常测试，当expression没有发生异常时通过测试；<br>XCTAssertNoThrowSpecific(expression, specificException, format…)  //异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过；<br>XCTAssertNoThrowSpecificNamed(expression, specificException, exception_name, format…)  //异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过</p>\n<p>示例代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div></pre></td><td class=\"code\"><pre><div class=\"line\">// XCTFail(format…)  //生成一个失败的测试；</div><div class=\"line\">//        XCTFail(@&quot;Fail&quot;);</div><div class=\"line\"></div><div class=\"line\">// XCTAssertNil(a1, format...) 为空判断， a1 为空时通过，反之不通过；</div><div class=\"line\">//        XCTAssertNil(@&quot;not nil string&quot;, @&quot;string must be nil&quot;);</div><div class=\"line\"></div><div class=\"line\">// XCTAssertNotNil(a1, format…) 不为空判断，a1不为空时通过，反之不通过；</div><div class=\"line\">XCTAssertNotNil(@&quot;not nil string&quot;, @&quot;string can not be nil&quot;);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// XCTAssert(expression, format...) 当expression求值为TRUE时通过；</div><div class=\"line\">//        XCTAssert((2 &gt; 2), @&quot;expression must be true&quot;);</div><div class=\"line\"></div><div class=\"line\">// XCTAssertTrue(expression, format...) 当expression求值为TRUE时通过；</div><div class=\"line\">XCTAssertTrue(1, @&quot;Can not be zero&quot;);</div><div class=\"line\"></div><div class=\"line\">// XCTAssertFalse(expression, format...) 当expression求值为False时通过；</div><div class=\"line\">XCTAssertFalse((2 &lt; 2), @&quot;expression must be false&quot;);</div><div class=\"line\"></div><div class=\"line\">// XCTAssertEqualObjects(a1, a2, format...) 判断相等， [a1 isEqual:a2] 值为TRUE时通过，其中一个不为空时，不通过；</div><div class=\"line\">//    XCTAssertEqualObjects(@&quot;1&quot;, @&quot;1&quot;, @&quot;[a1 isEqual:a2] should return YES&quot;);</div><div class=\"line\">//    XCTAssertEqualObjects(@&quot;1&quot;, @&quot;2&quot;, @&quot;[a1 isEqual:a2] should return YES&quot;);</div><div class=\"line\"></div><div class=\"line\">//     XCTAssertNotEqualObjects(a1, a2, format...) 判断不等， [a1 isEqual:a2] 值为False时通过，</div><div class=\"line\">//    XCTAssertNotEqualObjects(@&quot;1&quot;, @&quot;1&quot;, @&quot;[a1 isEqual:a2] should return NO&quot;);</div><div class=\"line\">//    XCTAssertNotEqualObjects(@&quot;1&quot;, @&quot;2&quot;, @&quot;[a1 isEqual:a2] should return NO&quot;);</div><div class=\"line\"></div><div class=\"line\">// XCTAssertEqual(a1, a2, format...) 判断相等（当a1和a2是 C语言标量、结构体或联合体时使用,实际测试发现NSString也可以）；</div><div class=\"line\">// 1.比较基本数据类型变量</div><div class=\"line\">//    XCTAssertEqual(1, 2, @&quot;a1 = a2 shoud be true&quot;); // 无法通过测试</div><div class=\"line\">//    XCTAssertEqual(1, 1, @&quot;a1 = a2 shoud be true&quot;); // 通过测试</div><div class=\"line\"></div><div class=\"line\">// 2.比较NSString对象</div><div class=\"line\">//    NSString *str1 = @&quot;1&quot;;</div><div class=\"line\">//    NSString *str2 = @&quot;1&quot;;</div><div class=\"line\">//    NSString *str3 = str1;</div><div class=\"line\">//    XCTAssertEqual(str1, str2, @&quot;a1 and a2 should point to the same object&quot;); // 通过测试</div><div class=\"line\">//    XCTAssertEqual(str1, str3, @&quot;a1 and a2 should point to the same object&quot;); // 通过测试</div><div class=\"line\"></div><div class=\"line\">// 3.比较NSArray对象</div><div class=\"line\">//    NSArray *array1 = @[@1];</div><div class=\"line\">//    NSArray *array2 = @[@1];</div><div class=\"line\">//    NSArray *array3 = array1;</div><div class=\"line\">//    XCTAssertEqual(array1, array2, @&quot;a1 and a2 should point to the same object&quot;); // 无法通过测试</div><div class=\"line\">//    XCTAssertEqual(array1, array3, @&quot;a1 and a2 should point to the same object&quot;); // 通过测试</div><div class=\"line\"></div><div class=\"line\">// XCTAssertNotEqual(a1, a2, format...) 判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；</div><div class=\"line\"></div><div class=\"line\">// XCTAssertEqualWithAccuracy(a1, a2, accuracy, format...) 判断相等，（double或float类型）提供一个误差范围，当在误差范围（+/- accuracy ）以内相等时通过测试；</div><div class=\"line\">//    XCTAssertEqualWithAccuracy(1.0f, 1.5f, 0.25f, @&quot;a1 = a2 in accuracy should return YES&quot;);</div><div class=\"line\"></div><div class=\"line\">// XCTAssertNotEqualWithAccuracy(a1, a2, accuracy, format...) 判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试；</div><div class=\"line\">//    XCTAssertNotEqualWithAccuracy(1.0f, 1.5f, 0.25f, @&quot;a1 = a2 in accuracy should return NO&quot;);</div><div class=\"line\"></div><div class=\"line\">// XCTAssertThrows(expression, format...) 异常测试，当expression发生异常时通过；反之不通过；（很变态）</div><div class=\"line\"></div><div class=\"line\">// XCTAssertThrowsSpecific(expression, specificException, format...) 异常测试，当expression发生 specificException 异常时通过；反之发生其他异常或不发生异常均不通过；</div><div class=\"line\"></div><div class=\"line\">// XCTAssertThrowsSpecificNamed(expression, specificException, exception_name, format...) 异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过；</div><div class=\"line\"></div><div class=\"line\">// XCTAssertNoThrow(expression, format…) 异常测试，当expression没有发生异常时通过测试；</div><div class=\"line\"></div><div class=\"line\">// XCTAssertNoThrowSpecific(expression, specificException, format...)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过；</div><div class=\"line\"></div><div class=\"line\">// XCTAssertNoThrowSpecificNamed(expression, specificException, exception_name, format...) 异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过</div></pre></td></tr></table></figure></p>\n<p>转自：<a href=\"http://www.jianshu.com/p/8bbec078cabe\" target=\"_blank\" rel=\"external\">iOS单元测试(作用及入门提升)</a><br>(<a href=\"http://www.jianshu.com/p/009844a0b9ed\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/009844a0b9ed</a>)</p>\n","site":{"data":{}},"excerpt":"<p>1.新建项目时注意勾选<code>Unit Tests</code>,<code>UI Tests</code><br>如果忘记勾选，File–&gt;new–&gt;target–&gt;iOS–&gt;Cocoa Unit Testing Bundle/Cocoa UI Testing Bundle 添加<br>2.setUp是每个测试方法调用前执行，tearDown是每个测试方法调用后执行<br>3.测试方法必须testXXX的格式，且不能有参数<br>4.测试方法的执行顺序是字典序排序,cmd + U进行单元测试，这个快捷键是全部测试，在代码左侧就是平常打断点的地方，有个菱形按钮是单独测试这个方法<br>","more":"<br>5.iOS9的http安全问题：现在进行异步请求的网络测试，由于测试方法主线程执行完就会结束，所以需要设置一下，否则没法查看异步返回结果。在方法结束前设置等待，调回回来的时候再让它继续执行。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">//waitForExpectationsWithTimeout是等待时间，超过了就不再等待往下执行。</div><div class=\"line\">#define WAIT do &#123;\\</div><div class=\"line\">[self expectationForNotification:@&quot;RSBaseTest&quot; object:nil handler:nil];\\</div><div class=\"line\">[self waitForExpectationsWithTimeout:30 handler:nil];\\</div><div class=\"line\">&#125; while (0);</div><div class=\"line\"></div><div class=\"line\">#define NOTIFY \\</div><div class=\"line\">[[NSNotificationCenter defaultCenter]postNotificationName:@&quot;RSBaseTest&quot; object:nil];</div></pre></td></tr></table></figure></p>\n<h2 id=\"常用的断言测试函数\"><a href=\"#常用的断言测试函数\" class=\"headerlink\" title=\"常用的断言测试函数\"></a>常用的断言测试函数</h2><p>XCTFail(format…)  //生成一个失败的测试；<br>XCTAssertNil(a1, format…)  //为空判断，a1为空时通过，反之不通过；<br>XCTAssertNotNil(a1, format…) //不为空判断，a1不为空时通过，反之不通过；<br>XCTAssert(expression, format…) //当expression求值为TRUE时通过；<br>XCTAssertTrue(expression, format…) //当expression求值为TRUE时通过；<br>XCTAssertFalse(expression, format…)  //当expression求值为False时通过；<br>XCTAssertEqualObjects(a1, a2, format…)  //判断相等，[a1 isEqual:a2]值为TRUE时通过，其中一个不为空时，不通过；<br>XCTAssertNotEqualObjects(a1, a2, format…)  //判断不等，[a1 isEqual:a2]值为False时通过；<br>XCTAssertEqual(a1, a2, format…)  //判断相等（当a1和a2是 C语言标量、结构体或联合体时使用,实际测试发现NSString也可以）；<br>XCTAssertNotEqual(a1, a2, format…)  //判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；<br>XCTAssertEqualWithAccuracy(a1, a2, accuracy, format…)  //判断相等，（double或float类型）提供一个误差范围，当在误差范围（+/-accuracy）以内相等时通过测试；<br>XCTAssertNotEqualWithAccuracy(a1, a2, accuracy, format…)   //判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试；<br>XCTAssertThrows(expression, format…)  //异常测试，当expression发生异常时通过；反之不通过；<br>XCTAssertThrowsSpecific(expression, specificException, format…)  //异常测试，当expression发生specificException异常时通过；反之发生其他异常或不发生异常均不通过；<br>XCTAssertThrowsSpecificNamed(expression, specificException, exception_name, format…)  //异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过；<br>XCTAssertNoThrow(expression, format…)  //异常测试，当expression没有发生异常时通过测试；<br>XCTAssertNoThrowSpecific(expression, specificException, format…)  //异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过；<br>XCTAssertNoThrowSpecificNamed(expression, specificException, exception_name, format…)  //异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过</p>\n<p>示例代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div></pre></td><td class=\"code\"><pre><div class=\"line\">// XCTFail(format…)  //生成一个失败的测试；</div><div class=\"line\">//        XCTFail(@&quot;Fail&quot;);</div><div class=\"line\"></div><div class=\"line\">// XCTAssertNil(a1, format...) 为空判断， a1 为空时通过，反之不通过；</div><div class=\"line\">//        XCTAssertNil(@&quot;not nil string&quot;, @&quot;string must be nil&quot;);</div><div class=\"line\"></div><div class=\"line\">// XCTAssertNotNil(a1, format…) 不为空判断，a1不为空时通过，反之不通过；</div><div class=\"line\">XCTAssertNotNil(@&quot;not nil string&quot;, @&quot;string can not be nil&quot;);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// XCTAssert(expression, format...) 当expression求值为TRUE时通过；</div><div class=\"line\">//        XCTAssert((2 &gt; 2), @&quot;expression must be true&quot;);</div><div class=\"line\"></div><div class=\"line\">// XCTAssertTrue(expression, format...) 当expression求值为TRUE时通过；</div><div class=\"line\">XCTAssertTrue(1, @&quot;Can not be zero&quot;);</div><div class=\"line\"></div><div class=\"line\">// XCTAssertFalse(expression, format...) 当expression求值为False时通过；</div><div class=\"line\">XCTAssertFalse((2 &lt; 2), @&quot;expression must be false&quot;);</div><div class=\"line\"></div><div class=\"line\">// XCTAssertEqualObjects(a1, a2, format...) 判断相等， [a1 isEqual:a2] 值为TRUE时通过，其中一个不为空时，不通过；</div><div class=\"line\">//    XCTAssertEqualObjects(@&quot;1&quot;, @&quot;1&quot;, @&quot;[a1 isEqual:a2] should return YES&quot;);</div><div class=\"line\">//    XCTAssertEqualObjects(@&quot;1&quot;, @&quot;2&quot;, @&quot;[a1 isEqual:a2] should return YES&quot;);</div><div class=\"line\"></div><div class=\"line\">//     XCTAssertNotEqualObjects(a1, a2, format...) 判断不等， [a1 isEqual:a2] 值为False时通过，</div><div class=\"line\">//    XCTAssertNotEqualObjects(@&quot;1&quot;, @&quot;1&quot;, @&quot;[a1 isEqual:a2] should return NO&quot;);</div><div class=\"line\">//    XCTAssertNotEqualObjects(@&quot;1&quot;, @&quot;2&quot;, @&quot;[a1 isEqual:a2] should return NO&quot;);</div><div class=\"line\"></div><div class=\"line\">// XCTAssertEqual(a1, a2, format...) 判断相等（当a1和a2是 C语言标量、结构体或联合体时使用,实际测试发现NSString也可以）；</div><div class=\"line\">// 1.比较基本数据类型变量</div><div class=\"line\">//    XCTAssertEqual(1, 2, @&quot;a1 = a2 shoud be true&quot;); // 无法通过测试</div><div class=\"line\">//    XCTAssertEqual(1, 1, @&quot;a1 = a2 shoud be true&quot;); // 通过测试</div><div class=\"line\"></div><div class=\"line\">// 2.比较NSString对象</div><div class=\"line\">//    NSString *str1 = @&quot;1&quot;;</div><div class=\"line\">//    NSString *str2 = @&quot;1&quot;;</div><div class=\"line\">//    NSString *str3 = str1;</div><div class=\"line\">//    XCTAssertEqual(str1, str2, @&quot;a1 and a2 should point to the same object&quot;); // 通过测试</div><div class=\"line\">//    XCTAssertEqual(str1, str3, @&quot;a1 and a2 should point to the same object&quot;); // 通过测试</div><div class=\"line\"></div><div class=\"line\">// 3.比较NSArray对象</div><div class=\"line\">//    NSArray *array1 = @[@1];</div><div class=\"line\">//    NSArray *array2 = @[@1];</div><div class=\"line\">//    NSArray *array3 = array1;</div><div class=\"line\">//    XCTAssertEqual(array1, array2, @&quot;a1 and a2 should point to the same object&quot;); // 无法通过测试</div><div class=\"line\">//    XCTAssertEqual(array1, array3, @&quot;a1 and a2 should point to the same object&quot;); // 通过测试</div><div class=\"line\"></div><div class=\"line\">// XCTAssertNotEqual(a1, a2, format...) 判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；</div><div class=\"line\"></div><div class=\"line\">// XCTAssertEqualWithAccuracy(a1, a2, accuracy, format...) 判断相等，（double或float类型）提供一个误差范围，当在误差范围（+/- accuracy ）以内相等时通过测试；</div><div class=\"line\">//    XCTAssertEqualWithAccuracy(1.0f, 1.5f, 0.25f, @&quot;a1 = a2 in accuracy should return YES&quot;);</div><div class=\"line\"></div><div class=\"line\">// XCTAssertNotEqualWithAccuracy(a1, a2, accuracy, format...) 判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试；</div><div class=\"line\">//    XCTAssertNotEqualWithAccuracy(1.0f, 1.5f, 0.25f, @&quot;a1 = a2 in accuracy should return NO&quot;);</div><div class=\"line\"></div><div class=\"line\">// XCTAssertThrows(expression, format...) 异常测试，当expression发生异常时通过；反之不通过；（很变态）</div><div class=\"line\"></div><div class=\"line\">// XCTAssertThrowsSpecific(expression, specificException, format...) 异常测试，当expression发生 specificException 异常时通过；反之发生其他异常或不发生异常均不通过；</div><div class=\"line\"></div><div class=\"line\">// XCTAssertThrowsSpecificNamed(expression, specificException, exception_name, format...) 异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过；</div><div class=\"line\"></div><div class=\"line\">// XCTAssertNoThrow(expression, format…) 异常测试，当expression没有发生异常时通过测试；</div><div class=\"line\"></div><div class=\"line\">// XCTAssertNoThrowSpecific(expression, specificException, format...)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过；</div><div class=\"line\"></div><div class=\"line\">// XCTAssertNoThrowSpecificNamed(expression, specificException, exception_name, format...) 异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过</div></pre></td></tr></table></figure></p>\n<p>转自：<a href=\"http://www.jianshu.com/p/8bbec078cabe\" target=\"_blank\" rel=\"external\">iOS单元测试(作用及入门提升)</a><br>(<a href=\"http://www.jianshu.com/p/009844a0b9ed\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/009844a0b9ed</a>)</p>"},{"title":"iOS多媒体学习笔记","date":"2017-05-06T03:41:05.000Z","toc":true,"_content":"\n## 音频\n### 音效 AudioToolbox.framework\n限制：\n* 音频播放时间不能超过30s\n* 数据必须是PCM或者IMA4格式\n* 音频文件必须打包成.caf、.aif、.wav中的一种（注意这是官方文档的说法，实际测试发现一些.mp3也可以播放）\n<!--more-->\n\n### 音乐 AVAudioPlayer\nAVFoundation.framework中的AVAudioPlayer\nAVAudioPlayer可以看成一个播放器，它支持多种音频格式，而且能够进行进度、音量、播放速度等控制。\nAVAudioPlayer使用：\n* 初始化AVAudioPlayer对象，此时通常指定本地文件路径。\n* 设置播放器属性，例如重复次数、音量大小等。\n* 调用play方法播放。\n\n### MPMusicPlayerController\n\n### 音频会话 AVAudioSession\n支持后台播放：\n* 1.设置后台运行模式：在plist文件中添加Required background modes，并且设置item 0=App plays audio or streams audio/video using AirPlay（其实可以直接通过Xcode在Project Targets-Capabilities-Background Modes中设置）\n* 2.设置AVAudioSession的类型为AVAudioSessionCategoryPlayback并且调用setActive::方法启动会话。\n```\nAVAudioSession *audioSession=[AVAudioSession sharedInstance];\n[audioSession setCategory:AVAudioSessionCategoryPlayback error:nil];\n[audioSession setActive:YES error:nil];\n```\n\n* 3.为了能够让应用退到后台之后支持耳机控制，建议添加远程控制事件（这一步不是后台播放必须的）\n在iOS中每个应用都有一个音频会话，这个会话就通过AVAudioSession来表示。AVAudioSession同样存在于AVFoundation框架中，它是单例模式设计，通过sharedInstance进行访问。在使用Apple设备时大家会发现有些应用只要打开其他音频播放就会终止，而有些应用却可以和其他应用同时播放，在多种音频环境中如何去控制播放的方式就是通过音频会话来完成的。\n\n### 音频队列服务（Audio Queue Services）\n* AVAudioPlayer只能播放本地文件，并且是一次性加载所以音频数据，初始化AVAudioPlayer时指定的URL也只能是File URL而不能是HTTP URL。\n* AudioToolbox框架中的音频队列服务Audio Queue Services，支持网络流媒体播放。\n\n### FSAudioStream\n\n## 录音\n### AVAudioRecorder\nAVFoundation框架中的AVAudioRecorder类\ninfo.plist 添加 `NSMicrophoneUsageDescription`\n### 音频队列服务（Audio Queue Services）\n\n## 视频播放\n### MPMoviePlayerController\nMediaPlayer.framework种的MPMoviePlayerController类，它支持本地视频和网络视频播放，如果要在UI中展示视频需要将view属性添加到界面中。\n\n### MPMoviePlayerViewController\n默认全屏播放，开发者在开发的时候直接使用这个视图控制器。\n注意：由于MPMoviePlayerViewController的初始化方法做了大量工作（例如设置URL、自动播放、添加点击Done完成的监控等），所以当再次点击播放弹出新的模态窗口的时如果不销毁之前的MPMoviePlayerViewController，那么新的对象就无法完成初始化，这样也就不能再次进行播放。\n\n### AVPlayer\nAVPlayer存在于AVFoundation中，它更加接近于底层，所以灵活性也更强。\nAVPlayer本身并不能显示视频，而且它也不像MPMoviePlayerController有一个view属性。如果AVPlayer要显示必须创建一个播放器层AVPlayerLayer用于展示，播放器层继承于CALayer，有了AVPlayerLayer之添加到控制器视图的layer中即可。\n几个相关类：\n* AVAsset：主要用于获取多媒体信息，是一个抽象类，不能直接使用。\n* AVURLAsset：AVAsset的子类，可以根据一个URL路径创建一个包含媒体信息的AVURLAsset对象。\n* AVPlayerItem：一个媒体资源管理对象，管理者视频的一些基本信息和状态，一个AVPlayerItem对应着一个视频资源。\n\n## 视频截图\n### MPMoviePlayerController\n### AVAssetImageGenerator\nAVFundation框架中的AVAssetImageGenerator\n```\n/**\n*  截取指定时间的视频缩略图\n*\n*  @param timeBySecond 时间点\n*/\n-(void)thumbnailImageRequest:(CGFloat )timeBySecond{\n    //创建URL\n    NSURL *url=[self getNetworkUrl];\n    //根据url创建AVURLAsset\n    AVURLAsset *urlAsset=[AVURLAsset assetWithURL:url];\n    //根据AVURLAsset创建AVAssetImageGenerator\n    AVAssetImageGenerator *imageGenerator=[AVAssetImageGenerator assetImageGeneratorWithAsset:urlAsset];\n    /*截图\n    * requestTime:缩略图创建时间\n    * actualTime:缩略图实际生成的时间\n    */\n    NSError *error=nil;\n    CMTime time=CMTimeMakeWithSeconds(timeBySecond, 10);//CMTime是表示电影时间信息的结构体，第一个参数表示是视频第几秒，第二个参数表示每秒帧数.(如果要活的某一秒的第几帧可以使用CMTimeMake方法)\n    CMTime actualTime;\n    CGImageRef cgImage= [imageGenerator copyCGImageAtTime:time actualTime:&actualTime error:&error];\n    if(error){\n    NSLog(@\"截取视频缩略图时发生错误，错误信息：%@\",error.localizedDescription);\n    return;\n    }\n    CMTimeShow(actualTime);\n    UIImage *image=[UIImage imageWithCGImage:cgImage];//转化为UIImage\n    //保存到相册\n    UIImageWriteToSavedPhotosAlbum(image,nil, nil, nil);\n    CGImageRelease(cgImage);\n}\n```\n### 第三方\niOS上常用的视频编码、解码框架有：VLC、ffmpeg\n\n## 摄像头（拍照和视频录制）\n### UIImagePickerController\nUIImagePickerController继承于UINavigationController\n\n### AVFoundation（AVCaptureSession/AVCaptureDevice）\n灵活性强。\n\n![优缺点比较](http://o8cfktdb3.bkt.clouddn.com/media.png)\n\n参考原文：[iOS开发系列--音频播放、录音、视频播放、拍照、视频录制](http://www.cnblogs.com/kenshincui/p/4186022.html)\n","source":"_posts/iOS多媒体学习笔记.md","raw":"---\ntitle: iOS多媒体学习笔记\ndate: 2017-05-06 11:41:05\ncategories: 笔记\ntags: [iOS,音频,视频,播放,录制]\ntoc: true\n---\n\n## 音频\n### 音效 AudioToolbox.framework\n限制：\n* 音频播放时间不能超过30s\n* 数据必须是PCM或者IMA4格式\n* 音频文件必须打包成.caf、.aif、.wav中的一种（注意这是官方文档的说法，实际测试发现一些.mp3也可以播放）\n<!--more-->\n\n### 音乐 AVAudioPlayer\nAVFoundation.framework中的AVAudioPlayer\nAVAudioPlayer可以看成一个播放器，它支持多种音频格式，而且能够进行进度、音量、播放速度等控制。\nAVAudioPlayer使用：\n* 初始化AVAudioPlayer对象，此时通常指定本地文件路径。\n* 设置播放器属性，例如重复次数、音量大小等。\n* 调用play方法播放。\n\n### MPMusicPlayerController\n\n### 音频会话 AVAudioSession\n支持后台播放：\n* 1.设置后台运行模式：在plist文件中添加Required background modes，并且设置item 0=App plays audio or streams audio/video using AirPlay（其实可以直接通过Xcode在Project Targets-Capabilities-Background Modes中设置）\n* 2.设置AVAudioSession的类型为AVAudioSessionCategoryPlayback并且调用setActive::方法启动会话。\n```\nAVAudioSession *audioSession=[AVAudioSession sharedInstance];\n[audioSession setCategory:AVAudioSessionCategoryPlayback error:nil];\n[audioSession setActive:YES error:nil];\n```\n\n* 3.为了能够让应用退到后台之后支持耳机控制，建议添加远程控制事件（这一步不是后台播放必须的）\n在iOS中每个应用都有一个音频会话，这个会话就通过AVAudioSession来表示。AVAudioSession同样存在于AVFoundation框架中，它是单例模式设计，通过sharedInstance进行访问。在使用Apple设备时大家会发现有些应用只要打开其他音频播放就会终止，而有些应用却可以和其他应用同时播放，在多种音频环境中如何去控制播放的方式就是通过音频会话来完成的。\n\n### 音频队列服务（Audio Queue Services）\n* AVAudioPlayer只能播放本地文件，并且是一次性加载所以音频数据，初始化AVAudioPlayer时指定的URL也只能是File URL而不能是HTTP URL。\n* AudioToolbox框架中的音频队列服务Audio Queue Services，支持网络流媒体播放。\n\n### FSAudioStream\n\n## 录音\n### AVAudioRecorder\nAVFoundation框架中的AVAudioRecorder类\ninfo.plist 添加 `NSMicrophoneUsageDescription`\n### 音频队列服务（Audio Queue Services）\n\n## 视频播放\n### MPMoviePlayerController\nMediaPlayer.framework种的MPMoviePlayerController类，它支持本地视频和网络视频播放，如果要在UI中展示视频需要将view属性添加到界面中。\n\n### MPMoviePlayerViewController\n默认全屏播放，开发者在开发的时候直接使用这个视图控制器。\n注意：由于MPMoviePlayerViewController的初始化方法做了大量工作（例如设置URL、自动播放、添加点击Done完成的监控等），所以当再次点击播放弹出新的模态窗口的时如果不销毁之前的MPMoviePlayerViewController，那么新的对象就无法完成初始化，这样也就不能再次进行播放。\n\n### AVPlayer\nAVPlayer存在于AVFoundation中，它更加接近于底层，所以灵活性也更强。\nAVPlayer本身并不能显示视频，而且它也不像MPMoviePlayerController有一个view属性。如果AVPlayer要显示必须创建一个播放器层AVPlayerLayer用于展示，播放器层继承于CALayer，有了AVPlayerLayer之添加到控制器视图的layer中即可。\n几个相关类：\n* AVAsset：主要用于获取多媒体信息，是一个抽象类，不能直接使用。\n* AVURLAsset：AVAsset的子类，可以根据一个URL路径创建一个包含媒体信息的AVURLAsset对象。\n* AVPlayerItem：一个媒体资源管理对象，管理者视频的一些基本信息和状态，一个AVPlayerItem对应着一个视频资源。\n\n## 视频截图\n### MPMoviePlayerController\n### AVAssetImageGenerator\nAVFundation框架中的AVAssetImageGenerator\n```\n/**\n*  截取指定时间的视频缩略图\n*\n*  @param timeBySecond 时间点\n*/\n-(void)thumbnailImageRequest:(CGFloat )timeBySecond{\n    //创建URL\n    NSURL *url=[self getNetworkUrl];\n    //根据url创建AVURLAsset\n    AVURLAsset *urlAsset=[AVURLAsset assetWithURL:url];\n    //根据AVURLAsset创建AVAssetImageGenerator\n    AVAssetImageGenerator *imageGenerator=[AVAssetImageGenerator assetImageGeneratorWithAsset:urlAsset];\n    /*截图\n    * requestTime:缩略图创建时间\n    * actualTime:缩略图实际生成的时间\n    */\n    NSError *error=nil;\n    CMTime time=CMTimeMakeWithSeconds(timeBySecond, 10);//CMTime是表示电影时间信息的结构体，第一个参数表示是视频第几秒，第二个参数表示每秒帧数.(如果要活的某一秒的第几帧可以使用CMTimeMake方法)\n    CMTime actualTime;\n    CGImageRef cgImage= [imageGenerator copyCGImageAtTime:time actualTime:&actualTime error:&error];\n    if(error){\n    NSLog(@\"截取视频缩略图时发生错误，错误信息：%@\",error.localizedDescription);\n    return;\n    }\n    CMTimeShow(actualTime);\n    UIImage *image=[UIImage imageWithCGImage:cgImage];//转化为UIImage\n    //保存到相册\n    UIImageWriteToSavedPhotosAlbum(image,nil, nil, nil);\n    CGImageRelease(cgImage);\n}\n```\n### 第三方\niOS上常用的视频编码、解码框架有：VLC、ffmpeg\n\n## 摄像头（拍照和视频录制）\n### UIImagePickerController\nUIImagePickerController继承于UINavigationController\n\n### AVFoundation（AVCaptureSession/AVCaptureDevice）\n灵活性强。\n\n![优缺点比较](http://o8cfktdb3.bkt.clouddn.com/media.png)\n\n参考原文：[iOS开发系列--音频播放、录音、视频播放、拍照、视频录制](http://www.cnblogs.com/kenshincui/p/4186022.html)\n","slug":"iOS多媒体学习笔记","published":1,"updated":"2017-07-14T03:57:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj53c1dwa0022h3jjfvf0lu4z","content":"<h2 id=\"音频\"><a href=\"#音频\" class=\"headerlink\" title=\"音频\"></a>音频</h2><h3 id=\"音效-AudioToolbox-framework\"><a href=\"#音效-AudioToolbox-framework\" class=\"headerlink\" title=\"音效 AudioToolbox.framework\"></a>音效 AudioToolbox.framework</h3><p>限制：</p>\n<ul>\n<li>音频播放时间不能超过30s</li>\n<li>数据必须是PCM或者IMA4格式</li>\n<li>音频文件必须打包成.caf、.aif、.wav中的一种（注意这是官方文档的说法，实际测试发现一些.mp3也可以播放）<a id=\"more\"></a>\n</li>\n</ul>\n<h3 id=\"音乐-AVAudioPlayer\"><a href=\"#音乐-AVAudioPlayer\" class=\"headerlink\" title=\"音乐 AVAudioPlayer\"></a>音乐 AVAudioPlayer</h3><p>AVFoundation.framework中的AVAudioPlayer<br>AVAudioPlayer可以看成一个播放器，它支持多种音频格式，而且能够进行进度、音量、播放速度等控制。<br>AVAudioPlayer使用：</p>\n<ul>\n<li>初始化AVAudioPlayer对象，此时通常指定本地文件路径。</li>\n<li>设置播放器属性，例如重复次数、音量大小等。</li>\n<li>调用play方法播放。</li>\n</ul>\n<h3 id=\"MPMusicPlayerController\"><a href=\"#MPMusicPlayerController\" class=\"headerlink\" title=\"MPMusicPlayerController\"></a>MPMusicPlayerController</h3><h3 id=\"音频会话-AVAudioSession\"><a href=\"#音频会话-AVAudioSession\" class=\"headerlink\" title=\"音频会话 AVAudioSession\"></a>音频会话 AVAudioSession</h3><p>支持后台播放：</p>\n<ul>\n<li>1.设置后台运行模式：在plist文件中添加Required background modes，并且设置item 0=App plays audio or streams audio/video using AirPlay（其实可以直接通过Xcode在Project Targets-Capabilities-Background Modes中设置）</li>\n<li><p>2.设置AVAudioSession的类型为AVAudioSessionCategoryPlayback并且调用setActive::方法启动会话。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">AVAudioSession *audioSession=[AVAudioSession sharedInstance];</div><div class=\"line\">[audioSession setCategory:AVAudioSessionCategoryPlayback error:nil];</div><div class=\"line\">[audioSession setActive:YES error:nil];</div></pre></td></tr></table></figure>\n</li>\n<li><p>3.为了能够让应用退到后台之后支持耳机控制，建议添加远程控制事件（这一步不是后台播放必须的）<br>在iOS中每个应用都有一个音频会话，这个会话就通过AVAudioSession来表示。AVAudioSession同样存在于AVFoundation框架中，它是单例模式设计，通过sharedInstance进行访问。在使用Apple设备时大家会发现有些应用只要打开其他音频播放就会终止，而有些应用却可以和其他应用同时播放，在多种音频环境中如何去控制播放的方式就是通过音频会话来完成的。</p>\n</li>\n</ul>\n<h3 id=\"音频队列服务（Audio-Queue-Services）\"><a href=\"#音频队列服务（Audio-Queue-Services）\" class=\"headerlink\" title=\"音频队列服务（Audio Queue Services）\"></a>音频队列服务（Audio Queue Services）</h3><ul>\n<li>AVAudioPlayer只能播放本地文件，并且是一次性加载所以音频数据，初始化AVAudioPlayer时指定的URL也只能是File URL而不能是HTTP URL。</li>\n<li>AudioToolbox框架中的音频队列服务Audio Queue Services，支持网络流媒体播放。</li>\n</ul>\n<h3 id=\"FSAudioStream\"><a href=\"#FSAudioStream\" class=\"headerlink\" title=\"FSAudioStream\"></a>FSAudioStream</h3><h2 id=\"录音\"><a href=\"#录音\" class=\"headerlink\" title=\"录音\"></a>录音</h2><h3 id=\"AVAudioRecorder\"><a href=\"#AVAudioRecorder\" class=\"headerlink\" title=\"AVAudioRecorder\"></a>AVAudioRecorder</h3><p>AVFoundation框架中的AVAudioRecorder类<br>info.plist 添加 <code>NSMicrophoneUsageDescription</code></p>\n<h3 id=\"音频队列服务（Audio-Queue-Services）-1\"><a href=\"#音频队列服务（Audio-Queue-Services）-1\" class=\"headerlink\" title=\"音频队列服务（Audio Queue Services）\"></a>音频队列服务（Audio Queue Services）</h3><h2 id=\"视频播放\"><a href=\"#视频播放\" class=\"headerlink\" title=\"视频播放\"></a>视频播放</h2><h3 id=\"MPMoviePlayerController\"><a href=\"#MPMoviePlayerController\" class=\"headerlink\" title=\"MPMoviePlayerController\"></a>MPMoviePlayerController</h3><p>MediaPlayer.framework种的MPMoviePlayerController类，它支持本地视频和网络视频播放，如果要在UI中展示视频需要将view属性添加到界面中。</p>\n<h3 id=\"MPMoviePlayerViewController\"><a href=\"#MPMoviePlayerViewController\" class=\"headerlink\" title=\"MPMoviePlayerViewController\"></a>MPMoviePlayerViewController</h3><p>默认全屏播放，开发者在开发的时候直接使用这个视图控制器。<br>注意：由于MPMoviePlayerViewController的初始化方法做了大量工作（例如设置URL、自动播放、添加点击Done完成的监控等），所以当再次点击播放弹出新的模态窗口的时如果不销毁之前的MPMoviePlayerViewController，那么新的对象就无法完成初始化，这样也就不能再次进行播放。</p>\n<h3 id=\"AVPlayer\"><a href=\"#AVPlayer\" class=\"headerlink\" title=\"AVPlayer\"></a>AVPlayer</h3><p>AVPlayer存在于AVFoundation中，它更加接近于底层，所以灵活性也更强。<br>AVPlayer本身并不能显示视频，而且它也不像MPMoviePlayerController有一个view属性。如果AVPlayer要显示必须创建一个播放器层AVPlayerLayer用于展示，播放器层继承于CALayer，有了AVPlayerLayer之添加到控制器视图的layer中即可。<br>几个相关类：</p>\n<ul>\n<li>AVAsset：主要用于获取多媒体信息，是一个抽象类，不能直接使用。</li>\n<li>AVURLAsset：AVAsset的子类，可以根据一个URL路径创建一个包含媒体信息的AVURLAsset对象。</li>\n<li>AVPlayerItem：一个媒体资源管理对象，管理者视频的一些基本信息和状态，一个AVPlayerItem对应着一个视频资源。</li>\n</ul>\n<h2 id=\"视频截图\"><a href=\"#视频截图\" class=\"headerlink\" title=\"视频截图\"></a>视频截图</h2><h3 id=\"MPMoviePlayerController-1\"><a href=\"#MPMoviePlayerController-1\" class=\"headerlink\" title=\"MPMoviePlayerController\"></a>MPMoviePlayerController</h3><h3 id=\"AVAssetImageGenerator\"><a href=\"#AVAssetImageGenerator\" class=\"headerlink\" title=\"AVAssetImageGenerator\"></a>AVAssetImageGenerator</h3><p>AVFundation框架中的AVAssetImageGenerator<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">*  截取指定时间的视频缩略图</div><div class=\"line\">*</div><div class=\"line\">*  @param timeBySecond 时间点</div><div class=\"line\">*/</div><div class=\"line\">-(void)thumbnailImageRequest:(CGFloat )timeBySecond&#123;</div><div class=\"line\">    //创建URL</div><div class=\"line\">    NSURL *url=[self getNetworkUrl];</div><div class=\"line\">    //根据url创建AVURLAsset</div><div class=\"line\">    AVURLAsset *urlAsset=[AVURLAsset assetWithURL:url];</div><div class=\"line\">    //根据AVURLAsset创建AVAssetImageGenerator</div><div class=\"line\">    AVAssetImageGenerator *imageGenerator=[AVAssetImageGenerator assetImageGeneratorWithAsset:urlAsset];</div><div class=\"line\">    /*截图</div><div class=\"line\">    * requestTime:缩略图创建时间</div><div class=\"line\">    * actualTime:缩略图实际生成的时间</div><div class=\"line\">    */</div><div class=\"line\">    NSError *error=nil;</div><div class=\"line\">    CMTime time=CMTimeMakeWithSeconds(timeBySecond, 10);//CMTime是表示电影时间信息的结构体，第一个参数表示是视频第几秒，第二个参数表示每秒帧数.(如果要活的某一秒的第几帧可以使用CMTimeMake方法)</div><div class=\"line\">    CMTime actualTime;</div><div class=\"line\">    CGImageRef cgImage= [imageGenerator copyCGImageAtTime:time actualTime:&amp;actualTime error:&amp;error];</div><div class=\"line\">    if(error)&#123;</div><div class=\"line\">    NSLog(@&quot;截取视频缩略图时发生错误，错误信息：%@&quot;,error.localizedDescription);</div><div class=\"line\">    return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    CMTimeShow(actualTime);</div><div class=\"line\">    UIImage *image=[UIImage imageWithCGImage:cgImage];//转化为UIImage</div><div class=\"line\">    //保存到相册</div><div class=\"line\">    UIImageWriteToSavedPhotosAlbum(image,nil, nil, nil);</div><div class=\"line\">    CGImageRelease(cgImage);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"第三方\"><a href=\"#第三方\" class=\"headerlink\" title=\"第三方\"></a>第三方</h3><p>iOS上常用的视频编码、解码框架有：VLC、ffmpeg</p>\n<h2 id=\"摄像头（拍照和视频录制）\"><a href=\"#摄像头（拍照和视频录制）\" class=\"headerlink\" title=\"摄像头（拍照和视频录制）\"></a>摄像头（拍照和视频录制）</h2><h3 id=\"UIImagePickerController\"><a href=\"#UIImagePickerController\" class=\"headerlink\" title=\"UIImagePickerController\"></a>UIImagePickerController</h3><p>UIImagePickerController继承于UINavigationController</p>\n<h3 id=\"AVFoundation（AVCaptureSession-AVCaptureDevice）\"><a href=\"#AVFoundation（AVCaptureSession-AVCaptureDevice）\" class=\"headerlink\" title=\"AVFoundation（AVCaptureSession/AVCaptureDevice）\"></a>AVFoundation（AVCaptureSession/AVCaptureDevice）</h3><p>灵活性强。</p>\n<p><img src=\"http://o8cfktdb3.bkt.clouddn.com/media.png\" alt=\"优缺点比较\"></p>\n<p>参考原文：<a href=\"http://www.cnblogs.com/kenshincui/p/4186022.html\" target=\"_blank\" rel=\"external\">iOS开发系列–音频播放、录音、视频播放、拍照、视频录制</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"音频\"><a href=\"#音频\" class=\"headerlink\" title=\"音频\"></a>音频</h2><h3 id=\"音效-AudioToolbox-framework\"><a href=\"#音效-AudioToolbox-framework\" class=\"headerlink\" title=\"音效 AudioToolbox.framework\"></a>音效 AudioToolbox.framework</h3><p>限制：</p>\n<ul>\n<li>音频播放时间不能超过30s</li>\n<li>数据必须是PCM或者IMA4格式</li>\n<li>音频文件必须打包成.caf、.aif、.wav中的一种（注意这是官方文档的说法，实际测试发现一些.mp3也可以播放）","more":"</li>\n</ul>\n<h3 id=\"音乐-AVAudioPlayer\"><a href=\"#音乐-AVAudioPlayer\" class=\"headerlink\" title=\"音乐 AVAudioPlayer\"></a>音乐 AVAudioPlayer</h3><p>AVFoundation.framework中的AVAudioPlayer<br>AVAudioPlayer可以看成一个播放器，它支持多种音频格式，而且能够进行进度、音量、播放速度等控制。<br>AVAudioPlayer使用：</p>\n<ul>\n<li>初始化AVAudioPlayer对象，此时通常指定本地文件路径。</li>\n<li>设置播放器属性，例如重复次数、音量大小等。</li>\n<li>调用play方法播放。</li>\n</ul>\n<h3 id=\"MPMusicPlayerController\"><a href=\"#MPMusicPlayerController\" class=\"headerlink\" title=\"MPMusicPlayerController\"></a>MPMusicPlayerController</h3><h3 id=\"音频会话-AVAudioSession\"><a href=\"#音频会话-AVAudioSession\" class=\"headerlink\" title=\"音频会话 AVAudioSession\"></a>音频会话 AVAudioSession</h3><p>支持后台播放：</p>\n<ul>\n<li>1.设置后台运行模式：在plist文件中添加Required background modes，并且设置item 0=App plays audio or streams audio/video using AirPlay（其实可以直接通过Xcode在Project Targets-Capabilities-Background Modes中设置）</li>\n<li><p>2.设置AVAudioSession的类型为AVAudioSessionCategoryPlayback并且调用setActive::方法启动会话。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">AVAudioSession *audioSession=[AVAudioSession sharedInstance];</div><div class=\"line\">[audioSession setCategory:AVAudioSessionCategoryPlayback error:nil];</div><div class=\"line\">[audioSession setActive:YES error:nil];</div></pre></td></tr></table></figure>\n</li>\n<li><p>3.为了能够让应用退到后台之后支持耳机控制，建议添加远程控制事件（这一步不是后台播放必须的）<br>在iOS中每个应用都有一个音频会话，这个会话就通过AVAudioSession来表示。AVAudioSession同样存在于AVFoundation框架中，它是单例模式设计，通过sharedInstance进行访问。在使用Apple设备时大家会发现有些应用只要打开其他音频播放就会终止，而有些应用却可以和其他应用同时播放，在多种音频环境中如何去控制播放的方式就是通过音频会话来完成的。</p>\n</li>\n</ul>\n<h3 id=\"音频队列服务（Audio-Queue-Services）\"><a href=\"#音频队列服务（Audio-Queue-Services）\" class=\"headerlink\" title=\"音频队列服务（Audio Queue Services）\"></a>音频队列服务（Audio Queue Services）</h3><ul>\n<li>AVAudioPlayer只能播放本地文件，并且是一次性加载所以音频数据，初始化AVAudioPlayer时指定的URL也只能是File URL而不能是HTTP URL。</li>\n<li>AudioToolbox框架中的音频队列服务Audio Queue Services，支持网络流媒体播放。</li>\n</ul>\n<h3 id=\"FSAudioStream\"><a href=\"#FSAudioStream\" class=\"headerlink\" title=\"FSAudioStream\"></a>FSAudioStream</h3><h2 id=\"录音\"><a href=\"#录音\" class=\"headerlink\" title=\"录音\"></a>录音</h2><h3 id=\"AVAudioRecorder\"><a href=\"#AVAudioRecorder\" class=\"headerlink\" title=\"AVAudioRecorder\"></a>AVAudioRecorder</h3><p>AVFoundation框架中的AVAudioRecorder类<br>info.plist 添加 <code>NSMicrophoneUsageDescription</code></p>\n<h3 id=\"音频队列服务（Audio-Queue-Services）-1\"><a href=\"#音频队列服务（Audio-Queue-Services）-1\" class=\"headerlink\" title=\"音频队列服务（Audio Queue Services）\"></a>音频队列服务（Audio Queue Services）</h3><h2 id=\"视频播放\"><a href=\"#视频播放\" class=\"headerlink\" title=\"视频播放\"></a>视频播放</h2><h3 id=\"MPMoviePlayerController\"><a href=\"#MPMoviePlayerController\" class=\"headerlink\" title=\"MPMoviePlayerController\"></a>MPMoviePlayerController</h3><p>MediaPlayer.framework种的MPMoviePlayerController类，它支持本地视频和网络视频播放，如果要在UI中展示视频需要将view属性添加到界面中。</p>\n<h3 id=\"MPMoviePlayerViewController\"><a href=\"#MPMoviePlayerViewController\" class=\"headerlink\" title=\"MPMoviePlayerViewController\"></a>MPMoviePlayerViewController</h3><p>默认全屏播放，开发者在开发的时候直接使用这个视图控制器。<br>注意：由于MPMoviePlayerViewController的初始化方法做了大量工作（例如设置URL、自动播放、添加点击Done完成的监控等），所以当再次点击播放弹出新的模态窗口的时如果不销毁之前的MPMoviePlayerViewController，那么新的对象就无法完成初始化，这样也就不能再次进行播放。</p>\n<h3 id=\"AVPlayer\"><a href=\"#AVPlayer\" class=\"headerlink\" title=\"AVPlayer\"></a>AVPlayer</h3><p>AVPlayer存在于AVFoundation中，它更加接近于底层，所以灵活性也更强。<br>AVPlayer本身并不能显示视频，而且它也不像MPMoviePlayerController有一个view属性。如果AVPlayer要显示必须创建一个播放器层AVPlayerLayer用于展示，播放器层继承于CALayer，有了AVPlayerLayer之添加到控制器视图的layer中即可。<br>几个相关类：</p>\n<ul>\n<li>AVAsset：主要用于获取多媒体信息，是一个抽象类，不能直接使用。</li>\n<li>AVURLAsset：AVAsset的子类，可以根据一个URL路径创建一个包含媒体信息的AVURLAsset对象。</li>\n<li>AVPlayerItem：一个媒体资源管理对象，管理者视频的一些基本信息和状态，一个AVPlayerItem对应着一个视频资源。</li>\n</ul>\n<h2 id=\"视频截图\"><a href=\"#视频截图\" class=\"headerlink\" title=\"视频截图\"></a>视频截图</h2><h3 id=\"MPMoviePlayerController-1\"><a href=\"#MPMoviePlayerController-1\" class=\"headerlink\" title=\"MPMoviePlayerController\"></a>MPMoviePlayerController</h3><h3 id=\"AVAssetImageGenerator\"><a href=\"#AVAssetImageGenerator\" class=\"headerlink\" title=\"AVAssetImageGenerator\"></a>AVAssetImageGenerator</h3><p>AVFundation框架中的AVAssetImageGenerator<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">*  截取指定时间的视频缩略图</div><div class=\"line\">*</div><div class=\"line\">*  @param timeBySecond 时间点</div><div class=\"line\">*/</div><div class=\"line\">-(void)thumbnailImageRequest:(CGFloat )timeBySecond&#123;</div><div class=\"line\">    //创建URL</div><div class=\"line\">    NSURL *url=[self getNetworkUrl];</div><div class=\"line\">    //根据url创建AVURLAsset</div><div class=\"line\">    AVURLAsset *urlAsset=[AVURLAsset assetWithURL:url];</div><div class=\"line\">    //根据AVURLAsset创建AVAssetImageGenerator</div><div class=\"line\">    AVAssetImageGenerator *imageGenerator=[AVAssetImageGenerator assetImageGeneratorWithAsset:urlAsset];</div><div class=\"line\">    /*截图</div><div class=\"line\">    * requestTime:缩略图创建时间</div><div class=\"line\">    * actualTime:缩略图实际生成的时间</div><div class=\"line\">    */</div><div class=\"line\">    NSError *error=nil;</div><div class=\"line\">    CMTime time=CMTimeMakeWithSeconds(timeBySecond, 10);//CMTime是表示电影时间信息的结构体，第一个参数表示是视频第几秒，第二个参数表示每秒帧数.(如果要活的某一秒的第几帧可以使用CMTimeMake方法)</div><div class=\"line\">    CMTime actualTime;</div><div class=\"line\">    CGImageRef cgImage= [imageGenerator copyCGImageAtTime:time actualTime:&amp;actualTime error:&amp;error];</div><div class=\"line\">    if(error)&#123;</div><div class=\"line\">    NSLog(@&quot;截取视频缩略图时发生错误，错误信息：%@&quot;,error.localizedDescription);</div><div class=\"line\">    return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    CMTimeShow(actualTime);</div><div class=\"line\">    UIImage *image=[UIImage imageWithCGImage:cgImage];//转化为UIImage</div><div class=\"line\">    //保存到相册</div><div class=\"line\">    UIImageWriteToSavedPhotosAlbum(image,nil, nil, nil);</div><div class=\"line\">    CGImageRelease(cgImage);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"第三方\"><a href=\"#第三方\" class=\"headerlink\" title=\"第三方\"></a>第三方</h3><p>iOS上常用的视频编码、解码框架有：VLC、ffmpeg</p>\n<h2 id=\"摄像头（拍照和视频录制）\"><a href=\"#摄像头（拍照和视频录制）\" class=\"headerlink\" title=\"摄像头（拍照和视频录制）\"></a>摄像头（拍照和视频录制）</h2><h3 id=\"UIImagePickerController\"><a href=\"#UIImagePickerController\" class=\"headerlink\" title=\"UIImagePickerController\"></a>UIImagePickerController</h3><p>UIImagePickerController继承于UINavigationController</p>\n<h3 id=\"AVFoundation（AVCaptureSession-AVCaptureDevice）\"><a href=\"#AVFoundation（AVCaptureSession-AVCaptureDevice）\" class=\"headerlink\" title=\"AVFoundation（AVCaptureSession/AVCaptureDevice）\"></a>AVFoundation（AVCaptureSession/AVCaptureDevice）</h3><p>灵活性强。</p>\n<p><img src=\"http://o8cfktdb3.bkt.clouddn.com/media.png\" alt=\"优缺点比较\"></p>\n<p>参考原文：<a href=\"http://www.cnblogs.com/kenshincui/p/4186022.html\" target=\"_blank\" rel=\"external\">iOS开发系列–音频播放、录音、视频播放、拍照、视频录制</a></p>"},{"title":"iOS多线程学习笔记","date":"2017-06-30T08:45:27.000Z","_content":"\n多线程的三种使用方式：NSThread，NSOperationQueue和NSOperation，GCD。\n一、NSThread\n1.创建线程的三种方式\n（1）创建、启动线程\n```\nNSThread* myThread = [[NSThread alloc] initWithTarget:self selector:@selector(doSomething:) object:nil];  \n//设置线程优先级、线程名称等信息\n[myThread start];\n```\n<!--more-->\n（2）创建线程后自动启动线程\n```\n[NSThread detachNewThreadSelector:@selector(doSomething:) toTarget:self withObject:nil];  \n```\n\n（3）隐式创建并启动线程\n```\n[self performSelectorInBackground:@selector(doSomething) withObject:nil];\n```\n注意：三种创建方式都只能传一个参数，如果需要传递多参数，可以封装一个对象将多个参数保存起来。\n\n2.回到主线程\n```\n[self performSelectorOnMainThread:@selector(updateUI:) withObject:image waitUntilDone:YES];  \n```\n\n获取主线程：[NSThread mainThread]\n3.线程间通讯\n使用performSelector: onThread: withObject: waitUntilDone: 方法\n4.线程同步\n加锁，三种方式：\n（1）NSLock\n注意：lock和unlock之间的”加锁代码“应该是抢占资源的读取和修改代码，不要将过多的其他操作代码放到里面，否则一个线程执行的时候另一个线程就一直在等待，就无法发挥多线程的作用了。\n```\ntheLock = [[NSLock alloc] init];  \n　　[theLock lock];\n　　//dosomething\n[theLock unlock];  \n```\n\n（2）NSCondition\n```\nticketsCondition = [[NSCondition alloc] init];  \n[ticketsCondition lock];  \n//dosomething\n[ticketsCondition unlock];  \n// [ticketsCondition signal]; 发送信号的方式，在一个线程唤醒另外一个线程的等待，即[ticketsCondition wait]。\n```\n\n（3）@synchronized：更简单，推荐\n```\n@synchronized(anObj)\n{\n// Everything between the braces is protected by the @synchronized directive.\n}\n```\n\n（4）iOS中的其他类型锁\nNSRecursiveLock ：递归锁，有时候“加锁代码”中存在递归调用，递归开始前加锁，递归调用开始后会重复执行此方法以至于反复执行加锁代码最终造成死锁，这个时候可以使用递归锁来解决。使用递归锁可以在一个线程中反复获取锁而不造成死锁，这个过程中会记录获取锁和释放锁的次数，只有最后两者平衡锁才被最终释放。\nNSDistributedLock：分布锁，它本身是一个互斥锁，基于文件方式实现锁机制，可以跨进程访问。\npthread_mutex_t：同步锁，基于C语言的同步锁机制，使用方法与其他同步锁机制类似。\n\n5.延迟执行\n（1）调用NSObject的方法:\n```\n[self performSelector:@selector(run) withObject:nil afterDelay:2.0];\n```\n\n（2）\n```\n[NSThread sleepForTimeInterval:2.0];\n[NSThread sleepUntilDate:(NSDate*)date]\n```\n\n(6)死亡：+ (void)exit()\n\n二、NSOperationQueue和NSOperation\n1.创建\nNSOperation的两个子类：NSInvocationOperation 和 NSBlockOperation。\n（1）NSInvocationOperation \n```\n/*创建一个调用操作\nobject:调用方法参数\n*/\nNSInvocationOperation *invocationOperation=[[NSInvocationOperation alloc]initWithTarget:self selector:@selector(loadImage) object:nil];\n//创建完NSInvocationOperation对象并不会调用，它由一个start方法启动操作，但是注意如果直接调用start方法，则此操作会在主线程中调用，一般不会这么操作,而是添加到NSOperationQueue中\n//    [invocationOperation start];\n\n//创建操作队列\nNSOperationQueue *operationQueue=[[NSOperationQueue alloc]init];\n//注意添加到操作队后，队列会开启一个线程执行此操作\n[operationQueue addOperation:invocationOperation];\n```\n\n（2）NSBlockOperation：相比NSInvocationOperation 更简单，推荐\n```\n//方法1：创建操作块添加到队列\n//        //创建多线程操作\n//        NSBlockOperation *blockOperation=[NSBlockOperation blockOperationWithBlock:^{\n//            [self loadImage:[NSNumber numberWithInt:i]];\n//        }];\n//        //创建操作队列\n//\n//        [operationQueue addOperation:blockOperation];\n\n//方法2：直接使用操队列添加操作\n[operationQueue addOperationWithBlock:^{\n[self loadImage:[NSNumber numberWithInt:i]];\n}];\n```\n\n（3）继承NSOperation\n在.m文件中实现main方法，main方法编写要执行的代码。\n\n2.设置并发数\n```\n[queue setMaxConcurrentOperationCount:5];\n```\n\n默认情况下是-1，-1表示没有限制，这样会同时运行队列中的全部的操作。\n\n3.线程执行顺序\n每个NSOperation可以设置依赖线程。假设操作A依赖于操作B，线程操作队列在启动线程时就会首先执行B操作，然后执行A。\n以下代码实现了优先加载最后一张图片：\n```\n-(void)loadImageWithMultiThread{\nint count=ROW_COUNT*COLUMN_COUNT;\n//创建操作队列\nNSOperationQueue *operationQueue=[[NSOperationQueue alloc]init];\noperationQueue.maxConcurrentOperationCount=5;//设置最大并发线程数\n\nNSBlockOperation *lastBlockOperation=[NSBlockOperation blockOperationWithBlock:^{\n    [self loadImage:[NSNumber numberWithInt:(count-1)]];\n}];\n//创建多个线程用于填充图片\nfor (int i=0; i<count-1; ++i) {\n//方法1：创建操作块添加到队列\n//创建多线程操作\nNSBlockOperation *blockOperation=[NSBlockOperation blockOperationWithBlock:^{\n[self loadImage:[NSNumber numberWithInt:i]];\n}];\n//设置依赖操作为最后一张图片加载操作\n[blockOperation addDependency:lastBlockOperation];\n[operationQueue addOperation:blockOperation];\n}\n//将最后一个图片的加载操作加入线程队列\n[operationQueue addOperation:lastBlockOperation];\n}\n```\n\n三、GCD\n1.dispatch queue\ndispatch queue分为下面三种：Serial，Concurrent，main，global\n（1）Serial\n又称为private dispatch queues，同时只执行一个任务。\n通常用于同步访问特定的资源或数据。当你创建多个Serial queue时，虽然它们各自是同步执行的，但Serial queue与Serial queue之间是并发执行的。\n（2）Concurrent\n可以并发地执行多个任务，但是执行完成的顺序是随机的。\n（3）Main dispatch queue\n主线程，它是全局可用的serial queue。\n```\ndispatch_queue_t mainQ = dispatch_get_main_queue();    \n```\n\n（4）global dispatch queue\n系统给每一个应用程序提供了三个concurrent dispatch queues。这三个并发调度队列是全局的，它们只有优先级的不同。\n因为是全局的，我们不需要去创建。我们只需要通过使用函数dispath_get_global_queue去得到队列。\n```\ndispatch_queue_t globalQ = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); \n```\n\n2.dispatch_group_async\n可以实现监听一组任务是否完成，完成后得到通知执行其他的操作\n```\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);  \ndispatch_group_t group = dispatch_group_create();  \ndispatch_group_async(group, queue, ^{  \n    [NSThread sleepForTimeInterval:1];  \n    NSLog(@\"group1\");  \n});  \ndispatch_group_async(group, queue, ^{  \n    [NSThread sleepForTimeInterval:2];  \n    NSLog(@\"group2\");  \n});  \ndispatch_group_async(group, queue, ^{  \n    [NSThread sleepForTimeInterval:3];  \n    NSLog(@\"group3\");  \n});  \ndispatch_group_notify(group, dispatch_get_main_queue(), ^{  \n    NSLog(@\"updateUi\");  \n});  \n```\n\n3.dispatch_barrier_async\n在前面的任务执行结束后它才执行，而且它后面的任务等它执行完成之后才会执行\n```\ndispatch_queue_t queue = dispatch_queue_create(\"gcdtest.rongfzh.yc\", DISPATCH_QUEUE_CONCURRENT);  \ndispatch_async(queue, ^{  \n    [NSThread sleepForTimeInterval:2];  \n    NSLog(@\"dispatch_async1\");  \n});  \ndispatch_async(queue, ^{  \n    [NSThread sleepForTimeInterval:4];  \n    NSLog(@\"dispatch_async2\");  \n});  \ndispatch_barrier_async(queue, ^{  \n    NSLog(@\"dispatch_barrier_async\");  \n    [NSThread sleepForTimeInterval:4];  \n\n});  \ndispatch_async(queue, ^{  \n    [NSThread sleepForTimeInterval:1];  \n    NSLog(@\"dispatch_async3\");  \n});  \n```\n\n4.dispatch_apply \n执行某个代码片段N次。\n注意：这个方法没有办法异步执行（为了不阻塞线程可以使用dispatch_async()包装一下再执行）\n```\ndispatch_apply(5, globalQ, ^(size_t index) {\n// 执行5次\n});\n```\n\n5.dispatch_time()： 延迟一定的时间后执行。\n```\ndispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 3*NSEC_PER_SEC);\ndispatch_after(time, dispatch_get_main_queue(), ^{\nNSLog(@\"3秒后添加到队列\");\n});\n　dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n\n// 2秒后异步执行这里的代码...\n\n　});\n```\n\n6.一次性代码\n```\nstatic dispatch_once_t onceToken;\ndispatch_once(&onceToken, ^{\n// 只执行1次的代码(这里面默认是线程安全的)\n});\n```\n\n7.dispatch_suspend(myQueue)： 挂起队列\n8.dispatch_resume(myQueue)：恢复队列\n\n注意：调用dispatch_suspend会增加队列挂起的引用计数，而调用dispatch_resume则会减少引用计数，当引用计数大于0时，队列会保持挂起状态。因此，这队列的挂起和恢复中，我们需要小心使用以避免引用计数计算错误的出现。\n参考链接：[荣芳志专栏中的文章](http://blog.csdn.net/totogo2010/article/details/8010231)\n　　　　　[iOS开发系列--并行开发其实很容易](http://www.cnblogs.com/kenshincui/p/3983982.html)\n\n","source":"_posts/iOS多线程学习笔记.md","raw":"---\ntitle: iOS多线程学习笔记\ndate: 2017-06-30 16:45:27\ncategories: 笔记\ntags: [iOS,多线程]\n---\n\n多线程的三种使用方式：NSThread，NSOperationQueue和NSOperation，GCD。\n一、NSThread\n1.创建线程的三种方式\n（1）创建、启动线程\n```\nNSThread* myThread = [[NSThread alloc] initWithTarget:self selector:@selector(doSomething:) object:nil];  \n//设置线程优先级、线程名称等信息\n[myThread start];\n```\n<!--more-->\n（2）创建线程后自动启动线程\n```\n[NSThread detachNewThreadSelector:@selector(doSomething:) toTarget:self withObject:nil];  \n```\n\n（3）隐式创建并启动线程\n```\n[self performSelectorInBackground:@selector(doSomething) withObject:nil];\n```\n注意：三种创建方式都只能传一个参数，如果需要传递多参数，可以封装一个对象将多个参数保存起来。\n\n2.回到主线程\n```\n[self performSelectorOnMainThread:@selector(updateUI:) withObject:image waitUntilDone:YES];  \n```\n\n获取主线程：[NSThread mainThread]\n3.线程间通讯\n使用performSelector: onThread: withObject: waitUntilDone: 方法\n4.线程同步\n加锁，三种方式：\n（1）NSLock\n注意：lock和unlock之间的”加锁代码“应该是抢占资源的读取和修改代码，不要将过多的其他操作代码放到里面，否则一个线程执行的时候另一个线程就一直在等待，就无法发挥多线程的作用了。\n```\ntheLock = [[NSLock alloc] init];  \n　　[theLock lock];\n　　//dosomething\n[theLock unlock];  \n```\n\n（2）NSCondition\n```\nticketsCondition = [[NSCondition alloc] init];  \n[ticketsCondition lock];  \n//dosomething\n[ticketsCondition unlock];  \n// [ticketsCondition signal]; 发送信号的方式，在一个线程唤醒另外一个线程的等待，即[ticketsCondition wait]。\n```\n\n（3）@synchronized：更简单，推荐\n```\n@synchronized(anObj)\n{\n// Everything between the braces is protected by the @synchronized directive.\n}\n```\n\n（4）iOS中的其他类型锁\nNSRecursiveLock ：递归锁，有时候“加锁代码”中存在递归调用，递归开始前加锁，递归调用开始后会重复执行此方法以至于反复执行加锁代码最终造成死锁，这个时候可以使用递归锁来解决。使用递归锁可以在一个线程中反复获取锁而不造成死锁，这个过程中会记录获取锁和释放锁的次数，只有最后两者平衡锁才被最终释放。\nNSDistributedLock：分布锁，它本身是一个互斥锁，基于文件方式实现锁机制，可以跨进程访问。\npthread_mutex_t：同步锁，基于C语言的同步锁机制，使用方法与其他同步锁机制类似。\n\n5.延迟执行\n（1）调用NSObject的方法:\n```\n[self performSelector:@selector(run) withObject:nil afterDelay:2.0];\n```\n\n（2）\n```\n[NSThread sleepForTimeInterval:2.0];\n[NSThread sleepUntilDate:(NSDate*)date]\n```\n\n(6)死亡：+ (void)exit()\n\n二、NSOperationQueue和NSOperation\n1.创建\nNSOperation的两个子类：NSInvocationOperation 和 NSBlockOperation。\n（1）NSInvocationOperation \n```\n/*创建一个调用操作\nobject:调用方法参数\n*/\nNSInvocationOperation *invocationOperation=[[NSInvocationOperation alloc]initWithTarget:self selector:@selector(loadImage) object:nil];\n//创建完NSInvocationOperation对象并不会调用，它由一个start方法启动操作，但是注意如果直接调用start方法，则此操作会在主线程中调用，一般不会这么操作,而是添加到NSOperationQueue中\n//    [invocationOperation start];\n\n//创建操作队列\nNSOperationQueue *operationQueue=[[NSOperationQueue alloc]init];\n//注意添加到操作队后，队列会开启一个线程执行此操作\n[operationQueue addOperation:invocationOperation];\n```\n\n（2）NSBlockOperation：相比NSInvocationOperation 更简单，推荐\n```\n//方法1：创建操作块添加到队列\n//        //创建多线程操作\n//        NSBlockOperation *blockOperation=[NSBlockOperation blockOperationWithBlock:^{\n//            [self loadImage:[NSNumber numberWithInt:i]];\n//        }];\n//        //创建操作队列\n//\n//        [operationQueue addOperation:blockOperation];\n\n//方法2：直接使用操队列添加操作\n[operationQueue addOperationWithBlock:^{\n[self loadImage:[NSNumber numberWithInt:i]];\n}];\n```\n\n（3）继承NSOperation\n在.m文件中实现main方法，main方法编写要执行的代码。\n\n2.设置并发数\n```\n[queue setMaxConcurrentOperationCount:5];\n```\n\n默认情况下是-1，-1表示没有限制，这样会同时运行队列中的全部的操作。\n\n3.线程执行顺序\n每个NSOperation可以设置依赖线程。假设操作A依赖于操作B，线程操作队列在启动线程时就会首先执行B操作，然后执行A。\n以下代码实现了优先加载最后一张图片：\n```\n-(void)loadImageWithMultiThread{\nint count=ROW_COUNT*COLUMN_COUNT;\n//创建操作队列\nNSOperationQueue *operationQueue=[[NSOperationQueue alloc]init];\noperationQueue.maxConcurrentOperationCount=5;//设置最大并发线程数\n\nNSBlockOperation *lastBlockOperation=[NSBlockOperation blockOperationWithBlock:^{\n    [self loadImage:[NSNumber numberWithInt:(count-1)]];\n}];\n//创建多个线程用于填充图片\nfor (int i=0; i<count-1; ++i) {\n//方法1：创建操作块添加到队列\n//创建多线程操作\nNSBlockOperation *blockOperation=[NSBlockOperation blockOperationWithBlock:^{\n[self loadImage:[NSNumber numberWithInt:i]];\n}];\n//设置依赖操作为最后一张图片加载操作\n[blockOperation addDependency:lastBlockOperation];\n[operationQueue addOperation:blockOperation];\n}\n//将最后一个图片的加载操作加入线程队列\n[operationQueue addOperation:lastBlockOperation];\n}\n```\n\n三、GCD\n1.dispatch queue\ndispatch queue分为下面三种：Serial，Concurrent，main，global\n（1）Serial\n又称为private dispatch queues，同时只执行一个任务。\n通常用于同步访问特定的资源或数据。当你创建多个Serial queue时，虽然它们各自是同步执行的，但Serial queue与Serial queue之间是并发执行的。\n（2）Concurrent\n可以并发地执行多个任务，但是执行完成的顺序是随机的。\n（3）Main dispatch queue\n主线程，它是全局可用的serial queue。\n```\ndispatch_queue_t mainQ = dispatch_get_main_queue();    \n```\n\n（4）global dispatch queue\n系统给每一个应用程序提供了三个concurrent dispatch queues。这三个并发调度队列是全局的，它们只有优先级的不同。\n因为是全局的，我们不需要去创建。我们只需要通过使用函数dispath_get_global_queue去得到队列。\n```\ndispatch_queue_t globalQ = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); \n```\n\n2.dispatch_group_async\n可以实现监听一组任务是否完成，完成后得到通知执行其他的操作\n```\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);  \ndispatch_group_t group = dispatch_group_create();  \ndispatch_group_async(group, queue, ^{  \n    [NSThread sleepForTimeInterval:1];  \n    NSLog(@\"group1\");  \n});  \ndispatch_group_async(group, queue, ^{  \n    [NSThread sleepForTimeInterval:2];  \n    NSLog(@\"group2\");  \n});  \ndispatch_group_async(group, queue, ^{  \n    [NSThread sleepForTimeInterval:3];  \n    NSLog(@\"group3\");  \n});  \ndispatch_group_notify(group, dispatch_get_main_queue(), ^{  \n    NSLog(@\"updateUi\");  \n});  \n```\n\n3.dispatch_barrier_async\n在前面的任务执行结束后它才执行，而且它后面的任务等它执行完成之后才会执行\n```\ndispatch_queue_t queue = dispatch_queue_create(\"gcdtest.rongfzh.yc\", DISPATCH_QUEUE_CONCURRENT);  \ndispatch_async(queue, ^{  \n    [NSThread sleepForTimeInterval:2];  \n    NSLog(@\"dispatch_async1\");  \n});  \ndispatch_async(queue, ^{  \n    [NSThread sleepForTimeInterval:4];  \n    NSLog(@\"dispatch_async2\");  \n});  \ndispatch_barrier_async(queue, ^{  \n    NSLog(@\"dispatch_barrier_async\");  \n    [NSThread sleepForTimeInterval:4];  \n\n});  \ndispatch_async(queue, ^{  \n    [NSThread sleepForTimeInterval:1];  \n    NSLog(@\"dispatch_async3\");  \n});  \n```\n\n4.dispatch_apply \n执行某个代码片段N次。\n注意：这个方法没有办法异步执行（为了不阻塞线程可以使用dispatch_async()包装一下再执行）\n```\ndispatch_apply(5, globalQ, ^(size_t index) {\n// 执行5次\n});\n```\n\n5.dispatch_time()： 延迟一定的时间后执行。\n```\ndispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 3*NSEC_PER_SEC);\ndispatch_after(time, dispatch_get_main_queue(), ^{\nNSLog(@\"3秒后添加到队列\");\n});\n　dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n\n// 2秒后异步执行这里的代码...\n\n　});\n```\n\n6.一次性代码\n```\nstatic dispatch_once_t onceToken;\ndispatch_once(&onceToken, ^{\n// 只执行1次的代码(这里面默认是线程安全的)\n});\n```\n\n7.dispatch_suspend(myQueue)： 挂起队列\n8.dispatch_resume(myQueue)：恢复队列\n\n注意：调用dispatch_suspend会增加队列挂起的引用计数，而调用dispatch_resume则会减少引用计数，当引用计数大于0时，队列会保持挂起状态。因此，这队列的挂起和恢复中，我们需要小心使用以避免引用计数计算错误的出现。\n参考链接：[荣芳志专栏中的文章](http://blog.csdn.net/totogo2010/article/details/8010231)\n　　　　　[iOS开发系列--并行开发其实很容易](http://www.cnblogs.com/kenshincui/p/3983982.html)\n\n","slug":"iOS多线程学习笔记","published":1,"updated":"2017-07-14T03:57:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj53c1dwc0026h3jjg1ra45l3","content":"<p>多线程的三种使用方式：NSThread，NSOperationQueue和NSOperation，GCD。<br>一、NSThread<br>1.创建线程的三种方式<br>（1）创建、启动线程<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSThread* myThread = [[NSThread alloc] initWithTarget:self selector:@selector(doSomething:) object:nil];  </div><div class=\"line\">//设置线程优先级、线程名称等信息</div><div class=\"line\">[myThread start];</div></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>（2）创建线程后自动启动线程<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[NSThread detachNewThreadSelector:@selector(doSomething:) toTarget:self withObject:nil];</div></pre></td></tr></table></figure></p>\n<p>（3）隐式创建并启动线程<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[self performSelectorInBackground:@selector(doSomething) withObject:nil];</div></pre></td></tr></table></figure></p>\n<p>注意：三种创建方式都只能传一个参数，如果需要传递多参数，可以封装一个对象将多个参数保存起来。</p>\n<p>2.回到主线程<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[self performSelectorOnMainThread:@selector(updateUI:) withObject:image waitUntilDone:YES];</div></pre></td></tr></table></figure></p>\n<p>获取主线程：[NSThread mainThread]<br>3.线程间通讯<br>使用performSelector: onThread: withObject: waitUntilDone: 方法<br>4.线程同步<br>加锁，三种方式：<br>（1）NSLock<br>注意：lock和unlock之间的”加锁代码“应该是抢占资源的读取和修改代码，不要将过多的其他操作代码放到里面，否则一个线程执行的时候另一个线程就一直在等待，就无法发挥多线程的作用了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">theLock = [[NSLock alloc] init];  </div><div class=\"line\">　　[theLock lock];</div><div class=\"line\">　　//dosomething</div><div class=\"line\">[theLock unlock];</div></pre></td></tr></table></figure></p>\n<p>（2）NSCondition<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ticketsCondition = [[NSCondition alloc] init];  </div><div class=\"line\">[ticketsCondition lock];  </div><div class=\"line\">//dosomething</div><div class=\"line\">[ticketsCondition unlock];  </div><div class=\"line\">// [ticketsCondition signal]; 发送信号的方式，在一个线程唤醒另外一个线程的等待，即[ticketsCondition wait]。</div></pre></td></tr></table></figure></p>\n<p>（3）@synchronized：更简单，推荐<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">@synchronized(anObj)</div><div class=\"line\">&#123;</div><div class=\"line\">// Everything between the braces is protected by the @synchronized directive.</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>（4）iOS中的其他类型锁<br>NSRecursiveLock ：递归锁，有时候“加锁代码”中存在递归调用，递归开始前加锁，递归调用开始后会重复执行此方法以至于反复执行加锁代码最终造成死锁，这个时候可以使用递归锁来解决。使用递归锁可以在一个线程中反复获取锁而不造成死锁，这个过程中会记录获取锁和释放锁的次数，只有最后两者平衡锁才被最终释放。<br>NSDistributedLock：分布锁，它本身是一个互斥锁，基于文件方式实现锁机制，可以跨进程访问。<br>pthread_mutex_t：同步锁，基于C语言的同步锁机制，使用方法与其他同步锁机制类似。</p>\n<p>5.延迟执行<br>（1）调用NSObject的方法:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[self performSelector:@selector(run) withObject:nil afterDelay:2.0];</div></pre></td></tr></table></figure></p>\n<p>（2）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[NSThread sleepForTimeInterval:2.0];</div><div class=\"line\">[NSThread sleepUntilDate:(NSDate*)date]</div></pre></td></tr></table></figure></p>\n<p>(6)死亡：+ (void)exit()</p>\n<p>二、NSOperationQueue和NSOperation<br>1.创建<br>NSOperation的两个子类：NSInvocationOperation 和 NSBlockOperation。<br>（1）NSInvocationOperation<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*创建一个调用操作</div><div class=\"line\">object:调用方法参数</div><div class=\"line\">*/</div><div class=\"line\">NSInvocationOperation *invocationOperation=[[NSInvocationOperation alloc]initWithTarget:self selector:@selector(loadImage) object:nil];</div><div class=\"line\">//创建完NSInvocationOperation对象并不会调用，它由一个start方法启动操作，但是注意如果直接调用start方法，则此操作会在主线程中调用，一般不会这么操作,而是添加到NSOperationQueue中</div><div class=\"line\">//    [invocationOperation start];</div><div class=\"line\"></div><div class=\"line\">//创建操作队列</div><div class=\"line\">NSOperationQueue *operationQueue=[[NSOperationQueue alloc]init];</div><div class=\"line\">//注意添加到操作队后，队列会开启一个线程执行此操作</div><div class=\"line\">[operationQueue addOperation:invocationOperation];</div></pre></td></tr></table></figure></p>\n<p>（2）NSBlockOperation：相比NSInvocationOperation 更简单，推荐<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">//方法1：创建操作块添加到队列</div><div class=\"line\">//        //创建多线程操作</div><div class=\"line\">//        NSBlockOperation *blockOperation=[NSBlockOperation blockOperationWithBlock:^&#123;</div><div class=\"line\">//            [self loadImage:[NSNumber numberWithInt:i]];</div><div class=\"line\">//        &#125;];</div><div class=\"line\">//        //创建操作队列</div><div class=\"line\">//</div><div class=\"line\">//        [operationQueue addOperation:blockOperation];</div><div class=\"line\"></div><div class=\"line\">//方法2：直接使用操队列添加操作</div><div class=\"line\">[operationQueue addOperationWithBlock:^&#123;</div><div class=\"line\">[self loadImage:[NSNumber numberWithInt:i]];</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<p>（3）继承NSOperation<br>在.m文件中实现main方法，main方法编写要执行的代码。</p>\n<p>2.设置并发数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[queue setMaxConcurrentOperationCount:5];</div></pre></td></tr></table></figure></p>\n<p>默认情况下是-1，-1表示没有限制，这样会同时运行队列中的全部的操作。</p>\n<p>3.线程执行顺序<br>每个NSOperation可以设置依赖线程。假设操作A依赖于操作B，线程操作队列在启动线程时就会首先执行B操作，然后执行A。<br>以下代码实现了优先加载最后一张图片：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)loadImageWithMultiThread&#123;</div><div class=\"line\">int count=ROW_COUNT*COLUMN_COUNT;</div><div class=\"line\">//创建操作队列</div><div class=\"line\">NSOperationQueue *operationQueue=[[NSOperationQueue alloc]init];</div><div class=\"line\">operationQueue.maxConcurrentOperationCount=5;//设置最大并发线程数</div><div class=\"line\"></div><div class=\"line\">NSBlockOperation *lastBlockOperation=[NSBlockOperation blockOperationWithBlock:^&#123;</div><div class=\"line\">    [self loadImage:[NSNumber numberWithInt:(count-1)]];</div><div class=\"line\">&#125;];</div><div class=\"line\">//创建多个线程用于填充图片</div><div class=\"line\">for (int i=0; i&lt;count-1; ++i) &#123;</div><div class=\"line\">//方法1：创建操作块添加到队列</div><div class=\"line\">//创建多线程操作</div><div class=\"line\">NSBlockOperation *blockOperation=[NSBlockOperation blockOperationWithBlock:^&#123;</div><div class=\"line\">[self loadImage:[NSNumber numberWithInt:i]];</div><div class=\"line\">&#125;];</div><div class=\"line\">//设置依赖操作为最后一张图片加载操作</div><div class=\"line\">[blockOperation addDependency:lastBlockOperation];</div><div class=\"line\">[operationQueue addOperation:blockOperation];</div><div class=\"line\">&#125;</div><div class=\"line\">//将最后一个图片的加载操作加入线程队列</div><div class=\"line\">[operationQueue addOperation:lastBlockOperation];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>三、GCD<br>1.dispatch queue<br>dispatch queue分为下面三种：Serial，Concurrent，main，global<br>（1）Serial<br>又称为private dispatch queues，同时只执行一个任务。<br>通常用于同步访问特定的资源或数据。当你创建多个Serial queue时，虽然它们各自是同步执行的，但Serial queue与Serial queue之间是并发执行的。<br>（2）Concurrent<br>可以并发地执行多个任务，但是执行完成的顺序是随机的。<br>（3）Main dispatch queue<br>主线程，它是全局可用的serial queue。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_queue_t mainQ = dispatch_get_main_queue();</div></pre></td></tr></table></figure></p>\n<p>（4）global dispatch queue<br>系统给每一个应用程序提供了三个concurrent dispatch queues。这三个并发调度队列是全局的，它们只有优先级的不同。<br>因为是全局的，我们不需要去创建。我们只需要通过使用函数dispath_get_global_queue去得到队列。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_queue_t globalQ = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div></pre></td></tr></table></figure></p>\n<p>2.dispatch_group_async<br>可以实现监听一组任务是否完成，完成后得到通知执行其他的操作<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);  </div><div class=\"line\">dispatch_group_t group = dispatch_group_create();  </div><div class=\"line\">dispatch_group_async(group, queue, ^&#123;  </div><div class=\"line\">    [NSThread sleepForTimeInterval:1];  </div><div class=\"line\">    NSLog(@&quot;group1&quot;);  </div><div class=\"line\">&#125;);  </div><div class=\"line\">dispatch_group_async(group, queue, ^&#123;  </div><div class=\"line\">    [NSThread sleepForTimeInterval:2];  </div><div class=\"line\">    NSLog(@&quot;group2&quot;);  </div><div class=\"line\">&#125;);  </div><div class=\"line\">dispatch_group_async(group, queue, ^&#123;  </div><div class=\"line\">    [NSThread sleepForTimeInterval:3];  </div><div class=\"line\">    NSLog(@&quot;group3&quot;);  </div><div class=\"line\">&#125;);  </div><div class=\"line\">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;  </div><div class=\"line\">    NSLog(@&quot;updateUi&quot;);  </div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>3.dispatch_barrier_async<br>在前面的任务执行结束后它才执行，而且它后面的任务等它执行完成之后才会执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;gcdtest.rongfzh.yc&quot;, DISPATCH_QUEUE_CONCURRENT);  </div><div class=\"line\">dispatch_async(queue, ^&#123;  </div><div class=\"line\">    [NSThread sleepForTimeInterval:2];  </div><div class=\"line\">    NSLog(@&quot;dispatch_async1&quot;);  </div><div class=\"line\">&#125;);  </div><div class=\"line\">dispatch_async(queue, ^&#123;  </div><div class=\"line\">    [NSThread sleepForTimeInterval:4];  </div><div class=\"line\">    NSLog(@&quot;dispatch_async2&quot;);  </div><div class=\"line\">&#125;);  </div><div class=\"line\">dispatch_barrier_async(queue, ^&#123;  </div><div class=\"line\">    NSLog(@&quot;dispatch_barrier_async&quot;);  </div><div class=\"line\">    [NSThread sleepForTimeInterval:4];  </div><div class=\"line\"></div><div class=\"line\">&#125;);  </div><div class=\"line\">dispatch_async(queue, ^&#123;  </div><div class=\"line\">    [NSThread sleepForTimeInterval:1];  </div><div class=\"line\">    NSLog(@&quot;dispatch_async3&quot;);  </div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>4.dispatch_apply<br>执行某个代码片段N次。<br>注意：这个方法没有办法异步执行（为了不阻塞线程可以使用dispatch_async()包装一下再执行）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_apply(5, globalQ, ^(size_t index) &#123;</div><div class=\"line\">// 执行5次</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>5.dispatch_time()： 延迟一定的时间后执行。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 3*NSEC_PER_SEC);</div><div class=\"line\">dispatch_after(time, dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">NSLog(@&quot;3秒后添加到队列&quot;);</div><div class=\"line\">&#125;);</div><div class=\"line\">　dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\"></div><div class=\"line\">// 2秒后异步执行这里的代码...</div><div class=\"line\"></div><div class=\"line\">　&#125;);</div></pre></td></tr></table></figure></p>\n<p>6.一次性代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">static dispatch_once_t onceToken;</div><div class=\"line\">dispatch_once(&amp;onceToken, ^&#123;</div><div class=\"line\">// 只执行1次的代码(这里面默认是线程安全的)</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>7.dispatch_suspend(myQueue)： 挂起队列<br>8.dispatch_resume(myQueue)：恢复队列</p>\n<p>注意：调用dispatch_suspend会增加队列挂起的引用计数，而调用dispatch_resume则会减少引用计数，当引用计数大于0时，队列会保持挂起状态。因此，这队列的挂起和恢复中，我们需要小心使用以避免引用计数计算错误的出现。<br>参考链接：<a href=\"http://blog.csdn.net/totogo2010/article/details/8010231\" target=\"_blank\" rel=\"external\">荣芳志专栏中的文章</a><br>　　　　　<a href=\"http://www.cnblogs.com/kenshincui/p/3983982.html\" target=\"_blank\" rel=\"external\">iOS开发系列–并行开发其实很容易</a></p>\n","site":{"data":{}},"excerpt":"<p>多线程的三种使用方式：NSThread，NSOperationQueue和NSOperation，GCD。<br>一、NSThread<br>1.创建线程的三种方式<br>（1）创建、启动线程<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSThread* myThread = [[NSThread alloc] initWithTarget:self selector:@selector(doSomething:) object:nil];  </div><div class=\"line\">//设置线程优先级、线程名称等信息</div><div class=\"line\">[myThread start];</div></pre></td></tr></table></figure></p>","more":"<p>（2）创建线程后自动启动线程<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[NSThread detachNewThreadSelector:@selector(doSomething:) toTarget:self withObject:nil];</div></pre></td></tr></table></figure></p>\n<p>（3）隐式创建并启动线程<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[self performSelectorInBackground:@selector(doSomething) withObject:nil];</div></pre></td></tr></table></figure></p>\n<p>注意：三种创建方式都只能传一个参数，如果需要传递多参数，可以封装一个对象将多个参数保存起来。</p>\n<p>2.回到主线程<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[self performSelectorOnMainThread:@selector(updateUI:) withObject:image waitUntilDone:YES];</div></pre></td></tr></table></figure></p>\n<p>获取主线程：[NSThread mainThread]<br>3.线程间通讯<br>使用performSelector: onThread: withObject: waitUntilDone: 方法<br>4.线程同步<br>加锁，三种方式：<br>（1）NSLock<br>注意：lock和unlock之间的”加锁代码“应该是抢占资源的读取和修改代码，不要将过多的其他操作代码放到里面，否则一个线程执行的时候另一个线程就一直在等待，就无法发挥多线程的作用了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">theLock = [[NSLock alloc] init];  </div><div class=\"line\">　　[theLock lock];</div><div class=\"line\">　　//dosomething</div><div class=\"line\">[theLock unlock];</div></pre></td></tr></table></figure></p>\n<p>（2）NSCondition<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ticketsCondition = [[NSCondition alloc] init];  </div><div class=\"line\">[ticketsCondition lock];  </div><div class=\"line\">//dosomething</div><div class=\"line\">[ticketsCondition unlock];  </div><div class=\"line\">// [ticketsCondition signal]; 发送信号的方式，在一个线程唤醒另外一个线程的等待，即[ticketsCondition wait]。</div></pre></td></tr></table></figure></p>\n<p>（3）@synchronized：更简单，推荐<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">@synchronized(anObj)</div><div class=\"line\">&#123;</div><div class=\"line\">// Everything between the braces is protected by the @synchronized directive.</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>（4）iOS中的其他类型锁<br>NSRecursiveLock ：递归锁，有时候“加锁代码”中存在递归调用，递归开始前加锁，递归调用开始后会重复执行此方法以至于反复执行加锁代码最终造成死锁，这个时候可以使用递归锁来解决。使用递归锁可以在一个线程中反复获取锁而不造成死锁，这个过程中会记录获取锁和释放锁的次数，只有最后两者平衡锁才被最终释放。<br>NSDistributedLock：分布锁，它本身是一个互斥锁，基于文件方式实现锁机制，可以跨进程访问。<br>pthread_mutex_t：同步锁，基于C语言的同步锁机制，使用方法与其他同步锁机制类似。</p>\n<p>5.延迟执行<br>（1）调用NSObject的方法:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[self performSelector:@selector(run) withObject:nil afterDelay:2.0];</div></pre></td></tr></table></figure></p>\n<p>（2）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[NSThread sleepForTimeInterval:2.0];</div><div class=\"line\">[NSThread sleepUntilDate:(NSDate*)date]</div></pre></td></tr></table></figure></p>\n<p>(6)死亡：+ (void)exit()</p>\n<p>二、NSOperationQueue和NSOperation<br>1.创建<br>NSOperation的两个子类：NSInvocationOperation 和 NSBlockOperation。<br>（1）NSInvocationOperation<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*创建一个调用操作</div><div class=\"line\">object:调用方法参数</div><div class=\"line\">*/</div><div class=\"line\">NSInvocationOperation *invocationOperation=[[NSInvocationOperation alloc]initWithTarget:self selector:@selector(loadImage) object:nil];</div><div class=\"line\">//创建完NSInvocationOperation对象并不会调用，它由一个start方法启动操作，但是注意如果直接调用start方法，则此操作会在主线程中调用，一般不会这么操作,而是添加到NSOperationQueue中</div><div class=\"line\">//    [invocationOperation start];</div><div class=\"line\"></div><div class=\"line\">//创建操作队列</div><div class=\"line\">NSOperationQueue *operationQueue=[[NSOperationQueue alloc]init];</div><div class=\"line\">//注意添加到操作队后，队列会开启一个线程执行此操作</div><div class=\"line\">[operationQueue addOperation:invocationOperation];</div></pre></td></tr></table></figure></p>\n<p>（2）NSBlockOperation：相比NSInvocationOperation 更简单，推荐<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">//方法1：创建操作块添加到队列</div><div class=\"line\">//        //创建多线程操作</div><div class=\"line\">//        NSBlockOperation *blockOperation=[NSBlockOperation blockOperationWithBlock:^&#123;</div><div class=\"line\">//            [self loadImage:[NSNumber numberWithInt:i]];</div><div class=\"line\">//        &#125;];</div><div class=\"line\">//        //创建操作队列</div><div class=\"line\">//</div><div class=\"line\">//        [operationQueue addOperation:blockOperation];</div><div class=\"line\"></div><div class=\"line\">//方法2：直接使用操队列添加操作</div><div class=\"line\">[operationQueue addOperationWithBlock:^&#123;</div><div class=\"line\">[self loadImage:[NSNumber numberWithInt:i]];</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<p>（3）继承NSOperation<br>在.m文件中实现main方法，main方法编写要执行的代码。</p>\n<p>2.设置并发数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[queue setMaxConcurrentOperationCount:5];</div></pre></td></tr></table></figure></p>\n<p>默认情况下是-1，-1表示没有限制，这样会同时运行队列中的全部的操作。</p>\n<p>3.线程执行顺序<br>每个NSOperation可以设置依赖线程。假设操作A依赖于操作B，线程操作队列在启动线程时就会首先执行B操作，然后执行A。<br>以下代码实现了优先加载最后一张图片：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)loadImageWithMultiThread&#123;</div><div class=\"line\">int count=ROW_COUNT*COLUMN_COUNT;</div><div class=\"line\">//创建操作队列</div><div class=\"line\">NSOperationQueue *operationQueue=[[NSOperationQueue alloc]init];</div><div class=\"line\">operationQueue.maxConcurrentOperationCount=5;//设置最大并发线程数</div><div class=\"line\"></div><div class=\"line\">NSBlockOperation *lastBlockOperation=[NSBlockOperation blockOperationWithBlock:^&#123;</div><div class=\"line\">    [self loadImage:[NSNumber numberWithInt:(count-1)]];</div><div class=\"line\">&#125;];</div><div class=\"line\">//创建多个线程用于填充图片</div><div class=\"line\">for (int i=0; i&lt;count-1; ++i) &#123;</div><div class=\"line\">//方法1：创建操作块添加到队列</div><div class=\"line\">//创建多线程操作</div><div class=\"line\">NSBlockOperation *blockOperation=[NSBlockOperation blockOperationWithBlock:^&#123;</div><div class=\"line\">[self loadImage:[NSNumber numberWithInt:i]];</div><div class=\"line\">&#125;];</div><div class=\"line\">//设置依赖操作为最后一张图片加载操作</div><div class=\"line\">[blockOperation addDependency:lastBlockOperation];</div><div class=\"line\">[operationQueue addOperation:blockOperation];</div><div class=\"line\">&#125;</div><div class=\"line\">//将最后一个图片的加载操作加入线程队列</div><div class=\"line\">[operationQueue addOperation:lastBlockOperation];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>三、GCD<br>1.dispatch queue<br>dispatch queue分为下面三种：Serial，Concurrent，main，global<br>（1）Serial<br>又称为private dispatch queues，同时只执行一个任务。<br>通常用于同步访问特定的资源或数据。当你创建多个Serial queue时，虽然它们各自是同步执行的，但Serial queue与Serial queue之间是并发执行的。<br>（2）Concurrent<br>可以并发地执行多个任务，但是执行完成的顺序是随机的。<br>（3）Main dispatch queue<br>主线程，它是全局可用的serial queue。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_queue_t mainQ = dispatch_get_main_queue();</div></pre></td></tr></table></figure></p>\n<p>（4）global dispatch queue<br>系统给每一个应用程序提供了三个concurrent dispatch queues。这三个并发调度队列是全局的，它们只有优先级的不同。<br>因为是全局的，我们不需要去创建。我们只需要通过使用函数dispath_get_global_queue去得到队列。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_queue_t globalQ = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div></pre></td></tr></table></figure></p>\n<p>2.dispatch_group_async<br>可以实现监听一组任务是否完成，完成后得到通知执行其他的操作<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);  </div><div class=\"line\">dispatch_group_t group = dispatch_group_create();  </div><div class=\"line\">dispatch_group_async(group, queue, ^&#123;  </div><div class=\"line\">    [NSThread sleepForTimeInterval:1];  </div><div class=\"line\">    NSLog(@&quot;group1&quot;);  </div><div class=\"line\">&#125;);  </div><div class=\"line\">dispatch_group_async(group, queue, ^&#123;  </div><div class=\"line\">    [NSThread sleepForTimeInterval:2];  </div><div class=\"line\">    NSLog(@&quot;group2&quot;);  </div><div class=\"line\">&#125;);  </div><div class=\"line\">dispatch_group_async(group, queue, ^&#123;  </div><div class=\"line\">    [NSThread sleepForTimeInterval:3];  </div><div class=\"line\">    NSLog(@&quot;group3&quot;);  </div><div class=\"line\">&#125;);  </div><div class=\"line\">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;  </div><div class=\"line\">    NSLog(@&quot;updateUi&quot;);  </div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>3.dispatch_barrier_async<br>在前面的任务执行结束后它才执行，而且它后面的任务等它执行完成之后才会执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;gcdtest.rongfzh.yc&quot;, DISPATCH_QUEUE_CONCURRENT);  </div><div class=\"line\">dispatch_async(queue, ^&#123;  </div><div class=\"line\">    [NSThread sleepForTimeInterval:2];  </div><div class=\"line\">    NSLog(@&quot;dispatch_async1&quot;);  </div><div class=\"line\">&#125;);  </div><div class=\"line\">dispatch_async(queue, ^&#123;  </div><div class=\"line\">    [NSThread sleepForTimeInterval:4];  </div><div class=\"line\">    NSLog(@&quot;dispatch_async2&quot;);  </div><div class=\"line\">&#125;);  </div><div class=\"line\">dispatch_barrier_async(queue, ^&#123;  </div><div class=\"line\">    NSLog(@&quot;dispatch_barrier_async&quot;);  </div><div class=\"line\">    [NSThread sleepForTimeInterval:4];  </div><div class=\"line\"></div><div class=\"line\">&#125;);  </div><div class=\"line\">dispatch_async(queue, ^&#123;  </div><div class=\"line\">    [NSThread sleepForTimeInterval:1];  </div><div class=\"line\">    NSLog(@&quot;dispatch_async3&quot;);  </div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>4.dispatch_apply<br>执行某个代码片段N次。<br>注意：这个方法没有办法异步执行（为了不阻塞线程可以使用dispatch_async()包装一下再执行）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_apply(5, globalQ, ^(size_t index) &#123;</div><div class=\"line\">// 执行5次</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>5.dispatch_time()： 延迟一定的时间后执行。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 3*NSEC_PER_SEC);</div><div class=\"line\">dispatch_after(time, dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">NSLog(@&quot;3秒后添加到队列&quot;);</div><div class=\"line\">&#125;);</div><div class=\"line\">　dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\"></div><div class=\"line\">// 2秒后异步执行这里的代码...</div><div class=\"line\"></div><div class=\"line\">　&#125;);</div></pre></td></tr></table></figure></p>\n<p>6.一次性代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">static dispatch_once_t onceToken;</div><div class=\"line\">dispatch_once(&amp;onceToken, ^&#123;</div><div class=\"line\">// 只执行1次的代码(这里面默认是线程安全的)</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>7.dispatch_suspend(myQueue)： 挂起队列<br>8.dispatch_resume(myQueue)：恢复队列</p>\n<p>注意：调用dispatch_suspend会增加队列挂起的引用计数，而调用dispatch_resume则会减少引用计数，当引用计数大于0时，队列会保持挂起状态。因此，这队列的挂起和恢复中，我们需要小心使用以避免引用计数计算错误的出现。<br>参考链接：<a href=\"http://blog.csdn.net/totogo2010/article/details/8010231\" target=\"_blank\" rel=\"external\">荣芳志专栏中的文章</a><br>　　　　　<a href=\"http://www.cnblogs.com/kenshincui/p/3983982.html\" target=\"_blank\" rel=\"external\">iOS开发系列–并行开发其实很容易</a></p>"},{"title":"iOS打包提交APP Store注意事项","date":"2017-04-13T04:20:22.000Z","_content":"\n1.改为正式环境\n* 接口改成线上服务器\n* 极光推送环境改为生产环境等\n\n2.版本号\ntarget -> general：`Version`和`Build`版本号\n<!--more-->\n3.签名\ntarget -> general -> signing\n\n4.删除断点，log\n\n5.本地化，语言包\n\n6.Capabilities -> background modes \n如果后台使用了位置，提交信息中应用描述添加免责声明\n> 温馨提示：GPS在后台持续运行，会大大降低电池的寿命。\n\n7.edit scheme: run,archive -> `debug` 改为 `release`\n\n8.打包ad-hoc，进行内测：clean -> build -> archive\n\n最后，打正式包，提交APP Store。\n\n","source":"_posts/iOS打包提交APP-Store注意事项.md","raw":"---\ntitle: iOS打包提交APP Store注意事项\ndate: 2017-04-13 12:20:22\ncategories: 笔记\ntags: [iOS,app store]\n---\n\n1.改为正式环境\n* 接口改成线上服务器\n* 极光推送环境改为生产环境等\n\n2.版本号\ntarget -> general：`Version`和`Build`版本号\n<!--more-->\n3.签名\ntarget -> general -> signing\n\n4.删除断点，log\n\n5.本地化，语言包\n\n6.Capabilities -> background modes \n如果后台使用了位置，提交信息中应用描述添加免责声明\n> 温馨提示：GPS在后台持续运行，会大大降低电池的寿命。\n\n7.edit scheme: run,archive -> `debug` 改为 `release`\n\n8.打包ad-hoc，进行内测：clean -> build -> archive\n\n最后，打正式包，提交APP Store。\n\n","slug":"iOS打包提交APP-Store注意事项","published":1,"updated":"2017-07-14T03:57:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj53c1dwc0028h3jj4iq0w96h","content":"<p>1.改为正式环境</p>\n<ul>\n<li>接口改成线上服务器</li>\n<li>极光推送环境改为生产环境等</li>\n</ul>\n<p>2.版本号<br>target -&gt; general：<code>Version</code>和<code>Build</code>版本号<br><a id=\"more\"></a><br>3.签名<br>target -&gt; general -&gt; signing</p>\n<p>4.删除断点，log</p>\n<p>5.本地化，语言包</p>\n<p>6.Capabilities -&gt; background modes<br>如果后台使用了位置，提交信息中应用描述添加免责声明</p>\n<blockquote>\n<p>温馨提示：GPS在后台持续运行，会大大降低电池的寿命。</p>\n</blockquote>\n<p>7.edit scheme: run,archive -&gt; <code>debug</code> 改为 <code>release</code></p>\n<p>8.打包ad-hoc，进行内测：clean -&gt; build -&gt; archive</p>\n<p>最后，打正式包，提交APP Store。</p>\n","site":{"data":{}},"excerpt":"<p>1.改为正式环境</p>\n<ul>\n<li>接口改成线上服务器</li>\n<li>极光推送环境改为生产环境等</li>\n</ul>\n<p>2.版本号<br>target -&gt; general：<code>Version</code>和<code>Build</code>版本号<br>","more":"<br>3.签名<br>target -&gt; general -&gt; signing</p>\n<p>4.删除断点，log</p>\n<p>5.本地化，语言包</p>\n<p>6.Capabilities -&gt; background modes<br>如果后台使用了位置，提交信息中应用描述添加免责声明</p>\n<blockquote>\n<p>温馨提示：GPS在后台持续运行，会大大降低电池的寿命。</p>\n</blockquote>\n<p>7.edit scheme: run,archive -&gt; <code>debug</code> 改为 <code>release</code></p>\n<p>8.打包ad-hoc，进行内测：clean -&gt; build -&gt; archive</p>\n<p>最后，打正式包，提交APP Store。</p>"},{"title":"iOS直播学习笔记","date":"2017-06-29T09:14:34.000Z","_content":"\n\n## 推流\n//LFLiveKit,librtmp\n\n1.安装Homebrew\n查看是否已经安装了Homebrew\n```\nman brew\n```\n<!--more-->\n安装Homebrew\n```\nruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n\n2.安装nginx\n```\n//从github下载Nginx到本地,增加home-brew对nginx的扩展\nbrew tap homebrew/nginx\n\n//安装Nginx服务器和rtmp模块\nbrew install nginx-full --with-rtmp-module\n\n查看是否安装成功\nnginx\n```\n\n在浏览器地址栏输入：`http://localhost:8080`\n如果出现`Welcome to nginx!`，则表示安装成功\n\n3.配置rtmp\n查看nginx配置文件安装在哪\nbrew info nginx-full\n\n前往`/usr/local/etc/nginx/nginx.conf`，在最后添加以下代码：\n```\nrtmp {\n    server {\n        listen 1990;\n        application liveApp {\n            live on;\n            record off;\n        }\n    }\n}\n```\n\n重新加载nginx的配置文件\nnginx -s reload\n\n4.安装ffmpeg进行推流\nbrew install ffmpeg\n\n5.使用ffmepg推流测试\n```\nffmpeg -re -i (视频全路径) -vcodec copy -f flv (rtmp路径)\nffmpeg -re -i /Users/xxx/Downloads/4.mp4 -vcodec copy -f flv rtmp://localhost:1990/liveApp/room\n```\n\n出现错误：\n```\n[tcp @ 0x7ffd66e08440] Connection to tcp://localhost:1990 failed (Connection refused), trying next address\n[flv @ 0x7ffd68005400] FLV does not support sample rate 48000, choose from (44100, 22050, 11025)\n[flv @ 0x7ffd68005400] Audio codec mp3 not compatible with flv\nCould not write header for output file #0 (incorrect codec parameters ?): Function not implemented\n```\n\n原因：flv格式不支持音频码率为48000的，只支持44100，22050，11025的，你得找一个音频码率为这三个中的其中一个的视频或者利用ffmpeg修改音频的码率\n\n\n6.使用VLC播放rtmp推流\nVLC\n\n7.用ffmpeg抓取桌面以及摄像头推流进行直播\n```\n//查看ffmpeg是否支持对应的设备\nffmpeg -f avfoundation -list_devices true -i \"\"\n//抓取桌面和摄像头进行推流\nffmpeg -f avfoundation -framerate 30 -i \"1:0\" -f avfoundation -framerate 30 -video_size 640x480 -i \"0\" -c:v libx264 -preset slow -filter_complex 'overlay=main_w-overlay_w-10:main_h-overlay_h-10' -acodec libmp3lame -ar 44100 -ac 1  -f flv rtmp://localhost:1990/liveApp/room\n```\n\n## 搭建WEB服务器\n1.安装node.js,NPM\n2.利用NPM下载第三方模块（Express和Socket.IO）\n创建package.json:\n```\n\"dependencies\": {\n\"express\": \"^4.14.0\",\n\"socket.io\": \"^1.4.8\"\n}\n```\n\n执行`npm install`\n\n3.http服务器搭建\n创建xxx.js文件，然后执行`node xxx.js`即可\n`\n// require\n// 加载http模块\nvar http = require('http');\n\n// 创建http服务器\nvar server = http.createServer(function(request,response){\n// response.write('Hello world');\n// response.end();\n});\n\n// 监听服务器\nserver.listen(8080,'192.168.0.101');\n\nconsole.log('监听8080');\n`\n\n4.express框架\nExpress框架建立在node.js内置的http模块上，可以快速地搭建一个Web服务器\n```\n// 引入express模块\nvar express = require('express');\n\n// 创建express服务器，创建服务器没有对访问服务器进行处理\nvar app = express();\n\n// 监听get请求，请求根目录，输出Hello world\napp.get('/',function(request,response){\nresponse.send('Hello world');\n});\n\napp.post('/',function(request,response){\nresponse.send('Hello world');\n});\n\napp.listen(8080,\"192.168.0.101\");\n\nconsole.log(\"监听8080\");\n```\n\n5.上传下载服务器搭建\n\n## 搭建socket即时通讯服务器\n1.WebSocket\nWebSocket：服务器和 客户端 都能主动的向对方发送或接收数据\nwebsocket协议头:ws\nSocket.IO:是一个完全由JavaScript实现、基于Node.js、支持WebSocket的协议用于实时通信、跨平台的开源框架。\n2.导入Socket.IO\n3.创建socket\n* （1）面向express框架开发，加载express框架，方便处理get,post请求\n* （2）因为socket依赖http,创建http服务器，使用http模块.\n* （3）可以通过express创建http服务器http.server(express)\n* （4）通过http服务器创建socket\n* （5）监听http服务器\n4.建立socket连接\n```\n// 监听socket连接\n// function参数必填socket\nsocket.on('connection',function(clientSocket){\nconsole.log('建立连接',clientSocket);\n});\n```\n\n5.SocketIO发送事件\n","source":"_posts/iOS直播学习笔记.md","raw":"---\ntitle: iOS直播学习笔记\ndate: 2017-06-29 17:14:34\ncategories: 笔记\ntags: [iOS,直播]\n---\n\n\n## 推流\n//LFLiveKit,librtmp\n\n1.安装Homebrew\n查看是否已经安装了Homebrew\n```\nman brew\n```\n<!--more-->\n安装Homebrew\n```\nruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n\n2.安装nginx\n```\n//从github下载Nginx到本地,增加home-brew对nginx的扩展\nbrew tap homebrew/nginx\n\n//安装Nginx服务器和rtmp模块\nbrew install nginx-full --with-rtmp-module\n\n查看是否安装成功\nnginx\n```\n\n在浏览器地址栏输入：`http://localhost:8080`\n如果出现`Welcome to nginx!`，则表示安装成功\n\n3.配置rtmp\n查看nginx配置文件安装在哪\nbrew info nginx-full\n\n前往`/usr/local/etc/nginx/nginx.conf`，在最后添加以下代码：\n```\nrtmp {\n    server {\n        listen 1990;\n        application liveApp {\n            live on;\n            record off;\n        }\n    }\n}\n```\n\n重新加载nginx的配置文件\nnginx -s reload\n\n4.安装ffmpeg进行推流\nbrew install ffmpeg\n\n5.使用ffmepg推流测试\n```\nffmpeg -re -i (视频全路径) -vcodec copy -f flv (rtmp路径)\nffmpeg -re -i /Users/xxx/Downloads/4.mp4 -vcodec copy -f flv rtmp://localhost:1990/liveApp/room\n```\n\n出现错误：\n```\n[tcp @ 0x7ffd66e08440] Connection to tcp://localhost:1990 failed (Connection refused), trying next address\n[flv @ 0x7ffd68005400] FLV does not support sample rate 48000, choose from (44100, 22050, 11025)\n[flv @ 0x7ffd68005400] Audio codec mp3 not compatible with flv\nCould not write header for output file #0 (incorrect codec parameters ?): Function not implemented\n```\n\n原因：flv格式不支持音频码率为48000的，只支持44100，22050，11025的，你得找一个音频码率为这三个中的其中一个的视频或者利用ffmpeg修改音频的码率\n\n\n6.使用VLC播放rtmp推流\nVLC\n\n7.用ffmpeg抓取桌面以及摄像头推流进行直播\n```\n//查看ffmpeg是否支持对应的设备\nffmpeg -f avfoundation -list_devices true -i \"\"\n//抓取桌面和摄像头进行推流\nffmpeg -f avfoundation -framerate 30 -i \"1:0\" -f avfoundation -framerate 30 -video_size 640x480 -i \"0\" -c:v libx264 -preset slow -filter_complex 'overlay=main_w-overlay_w-10:main_h-overlay_h-10' -acodec libmp3lame -ar 44100 -ac 1  -f flv rtmp://localhost:1990/liveApp/room\n```\n\n## 搭建WEB服务器\n1.安装node.js,NPM\n2.利用NPM下载第三方模块（Express和Socket.IO）\n创建package.json:\n```\n\"dependencies\": {\n\"express\": \"^4.14.0\",\n\"socket.io\": \"^1.4.8\"\n}\n```\n\n执行`npm install`\n\n3.http服务器搭建\n创建xxx.js文件，然后执行`node xxx.js`即可\n`\n// require\n// 加载http模块\nvar http = require('http');\n\n// 创建http服务器\nvar server = http.createServer(function(request,response){\n// response.write('Hello world');\n// response.end();\n});\n\n// 监听服务器\nserver.listen(8080,'192.168.0.101');\n\nconsole.log('监听8080');\n`\n\n4.express框架\nExpress框架建立在node.js内置的http模块上，可以快速地搭建一个Web服务器\n```\n// 引入express模块\nvar express = require('express');\n\n// 创建express服务器，创建服务器没有对访问服务器进行处理\nvar app = express();\n\n// 监听get请求，请求根目录，输出Hello world\napp.get('/',function(request,response){\nresponse.send('Hello world');\n});\n\napp.post('/',function(request,response){\nresponse.send('Hello world');\n});\n\napp.listen(8080,\"192.168.0.101\");\n\nconsole.log(\"监听8080\");\n```\n\n5.上传下载服务器搭建\n\n## 搭建socket即时通讯服务器\n1.WebSocket\nWebSocket：服务器和 客户端 都能主动的向对方发送或接收数据\nwebsocket协议头:ws\nSocket.IO:是一个完全由JavaScript实现、基于Node.js、支持WebSocket的协议用于实时通信、跨平台的开源框架。\n2.导入Socket.IO\n3.创建socket\n* （1）面向express框架开发，加载express框架，方便处理get,post请求\n* （2）因为socket依赖http,创建http服务器，使用http模块.\n* （3）可以通过express创建http服务器http.server(express)\n* （4）通过http服务器创建socket\n* （5）监听http服务器\n4.建立socket连接\n```\n// 监听socket连接\n// function参数必填socket\nsocket.on('connection',function(clientSocket){\nconsole.log('建立连接',clientSocket);\n});\n```\n\n5.SocketIO发送事件\n","slug":"iOS直播学习笔记","published":1,"updated":"2017-07-14T03:57:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj53c1dwe002bh3jjqeklai2j","content":"<h2 id=\"推流\"><a href=\"#推流\" class=\"headerlink\" title=\"推流\"></a>推流</h2><p>//LFLiveKit,librtmp</p>\n<p>1.安装Homebrew<br>查看是否已经安装了Homebrew<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">man brew</div></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>安装Homebrew<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</div></pre></td></tr></table></figure></p>\n<p>2.安装nginx<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">//从github下载Nginx到本地,增加home-brew对nginx的扩展</div><div class=\"line\">brew tap homebrew/nginx</div><div class=\"line\"></div><div class=\"line\">//安装Nginx服务器和rtmp模块</div><div class=\"line\">brew install nginx-full --with-rtmp-module</div><div class=\"line\"></div><div class=\"line\">查看是否安装成功</div><div class=\"line\">nginx</div></pre></td></tr></table></figure></p>\n<p>在浏览器地址栏输入：<code>http://localhost:8080</code><br>如果出现<code>Welcome to nginx!</code>，则表示安装成功</p>\n<p>3.配置rtmp<br>查看nginx配置文件安装在哪<br>brew info nginx-full</p>\n<p>前往<code>/usr/local/etc/nginx/nginx.conf</code>，在最后添加以下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">rtmp &#123;</div><div class=\"line\">    server &#123;</div><div class=\"line\">        listen 1990;</div><div class=\"line\">        application liveApp &#123;</div><div class=\"line\">            live on;</div><div class=\"line\">            record off;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>重新加载nginx的配置文件<br>nginx -s reload</p>\n<p>4.安装ffmpeg进行推流<br>brew install ffmpeg</p>\n<p>5.使用ffmepg推流测试<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">ffmpeg -re -i (视频全路径) -vcodec copy -f flv (rtmp路径)</div><div class=\"line\">ffmpeg -re -i /Users/xxx/Downloads/4.mp4 -vcodec copy -f flv rtmp://localhost:1990/liveApp/room</div></pre></td></tr></table></figure></p>\n<p>出现错误：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">[tcp @ 0x7ffd66e08440] Connection to tcp://localhost:1990 failed (Connection refused), trying next address</div><div class=\"line\">[flv @ 0x7ffd68005400] FLV does not support sample rate 48000, choose from (44100, 22050, 11025)</div><div class=\"line\">[flv @ 0x7ffd68005400] Audio codec mp3 not compatible with flv</div><div class=\"line\">Could not write header for output file #0 (incorrect codec parameters ?): Function not implemented</div></pre></td></tr></table></figure></p>\n<p>原因：flv格式不支持音频码率为48000的，只支持44100，22050，11025的，你得找一个音频码率为这三个中的其中一个的视频或者利用ffmpeg修改音频的码率</p>\n<p>6.使用VLC播放rtmp推流<br>VLC</p>\n<p>7.用ffmpeg抓取桌面以及摄像头推流进行直播<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">//查看ffmpeg是否支持对应的设备</div><div class=\"line\">ffmpeg -f avfoundation -list_devices true -i &quot;&quot;</div><div class=\"line\">//抓取桌面和摄像头进行推流</div><div class=\"line\">ffmpeg -f avfoundation -framerate 30 -i &quot;1:0&quot; -f avfoundation -framerate 30 -video_size 640x480 -i &quot;0&quot; -c:v libx264 -preset slow -filter_complex &apos;overlay=main_w-overlay_w-10:main_h-overlay_h-10&apos; -acodec libmp3lame -ar 44100 -ac 1  -f flv rtmp://localhost:1990/liveApp/room</div></pre></td></tr></table></figure></p>\n<h2 id=\"搭建WEB服务器\"><a href=\"#搭建WEB服务器\" class=\"headerlink\" title=\"搭建WEB服务器\"></a>搭建WEB服务器</h2><p>1.安装node.js,NPM<br>2.利用NPM下载第三方模块（Express和Socket.IO）<br>创建package.json:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;dependencies&quot;: &#123;</div><div class=\"line\">&quot;express&quot;: &quot;^4.14.0&quot;,</div><div class=\"line\">&quot;socket.io&quot;: &quot;^1.4.8&quot;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>执行<code>npm install</code></p>\n<p>3.http服务器搭建<br>创建xxx.js文件，然后执行<code>node xxx.js</code>即可<br>`<br>// require<br>// 加载http模块<br>var http = require(‘http’);</p>\n<p>// 创建http服务器<br>var server = http.createServer(function(request,response){<br>// response.write(‘Hello world’);<br>// response.end();<br>});</p>\n<p>// 监听服务器<br>server.listen(8080,’192.168.0.101’);</p>\n<p>console.log(‘监听8080’);<br>`</p>\n<p>4.express框架<br>Express框架建立在node.js内置的http模块上，可以快速地搭建一个Web服务器<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 引入express模块</div><div class=\"line\">var express = require(&apos;express&apos;);</div><div class=\"line\"></div><div class=\"line\">// 创建express服务器，创建服务器没有对访问服务器进行处理</div><div class=\"line\">var app = express();</div><div class=\"line\"></div><div class=\"line\">// 监听get请求，请求根目录，输出Hello world</div><div class=\"line\">app.get(&apos;/&apos;,function(request,response)&#123;</div><div class=\"line\">response.send(&apos;Hello world&apos;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">app.post(&apos;/&apos;,function(request,response)&#123;</div><div class=\"line\">response.send(&apos;Hello world&apos;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">app.listen(8080,&quot;192.168.0.101&quot;);</div><div class=\"line\"></div><div class=\"line\">console.log(&quot;监听8080&quot;);</div></pre></td></tr></table></figure></p>\n<p>5.上传下载服务器搭建</p>\n<h2 id=\"搭建socket即时通讯服务器\"><a href=\"#搭建socket即时通讯服务器\" class=\"headerlink\" title=\"搭建socket即时通讯服务器\"></a>搭建socket即时通讯服务器</h2><p>1.WebSocket<br>WebSocket：服务器和 客户端 都能主动的向对方发送或接收数据<br>websocket协议头:ws<br>Socket.IO:是一个完全由JavaScript实现、基于Node.js、支持WebSocket的协议用于实时通信、跨平台的开源框架。<br>2.导入Socket.IO<br>3.创建socket</p>\n<ul>\n<li>（1）面向express框架开发，加载express框架，方便处理get,post请求</li>\n<li>（2）因为socket依赖http,创建http服务器，使用http模块.</li>\n<li>（3）可以通过express创建http服务器http.server(express)</li>\n<li>（4）通过http服务器创建socket</li>\n<li>（5）监听http服务器<br>4.建立socket连接<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 监听socket连接</div><div class=\"line\">// function参数必填socket</div><div class=\"line\">socket.on(&apos;connection&apos;,function(clientSocket)&#123;</div><div class=\"line\">console.log(&apos;建立连接&apos;,clientSocket);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>5.SocketIO发送事件</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"推流\"><a href=\"#推流\" class=\"headerlink\" title=\"推流\"></a>推流</h2><p>//LFLiveKit,librtmp</p>\n<p>1.安装Homebrew<br>查看是否已经安装了Homebrew<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">man brew</div></pre></td></tr></table></figure></p>","more":"<p>安装Homebrew<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</div></pre></td></tr></table></figure></p>\n<p>2.安装nginx<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">//从github下载Nginx到本地,增加home-brew对nginx的扩展</div><div class=\"line\">brew tap homebrew/nginx</div><div class=\"line\"></div><div class=\"line\">//安装Nginx服务器和rtmp模块</div><div class=\"line\">brew install nginx-full --with-rtmp-module</div><div class=\"line\"></div><div class=\"line\">查看是否安装成功</div><div class=\"line\">nginx</div></pre></td></tr></table></figure></p>\n<p>在浏览器地址栏输入：<code>http://localhost:8080</code><br>如果出现<code>Welcome to nginx!</code>，则表示安装成功</p>\n<p>3.配置rtmp<br>查看nginx配置文件安装在哪<br>brew info nginx-full</p>\n<p>前往<code>/usr/local/etc/nginx/nginx.conf</code>，在最后添加以下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">rtmp &#123;</div><div class=\"line\">    server &#123;</div><div class=\"line\">        listen 1990;</div><div class=\"line\">        application liveApp &#123;</div><div class=\"line\">            live on;</div><div class=\"line\">            record off;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>重新加载nginx的配置文件<br>nginx -s reload</p>\n<p>4.安装ffmpeg进行推流<br>brew install ffmpeg</p>\n<p>5.使用ffmepg推流测试<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">ffmpeg -re -i (视频全路径) -vcodec copy -f flv (rtmp路径)</div><div class=\"line\">ffmpeg -re -i /Users/xxx/Downloads/4.mp4 -vcodec copy -f flv rtmp://localhost:1990/liveApp/room</div></pre></td></tr></table></figure></p>\n<p>出现错误：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">[tcp @ 0x7ffd66e08440] Connection to tcp://localhost:1990 failed (Connection refused), trying next address</div><div class=\"line\">[flv @ 0x7ffd68005400] FLV does not support sample rate 48000, choose from (44100, 22050, 11025)</div><div class=\"line\">[flv @ 0x7ffd68005400] Audio codec mp3 not compatible with flv</div><div class=\"line\">Could not write header for output file #0 (incorrect codec parameters ?): Function not implemented</div></pre></td></tr></table></figure></p>\n<p>原因：flv格式不支持音频码率为48000的，只支持44100，22050，11025的，你得找一个音频码率为这三个中的其中一个的视频或者利用ffmpeg修改音频的码率</p>\n<p>6.使用VLC播放rtmp推流<br>VLC</p>\n<p>7.用ffmpeg抓取桌面以及摄像头推流进行直播<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">//查看ffmpeg是否支持对应的设备</div><div class=\"line\">ffmpeg -f avfoundation -list_devices true -i &quot;&quot;</div><div class=\"line\">//抓取桌面和摄像头进行推流</div><div class=\"line\">ffmpeg -f avfoundation -framerate 30 -i &quot;1:0&quot; -f avfoundation -framerate 30 -video_size 640x480 -i &quot;0&quot; -c:v libx264 -preset slow -filter_complex &apos;overlay=main_w-overlay_w-10:main_h-overlay_h-10&apos; -acodec libmp3lame -ar 44100 -ac 1  -f flv rtmp://localhost:1990/liveApp/room</div></pre></td></tr></table></figure></p>\n<h2 id=\"搭建WEB服务器\"><a href=\"#搭建WEB服务器\" class=\"headerlink\" title=\"搭建WEB服务器\"></a>搭建WEB服务器</h2><p>1.安装node.js,NPM<br>2.利用NPM下载第三方模块（Express和Socket.IO）<br>创建package.json:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;dependencies&quot;: &#123;</div><div class=\"line\">&quot;express&quot;: &quot;^4.14.0&quot;,</div><div class=\"line\">&quot;socket.io&quot;: &quot;^1.4.8&quot;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>执行<code>npm install</code></p>\n<p>3.http服务器搭建<br>创建xxx.js文件，然后执行<code>node xxx.js</code>即可<br>`<br>// require<br>// 加载http模块<br>var http = require(‘http’);</p>\n<p>// 创建http服务器<br>var server = http.createServer(function(request,response){<br>// response.write(‘Hello world’);<br>// response.end();<br>});</p>\n<p>// 监听服务器<br>server.listen(8080,’192.168.0.101’);</p>\n<p>console.log(‘监听8080’);<br>`</p>\n<p>4.express框架<br>Express框架建立在node.js内置的http模块上，可以快速地搭建一个Web服务器<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 引入express模块</div><div class=\"line\">var express = require(&apos;express&apos;);</div><div class=\"line\"></div><div class=\"line\">// 创建express服务器，创建服务器没有对访问服务器进行处理</div><div class=\"line\">var app = express();</div><div class=\"line\"></div><div class=\"line\">// 监听get请求，请求根目录，输出Hello world</div><div class=\"line\">app.get(&apos;/&apos;,function(request,response)&#123;</div><div class=\"line\">response.send(&apos;Hello world&apos;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">app.post(&apos;/&apos;,function(request,response)&#123;</div><div class=\"line\">response.send(&apos;Hello world&apos;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">app.listen(8080,&quot;192.168.0.101&quot;);</div><div class=\"line\"></div><div class=\"line\">console.log(&quot;监听8080&quot;);</div></pre></td></tr></table></figure></p>\n<p>5.上传下载服务器搭建</p>\n<h2 id=\"搭建socket即时通讯服务器\"><a href=\"#搭建socket即时通讯服务器\" class=\"headerlink\" title=\"搭建socket即时通讯服务器\"></a>搭建socket即时通讯服务器</h2><p>1.WebSocket<br>WebSocket：服务器和 客户端 都能主动的向对方发送或接收数据<br>websocket协议头:ws<br>Socket.IO:是一个完全由JavaScript实现、基于Node.js、支持WebSocket的协议用于实时通信、跨平台的开源框架。<br>2.导入Socket.IO<br>3.创建socket</p>\n<ul>\n<li>（1）面向express框架开发，加载express框架，方便处理get,post请求</li>\n<li>（2）因为socket依赖http,创建http服务器，使用http模块.</li>\n<li>（3）可以通过express创建http服务器http.server(express)</li>\n<li>（4）通过http服务器创建socket</li>\n<li>（5）监听http服务器<br>4.建立socket连接<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 监听socket连接</div><div class=\"line\">// function参数必填socket</div><div class=\"line\">socket.on(&apos;connection&apos;,function(clientSocket)&#123;</div><div class=\"line\">console.log(&apos;建立连接&apos;,clientSocket);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>5.SocketIO发送事件</p>"},{"title":"iOS调试与性能优化学习笔记","date":"2017-06-05T10:31:25.000Z","_content":"\n1.全局断点\n2.条件断点 condational\n3.符号断点 symbolic  -[NSObject(NSObject) doesNotRecognizeSelector:]\n4.NSLog\n5.僵尸对象\n<!--more-->\n6.lldb LLVM GCC:p po expr call\nimage lookup --address 0x0000000100004af8\n7.instruments-profile:\nanalyze：发现release问题，以及继承过程中的父类方法缺失等\nleaks:自动加载Allocations，监控程序运行过程中的内存变化\n《How to Use Instruments in Xcode》： https://www.raywenderlich.com/97886/instruments-tutorial-with-swift-getting-started\n《与调试器共舞 - LLDB 的华尔兹》：https://objccn.io/issue-19-2/\n《LLDB调试命令初探》：http://www.starfelix.com/blog/2014/03/17/lldbdiao-shi-ming-ling-chu-tan/\n《The LLDB Debugger》：http://lldb.llvm.org/tutorial.html\n《About LLDB and Xcode》：https://developer.apple.com/library/mac/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/Introduction.html\nhttp://www.cnblogs.com/daiweilai/p/4234336.html\n8.Debug View Hierarchy\n9.预编译指令:\n//swift语言\n#if DEBUG\nfunc dlog<T>(object: T) {\nprintln(object)\n}\n#else\nfunc dlog<T>(object: T) {}\n#endif\n\n#warning\n#error\n#pragma message\n\n","source":"_posts/iOS调试与性能优化学习笔记.md","raw":"---\ntitle: iOS调试与性能优化学习笔记\ndate: 2017-06-05 18:31:25\ncategories: 笔记\ntags: [iOS,优化]\n---\n\n1.全局断点\n2.条件断点 condational\n3.符号断点 symbolic  -[NSObject(NSObject) doesNotRecognizeSelector:]\n4.NSLog\n5.僵尸对象\n<!--more-->\n6.lldb LLVM GCC:p po expr call\nimage lookup --address 0x0000000100004af8\n7.instruments-profile:\nanalyze：发现release问题，以及继承过程中的父类方法缺失等\nleaks:自动加载Allocations，监控程序运行过程中的内存变化\n《How to Use Instruments in Xcode》： https://www.raywenderlich.com/97886/instruments-tutorial-with-swift-getting-started\n《与调试器共舞 - LLDB 的华尔兹》：https://objccn.io/issue-19-2/\n《LLDB调试命令初探》：http://www.starfelix.com/blog/2014/03/17/lldbdiao-shi-ming-ling-chu-tan/\n《The LLDB Debugger》：http://lldb.llvm.org/tutorial.html\n《About LLDB and Xcode》：https://developer.apple.com/library/mac/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/Introduction.html\nhttp://www.cnblogs.com/daiweilai/p/4234336.html\n8.Debug View Hierarchy\n9.预编译指令:\n//swift语言\n#if DEBUG\nfunc dlog<T>(object: T) {\nprintln(object)\n}\n#else\nfunc dlog<T>(object: T) {}\n#endif\n\n#warning\n#error\n#pragma message\n\n","slug":"iOS调试与性能优化学习笔记","published":1,"updated":"2017-07-14T03:57:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj53c1dwg002eh3jjzkvs8ah9","content":"<p>1.全局断点<br>2.条件断点 condational<br>3.符号断点 symbolic  -[NSObject(NSObject) doesNotRecognizeSelector:]<br>4.NSLog<br>5.僵尸对象<br><a id=\"more\"></a><br>6.lldb LLVM GCC:p po expr call<br>image lookup –address 0x0000000100004af8<br>7.instruments-profile:<br>analyze：发现release问题，以及继承过程中的父类方法缺失等<br>leaks:自动加载Allocations，监控程序运行过程中的内存变化<br>《How to Use Instruments in Xcode》： <a href=\"https://www.raywenderlich.com/97886/instruments-tutorial-with-swift-getting-started\" target=\"_blank\" rel=\"external\">https://www.raywenderlich.com/97886/instruments-tutorial-with-swift-getting-started</a><br>《与调试器共舞 - LLDB 的华尔兹》：<a href=\"https://objccn.io/issue-19-2/\" target=\"_blank\" rel=\"external\">https://objccn.io/issue-19-2/</a><br>《LLDB调试命令初探》：<a href=\"http://www.starfelix.com/blog/2014/03/17/lldbdiao-shi-ming-ling-chu-tan/\" target=\"_blank\" rel=\"external\">http://www.starfelix.com/blog/2014/03/17/lldbdiao-shi-ming-ling-chu-tan/</a><br>《The LLDB Debugger》：<a href=\"http://lldb.llvm.org/tutorial.html\" target=\"_blank\" rel=\"external\">http://lldb.llvm.org/tutorial.html</a><br>《About LLDB and Xcode》：<a href=\"https://developer.apple.com/library/mac/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/Introduction.html\" target=\"_blank\" rel=\"external\">https://developer.apple.com/library/mac/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/Introduction.html</a><br><a href=\"http://www.cnblogs.com/daiweilai/p/4234336.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/daiweilai/p/4234336.html</a><br>8.Debug View Hierarchy<br>9.预编译指令:<br>//swift语言</p>\n<p>#if DEBUG<br>func dlog<t>(object: T) {<br>println(object)<br>}</t></p>\n<p>#else<br>func dlog<t>(object: T) {}</t></p>\n<p>#endif</p>\n<p>#warning</p>\n<p>#error</p>\n<p>#pragma message</p>\n","site":{"data":{}},"excerpt":"<p>1.全局断点<br>2.条件断点 condational<br>3.符号断点 symbolic  -[NSObject(NSObject) doesNotRecognizeSelector:]<br>4.NSLog<br>5.僵尸对象<br>","more":"<br>6.lldb LLVM GCC:p po expr call<br>image lookup –address 0x0000000100004af8<br>7.instruments-profile:<br>analyze：发现release问题，以及继承过程中的父类方法缺失等<br>leaks:自动加载Allocations，监控程序运行过程中的内存变化<br>《How to Use Instruments in Xcode》： <a href=\"https://www.raywenderlich.com/97886/instruments-tutorial-with-swift-getting-started\" target=\"_blank\" rel=\"external\">https://www.raywenderlich.com/97886/instruments-tutorial-with-swift-getting-started</a><br>《与调试器共舞 - LLDB 的华尔兹》：<a href=\"https://objccn.io/issue-19-2/\" target=\"_blank\" rel=\"external\">https://objccn.io/issue-19-2/</a><br>《LLDB调试命令初探》：<a href=\"http://www.starfelix.com/blog/2014/03/17/lldbdiao-shi-ming-ling-chu-tan/\" target=\"_blank\" rel=\"external\">http://www.starfelix.com/blog/2014/03/17/lldbdiao-shi-ming-ling-chu-tan/</a><br>《The LLDB Debugger》：<a href=\"http://lldb.llvm.org/tutorial.html\" target=\"_blank\" rel=\"external\">http://lldb.llvm.org/tutorial.html</a><br>《About LLDB and Xcode》：<a href=\"https://developer.apple.com/library/mac/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/Introduction.html\" target=\"_blank\" rel=\"external\">https://developer.apple.com/library/mac/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/Introduction.html</a><br><a href=\"http://www.cnblogs.com/daiweilai/p/4234336.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/daiweilai/p/4234336.html</a><br>8.Debug View Hierarchy<br>9.预编译指令:<br>//swift语言</p>\n<p>#if DEBUG<br>func dlog<t>(object: T) {<br>println(object)<br>}</t></p>\n<p>#else<br>func dlog<t>(object: T) {}</t></p>\n<p>#endif</p>\n<p>#warning</p>\n<p>#error</p>\n<p>#pragma message</p>"},{"title":"iOS面试知识点总结","date":"2017-06-30T06:31:59.000Z","_content":"\n1.category与extension的区别\n* category可以不用继承系统类，直接给系统类添加方法，最大程度的体现了Objective-C的动态语言特性。可以用来定义私有方法。\n* extension为一个类增加私有方法,属性或成员变量,并且新添加的方法一定要予以实现。Extension都是放在.m文件中@implementation的上方。\n区别：Extension可以添加属性。另外Extension添加的方法是必须要实现的。\n2.OC中的私有变量用@private修饰，私有方法用category\n<!--more-->\n3.NSInteger是基本数据类型Int或者Long的别名(NSInteger的定义typedef long NSInteger)，它的区别在于，NSInteger会根据系统是32位还是64位来决定是本身是int还是Long。\n\n4.block\n\n5.Objective-C的内存管理\n(1)主要有三种方式ARC(自动内存计数)、手动内存计数、内存池\n内存管理机制；当使用new,alloc和copy方法创建一个对象时,该对象的保留计数器值为1.当不再使用该对象时,要负责向该对象发送一条release或autorelease消息.这样,该对象将在使用寿命结束时被销毁.\n(2)堆与栈\n* 栈:是由编译器自动管理，无需我们手工控制；\n* 堆:释放工作由程序员控制，容易产生memory leak。\n6.属性关键字\n(1)atomic/nonatomic\n* atomic提供多线程安全。是防止在未写完的时候被另外一个线程读取，造成数据错误\n* non-atomic:在自己管理内存的环境中，解析的访问器保留并自动释放返回的值，如果指定了 nonatomic ，那么访问器只是简单地返回这个值\n(2)assign/weak\n* 用assign声明的变量在栈中可能不会自动赋值为nil，就会造成野指针错误\n* 用weak声明的变量在栈中会自动清空，赋值为nil\nassigin 可以用非OC对象,而weak必须用于OC对象\n在ARC中,在有可能出现循环引用的时候,往往要通过让其中一端使用weak来解决,比如:delegate代理属性\n(3)浅复制和深复制的区别?\n* 浅层复制：只复制指向对象的指针，而不复制引用对象本身。\n* 深层复制：复制引用对象本身。\n(4)copy/mutableCopy\n* copy是指针复制（浅拷贝）\n* mutableCopy就是对象复制（深拷贝）\n\n7.多态：不同对象以自己的方式响应相同的消息的能力叫做多态。子类指针可以赋值给父类对象。\n主要是将数据类型的确定由编译时，推迟到了运行时。\n(1)对于语句NSString*obj = [[NSData alloc] init]; obj在编译时和运行时分别时什么类型的对象?\n答：编译时是NSString的类型;运行时是NSData类型的对象。\n(2)id声明的对象具有运行时的特性，即可以指向任意类型的objcetive-c的对象.\n8.NSObject方法\n类方法：alloc,class,description\n实例方法：init,dealloc,performSelector\n\n9.通知与协议\n* 协议有控制链(has-a)的关系，通知没有。\n* 通知：一对多。代理/block：一对一。\n* OC中的多继承用委托代理实现\n\n10.事件的传递与响应\n传递：application->window->controller->view\n响应：view->controller->window->application\n重写hitTest:withEvent:方法\n\n11.延迟加载：用到的时候才去初始化。\n延迟加载可以避免内存过高，异步加载可以避免线程堵塞。\n\n12. 多线程\n(1)Object C中创建线程的方法是什么?如果在主线程中执行代码，方法是什么?如果想延时执行代码、方法又是什么?\n答：线程创建有三种方法\n* 使用NSThread创建\n* 使用GCD的dispatch\n* 使用子类化的NSOperation,然后将其加入NSOperationQueue;\n(2)在主线程执行代码，方法是performSelectorOnMainThread\n如果想延时执行代码可以用performSelector:onThread:withObject:waitUntilDone:\n(3)进程与线程\n进程有独立的地址空间\n线程有自己的堆栈和局部变量\n(4)队列：串行、并行、全局、主队列\n\n13.持久化存储机制：存到文件，存到NSUserDeaults(plist文件)，sqlite数据库\nNSUserDeaults数据存储在沙盒library下的Preferences文件夹。\n沙盒目录：documents、library(chches,preferences),tmp\nSDWebImage原理：内存中找->沙盒中找，缓存到内存->网络上获取，缓存到内存，缓存到沙盒\n\n14.网络\n(1)发起网络请求的对象：AFHTTPSessionManager、ASIHTTPRequest与NSURLConnection\n(2)http与socket\n* http:短连接，请求方式为客户端主动发起请求，服务器才能给响应，一次请求完毕后则断开连接，以节省资源。服务器不能主动给客户端响应（除非采取http长连接 技术）\n* socket:长连接，客户端和服务器可以保持连接通道，双方 都可以主动发送数据\n\n15.fmmpeg框架\n答：音视频编解码框架，内部使用UDP协议针对流媒体开发，内部开辟了六个端口来接受流媒体数据，完成快速接受之目的。 \n16.Cocoa Touch中一小部分可用的框架：\n* 音频和视频：Core Audio ，OpenAL ，Media Library ，AV Foundation\n* 数据管理 ：Core Data ，SQLite\n* 图形和动画 ：Core Animation ，OpenGL ES ，Quartz 2D\n* 网络：Bonjour ，WebKit ，BSD Sockets\n* 用户应用：Address Book ，Core Location ，Map Kit ，Store Kit\n\n17.isMemberOfClass 与 isKindOfClass \nisKindOfClass 不仅用来确定一个对象是否是一个类的成员,也可以用来确定一个对象是否派生自该类的类的成员\n,而isMemberOfClass 只能做到第一点\n\n18.UIViewController的生命周期\n-[ViewController initWithNibName:bundle:]；\n-[ViewController init]；\n-[ViewController loadView]；\n-[ViewController viewDidLoad]；\n-[ViewController viewWillDisappear:]；\n-[ViewController viewWillAppear:]；\n-[ViewController viewDidAppear:]；\n-[ViewController viewDidDisappear:]；\n\nReceived simulated memory warning.\n-[ViewController viewVillUnload]\n-[ViewController viewDidUnload]\n\n(1)创建Controller：\n* 通过storyBoard:\n> [UIStoryboard storyboardWithName:@\"\" bundle:nil]instantiateInitialViewController` \n> 此处bundle:nil 等价于 [NSBundle mainBundle]\n* 通过XIB\n    + 加载与控制器同名的XIB文件:使用`init`或`initWithNibName`加载\n    + 加载与控制器不同名的XIB Controller文件,通过`loadNibNamed`加载控制器（不同名需要修改file owner）\n```\nSecondViewController *secondVc = [[[NSBundle mainBundle]loadNibNamed:@\"SecondVC\" owner:nil options:nil] lastObject]\n```\n\n    + 加载与控制器不同名的XIB View文件,通过`loadNibNamed`加载控制器的view（不同名需要修改file owner）\n```\nSecondViewController *secondVc = [[SecondViewController alloc]init];\nsecondVc.view = [[[NSBundle mainBundle]loadNibNamed:@\"SecondViewController\" owner:nil options:nil] lastObject];\n```\n在创建控制器的时候直接指定要加载xib作为控制器的view,名称不相干\n> 需要修改xib文件的fileOwner进行关联\n> 需要将fileOwner里面的view指向xib里面的view\n(2)创建View:\n* 通过XIB：[[NSBundle alloc]loadNibNamed:@\"\" owner:self options:nil];\n\n19.OC单例\n```\n+(instancetype)shareNetworkTools{\n    static id instance;\n    static dispatch_once_t onceToken;\n    //onceToken默认等于0，如果是0就执行block，如果不是就不执行\n    NSLog(@\"%ld\",onceToken);\n    dispatch_once(&onceToken, ^{\n        instance = [[self alloc] init];\n    });\n    return instance;\n}\n```\n\nswift单例\n```\n/*\n//在swift中，类方法中不允许定义静态变量\nstatic var once_t: dispatch_once_t = 0\nstatic var instance: NetworkTools?\n//用于获取单例对象的类方法\nclass func shareNetworkTools() -> NetworkTools{\n    print(once_t)\n    dispatch_once(&once_t) { () -> Void in\n        instance = NetworkTools()\n    }\n    return instance!\n}\n*/\n//swift中的let是线程安全的\nstatic let instance: NetworkTools = NetworkTools()\nclass func shareNetworkTools() -> NetworkTools{\n    return instance\n}\n\n//init方法在需要的时候才创建\noverride init(){\nsuper.init()\nprint(\"----------\")\n}\n```\n\n","source":"_posts/iOS面试知识点总结.md","raw":"---\ntitle: iOS面试知识点总结\ndate: 2017-06-30 14:31:59\ncategories: 笔记\ntags: [iOS,面试]\n---\n\n1.category与extension的区别\n* category可以不用继承系统类，直接给系统类添加方法，最大程度的体现了Objective-C的动态语言特性。可以用来定义私有方法。\n* extension为一个类增加私有方法,属性或成员变量,并且新添加的方法一定要予以实现。Extension都是放在.m文件中@implementation的上方。\n区别：Extension可以添加属性。另外Extension添加的方法是必须要实现的。\n2.OC中的私有变量用@private修饰，私有方法用category\n<!--more-->\n3.NSInteger是基本数据类型Int或者Long的别名(NSInteger的定义typedef long NSInteger)，它的区别在于，NSInteger会根据系统是32位还是64位来决定是本身是int还是Long。\n\n4.block\n\n5.Objective-C的内存管理\n(1)主要有三种方式ARC(自动内存计数)、手动内存计数、内存池\n内存管理机制；当使用new,alloc和copy方法创建一个对象时,该对象的保留计数器值为1.当不再使用该对象时,要负责向该对象发送一条release或autorelease消息.这样,该对象将在使用寿命结束时被销毁.\n(2)堆与栈\n* 栈:是由编译器自动管理，无需我们手工控制；\n* 堆:释放工作由程序员控制，容易产生memory leak。\n6.属性关键字\n(1)atomic/nonatomic\n* atomic提供多线程安全。是防止在未写完的时候被另外一个线程读取，造成数据错误\n* non-atomic:在自己管理内存的环境中，解析的访问器保留并自动释放返回的值，如果指定了 nonatomic ，那么访问器只是简单地返回这个值\n(2)assign/weak\n* 用assign声明的变量在栈中可能不会自动赋值为nil，就会造成野指针错误\n* 用weak声明的变量在栈中会自动清空，赋值为nil\nassigin 可以用非OC对象,而weak必须用于OC对象\n在ARC中,在有可能出现循环引用的时候,往往要通过让其中一端使用weak来解决,比如:delegate代理属性\n(3)浅复制和深复制的区别?\n* 浅层复制：只复制指向对象的指针，而不复制引用对象本身。\n* 深层复制：复制引用对象本身。\n(4)copy/mutableCopy\n* copy是指针复制（浅拷贝）\n* mutableCopy就是对象复制（深拷贝）\n\n7.多态：不同对象以自己的方式响应相同的消息的能力叫做多态。子类指针可以赋值给父类对象。\n主要是将数据类型的确定由编译时，推迟到了运行时。\n(1)对于语句NSString*obj = [[NSData alloc] init]; obj在编译时和运行时分别时什么类型的对象?\n答：编译时是NSString的类型;运行时是NSData类型的对象。\n(2)id声明的对象具有运行时的特性，即可以指向任意类型的objcetive-c的对象.\n8.NSObject方法\n类方法：alloc,class,description\n实例方法：init,dealloc,performSelector\n\n9.通知与协议\n* 协议有控制链(has-a)的关系，通知没有。\n* 通知：一对多。代理/block：一对一。\n* OC中的多继承用委托代理实现\n\n10.事件的传递与响应\n传递：application->window->controller->view\n响应：view->controller->window->application\n重写hitTest:withEvent:方法\n\n11.延迟加载：用到的时候才去初始化。\n延迟加载可以避免内存过高，异步加载可以避免线程堵塞。\n\n12. 多线程\n(1)Object C中创建线程的方法是什么?如果在主线程中执行代码，方法是什么?如果想延时执行代码、方法又是什么?\n答：线程创建有三种方法\n* 使用NSThread创建\n* 使用GCD的dispatch\n* 使用子类化的NSOperation,然后将其加入NSOperationQueue;\n(2)在主线程执行代码，方法是performSelectorOnMainThread\n如果想延时执行代码可以用performSelector:onThread:withObject:waitUntilDone:\n(3)进程与线程\n进程有独立的地址空间\n线程有自己的堆栈和局部变量\n(4)队列：串行、并行、全局、主队列\n\n13.持久化存储机制：存到文件，存到NSUserDeaults(plist文件)，sqlite数据库\nNSUserDeaults数据存储在沙盒library下的Preferences文件夹。\n沙盒目录：documents、library(chches,preferences),tmp\nSDWebImage原理：内存中找->沙盒中找，缓存到内存->网络上获取，缓存到内存，缓存到沙盒\n\n14.网络\n(1)发起网络请求的对象：AFHTTPSessionManager、ASIHTTPRequest与NSURLConnection\n(2)http与socket\n* http:短连接，请求方式为客户端主动发起请求，服务器才能给响应，一次请求完毕后则断开连接，以节省资源。服务器不能主动给客户端响应（除非采取http长连接 技术）\n* socket:长连接，客户端和服务器可以保持连接通道，双方 都可以主动发送数据\n\n15.fmmpeg框架\n答：音视频编解码框架，内部使用UDP协议针对流媒体开发，内部开辟了六个端口来接受流媒体数据，完成快速接受之目的。 \n16.Cocoa Touch中一小部分可用的框架：\n* 音频和视频：Core Audio ，OpenAL ，Media Library ，AV Foundation\n* 数据管理 ：Core Data ，SQLite\n* 图形和动画 ：Core Animation ，OpenGL ES ，Quartz 2D\n* 网络：Bonjour ，WebKit ，BSD Sockets\n* 用户应用：Address Book ，Core Location ，Map Kit ，Store Kit\n\n17.isMemberOfClass 与 isKindOfClass \nisKindOfClass 不仅用来确定一个对象是否是一个类的成员,也可以用来确定一个对象是否派生自该类的类的成员\n,而isMemberOfClass 只能做到第一点\n\n18.UIViewController的生命周期\n-[ViewController initWithNibName:bundle:]；\n-[ViewController init]；\n-[ViewController loadView]；\n-[ViewController viewDidLoad]；\n-[ViewController viewWillDisappear:]；\n-[ViewController viewWillAppear:]；\n-[ViewController viewDidAppear:]；\n-[ViewController viewDidDisappear:]；\n\nReceived simulated memory warning.\n-[ViewController viewVillUnload]\n-[ViewController viewDidUnload]\n\n(1)创建Controller：\n* 通过storyBoard:\n> [UIStoryboard storyboardWithName:@\"\" bundle:nil]instantiateInitialViewController` \n> 此处bundle:nil 等价于 [NSBundle mainBundle]\n* 通过XIB\n    + 加载与控制器同名的XIB文件:使用`init`或`initWithNibName`加载\n    + 加载与控制器不同名的XIB Controller文件,通过`loadNibNamed`加载控制器（不同名需要修改file owner）\n```\nSecondViewController *secondVc = [[[NSBundle mainBundle]loadNibNamed:@\"SecondVC\" owner:nil options:nil] lastObject]\n```\n\n    + 加载与控制器不同名的XIB View文件,通过`loadNibNamed`加载控制器的view（不同名需要修改file owner）\n```\nSecondViewController *secondVc = [[SecondViewController alloc]init];\nsecondVc.view = [[[NSBundle mainBundle]loadNibNamed:@\"SecondViewController\" owner:nil options:nil] lastObject];\n```\n在创建控制器的时候直接指定要加载xib作为控制器的view,名称不相干\n> 需要修改xib文件的fileOwner进行关联\n> 需要将fileOwner里面的view指向xib里面的view\n(2)创建View:\n* 通过XIB：[[NSBundle alloc]loadNibNamed:@\"\" owner:self options:nil];\n\n19.OC单例\n```\n+(instancetype)shareNetworkTools{\n    static id instance;\n    static dispatch_once_t onceToken;\n    //onceToken默认等于0，如果是0就执行block，如果不是就不执行\n    NSLog(@\"%ld\",onceToken);\n    dispatch_once(&onceToken, ^{\n        instance = [[self alloc] init];\n    });\n    return instance;\n}\n```\n\nswift单例\n```\n/*\n//在swift中，类方法中不允许定义静态变量\nstatic var once_t: dispatch_once_t = 0\nstatic var instance: NetworkTools?\n//用于获取单例对象的类方法\nclass func shareNetworkTools() -> NetworkTools{\n    print(once_t)\n    dispatch_once(&once_t) { () -> Void in\n        instance = NetworkTools()\n    }\n    return instance!\n}\n*/\n//swift中的let是线程安全的\nstatic let instance: NetworkTools = NetworkTools()\nclass func shareNetworkTools() -> NetworkTools{\n    return instance\n}\n\n//init方法在需要的时候才创建\noverride init(){\nsuper.init()\nprint(\"----------\")\n}\n```\n\n","slug":"iOS面试知识点总结","published":1,"updated":"2017-07-14T03:57:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj53c1dwh002ih3jjzc8it3v5","content":"<p>1.category与extension的区别</p>\n<ul>\n<li>category可以不用继承系统类，直接给系统类添加方法，最大程度的体现了Objective-C的动态语言特性。可以用来定义私有方法。</li>\n<li>extension为一个类增加私有方法,属性或成员变量,并且新添加的方法一定要予以实现。Extension都是放在.m文件中@implementation的上方。<br>区别：Extension可以添加属性。另外Extension添加的方法是必须要实现的。<br>2.OC中的私有变量用@private修饰，私有方法用category<a id=\"more\"></a>\n3.NSInteger是基本数据类型Int或者Long的别名(NSInteger的定义typedef long NSInteger)，它的区别在于，NSInteger会根据系统是32位还是64位来决定是本身是int还是Long。</li>\n</ul>\n<p>4.block</p>\n<p>5.Objective-C的内存管理<br>(1)主要有三种方式ARC(自动内存计数)、手动内存计数、内存池<br>内存管理机制；当使用new,alloc和copy方法创建一个对象时,该对象的保留计数器值为1.当不再使用该对象时,要负责向该对象发送一条release或autorelease消息.这样,该对象将在使用寿命结束时被销毁.<br>(2)堆与栈</p>\n<ul>\n<li>栈:是由编译器自动管理，无需我们手工控制；</li>\n<li>堆:释放工作由程序员控制，容易产生memory leak。<br>6.属性关键字<br>(1)atomic/nonatomic</li>\n<li>atomic提供多线程安全。是防止在未写完的时候被另外一个线程读取，造成数据错误</li>\n<li>non-atomic:在自己管理内存的环境中，解析的访问器保留并自动释放返回的值，如果指定了 nonatomic ，那么访问器只是简单地返回这个值<br>(2)assign/weak</li>\n<li>用assign声明的变量在栈中可能不会自动赋值为nil，就会造成野指针错误</li>\n<li>用weak声明的变量在栈中会自动清空，赋值为nil<br>assigin 可以用非OC对象,而weak必须用于OC对象<br>在ARC中,在有可能出现循环引用的时候,往往要通过让其中一端使用weak来解决,比如:delegate代理属性<br>(3)浅复制和深复制的区别?</li>\n<li>浅层复制：只复制指向对象的指针，而不复制引用对象本身。</li>\n<li>深层复制：复制引用对象本身。<br>(4)copy/mutableCopy</li>\n<li>copy是指针复制（浅拷贝）</li>\n<li>mutableCopy就是对象复制（深拷贝）</li>\n</ul>\n<p>7.多态：不同对象以自己的方式响应相同的消息的能力叫做多态。子类指针可以赋值给父类对象。<br>主要是将数据类型的确定由编译时，推迟到了运行时。<br>(1)对于语句NSString*obj = [[NSData alloc] init]; obj在编译时和运行时分别时什么类型的对象?<br>答：编译时是NSString的类型;运行时是NSData类型的对象。<br>(2)id声明的对象具有运行时的特性，即可以指向任意类型的objcetive-c的对象.<br>8.NSObject方法<br>类方法：alloc,class,description<br>实例方法：init,dealloc,performSelector</p>\n<p>9.通知与协议</p>\n<ul>\n<li>协议有控制链(has-a)的关系，通知没有。</li>\n<li>通知：一对多。代理/block：一对一。</li>\n<li>OC中的多继承用委托代理实现</li>\n</ul>\n<p>10.事件的传递与响应<br>传递：application-&gt;window-&gt;controller-&gt;view<br>响应：view-&gt;controller-&gt;window-&gt;application<br>重写hitTest:withEvent:方法</p>\n<p>11.延迟加载：用到的时候才去初始化。<br>延迟加载可以避免内存过高，异步加载可以避免线程堵塞。</p>\n<ol>\n<li>多线程<br>(1)Object C中创建线程的方法是什么?如果在主线程中执行代码，方法是什么?如果想延时执行代码、方法又是什么?<br>答：线程创建有三种方法</li>\n</ol>\n<ul>\n<li>使用NSThread创建</li>\n<li>使用GCD的dispatch</li>\n<li>使用子类化的NSOperation,然后将其加入NSOperationQueue;<br>(2)在主线程执行代码，方法是performSelectorOnMainThread<br>如果想延时执行代码可以用performSelector:onThread:withObject:waitUntilDone:<br>(3)进程与线程<br>进程有独立的地址空间<br>线程有自己的堆栈和局部变量<br>(4)队列：串行、并行、全局、主队列</li>\n</ul>\n<p>13.持久化存储机制：存到文件，存到NSUserDeaults(plist文件)，sqlite数据库<br>NSUserDeaults数据存储在沙盒library下的Preferences文件夹。<br>沙盒目录：documents、library(chches,preferences),tmp<br>SDWebImage原理：内存中找-&gt;沙盒中找，缓存到内存-&gt;网络上获取，缓存到内存，缓存到沙盒</p>\n<p>14.网络<br>(1)发起网络请求的对象：AFHTTPSessionManager、ASIHTTPRequest与NSURLConnection<br>(2)http与socket</p>\n<ul>\n<li>http:短连接，请求方式为客户端主动发起请求，服务器才能给响应，一次请求完毕后则断开连接，以节省资源。服务器不能主动给客户端响应（除非采取http长连接 技术）</li>\n<li>socket:长连接，客户端和服务器可以保持连接通道，双方 都可以主动发送数据</li>\n</ul>\n<p>15.fmmpeg框架<br>答：音视频编解码框架，内部使用UDP协议针对流媒体开发，内部开辟了六个端口来接受流媒体数据，完成快速接受之目的。<br>16.Cocoa Touch中一小部分可用的框架：</p>\n<ul>\n<li>音频和视频：Core Audio ，OpenAL ，Media Library ，AV Foundation</li>\n<li>数据管理 ：Core Data ，SQLite</li>\n<li>图形和动画 ：Core Animation ，OpenGL ES ，Quartz 2D</li>\n<li>网络：Bonjour ，WebKit ，BSD Sockets</li>\n<li>用户应用：Address Book ，Core Location ，Map Kit ，Store Kit</li>\n</ul>\n<p>17.isMemberOfClass 与 isKindOfClass<br>isKindOfClass 不仅用来确定一个对象是否是一个类的成员,也可以用来确定一个对象是否派生自该类的类的成员<br>,而isMemberOfClass 只能做到第一点</p>\n<p>18.UIViewController的生命周期<br>-[ViewController initWithNibName:bundle:]；<br>-[ViewController init]；<br>-[ViewController loadView]；<br>-[ViewController viewDidLoad]；<br>-[ViewController viewWillDisappear:]；<br>-[ViewController viewWillAppear:]；<br>-[ViewController viewDidAppear:]；<br>-[ViewController viewDidDisappear:]；</p>\n<p>Received simulated memory warning.<br>-[ViewController viewVillUnload]<br>-[ViewController viewDidUnload]</p>\n<p>(1)创建Controller：</p>\n<ul>\n<li>通过storyBoard:<blockquote>\n<p>[UIStoryboard storyboardWithName:@”” bundle:nil]instantiateInitialViewController`<br>此处bundle:nil 等价于 [NSBundle mainBundle]</p>\n</blockquote>\n</li>\n<li><p>通过XIB</p>\n<ul>\n<li>加载与控制器同名的XIB文件:使用<code>init</code>或<code>initWithNibName</code>加载</li>\n<li><p>加载与控制器不同名的XIB Controller文件,通过<code>loadNibNamed</code>加载控制器（不同名需要修改file owner）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">SecondViewController *secondVc = [[[NSBundle mainBundle]loadNibNamed:@&quot;SecondVC&quot; owner:nil options:nil] lastObject]</div></pre></td></tr></table></figure>\n</li>\n<li><p>加载与控制器不同名的XIB View文件,通过<code>loadNibNamed</code>加载控制器的view（不同名需要修改file owner）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">SecondViewController *secondVc = [[SecondViewController alloc]init];</div><div class=\"line\">secondVc.view = [[[NSBundle mainBundle]loadNibNamed:@&quot;SecondViewController&quot; owner:nil options:nil] lastObject];</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p>在创建控制器的时候直接指定要加载xib作为控制器的view,名称不相干</p>\n<blockquote>\n<p>需要修改xib文件的fileOwner进行关联<br>需要将fileOwner里面的view指向xib里面的view<br>(2)创建View:</p>\n<ul>\n<li>通过XIB：[[NSBundle alloc]loadNibNamed:@”” owner:self options:nil];</li>\n</ul>\n</blockquote>\n<p>19.OC单例<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">+(instancetype)shareNetworkTools&#123;</div><div class=\"line\">    static id instance;</div><div class=\"line\">    static dispatch_once_t onceToken;</div><div class=\"line\">    //onceToken默认等于0，如果是0就执行block，如果不是就不执行</div><div class=\"line\">    NSLog(@&quot;%ld&quot;,onceToken);</div><div class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</div><div class=\"line\">        instance = [[self alloc] init];</div><div class=\"line\">    &#125;);</div><div class=\"line\">    return instance;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>swift单例<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*</div><div class=\"line\">//在swift中，类方法中不允许定义静态变量</div><div class=\"line\">static var once_t: dispatch_once_t = 0</div><div class=\"line\">static var instance: NetworkTools?</div><div class=\"line\">//用于获取单例对象的类方法</div><div class=\"line\">class func shareNetworkTools() -&gt; NetworkTools&#123;</div><div class=\"line\">    print(once_t)</div><div class=\"line\">    dispatch_once(&amp;once_t) &#123; () -&gt; Void in</div><div class=\"line\">        instance = NetworkTools()</div><div class=\"line\">    &#125;</div><div class=\"line\">    return instance!</div><div class=\"line\">&#125;</div><div class=\"line\">*/</div><div class=\"line\">//swift中的let是线程安全的</div><div class=\"line\">static let instance: NetworkTools = NetworkTools()</div><div class=\"line\">class func shareNetworkTools() -&gt; NetworkTools&#123;</div><div class=\"line\">    return instance</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//init方法在需要的时候才创建</div><div class=\"line\">override init()&#123;</div><div class=\"line\">super.init()</div><div class=\"line\">print(&quot;----------&quot;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>1.category与extension的区别</p>\n<ul>\n<li>category可以不用继承系统类，直接给系统类添加方法，最大程度的体现了Objective-C的动态语言特性。可以用来定义私有方法。</li>\n<li>extension为一个类增加私有方法,属性或成员变量,并且新添加的方法一定要予以实现。Extension都是放在.m文件中@implementation的上方。<br>区别：Extension可以添加属性。另外Extension添加的方法是必须要实现的。<br>2.OC中的私有变量用@private修饰，私有方法用category","more":"3.NSInteger是基本数据类型Int或者Long的别名(NSInteger的定义typedef long NSInteger)，它的区别在于，NSInteger会根据系统是32位还是64位来决定是本身是int还是Long。</li>\n</ul>\n<p>4.block</p>\n<p>5.Objective-C的内存管理<br>(1)主要有三种方式ARC(自动内存计数)、手动内存计数、内存池<br>内存管理机制；当使用new,alloc和copy方法创建一个对象时,该对象的保留计数器值为1.当不再使用该对象时,要负责向该对象发送一条release或autorelease消息.这样,该对象将在使用寿命结束时被销毁.<br>(2)堆与栈</p>\n<ul>\n<li>栈:是由编译器自动管理，无需我们手工控制；</li>\n<li>堆:释放工作由程序员控制，容易产生memory leak。<br>6.属性关键字<br>(1)atomic/nonatomic</li>\n<li>atomic提供多线程安全。是防止在未写完的时候被另外一个线程读取，造成数据错误</li>\n<li>non-atomic:在自己管理内存的环境中，解析的访问器保留并自动释放返回的值，如果指定了 nonatomic ，那么访问器只是简单地返回这个值<br>(2)assign/weak</li>\n<li>用assign声明的变量在栈中可能不会自动赋值为nil，就会造成野指针错误</li>\n<li>用weak声明的变量在栈中会自动清空，赋值为nil<br>assigin 可以用非OC对象,而weak必须用于OC对象<br>在ARC中,在有可能出现循环引用的时候,往往要通过让其中一端使用weak来解决,比如:delegate代理属性<br>(3)浅复制和深复制的区别?</li>\n<li>浅层复制：只复制指向对象的指针，而不复制引用对象本身。</li>\n<li>深层复制：复制引用对象本身。<br>(4)copy/mutableCopy</li>\n<li>copy是指针复制（浅拷贝）</li>\n<li>mutableCopy就是对象复制（深拷贝）</li>\n</ul>\n<p>7.多态：不同对象以自己的方式响应相同的消息的能力叫做多态。子类指针可以赋值给父类对象。<br>主要是将数据类型的确定由编译时，推迟到了运行时。<br>(1)对于语句NSString*obj = [[NSData alloc] init]; obj在编译时和运行时分别时什么类型的对象?<br>答：编译时是NSString的类型;运行时是NSData类型的对象。<br>(2)id声明的对象具有运行时的特性，即可以指向任意类型的objcetive-c的对象.<br>8.NSObject方法<br>类方法：alloc,class,description<br>实例方法：init,dealloc,performSelector</p>\n<p>9.通知与协议</p>\n<ul>\n<li>协议有控制链(has-a)的关系，通知没有。</li>\n<li>通知：一对多。代理/block：一对一。</li>\n<li>OC中的多继承用委托代理实现</li>\n</ul>\n<p>10.事件的传递与响应<br>传递：application-&gt;window-&gt;controller-&gt;view<br>响应：view-&gt;controller-&gt;window-&gt;application<br>重写hitTest:withEvent:方法</p>\n<p>11.延迟加载：用到的时候才去初始化。<br>延迟加载可以避免内存过高，异步加载可以避免线程堵塞。</p>\n<ol>\n<li>多线程<br>(1)Object C中创建线程的方法是什么?如果在主线程中执行代码，方法是什么?如果想延时执行代码、方法又是什么?<br>答：线程创建有三种方法</li>\n</ol>\n<ul>\n<li>使用NSThread创建</li>\n<li>使用GCD的dispatch</li>\n<li>使用子类化的NSOperation,然后将其加入NSOperationQueue;<br>(2)在主线程执行代码，方法是performSelectorOnMainThread<br>如果想延时执行代码可以用performSelector:onThread:withObject:waitUntilDone:<br>(3)进程与线程<br>进程有独立的地址空间<br>线程有自己的堆栈和局部变量<br>(4)队列：串行、并行、全局、主队列</li>\n</ul>\n<p>13.持久化存储机制：存到文件，存到NSUserDeaults(plist文件)，sqlite数据库<br>NSUserDeaults数据存储在沙盒library下的Preferences文件夹。<br>沙盒目录：documents、library(chches,preferences),tmp<br>SDWebImage原理：内存中找-&gt;沙盒中找，缓存到内存-&gt;网络上获取，缓存到内存，缓存到沙盒</p>\n<p>14.网络<br>(1)发起网络请求的对象：AFHTTPSessionManager、ASIHTTPRequest与NSURLConnection<br>(2)http与socket</p>\n<ul>\n<li>http:短连接，请求方式为客户端主动发起请求，服务器才能给响应，一次请求完毕后则断开连接，以节省资源。服务器不能主动给客户端响应（除非采取http长连接 技术）</li>\n<li>socket:长连接，客户端和服务器可以保持连接通道，双方 都可以主动发送数据</li>\n</ul>\n<p>15.fmmpeg框架<br>答：音视频编解码框架，内部使用UDP协议针对流媒体开发，内部开辟了六个端口来接受流媒体数据，完成快速接受之目的。<br>16.Cocoa Touch中一小部分可用的框架：</p>\n<ul>\n<li>音频和视频：Core Audio ，OpenAL ，Media Library ，AV Foundation</li>\n<li>数据管理 ：Core Data ，SQLite</li>\n<li>图形和动画 ：Core Animation ，OpenGL ES ，Quartz 2D</li>\n<li>网络：Bonjour ，WebKit ，BSD Sockets</li>\n<li>用户应用：Address Book ，Core Location ，Map Kit ，Store Kit</li>\n</ul>\n<p>17.isMemberOfClass 与 isKindOfClass<br>isKindOfClass 不仅用来确定一个对象是否是一个类的成员,也可以用来确定一个对象是否派生自该类的类的成员<br>,而isMemberOfClass 只能做到第一点</p>\n<p>18.UIViewController的生命周期<br>-[ViewController initWithNibName:bundle:]；<br>-[ViewController init]；<br>-[ViewController loadView]；<br>-[ViewController viewDidLoad]；<br>-[ViewController viewWillDisappear:]；<br>-[ViewController viewWillAppear:]；<br>-[ViewController viewDidAppear:]；<br>-[ViewController viewDidDisappear:]；</p>\n<p>Received simulated memory warning.<br>-[ViewController viewVillUnload]<br>-[ViewController viewDidUnload]</p>\n<p>(1)创建Controller：</p>\n<ul>\n<li>通过storyBoard:<blockquote>\n<p>[UIStoryboard storyboardWithName:@”” bundle:nil]instantiateInitialViewController`<br>此处bundle:nil 等价于 [NSBundle mainBundle]</p>\n</blockquote>\n</li>\n<li><p>通过XIB</p>\n<ul>\n<li>加载与控制器同名的XIB文件:使用<code>init</code>或<code>initWithNibName</code>加载</li>\n<li><p>加载与控制器不同名的XIB Controller文件,通过<code>loadNibNamed</code>加载控制器（不同名需要修改file owner）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">SecondViewController *secondVc = [[[NSBundle mainBundle]loadNibNamed:@&quot;SecondVC&quot; owner:nil options:nil] lastObject]</div></pre></td></tr></table></figure>\n</li>\n<li><p>加载与控制器不同名的XIB View文件,通过<code>loadNibNamed</code>加载控制器的view（不同名需要修改file owner）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">SecondViewController *secondVc = [[SecondViewController alloc]init];</div><div class=\"line\">secondVc.view = [[[NSBundle mainBundle]loadNibNamed:@&quot;SecondViewController&quot; owner:nil options:nil] lastObject];</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p>在创建控制器的时候直接指定要加载xib作为控制器的view,名称不相干</p>\n<blockquote>\n<p>需要修改xib文件的fileOwner进行关联<br>需要将fileOwner里面的view指向xib里面的view<br>(2)创建View:</p>\n<ul>\n<li>通过XIB：[[NSBundle alloc]loadNibNamed:@”” owner:self options:nil];</li>\n</ul>\n</blockquote>\n<p>19.OC单例<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">+(instancetype)shareNetworkTools&#123;</div><div class=\"line\">    static id instance;</div><div class=\"line\">    static dispatch_once_t onceToken;</div><div class=\"line\">    //onceToken默认等于0，如果是0就执行block，如果不是就不执行</div><div class=\"line\">    NSLog(@&quot;%ld&quot;,onceToken);</div><div class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</div><div class=\"line\">        instance = [[self alloc] init];</div><div class=\"line\">    &#125;);</div><div class=\"line\">    return instance;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>swift单例<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*</div><div class=\"line\">//在swift中，类方法中不允许定义静态变量</div><div class=\"line\">static var once_t: dispatch_once_t = 0</div><div class=\"line\">static var instance: NetworkTools?</div><div class=\"line\">//用于获取单例对象的类方法</div><div class=\"line\">class func shareNetworkTools() -&gt; NetworkTools&#123;</div><div class=\"line\">    print(once_t)</div><div class=\"line\">    dispatch_once(&amp;once_t) &#123; () -&gt; Void in</div><div class=\"line\">        instance = NetworkTools()</div><div class=\"line\">    &#125;</div><div class=\"line\">    return instance!</div><div class=\"line\">&#125;</div><div class=\"line\">*/</div><div class=\"line\">//swift中的let是线程安全的</div><div class=\"line\">static let instance: NetworkTools = NetworkTools()</div><div class=\"line\">class func shareNetworkTools() -&gt; NetworkTools&#123;</div><div class=\"line\">    return instance</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//init方法在需要的时候才创建</div><div class=\"line\">override init()&#123;</div><div class=\"line\">super.init()</div><div class=\"line\">print(&quot;----------&quot;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>"},{"title":"java开发环境配置","date":"2017-06-06T03:27:51.000Z","toc":true,"_content":"\nJava开发需要：\n1.JDK (Java Deverlopment Kit)\nJava开发工具包(JDK)是一个用于开发Java应用程序和小程序的软件开发环境。\n它包括Java运行时环境(JRE)，编译器/加载程序(JAVA)，编译器(javac)，归档器(jar)，文档生成(Javadoc)以及 Java 开发的其他工具。\n2.IDE (Integrated Development Environment)\n集成开发环境：MyEclipse,IDEA\n\n# tomcat\n## 1.下载：[http://tomcat.apache.org](http://tomcat.apache.org)\n## 2.修改权限，否则会提示`permission denny`错误：\n```\nsudo chmod 755 xxx/bin/*.sh  (xxx表示你tomcat放至的路径) \n```\n\n## 3.将Tomcat写入系统的环境变量PATH中。\n<!--more-->\n```\n$ pico .bash_profile \n```\n\n在打开的页面中，输入以下：\n```\nexport PATH=$PATH:tomcat_dir/bin;  \nexport PATH=$PATH:tomcat_dir/logs;  \n```\n\n其中tomcat_dir为tomcat根目录\n接着按下 control+x，再按 y 表示确定修改，最后回车。\n\n验证是否成功\n> $ echo $PATH\n显示如下:\n> $ -bash: /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Users/fuhua/Documents/Tomcat/apache-tomcat-8.0.30/bin: No such file or directory\n需要重新启动计算机，以便完成系统环境变量的配置。\n\n## 4.启动Tomcat.\n* 如果你完成将Tomcat写入系统的环境变量PATH中，你可以直接在终端输入 startup.sh ；\n* 如果你没有完成，那么就要定位到Tomcat的bin目录中，如在终端输入 \n```\n$ cd tomcat_dir/bin\n$ startup.sh\nTomcat started.\n```\n\n* 在浏览器中输入[http://localhost:8080/](http://localhost:8080/)\n如果出现Apache Tomcat界面，代表 tomcat 启动成功。\n\n\n# MySQL\n## 安装MySQL\n* 下载：[MySQL官网](https://dev.mysql.com/downloads/mysql/)\n* 安装完成时记得保存弹出框中的密码，这是mysql root账号和密码\n* 系统偏好设置中，点击MySQL开启MySQL Server服务\n## 修改root账户密码\n* 关闭MySQL Server服务\n* 终端输入\n```\n// 苹果系统下 mysql server 的安装地址\n$ cd /usr/local/mysql/bin/\n// 登录管理员权限\n$ sudo su\n// 禁止 mysql 验证功能\nsh-3.2# ./mysqld_safe --skip-grant-tables &\n//终端输出\n[1] 2487\nsh-3.2# Logging to '/usr/local/mysql-5.7.18-macos10.12-x86_64/data/192.168.1.143.err'.\n2017-06-06T06:35:36.6NZ mysqld_safe Starting mysqld daemon with databases from /usr/local/mysql-5.7.18-macos10.12-x86_64/data\nsh-3.2# ./mysql\nWelcome to the MySQL monitor.  Commands end with ; or \\g.\nYour MySQL connection id is 3\nServer version: 5.7.18 MySQL Community Server (GPL)\n\nCopyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.\n\nOracle is a registered trademark of Oracle Corporation and/or its\naffiliates. Other names may be trademarks of their respective\nowners.\n\nType 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\n\nmysql> FLUSH PRIVILEGES;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> SET PASSWORD FOR 'root'@'localhost' = PASSWORD('123456');\nQuery OK, 0 rows affected, 1 warning (0.00 sec)\n```\n\n## 安装MySQL Workbench\n[https://dev.mysql.com/downloads/workbench/](https://dev.mysql.com/downloads/workbench/)\nMySQL connections + ：输入connection name创建新链接\n\n## 加入系统环境变量 \n```\n$ cd /usr/local/mysql/bin\n$ ls\n//查看目录中是否有mysql\n$ vim ~/.bash_profile\n//在该文件中添加 PATH=$PATH:/usr/local/mysql/bin\n$ source ~/.bash_profile\n$ mysql -uroot -p   //登录mysql\n//输入密码后，登录成功会显示：\nWelcome to the MySQL monitor.  Commands end with ; or \\g.\nYour MySQL connection id is 22\nServer version: 5.7.18 MySQL Community Server (GPL)\n\nCopyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.\n\nOracle is a registered trademark of Oracle Corporation and/or its\naffiliates. Other names may be trademarks of their respective\nowners.\n\nType 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\n```\n\n可以通过以下名录修改密码：\n> $ $ SET PASSWORD FOR 'root'@'localhost' = PASSWORD('newpass');\n\n# JDK\n## 安装JDK\n### 下载：[JDK官网](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html)\n### 安装\n* mac自带jdk，安装目录：/System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home\n* 自己安装目录：/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home\n### 配置jdk环境变量\u0010\u0010\n（1）只针对当前用户\n```\n$ touch ~/.bash_profile  \n$ vim ~/.bash_profile  \n```\n\n在编辑器中添加如下内容：\n```\nJAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home\nCLASSPAHT=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\nPATH=$JAVA_HOME/bin:$PATH:\nexport JAVA_HOME\nexport CLASSPATH\nexport PATH\n```\n\n使系统变量生效，使用以下命令或重启电脑：\n```\n$ source .bash_profile\n```\n\n查看java版本：\n```\n$ java -version\n```\n\n检查系统变量是否生效：\n```\n$ echo $JAVA_HOME\n```\n\n（2）针对所有用户\n```\n$ cd /etc\n$ sudo vi profile\n```\n\n在编辑器最下面添加如下内容：\n```\nJAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home\nCLASSPAHT=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\nPATH=$JAVA_HOME/bin:$PATH:\n```\n\n接下来同上：\n```\n$ source .bash_profile\n$ java -version\n$ echo $JAVA_HOME\n```\n\n","source":"_posts/java开发环境配置.md","raw":"---\ntitle: java开发环境配置\ndate: 2017-06-06 11:27:51\ncategories: 笔记\ntags: [Java,web]\ntoc: true\n---\n\nJava开发需要：\n1.JDK (Java Deverlopment Kit)\nJava开发工具包(JDK)是一个用于开发Java应用程序和小程序的软件开发环境。\n它包括Java运行时环境(JRE)，编译器/加载程序(JAVA)，编译器(javac)，归档器(jar)，文档生成(Javadoc)以及 Java 开发的其他工具。\n2.IDE (Integrated Development Environment)\n集成开发环境：MyEclipse,IDEA\n\n# tomcat\n## 1.下载：[http://tomcat.apache.org](http://tomcat.apache.org)\n## 2.修改权限，否则会提示`permission denny`错误：\n```\nsudo chmod 755 xxx/bin/*.sh  (xxx表示你tomcat放至的路径) \n```\n\n## 3.将Tomcat写入系统的环境变量PATH中。\n<!--more-->\n```\n$ pico .bash_profile \n```\n\n在打开的页面中，输入以下：\n```\nexport PATH=$PATH:tomcat_dir/bin;  \nexport PATH=$PATH:tomcat_dir/logs;  \n```\n\n其中tomcat_dir为tomcat根目录\n接着按下 control+x，再按 y 表示确定修改，最后回车。\n\n验证是否成功\n> $ echo $PATH\n显示如下:\n> $ -bash: /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Users/fuhua/Documents/Tomcat/apache-tomcat-8.0.30/bin: No such file or directory\n需要重新启动计算机，以便完成系统环境变量的配置。\n\n## 4.启动Tomcat.\n* 如果你完成将Tomcat写入系统的环境变量PATH中，你可以直接在终端输入 startup.sh ；\n* 如果你没有完成，那么就要定位到Tomcat的bin目录中，如在终端输入 \n```\n$ cd tomcat_dir/bin\n$ startup.sh\nTomcat started.\n```\n\n* 在浏览器中输入[http://localhost:8080/](http://localhost:8080/)\n如果出现Apache Tomcat界面，代表 tomcat 启动成功。\n\n\n# MySQL\n## 安装MySQL\n* 下载：[MySQL官网](https://dev.mysql.com/downloads/mysql/)\n* 安装完成时记得保存弹出框中的密码，这是mysql root账号和密码\n* 系统偏好设置中，点击MySQL开启MySQL Server服务\n## 修改root账户密码\n* 关闭MySQL Server服务\n* 终端输入\n```\n// 苹果系统下 mysql server 的安装地址\n$ cd /usr/local/mysql/bin/\n// 登录管理员权限\n$ sudo su\n// 禁止 mysql 验证功能\nsh-3.2# ./mysqld_safe --skip-grant-tables &\n//终端输出\n[1] 2487\nsh-3.2# Logging to '/usr/local/mysql-5.7.18-macos10.12-x86_64/data/192.168.1.143.err'.\n2017-06-06T06:35:36.6NZ mysqld_safe Starting mysqld daemon with databases from /usr/local/mysql-5.7.18-macos10.12-x86_64/data\nsh-3.2# ./mysql\nWelcome to the MySQL monitor.  Commands end with ; or \\g.\nYour MySQL connection id is 3\nServer version: 5.7.18 MySQL Community Server (GPL)\n\nCopyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.\n\nOracle is a registered trademark of Oracle Corporation and/or its\naffiliates. Other names may be trademarks of their respective\nowners.\n\nType 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\n\nmysql> FLUSH PRIVILEGES;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> SET PASSWORD FOR 'root'@'localhost' = PASSWORD('123456');\nQuery OK, 0 rows affected, 1 warning (0.00 sec)\n```\n\n## 安装MySQL Workbench\n[https://dev.mysql.com/downloads/workbench/](https://dev.mysql.com/downloads/workbench/)\nMySQL connections + ：输入connection name创建新链接\n\n## 加入系统环境变量 \n```\n$ cd /usr/local/mysql/bin\n$ ls\n//查看目录中是否有mysql\n$ vim ~/.bash_profile\n//在该文件中添加 PATH=$PATH:/usr/local/mysql/bin\n$ source ~/.bash_profile\n$ mysql -uroot -p   //登录mysql\n//输入密码后，登录成功会显示：\nWelcome to the MySQL monitor.  Commands end with ; or \\g.\nYour MySQL connection id is 22\nServer version: 5.7.18 MySQL Community Server (GPL)\n\nCopyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.\n\nOracle is a registered trademark of Oracle Corporation and/or its\naffiliates. Other names may be trademarks of their respective\nowners.\n\nType 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\n```\n\n可以通过以下名录修改密码：\n> $ $ SET PASSWORD FOR 'root'@'localhost' = PASSWORD('newpass');\n\n# JDK\n## 安装JDK\n### 下载：[JDK官网](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html)\n### 安装\n* mac自带jdk，安装目录：/System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home\n* 自己安装目录：/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home\n### 配置jdk环境变量\u0010\u0010\n（1）只针对当前用户\n```\n$ touch ~/.bash_profile  \n$ vim ~/.bash_profile  \n```\n\n在编辑器中添加如下内容：\n```\nJAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home\nCLASSPAHT=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\nPATH=$JAVA_HOME/bin:$PATH:\nexport JAVA_HOME\nexport CLASSPATH\nexport PATH\n```\n\n使系统变量生效，使用以下命令或重启电脑：\n```\n$ source .bash_profile\n```\n\n查看java版本：\n```\n$ java -version\n```\n\n检查系统变量是否生效：\n```\n$ echo $JAVA_HOME\n```\n\n（2）针对所有用户\n```\n$ cd /etc\n$ sudo vi profile\n```\n\n在编辑器最下面添加如下内容：\n```\nJAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home\nCLASSPAHT=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\nPATH=$JAVA_HOME/bin:$PATH:\n```\n\n接下来同上：\n```\n$ source .bash_profile\n$ java -version\n$ echo $JAVA_HOME\n```\n\n","slug":"java开发环境配置","published":1,"updated":"2017-07-14T03:57:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj53c1dwi002kh3jjrsx7qjxh","content":"<p>Java开发需要：<br>1.JDK (Java Deverlopment Kit)<br>Java开发工具包(JDK)是一个用于开发Java应用程序和小程序的软件开发环境。<br>它包括Java运行时环境(JRE)，编译器/加载程序(JAVA)，编译器(javac)，归档器(jar)，文档生成(Javadoc)以及 Java 开发的其他工具。<br>2.IDE (Integrated Development Environment)<br>集成开发环境：MyEclipse,IDEA</p>\n<h1 id=\"tomcat\"><a href=\"#tomcat\" class=\"headerlink\" title=\"tomcat\"></a>tomcat</h1><h2 id=\"1-下载：http-tomcat-apache-org\"><a href=\"#1-下载：http-tomcat-apache-org\" class=\"headerlink\" title=\"1.下载：http://tomcat.apache.org\"></a>1.下载：<a href=\"http://tomcat.apache.org\" target=\"_blank\" rel=\"external\">http://tomcat.apache.org</a></h2><h2 id=\"2-修改权限，否则会提示permission-denny错误：\"><a href=\"#2-修改权限，否则会提示permission-denny错误：\" class=\"headerlink\" title=\"2.修改权限，否则会提示permission denny错误：\"></a>2.修改权限，否则会提示<code>permission denny</code>错误：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo chmod 755 xxx/bin/*.sh  (xxx表示你tomcat放至的路径)</div></pre></td></tr></table></figure>\n<h2 id=\"3-将Tomcat写入系统的环境变量PATH中。\"><a href=\"#3-将Tomcat写入系统的环境变量PATH中。\" class=\"headerlink\" title=\"3.将Tomcat写入系统的环境变量PATH中。\"></a>3.将Tomcat写入系统的环境变量PATH中。</h2><a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ pico .bash_profile</div></pre></td></tr></table></figure>\n<p>在打开的页面中，输入以下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">export PATH=$PATH:tomcat_dir/bin;  </div><div class=\"line\">export PATH=$PATH:tomcat_dir/logs;</div></pre></td></tr></table></figure></p>\n<p>其中tomcat_dir为tomcat根目录<br>接着按下 control+x，再按 y 表示确定修改，最后回车。</p>\n<p>验证是否成功</p>\n<blockquote>\n<p>$ echo $PATH<br>显示如下:<br>$ -bash: /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Users/fuhua/Documents/Tomcat/apache-tomcat-8.0.30/bin: No such file or directory<br>需要重新启动计算机，以便完成系统环境变量的配置。</p>\n</blockquote>\n<h2 id=\"4-启动Tomcat\"><a href=\"#4-启动Tomcat\" class=\"headerlink\" title=\"4.启动Tomcat.\"></a>4.启动Tomcat.</h2><ul>\n<li>如果你完成将Tomcat写入系统的环境变量PATH中，你可以直接在终端输入 startup.sh ；</li>\n<li><p>如果你没有完成，那么就要定位到Tomcat的bin目录中，如在终端输入 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd tomcat_dir/bin</div><div class=\"line\">$ startup.sh</div><div class=\"line\">Tomcat started.</div></pre></td></tr></table></figure>\n</li>\n<li><p>在浏览器中输入<a href=\"http://localhost:8080/\" target=\"_blank\" rel=\"external\">http://localhost:8080/</a><br>如果出现Apache Tomcat界面，代表 tomcat 启动成功。</p>\n</li>\n</ul>\n<h1 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h1><h2 id=\"安装MySQL\"><a href=\"#安装MySQL\" class=\"headerlink\" title=\"安装MySQL\"></a>安装MySQL</h2><ul>\n<li>下载：<a href=\"https://dev.mysql.com/downloads/mysql/\" target=\"_blank\" rel=\"external\">MySQL官网</a></li>\n<li>安装完成时记得保存弹出框中的密码，这是mysql root账号和密码</li>\n<li>系统偏好设置中，点击MySQL开启MySQL Server服务<h2 id=\"修改root账户密码\"><a href=\"#修改root账户密码\" class=\"headerlink\" title=\"修改root账户密码\"></a>修改root账户密码</h2></li>\n<li>关闭MySQL Server服务</li>\n<li>终端输入<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 苹果系统下 mysql server 的安装地址</div><div class=\"line\">$ cd /usr/local/mysql/bin/</div><div class=\"line\">// 登录管理员权限</div><div class=\"line\">$ sudo su</div><div class=\"line\">// 禁止 mysql 验证功能</div><div class=\"line\">sh-3.2# ./mysqld_safe --skip-grant-tables &amp;</div><div class=\"line\">//终端输出</div><div class=\"line\">[1] 2487</div><div class=\"line\">sh-3.2# Logging to &apos;/usr/local/mysql-5.7.18-macos10.12-x86_64/data/192.168.1.143.err&apos;.</div><div class=\"line\">2017-06-06T06:35:36.6NZ mysqld_safe Starting mysqld daemon with databases from /usr/local/mysql-5.7.18-macos10.12-x86_64/data</div><div class=\"line\">sh-3.2# ./mysql</div><div class=\"line\">Welcome to the MySQL monitor.  Commands end with ; or \\g.</div><div class=\"line\">Your MySQL connection id is 3</div><div class=\"line\">Server version: 5.7.18 MySQL Community Server (GPL)</div><div class=\"line\"></div><div class=\"line\">Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.</div><div class=\"line\"></div><div class=\"line\">Oracle is a registered trademark of Oracle Corporation and/or its</div><div class=\"line\">affiliates. Other names may be trademarks of their respective</div><div class=\"line\">owners.</div><div class=\"line\"></div><div class=\"line\">Type &apos;help;&apos; or &apos;\\h&apos; for help. Type &apos;\\c&apos; to clear the current input statement.</div><div class=\"line\"></div><div class=\"line\">mysql&gt; FLUSH PRIVILEGES;</div><div class=\"line\">Query OK, 0 rows affected (0.00 sec)</div><div class=\"line\"></div><div class=\"line\">mysql&gt; SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos; = PASSWORD(&apos;123456&apos;);</div><div class=\"line\">Query OK, 0 rows affected, 1 warning (0.00 sec)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"安装MySQL-Workbench\"><a href=\"#安装MySQL-Workbench\" class=\"headerlink\" title=\"安装MySQL Workbench\"></a>安装MySQL Workbench</h2><p><a href=\"https://dev.mysql.com/downloads/workbench/\" target=\"_blank\" rel=\"external\">https://dev.mysql.com/downloads/workbench/</a><br>MySQL connections + ：输入connection name创建新链接</p>\n<h2 id=\"加入系统环境变量\"><a href=\"#加入系统环境变量\" class=\"headerlink\" title=\"加入系统环境变量\"></a>加入系统环境变量</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd /usr/local/mysql/bin</div><div class=\"line\">$ ls</div><div class=\"line\">//查看目录中是否有mysql</div><div class=\"line\">$ vim ~/.bash_profile</div><div class=\"line\">//在该文件中添加 PATH=$PATH:/usr/local/mysql/bin</div><div class=\"line\">$ source ~/.bash_profile</div><div class=\"line\">$ mysql -uroot -p   //登录mysql</div><div class=\"line\">//输入密码后，登录成功会显示：</div><div class=\"line\">Welcome to the MySQL monitor.  Commands end with ; or \\g.</div><div class=\"line\">Your MySQL connection id is 22</div><div class=\"line\">Server version: 5.7.18 MySQL Community Server (GPL)</div><div class=\"line\"></div><div class=\"line\">Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.</div><div class=\"line\"></div><div class=\"line\">Oracle is a registered trademark of Oracle Corporation and/or its</div><div class=\"line\">affiliates. Other names may be trademarks of their respective</div><div class=\"line\">owners.</div><div class=\"line\"></div><div class=\"line\">Type &apos;help;&apos; or &apos;\\h&apos; for help. Type &apos;\\c&apos; to clear the current input statement.</div></pre></td></tr></table></figure>\n<p>可以通过以下名录修改密码：</p>\n<blockquote>\n<p>$ $ SET PASSWORD FOR ‘root’@’localhost’ = PASSWORD(‘newpass’);</p>\n</blockquote>\n<h1 id=\"JDK\"><a href=\"#JDK\" class=\"headerlink\" title=\"JDK\"></a>JDK</h1><h2 id=\"安装JDK\"><a href=\"#安装JDK\" class=\"headerlink\" title=\"安装JDK\"></a>安装JDK</h2><h3 id=\"下载：JDK官网\"><a href=\"#下载：JDK官网\" class=\"headerlink\" title=\"下载：JDK官网\"></a>下载：<a href=\"http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\" target=\"_blank\" rel=\"external\">JDK官网</a></h3><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><ul>\n<li>mac自带jdk，安装目录：/System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home</li>\n<li>自己安装目录：/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home<h3 id=\"配置jdk环境变量\"><a href=\"#配置jdk环境变量\" class=\"headerlink\" title=\"配置jdk环境变量\u0010\u0010\"></a>配置jdk环境变量\u0010\u0010</h3>（1）只针对当前用户<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ touch ~/.bash_profile  </div><div class=\"line\">$ vim ~/.bash_profile</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>在编辑器中添加如下内容：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home</div><div class=\"line\">CLASSPAHT=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</div><div class=\"line\">PATH=$JAVA_HOME/bin:$PATH:</div><div class=\"line\">export JAVA_HOME</div><div class=\"line\">export CLASSPATH</div><div class=\"line\">export PATH</div></pre></td></tr></table></figure></p>\n<p>使系统变量生效，使用以下命令或重启电脑：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ source .bash_profile</div></pre></td></tr></table></figure></p>\n<p>查看java版本：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ java -version</div></pre></td></tr></table></figure></p>\n<p>检查系统变量是否生效：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ echo $JAVA_HOME</div></pre></td></tr></table></figure></p>\n<p>（2）针对所有用户<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd /etc</div><div class=\"line\">$ sudo vi profile</div></pre></td></tr></table></figure></p>\n<p>在编辑器最下面添加如下内容：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home</div><div class=\"line\">CLASSPAHT=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</div><div class=\"line\">PATH=$JAVA_HOME/bin:$PATH:</div></pre></td></tr></table></figure></p>\n<p>接下来同上：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ source .bash_profile</div><div class=\"line\">$ java -version</div><div class=\"line\">$ echo $JAVA_HOME</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>Java开发需要：<br>1.JDK (Java Deverlopment Kit)<br>Java开发工具包(JDK)是一个用于开发Java应用程序和小程序的软件开发环境。<br>它包括Java运行时环境(JRE)，编译器/加载程序(JAVA)，编译器(javac)，归档器(jar)，文档生成(Javadoc)以及 Java 开发的其他工具。<br>2.IDE (Integrated Development Environment)<br>集成开发环境：MyEclipse,IDEA</p>\n<h1 id=\"tomcat\"><a href=\"#tomcat\" class=\"headerlink\" title=\"tomcat\"></a>tomcat</h1><h2 id=\"1-下载：http-tomcat-apache-org\"><a href=\"#1-下载：http-tomcat-apache-org\" class=\"headerlink\" title=\"1.下载：http://tomcat.apache.org\"></a>1.下载：<a href=\"http://tomcat.apache.org\" target=\"_blank\" rel=\"external\">http://tomcat.apache.org</a></h2><h2 id=\"2-修改权限，否则会提示permission-denny错误：\"><a href=\"#2-修改权限，否则会提示permission-denny错误：\" class=\"headerlink\" title=\"2.修改权限，否则会提示permission denny错误：\"></a>2.修改权限，否则会提示<code>permission denny</code>错误：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo chmod 755 xxx/bin/*.sh  (xxx表示你tomcat放至的路径)</div></pre></td></tr></table></figure>\n<h2 id=\"3-将Tomcat写入系统的环境变量PATH中。\"><a href=\"#3-将Tomcat写入系统的环境变量PATH中。\" class=\"headerlink\" title=\"3.将Tomcat写入系统的环境变量PATH中。\"></a>3.将Tomcat写入系统的环境变量PATH中。</h2>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ pico .bash_profile</div></pre></td></tr></table></figure>\n<p>在打开的页面中，输入以下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">export PATH=$PATH:tomcat_dir/bin;  </div><div class=\"line\">export PATH=$PATH:tomcat_dir/logs;</div></pre></td></tr></table></figure></p>\n<p>其中tomcat_dir为tomcat根目录<br>接着按下 control+x，再按 y 表示确定修改，最后回车。</p>\n<p>验证是否成功</p>\n<blockquote>\n<p>$ echo $PATH<br>显示如下:<br>$ -bash: /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Users/fuhua/Documents/Tomcat/apache-tomcat-8.0.30/bin: No such file or directory<br>需要重新启动计算机，以便完成系统环境变量的配置。</p>\n</blockquote>\n<h2 id=\"4-启动Tomcat\"><a href=\"#4-启动Tomcat\" class=\"headerlink\" title=\"4.启动Tomcat.\"></a>4.启动Tomcat.</h2><ul>\n<li>如果你完成将Tomcat写入系统的环境变量PATH中，你可以直接在终端输入 startup.sh ；</li>\n<li><p>如果你没有完成，那么就要定位到Tomcat的bin目录中，如在终端输入 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd tomcat_dir/bin</div><div class=\"line\">$ startup.sh</div><div class=\"line\">Tomcat started.</div></pre></td></tr></table></figure>\n</li>\n<li><p>在浏览器中输入<a href=\"http://localhost:8080/\" target=\"_blank\" rel=\"external\">http://localhost:8080/</a><br>如果出现Apache Tomcat界面，代表 tomcat 启动成功。</p>\n</li>\n</ul>\n<h1 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h1><h2 id=\"安装MySQL\"><a href=\"#安装MySQL\" class=\"headerlink\" title=\"安装MySQL\"></a>安装MySQL</h2><ul>\n<li>下载：<a href=\"https://dev.mysql.com/downloads/mysql/\" target=\"_blank\" rel=\"external\">MySQL官网</a></li>\n<li>安装完成时记得保存弹出框中的密码，这是mysql root账号和密码</li>\n<li>系统偏好设置中，点击MySQL开启MySQL Server服务<h2 id=\"修改root账户密码\"><a href=\"#修改root账户密码\" class=\"headerlink\" title=\"修改root账户密码\"></a>修改root账户密码</h2></li>\n<li>关闭MySQL Server服务</li>\n<li>终端输入<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 苹果系统下 mysql server 的安装地址</div><div class=\"line\">$ cd /usr/local/mysql/bin/</div><div class=\"line\">// 登录管理员权限</div><div class=\"line\">$ sudo su</div><div class=\"line\">// 禁止 mysql 验证功能</div><div class=\"line\">sh-3.2# ./mysqld_safe --skip-grant-tables &amp;</div><div class=\"line\">//终端输出</div><div class=\"line\">[1] 2487</div><div class=\"line\">sh-3.2# Logging to &apos;/usr/local/mysql-5.7.18-macos10.12-x86_64/data/192.168.1.143.err&apos;.</div><div class=\"line\">2017-06-06T06:35:36.6NZ mysqld_safe Starting mysqld daemon with databases from /usr/local/mysql-5.7.18-macos10.12-x86_64/data</div><div class=\"line\">sh-3.2# ./mysql</div><div class=\"line\">Welcome to the MySQL monitor.  Commands end with ; or \\g.</div><div class=\"line\">Your MySQL connection id is 3</div><div class=\"line\">Server version: 5.7.18 MySQL Community Server (GPL)</div><div class=\"line\"></div><div class=\"line\">Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.</div><div class=\"line\"></div><div class=\"line\">Oracle is a registered trademark of Oracle Corporation and/or its</div><div class=\"line\">affiliates. Other names may be trademarks of their respective</div><div class=\"line\">owners.</div><div class=\"line\"></div><div class=\"line\">Type &apos;help;&apos; or &apos;\\h&apos; for help. Type &apos;\\c&apos; to clear the current input statement.</div><div class=\"line\"></div><div class=\"line\">mysql&gt; FLUSH PRIVILEGES;</div><div class=\"line\">Query OK, 0 rows affected (0.00 sec)</div><div class=\"line\"></div><div class=\"line\">mysql&gt; SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos; = PASSWORD(&apos;123456&apos;);</div><div class=\"line\">Query OK, 0 rows affected, 1 warning (0.00 sec)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"安装MySQL-Workbench\"><a href=\"#安装MySQL-Workbench\" class=\"headerlink\" title=\"安装MySQL Workbench\"></a>安装MySQL Workbench</h2><p><a href=\"https://dev.mysql.com/downloads/workbench/\" target=\"_blank\" rel=\"external\">https://dev.mysql.com/downloads/workbench/</a><br>MySQL connections + ：输入connection name创建新链接</p>\n<h2 id=\"加入系统环境变量\"><a href=\"#加入系统环境变量\" class=\"headerlink\" title=\"加入系统环境变量\"></a>加入系统环境变量</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd /usr/local/mysql/bin</div><div class=\"line\">$ ls</div><div class=\"line\">//查看目录中是否有mysql</div><div class=\"line\">$ vim ~/.bash_profile</div><div class=\"line\">//在该文件中添加 PATH=$PATH:/usr/local/mysql/bin</div><div class=\"line\">$ source ~/.bash_profile</div><div class=\"line\">$ mysql -uroot -p   //登录mysql</div><div class=\"line\">//输入密码后，登录成功会显示：</div><div class=\"line\">Welcome to the MySQL monitor.  Commands end with ; or \\g.</div><div class=\"line\">Your MySQL connection id is 22</div><div class=\"line\">Server version: 5.7.18 MySQL Community Server (GPL)</div><div class=\"line\"></div><div class=\"line\">Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.</div><div class=\"line\"></div><div class=\"line\">Oracle is a registered trademark of Oracle Corporation and/or its</div><div class=\"line\">affiliates. Other names may be trademarks of their respective</div><div class=\"line\">owners.</div><div class=\"line\"></div><div class=\"line\">Type &apos;help;&apos; or &apos;\\h&apos; for help. Type &apos;\\c&apos; to clear the current input statement.</div></pre></td></tr></table></figure>\n<p>可以通过以下名录修改密码：</p>\n<blockquote>\n<p>$ $ SET PASSWORD FOR ‘root’@’localhost’ = PASSWORD(‘newpass’);</p>\n</blockquote>\n<h1 id=\"JDK\"><a href=\"#JDK\" class=\"headerlink\" title=\"JDK\"></a>JDK</h1><h2 id=\"安装JDK\"><a href=\"#安装JDK\" class=\"headerlink\" title=\"安装JDK\"></a>安装JDK</h2><h3 id=\"下载：JDK官网\"><a href=\"#下载：JDK官网\" class=\"headerlink\" title=\"下载：JDK官网\"></a>下载：<a href=\"http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\" target=\"_blank\" rel=\"external\">JDK官网</a></h3><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><ul>\n<li>mac自带jdk，安装目录：/System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home</li>\n<li>自己安装目录：/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home<h3 id=\"配置jdk环境变量\"><a href=\"#配置jdk环境变量\" class=\"headerlink\" title=\"配置jdk环境变量\u0010\u0010\"></a>配置jdk环境变量\u0010\u0010</h3>（1）只针对当前用户<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ touch ~/.bash_profile  </div><div class=\"line\">$ vim ~/.bash_profile</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>在编辑器中添加如下内容：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home</div><div class=\"line\">CLASSPAHT=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</div><div class=\"line\">PATH=$JAVA_HOME/bin:$PATH:</div><div class=\"line\">export JAVA_HOME</div><div class=\"line\">export CLASSPATH</div><div class=\"line\">export PATH</div></pre></td></tr></table></figure></p>\n<p>使系统变量生效，使用以下命令或重启电脑：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ source .bash_profile</div></pre></td></tr></table></figure></p>\n<p>查看java版本：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ java -version</div></pre></td></tr></table></figure></p>\n<p>检查系统变量是否生效：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ echo $JAVA_HOME</div></pre></td></tr></table></figure></p>\n<p>（2）针对所有用户<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd /etc</div><div class=\"line\">$ sudo vi profile</div></pre></td></tr></table></figure></p>\n<p>在编辑器最下面添加如下内容：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home</div><div class=\"line\">CLASSPAHT=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</div><div class=\"line\">PATH=$JAVA_HOME/bin:$PATH:</div></pre></td></tr></table></figure></p>\n<p>接下来同上：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ source .bash_profile</div><div class=\"line\">$ java -version</div><div class=\"line\">$ echo $JAVA_HOME</div></pre></td></tr></table></figure></p>"},{"title":"mac显示隐藏文件","date":"2017-03-21T10:37:39.000Z","_content":"\n1.显示隐藏文件\n```\ndefaults write com.apple.finder AppleShowAllFiles Yes && killall Finder \n```\n\n2.不显示隐藏文件\n```\ndefaults write com.apple.finder AppleShowAllFiles No && killall Finder \n```\n\n3.删除文件夹下的所有 .git 文件\n```\nfind . -name \".git\" | xargs rm -Rf　　\n```\n","source":"_posts/mac显示隐藏文件.md","raw":"---\ntitle: mac显示隐藏文件\ndate: 2017-03-21 18:37:39\ncategories: 笔记\ntags: [技巧,隐藏文件]\n---\n\n1.显示隐藏文件\n```\ndefaults write com.apple.finder AppleShowAllFiles Yes && killall Finder \n```\n\n2.不显示隐藏文件\n```\ndefaults write com.apple.finder AppleShowAllFiles No && killall Finder \n```\n\n3.删除文件夹下的所有 .git 文件\n```\nfind . -name \".git\" | xargs rm -Rf　　\n```\n","slug":"mac显示隐藏文件","published":1,"updated":"2017-07-14T03:57:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj53c1dwj002nh3jjcxi5lql3","content":"<p>1.显示隐藏文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">defaults write com.apple.finder AppleShowAllFiles Yes &amp;&amp; killall Finder</div></pre></td></tr></table></figure></p>\n<p>2.不显示隐藏文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">defaults write com.apple.finder AppleShowAllFiles No &amp;&amp; killall Finder</div></pre></td></tr></table></figure></p>\n<p>3.删除文件夹下的所有 .git 文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">find . -name &quot;.git&quot; | xargs rm -Rf</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>1.显示隐藏文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">defaults write com.apple.finder AppleShowAllFiles Yes &amp;&amp; killall Finder</div></pre></td></tr></table></figure></p>\n<p>2.不显示隐藏文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">defaults write com.apple.finder AppleShowAllFiles No &amp;&amp; killall Finder</div></pre></td></tr></table></figure></p>\n<p>3.删除文件夹下的所有 .git 文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">find . -name &quot;.git&quot; | xargs rm -Rf</div></pre></td></tr></table></figure></p>\n"},{"title":"mysql学习笔记","date":"2017-06-08T05:41:17.000Z","toc":true,"_content":"\n## 数据库\n### 创建数据库\n```\ncreate database db;\n```\n\n### 删除数据库\n```\ndrop database db;\n```\n\n### 查看数据库\n<!--more-->\n```\nshow databases;\n```\n\n### 使用数据库\n```\nuse db;\n```\n\n## 表\n### 创建表\n```\nCREATE TABLE db.tb (\n`id` INT NOT NULL AUTO_INCREMENT,\n`name` VARCHAR(45) NOT NULL,\nPRIMARY KEY (`cid`));\n```\n\n### 删除表\n```\ndrop table tb\n```\n\n### 修改表名\n```\nRENAME TABLE tb TO new_tbname;\nALTER TABLE tb RENAME TO new_tbname;\n```\n\n### 初始化表(清空)\n```\nTRUNCATE TABLE tb\n```\n\n### 复制表：\n```\nCREATE TABLE tb_name2 SELECT * FROM tb_name;\n```\n或者部分复制：\n```\nCREATE TABLE tb_name2 SELECT id,name FROM tb_name;\n```\n\n### 查看数据库中可用的表：\n```\nSHOW TABLES;\n```\n\n### 查看表的结构：\n```\nDESCRIBE tb_name;\nSHOW COLUMNS in tb_name; 　　//from也可以\n```\n\n## 列/约束\nALTER TABLE tb ADD[CHANGE,RENAME,DROP]\n### 增加列/约束\n```\nalter table tb add column name VARCHAR(45) not null after id,add primary key(id);\n```\n\n### 删除列/约束\n```\nalter table tb drop col2 drop primary key(id);\n```\n\n### 修改列/约束\nALTER TABLE tb MODIFY col2 int NOT NULL DEFAULT 100 add col1 int identity(1,1);\nALTER TABLE tb ALTER col2 SET DEFAULT 1000;\nALTER TABLE tb ALTER col2 DROP DEFAULT;\n\n### 约束\nprimary key,not null,unique,asc/desc/default 0/AUTO_INCREMENT/zerofill\n\n## 单表操作\n### 插入\n```\ninsert into tb(col1,col2) values(value1,value2)\n```\n\n### 删除\n```\ndelete from tb [WHERE Clause]\n```\n\n### 更新\n```\nupdate tb set col1=value1 [WHERE Clause]\n```\n\n使用MySQL执行update的时候报错：\n```\nError Code: 1175. You are using safe update mode and you tried to update a table without a WHERE that uses a KEY column To disable safe mode, toggle the option in Preferences -> SQL Queries and reconnect.\n```\n\n解决方法：\n执行命令 SET SQL_SAFE_UPDATES = 0;  //修改下数据库模式\n如果想要提高数据库安全等级，可以在恢复回原有的设置，执行命令：SET SQL_SAFE_UPDATES = 1;\n\n### 查找\n```\nselect * from tb [WHERE Clause]\n```\n\n### where\n* =、>、<、<> and/not and  or  is null/is not null\n* 分组查询：order by/group by/having\n```\nselect * from tb order by col1,col2 asc/desc\n```\n\n* like\n```\nSELECT field1, field2,...fieldN \nFROM tb\nWHERE field1 LIKE condition1 [AND [OR]] filed2 = 'somevalue'\n```\n\n* in/not in\n```\nselect * from tb1 where a [not] in (value1,value2,value3)\n```\n\n* between/not between\n\n* exists/not exists\n\n* 全选/全不选\nwhere 1=1 表示选择全部    \nwhere 1=2 表示全部不选，\n\n* 分页\n```\ndeclare @start int,@end int\n@sql  nvarchar(600)\nset @sql=’select top’+str(@end-@start+1)+’+from T where rid not in(select top’+str(@str-1)+’Rid from T where Rid>-1)’\nexec sp_executesql @sql\n```\n\n* 删除重复记录\n```\n1),delete from tablename where id not in (select max(id) from tablename group by col1,col2,...)\n2),select distinct * into temp from tablename\ndelete from tablename\ninsert into tablename select * from temp\n```\n\n* 列出数据库里所有的表名\n```\nselect name from sysobjects where type='U' // U代表用户\n```\n\n* 列出表里的所有的列名\n```\nselect name from syscolumns where id=object_id('TableName')\nselect column_name,data_type from information_schema.columns\nwhere table_name = '表名'   //查询某一个表的字段和数据类型\n```\n\n* 获取当前数据库中的所有用户表\n```\nselect Name from sysobjects where xtype='u' and status>=0\n```\n\n## 多表操作\n### union\n通过组合其他两个结果表（例如 TABLE1 和 TABLE2）并消去表中任何重复行而派生出一个结果表。当 ALL 随 UNION 一起使用时（即 UNION ALL），不消除重复行。两种情况下，派生表的每一行不是来自 TABLE1 就是来自 TABLE2。\n```\nSELECT expression1, expression2, ... expression_n\nFROM tb1\n[WHERE conditions]\nUNION [ALL | DISTINCT]\nSELECT expression1, expression2, ... expression_n\nFROM tb2\n[WHERE conditions];\n\nDISTINCT: 可选，删除结果集中重复的数据。默认情况下 UNION 操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没啥影响。\nALL: 可选，返回所有结果集，包含重复数据。\n```\n\n### EXCEPT\n通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个结果表。当 ALL 随 EXCEPT 一起使用时 (EXCEPT ALL)，不消除重复行。\n### INTERSECT\n通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表。当 ALL 随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。\n\n注：使用运算词的几个查询结果行必须是一致的。 \n\n### 分组：group by\ncount,sum,max,min,avg\n\n### 连接：join\n* INNER JOIN（内连接,或等值连接）：获取两个表中字段匹配关系的记录。\n```\nSELECT a.col1, a.col2, b.col3 FROM tb1 a INNER JOIN tb2 b\nON a.col1 = b.col1;\n等价于\nSELECT a.col1, a.col2, b.col3 FROM tb1 a, tb2 b \nWHERE a.col1 = b.col1;\n```\n\n* LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。\n```\nSELECT a.col1, a.col2, b.col3 FROM tb1 a LEFT JOIN tb2 b \nON a.col1 = b.col1;\n```\n\n* RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。\n```\nSELECT a.col1, a.col2, b.col3 FROM tb1 a RIGHT JOIN tb2 b \nON a.col1 = b.col1;\n```\n\n## 高级用法\n### 索引\n\n### 临时表\n\n### 视图\n","source":"_posts/mysql学习笔记.md","raw":"---\ntitle: mysql学习笔记\ndate: 2017-06-08 13:41:17\ncategories: 笔记\ntags: [Java,mysql]\ntoc: true\n---\n\n## 数据库\n### 创建数据库\n```\ncreate database db;\n```\n\n### 删除数据库\n```\ndrop database db;\n```\n\n### 查看数据库\n<!--more-->\n```\nshow databases;\n```\n\n### 使用数据库\n```\nuse db;\n```\n\n## 表\n### 创建表\n```\nCREATE TABLE db.tb (\n`id` INT NOT NULL AUTO_INCREMENT,\n`name` VARCHAR(45) NOT NULL,\nPRIMARY KEY (`cid`));\n```\n\n### 删除表\n```\ndrop table tb\n```\n\n### 修改表名\n```\nRENAME TABLE tb TO new_tbname;\nALTER TABLE tb RENAME TO new_tbname;\n```\n\n### 初始化表(清空)\n```\nTRUNCATE TABLE tb\n```\n\n### 复制表：\n```\nCREATE TABLE tb_name2 SELECT * FROM tb_name;\n```\n或者部分复制：\n```\nCREATE TABLE tb_name2 SELECT id,name FROM tb_name;\n```\n\n### 查看数据库中可用的表：\n```\nSHOW TABLES;\n```\n\n### 查看表的结构：\n```\nDESCRIBE tb_name;\nSHOW COLUMNS in tb_name; 　　//from也可以\n```\n\n## 列/约束\nALTER TABLE tb ADD[CHANGE,RENAME,DROP]\n### 增加列/约束\n```\nalter table tb add column name VARCHAR(45) not null after id,add primary key(id);\n```\n\n### 删除列/约束\n```\nalter table tb drop col2 drop primary key(id);\n```\n\n### 修改列/约束\nALTER TABLE tb MODIFY col2 int NOT NULL DEFAULT 100 add col1 int identity(1,1);\nALTER TABLE tb ALTER col2 SET DEFAULT 1000;\nALTER TABLE tb ALTER col2 DROP DEFAULT;\n\n### 约束\nprimary key,not null,unique,asc/desc/default 0/AUTO_INCREMENT/zerofill\n\n## 单表操作\n### 插入\n```\ninsert into tb(col1,col2) values(value1,value2)\n```\n\n### 删除\n```\ndelete from tb [WHERE Clause]\n```\n\n### 更新\n```\nupdate tb set col1=value1 [WHERE Clause]\n```\n\n使用MySQL执行update的时候报错：\n```\nError Code: 1175. You are using safe update mode and you tried to update a table without a WHERE that uses a KEY column To disable safe mode, toggle the option in Preferences -> SQL Queries and reconnect.\n```\n\n解决方法：\n执行命令 SET SQL_SAFE_UPDATES = 0;  //修改下数据库模式\n如果想要提高数据库安全等级，可以在恢复回原有的设置，执行命令：SET SQL_SAFE_UPDATES = 1;\n\n### 查找\n```\nselect * from tb [WHERE Clause]\n```\n\n### where\n* =、>、<、<> and/not and  or  is null/is not null\n* 分组查询：order by/group by/having\n```\nselect * from tb order by col1,col2 asc/desc\n```\n\n* like\n```\nSELECT field1, field2,...fieldN \nFROM tb\nWHERE field1 LIKE condition1 [AND [OR]] filed2 = 'somevalue'\n```\n\n* in/not in\n```\nselect * from tb1 where a [not] in (value1,value2,value3)\n```\n\n* between/not between\n\n* exists/not exists\n\n* 全选/全不选\nwhere 1=1 表示选择全部    \nwhere 1=2 表示全部不选，\n\n* 分页\n```\ndeclare @start int,@end int\n@sql  nvarchar(600)\nset @sql=’select top’+str(@end-@start+1)+’+from T where rid not in(select top’+str(@str-1)+’Rid from T where Rid>-1)’\nexec sp_executesql @sql\n```\n\n* 删除重复记录\n```\n1),delete from tablename where id not in (select max(id) from tablename group by col1,col2,...)\n2),select distinct * into temp from tablename\ndelete from tablename\ninsert into tablename select * from temp\n```\n\n* 列出数据库里所有的表名\n```\nselect name from sysobjects where type='U' // U代表用户\n```\n\n* 列出表里的所有的列名\n```\nselect name from syscolumns where id=object_id('TableName')\nselect column_name,data_type from information_schema.columns\nwhere table_name = '表名'   //查询某一个表的字段和数据类型\n```\n\n* 获取当前数据库中的所有用户表\n```\nselect Name from sysobjects where xtype='u' and status>=0\n```\n\n## 多表操作\n### union\n通过组合其他两个结果表（例如 TABLE1 和 TABLE2）并消去表中任何重复行而派生出一个结果表。当 ALL 随 UNION 一起使用时（即 UNION ALL），不消除重复行。两种情况下，派生表的每一行不是来自 TABLE1 就是来自 TABLE2。\n```\nSELECT expression1, expression2, ... expression_n\nFROM tb1\n[WHERE conditions]\nUNION [ALL | DISTINCT]\nSELECT expression1, expression2, ... expression_n\nFROM tb2\n[WHERE conditions];\n\nDISTINCT: 可选，删除结果集中重复的数据。默认情况下 UNION 操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没啥影响。\nALL: 可选，返回所有结果集，包含重复数据。\n```\n\n### EXCEPT\n通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个结果表。当 ALL 随 EXCEPT 一起使用时 (EXCEPT ALL)，不消除重复行。\n### INTERSECT\n通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表。当 ALL 随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。\n\n注：使用运算词的几个查询结果行必须是一致的。 \n\n### 分组：group by\ncount,sum,max,min,avg\n\n### 连接：join\n* INNER JOIN（内连接,或等值连接）：获取两个表中字段匹配关系的记录。\n```\nSELECT a.col1, a.col2, b.col3 FROM tb1 a INNER JOIN tb2 b\nON a.col1 = b.col1;\n等价于\nSELECT a.col1, a.col2, b.col3 FROM tb1 a, tb2 b \nWHERE a.col1 = b.col1;\n```\n\n* LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。\n```\nSELECT a.col1, a.col2, b.col3 FROM tb1 a LEFT JOIN tb2 b \nON a.col1 = b.col1;\n```\n\n* RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。\n```\nSELECT a.col1, a.col2, b.col3 FROM tb1 a RIGHT JOIN tb2 b \nON a.col1 = b.col1;\n```\n\n## 高级用法\n### 索引\n\n### 临时表\n\n### 视图\n","slug":"mysql学习笔记","published":1,"updated":"2017-07-14T03:57:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj53c1dwk002qh3jja7bdozjd","content":"<h2 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h2><h3 id=\"创建数据库\"><a href=\"#创建数据库\" class=\"headerlink\" title=\"创建数据库\"></a>创建数据库</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">create database db;</div></pre></td></tr></table></figure>\n<h3 id=\"删除数据库\"><a href=\"#删除数据库\" class=\"headerlink\" title=\"删除数据库\"></a>删除数据库</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">drop database db;</div></pre></td></tr></table></figure>\n<h3 id=\"查看数据库\"><a href=\"#查看数据库\" class=\"headerlink\" title=\"查看数据库\"></a>查看数据库</h3><a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">show databases;</div></pre></td></tr></table></figure>\n<h3 id=\"使用数据库\"><a href=\"#使用数据库\" class=\"headerlink\" title=\"使用数据库\"></a>使用数据库</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">use db;</div></pre></td></tr></table></figure>\n<h2 id=\"表\"><a href=\"#表\" class=\"headerlink\" title=\"表\"></a>表</h2><h3 id=\"创建表\"><a href=\"#创建表\" class=\"headerlink\" title=\"创建表\"></a>创建表</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">CREATE TABLE db.tb (</div><div class=\"line\">`id` INT NOT NULL AUTO_INCREMENT,</div><div class=\"line\">`name` VARCHAR(45) NOT NULL,</div><div class=\"line\">PRIMARY KEY (`cid`));</div></pre></td></tr></table></figure>\n<h3 id=\"删除表\"><a href=\"#删除表\" class=\"headerlink\" title=\"删除表\"></a>删除表</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">drop table tb</div></pre></td></tr></table></figure>\n<h3 id=\"修改表名\"><a href=\"#修改表名\" class=\"headerlink\" title=\"修改表名\"></a>修改表名</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">RENAME TABLE tb TO new_tbname;</div><div class=\"line\">ALTER TABLE tb RENAME TO new_tbname;</div></pre></td></tr></table></figure>\n<h3 id=\"初始化表-清空\"><a href=\"#初始化表-清空\" class=\"headerlink\" title=\"初始化表(清空)\"></a>初始化表(清空)</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">TRUNCATE TABLE tb</div></pre></td></tr></table></figure>\n<h3 id=\"复制表：\"><a href=\"#复制表：\" class=\"headerlink\" title=\"复制表：\"></a>复制表：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">CREATE TABLE tb_name2 SELECT * FROM tb_name;</div></pre></td></tr></table></figure>\n<p>或者部分复制：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">CREATE TABLE tb_name2 SELECT id,name FROM tb_name;</div></pre></td></tr></table></figure></p>\n<h3 id=\"查看数据库中可用的表：\"><a href=\"#查看数据库中可用的表：\" class=\"headerlink\" title=\"查看数据库中可用的表：\"></a>查看数据库中可用的表：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">SHOW TABLES;</div></pre></td></tr></table></figure>\n<h3 id=\"查看表的结构：\"><a href=\"#查看表的结构：\" class=\"headerlink\" title=\"查看表的结构：\"></a>查看表的结构：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">DESCRIBE tb_name;</div><div class=\"line\">SHOW COLUMNS in tb_name; 　　//from也可以</div></pre></td></tr></table></figure>\n<h2 id=\"列-约束\"><a href=\"#列-约束\" class=\"headerlink\" title=\"列/约束\"></a>列/约束</h2><p>ALTER TABLE tb ADD[CHANGE,RENAME,DROP]</p>\n<h3 id=\"增加列-约束\"><a href=\"#增加列-约束\" class=\"headerlink\" title=\"增加列/约束\"></a>增加列/约束</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">alter table tb add column name VARCHAR(45) not null after id,add primary key(id);</div></pre></td></tr></table></figure>\n<h3 id=\"删除列-约束\"><a href=\"#删除列-约束\" class=\"headerlink\" title=\"删除列/约束\"></a>删除列/约束</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">alter table tb drop col2 drop primary key(id);</div></pre></td></tr></table></figure>\n<h3 id=\"修改列-约束\"><a href=\"#修改列-约束\" class=\"headerlink\" title=\"修改列/约束\"></a>修改列/约束</h3><p>ALTER TABLE tb MODIFY col2 int NOT NULL DEFAULT 100 add col1 int identity(1,1);<br>ALTER TABLE tb ALTER col2 SET DEFAULT 1000;<br>ALTER TABLE tb ALTER col2 DROP DEFAULT;</p>\n<h3 id=\"约束\"><a href=\"#约束\" class=\"headerlink\" title=\"约束\"></a>约束</h3><p>primary key,not null,unique,asc/desc/default 0/AUTO_INCREMENT/zerofill</p>\n<h2 id=\"单表操作\"><a href=\"#单表操作\" class=\"headerlink\" title=\"单表操作\"></a>单表操作</h2><h3 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">insert into tb(col1,col2) values(value1,value2)</div></pre></td></tr></table></figure>\n<h3 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">delete from tb [WHERE Clause]</div></pre></td></tr></table></figure>\n<h3 id=\"更新\"><a href=\"#更新\" class=\"headerlink\" title=\"更新\"></a>更新</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">update tb set col1=value1 [WHERE Clause]</div></pre></td></tr></table></figure>\n<p>使用MySQL执行update的时候报错：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Error Code: 1175. You are using safe update mode and you tried to update a table without a WHERE that uses a KEY column To disable safe mode, toggle the option in Preferences -&gt; SQL Queries and reconnect.</div></pre></td></tr></table></figure></p>\n<p>解决方法：<br>执行命令 SET SQL_SAFE_UPDATES = 0;  //修改下数据库模式<br>如果想要提高数据库安全等级，可以在恢复回原有的设置，执行命令：SET SQL_SAFE_UPDATES = 1;</p>\n<h3 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select * from tb [WHERE Clause]</div></pre></td></tr></table></figure>\n<h3 id=\"where\"><a href=\"#where\" class=\"headerlink\" title=\"where\"></a>where</h3><ul>\n<li>=、&gt;、&lt;、&lt;&gt; and/not and  or  is null/is not null</li>\n<li><p>分组查询：order by/group by/having</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select * from tb order by col1,col2 asc/desc</div></pre></td></tr></table></figure>\n</li>\n<li><p>like</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">SELECT field1, field2,...fieldN </div><div class=\"line\">FROM tb</div><div class=\"line\">WHERE field1 LIKE condition1 [AND [OR]] filed2 = &apos;somevalue&apos;</div></pre></td></tr></table></figure>\n</li>\n<li><p>in/not in</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select * from tb1 where a [not] in (value1,value2,value3)</div></pre></td></tr></table></figure>\n</li>\n<li><p>between/not between</p>\n</li>\n<li><p>exists/not exists</p>\n</li>\n<li><p>全选/全不选<br>where 1=1 表示选择全部<br>where 1=2 表示全部不选，</p>\n</li>\n<li><p>分页</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">declare @start int,@end int</div><div class=\"line\">@sql  nvarchar(600)</div><div class=\"line\">set @sql=’select top’+str(@end-@start+1)+’+from T where rid not in(select top’+str(@str-1)+’Rid from T where Rid&gt;-1)’</div><div class=\"line\">exec sp_executesql @sql</div></pre></td></tr></table></figure>\n</li>\n<li><p>删除重复记录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">1),delete from tablename where id not in (select max(id) from tablename group by col1,col2,...)</div><div class=\"line\">2),select distinct * into temp from tablename</div><div class=\"line\">delete from tablename</div><div class=\"line\">insert into tablename select * from temp</div></pre></td></tr></table></figure>\n</li>\n<li><p>列出数据库里所有的表名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select name from sysobjects where type=&apos;U&apos; // U代表用户</div></pre></td></tr></table></figure>\n</li>\n<li><p>列出表里的所有的列名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">select name from syscolumns where id=object_id(&apos;TableName&apos;)</div><div class=\"line\">select column_name,data_type from information_schema.columns</div><div class=\"line\">where table_name = &apos;表名&apos;   //查询某一个表的字段和数据类型</div></pre></td></tr></table></figure>\n</li>\n<li><p>获取当前数据库中的所有用户表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select Name from sysobjects where xtype=&apos;u&apos; and status&gt;=0</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"多表操作\"><a href=\"#多表操作\" class=\"headerlink\" title=\"多表操作\"></a>多表操作</h2><h3 id=\"union\"><a href=\"#union\" class=\"headerlink\" title=\"union\"></a>union</h3><p>通过组合其他两个结果表（例如 TABLE1 和 TABLE2）并消去表中任何重复行而派生出一个结果表。当 ALL 随 UNION 一起使用时（即 UNION ALL），不消除重复行。两种情况下，派生表的每一行不是来自 TABLE1 就是来自 TABLE2。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">SELECT expression1, expression2, ... expression_n</div><div class=\"line\">FROM tb1</div><div class=\"line\">[WHERE conditions]</div><div class=\"line\">UNION [ALL | DISTINCT]</div><div class=\"line\">SELECT expression1, expression2, ... expression_n</div><div class=\"line\">FROM tb2</div><div class=\"line\">[WHERE conditions];</div><div class=\"line\"></div><div class=\"line\">DISTINCT: 可选，删除结果集中重复的数据。默认情况下 UNION 操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没啥影响。</div><div class=\"line\">ALL: 可选，返回所有结果集，包含重复数据。</div></pre></td></tr></table></figure></p>\n<h3 id=\"EXCEPT\"><a href=\"#EXCEPT\" class=\"headerlink\" title=\"EXCEPT\"></a>EXCEPT</h3><p>通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个结果表。当 ALL 随 EXCEPT 一起使用时 (EXCEPT ALL)，不消除重复行。</p>\n<h3 id=\"INTERSECT\"><a href=\"#INTERSECT\" class=\"headerlink\" title=\"INTERSECT\"></a>INTERSECT</h3><p>通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表。当 ALL 随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。</p>\n<p>注：使用运算词的几个查询结果行必须是一致的。 </p>\n<h3 id=\"分组：group-by\"><a href=\"#分组：group-by\" class=\"headerlink\" title=\"分组：group by\"></a>分组：group by</h3><p>count,sum,max,min,avg</p>\n<h3 id=\"连接：join\"><a href=\"#连接：join\" class=\"headerlink\" title=\"连接：join\"></a>连接：join</h3><ul>\n<li><p>INNER JOIN（内连接,或等值连接）：获取两个表中字段匹配关系的记录。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">SELECT a.col1, a.col2, b.col3 FROM tb1 a INNER JOIN tb2 b</div><div class=\"line\">ON a.col1 = b.col1;</div><div class=\"line\">等价于</div><div class=\"line\">SELECT a.col1, a.col2, b.col3 FROM tb1 a, tb2 b </div><div class=\"line\">WHERE a.col1 = b.col1;</div></pre></td></tr></table></figure>\n</li>\n<li><p>LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">SELECT a.col1, a.col2, b.col3 FROM tb1 a LEFT JOIN tb2 b </div><div class=\"line\">ON a.col1 = b.col1;</div></pre></td></tr></table></figure>\n</li>\n<li><p>RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">SELECT a.col1, a.col2, b.col3 FROM tb1 a RIGHT JOIN tb2 b </div><div class=\"line\">ON a.col1 = b.col1;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"高级用法\"><a href=\"#高级用法\" class=\"headerlink\" title=\"高级用法\"></a>高级用法</h2><h3 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h3><h3 id=\"临时表\"><a href=\"#临时表\" class=\"headerlink\" title=\"临时表\"></a>临时表</h3><h3 id=\"视图\"><a href=\"#视图\" class=\"headerlink\" title=\"视图\"></a>视图</h3>","site":{"data":{}},"excerpt":"<h2 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h2><h3 id=\"创建数据库\"><a href=\"#创建数据库\" class=\"headerlink\" title=\"创建数据库\"></a>创建数据库</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">create database db;</div></pre></td></tr></table></figure>\n<h3 id=\"删除数据库\"><a href=\"#删除数据库\" class=\"headerlink\" title=\"删除数据库\"></a>删除数据库</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">drop database db;</div></pre></td></tr></table></figure>\n<h3 id=\"查看数据库\"><a href=\"#查看数据库\" class=\"headerlink\" title=\"查看数据库\"></a>查看数据库</h3>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">show databases;</div></pre></td></tr></table></figure>\n<h3 id=\"使用数据库\"><a href=\"#使用数据库\" class=\"headerlink\" title=\"使用数据库\"></a>使用数据库</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">use db;</div></pre></td></tr></table></figure>\n<h2 id=\"表\"><a href=\"#表\" class=\"headerlink\" title=\"表\"></a>表</h2><h3 id=\"创建表\"><a href=\"#创建表\" class=\"headerlink\" title=\"创建表\"></a>创建表</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">CREATE TABLE db.tb (</div><div class=\"line\">`id` INT NOT NULL AUTO_INCREMENT,</div><div class=\"line\">`name` VARCHAR(45) NOT NULL,</div><div class=\"line\">PRIMARY KEY (`cid`));</div></pre></td></tr></table></figure>\n<h3 id=\"删除表\"><a href=\"#删除表\" class=\"headerlink\" title=\"删除表\"></a>删除表</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">drop table tb</div></pre></td></tr></table></figure>\n<h3 id=\"修改表名\"><a href=\"#修改表名\" class=\"headerlink\" title=\"修改表名\"></a>修改表名</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">RENAME TABLE tb TO new_tbname;</div><div class=\"line\">ALTER TABLE tb RENAME TO new_tbname;</div></pre></td></tr></table></figure>\n<h3 id=\"初始化表-清空\"><a href=\"#初始化表-清空\" class=\"headerlink\" title=\"初始化表(清空)\"></a>初始化表(清空)</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">TRUNCATE TABLE tb</div></pre></td></tr></table></figure>\n<h3 id=\"复制表：\"><a href=\"#复制表：\" class=\"headerlink\" title=\"复制表：\"></a>复制表：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">CREATE TABLE tb_name2 SELECT * FROM tb_name;</div></pre></td></tr></table></figure>\n<p>或者部分复制：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">CREATE TABLE tb_name2 SELECT id,name FROM tb_name;</div></pre></td></tr></table></figure></p>\n<h3 id=\"查看数据库中可用的表：\"><a href=\"#查看数据库中可用的表：\" class=\"headerlink\" title=\"查看数据库中可用的表：\"></a>查看数据库中可用的表：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">SHOW TABLES;</div></pre></td></tr></table></figure>\n<h3 id=\"查看表的结构：\"><a href=\"#查看表的结构：\" class=\"headerlink\" title=\"查看表的结构：\"></a>查看表的结构：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">DESCRIBE tb_name;</div><div class=\"line\">SHOW COLUMNS in tb_name; 　　//from也可以</div></pre></td></tr></table></figure>\n<h2 id=\"列-约束\"><a href=\"#列-约束\" class=\"headerlink\" title=\"列/约束\"></a>列/约束</h2><p>ALTER TABLE tb ADD[CHANGE,RENAME,DROP]</p>\n<h3 id=\"增加列-约束\"><a href=\"#增加列-约束\" class=\"headerlink\" title=\"增加列/约束\"></a>增加列/约束</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">alter table tb add column name VARCHAR(45) not null after id,add primary key(id);</div></pre></td></tr></table></figure>\n<h3 id=\"删除列-约束\"><a href=\"#删除列-约束\" class=\"headerlink\" title=\"删除列/约束\"></a>删除列/约束</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">alter table tb drop col2 drop primary key(id);</div></pre></td></tr></table></figure>\n<h3 id=\"修改列-约束\"><a href=\"#修改列-约束\" class=\"headerlink\" title=\"修改列/约束\"></a>修改列/约束</h3><p>ALTER TABLE tb MODIFY col2 int NOT NULL DEFAULT 100 add col1 int identity(1,1);<br>ALTER TABLE tb ALTER col2 SET DEFAULT 1000;<br>ALTER TABLE tb ALTER col2 DROP DEFAULT;</p>\n<h3 id=\"约束\"><a href=\"#约束\" class=\"headerlink\" title=\"约束\"></a>约束</h3><p>primary key,not null,unique,asc/desc/default 0/AUTO_INCREMENT/zerofill</p>\n<h2 id=\"单表操作\"><a href=\"#单表操作\" class=\"headerlink\" title=\"单表操作\"></a>单表操作</h2><h3 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">insert into tb(col1,col2) values(value1,value2)</div></pre></td></tr></table></figure>\n<h3 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">delete from tb [WHERE Clause]</div></pre></td></tr></table></figure>\n<h3 id=\"更新\"><a href=\"#更新\" class=\"headerlink\" title=\"更新\"></a>更新</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">update tb set col1=value1 [WHERE Clause]</div></pre></td></tr></table></figure>\n<p>使用MySQL执行update的时候报错：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Error Code: 1175. You are using safe update mode and you tried to update a table without a WHERE that uses a KEY column To disable safe mode, toggle the option in Preferences -&gt; SQL Queries and reconnect.</div></pre></td></tr></table></figure></p>\n<p>解决方法：<br>执行命令 SET SQL_SAFE_UPDATES = 0;  //修改下数据库模式<br>如果想要提高数据库安全等级，可以在恢复回原有的设置，执行命令：SET SQL_SAFE_UPDATES = 1;</p>\n<h3 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select * from tb [WHERE Clause]</div></pre></td></tr></table></figure>\n<h3 id=\"where\"><a href=\"#where\" class=\"headerlink\" title=\"where\"></a>where</h3><ul>\n<li>=、&gt;、&lt;、&lt;&gt; and/not and  or  is null/is not null</li>\n<li><p>分组查询：order by/group by/having</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select * from tb order by col1,col2 asc/desc</div></pre></td></tr></table></figure>\n</li>\n<li><p>like</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">SELECT field1, field2,...fieldN </div><div class=\"line\">FROM tb</div><div class=\"line\">WHERE field1 LIKE condition1 [AND [OR]] filed2 = &apos;somevalue&apos;</div></pre></td></tr></table></figure>\n</li>\n<li><p>in/not in</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select * from tb1 where a [not] in (value1,value2,value3)</div></pre></td></tr></table></figure>\n</li>\n<li><p>between/not between</p>\n</li>\n<li><p>exists/not exists</p>\n</li>\n<li><p>全选/全不选<br>where 1=1 表示选择全部<br>where 1=2 表示全部不选，</p>\n</li>\n<li><p>分页</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">declare @start int,@end int</div><div class=\"line\">@sql  nvarchar(600)</div><div class=\"line\">set @sql=’select top’+str(@end-@start+1)+’+from T where rid not in(select top’+str(@str-1)+’Rid from T where Rid&gt;-1)’</div><div class=\"line\">exec sp_executesql @sql</div></pre></td></tr></table></figure>\n</li>\n<li><p>删除重复记录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">1),delete from tablename where id not in (select max(id) from tablename group by col1,col2,...)</div><div class=\"line\">2),select distinct * into temp from tablename</div><div class=\"line\">delete from tablename</div><div class=\"line\">insert into tablename select * from temp</div></pre></td></tr></table></figure>\n</li>\n<li><p>列出数据库里所有的表名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select name from sysobjects where type=&apos;U&apos; // U代表用户</div></pre></td></tr></table></figure>\n</li>\n<li><p>列出表里的所有的列名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">select name from syscolumns where id=object_id(&apos;TableName&apos;)</div><div class=\"line\">select column_name,data_type from information_schema.columns</div><div class=\"line\">where table_name = &apos;表名&apos;   //查询某一个表的字段和数据类型</div></pre></td></tr></table></figure>\n</li>\n<li><p>获取当前数据库中的所有用户表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">select Name from sysobjects where xtype=&apos;u&apos; and status&gt;=0</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"多表操作\"><a href=\"#多表操作\" class=\"headerlink\" title=\"多表操作\"></a>多表操作</h2><h3 id=\"union\"><a href=\"#union\" class=\"headerlink\" title=\"union\"></a>union</h3><p>通过组合其他两个结果表（例如 TABLE1 和 TABLE2）并消去表中任何重复行而派生出一个结果表。当 ALL 随 UNION 一起使用时（即 UNION ALL），不消除重复行。两种情况下，派生表的每一行不是来自 TABLE1 就是来自 TABLE2。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">SELECT expression1, expression2, ... expression_n</div><div class=\"line\">FROM tb1</div><div class=\"line\">[WHERE conditions]</div><div class=\"line\">UNION [ALL | DISTINCT]</div><div class=\"line\">SELECT expression1, expression2, ... expression_n</div><div class=\"line\">FROM tb2</div><div class=\"line\">[WHERE conditions];</div><div class=\"line\"></div><div class=\"line\">DISTINCT: 可选，删除结果集中重复的数据。默认情况下 UNION 操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没啥影响。</div><div class=\"line\">ALL: 可选，返回所有结果集，包含重复数据。</div></pre></td></tr></table></figure></p>\n<h3 id=\"EXCEPT\"><a href=\"#EXCEPT\" class=\"headerlink\" title=\"EXCEPT\"></a>EXCEPT</h3><p>通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个结果表。当 ALL 随 EXCEPT 一起使用时 (EXCEPT ALL)，不消除重复行。</p>\n<h3 id=\"INTERSECT\"><a href=\"#INTERSECT\" class=\"headerlink\" title=\"INTERSECT\"></a>INTERSECT</h3><p>通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表。当 ALL 随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。</p>\n<p>注：使用运算词的几个查询结果行必须是一致的。 </p>\n<h3 id=\"分组：group-by\"><a href=\"#分组：group-by\" class=\"headerlink\" title=\"分组：group by\"></a>分组：group by</h3><p>count,sum,max,min,avg</p>\n<h3 id=\"连接：join\"><a href=\"#连接：join\" class=\"headerlink\" title=\"连接：join\"></a>连接：join</h3><ul>\n<li><p>INNER JOIN（内连接,或等值连接）：获取两个表中字段匹配关系的记录。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">SELECT a.col1, a.col2, b.col3 FROM tb1 a INNER JOIN tb2 b</div><div class=\"line\">ON a.col1 = b.col1;</div><div class=\"line\">等价于</div><div class=\"line\">SELECT a.col1, a.col2, b.col3 FROM tb1 a, tb2 b </div><div class=\"line\">WHERE a.col1 = b.col1;</div></pre></td></tr></table></figure>\n</li>\n<li><p>LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">SELECT a.col1, a.col2, b.col3 FROM tb1 a LEFT JOIN tb2 b </div><div class=\"line\">ON a.col1 = b.col1;</div></pre></td></tr></table></figure>\n</li>\n<li><p>RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">SELECT a.col1, a.col2, b.col3 FROM tb1 a RIGHT JOIN tb2 b </div><div class=\"line\">ON a.col1 = b.col1;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"高级用法\"><a href=\"#高级用法\" class=\"headerlink\" title=\"高级用法\"></a>高级用法</h2><h3 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h3><h3 id=\"临时表\"><a href=\"#临时表\" class=\"headerlink\" title=\"临时表\"></a>临时表</h3><h3 id=\"视图\"><a href=\"#视图\" class=\"headerlink\" title=\"视图\"></a>视图</h3>"},{"title":"toStudy","date":"2017-01-01T04:04:11.000Z","_content":"","source":"_posts/toStudy.md","raw":"---\ntitle: toStudy\ndate: 2017-01-01 12:04:11\ncategories:\ntags:\n---\n","slug":"toStudy","published":1,"updated":"2017-07-14T03:57:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj53c1dwl002uh3jj3emjdthw","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"几种常见算法","date":"2017-06-09T03:02:24.000Z","comments":1,"_content":"\n## 排序\n1、插入排序\n在要排序的一组数中，假设前面(n-1) [n>=2] 个数已经是排好顺序的，现在要把第n个数插到前面的有序数中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。\n<!--more-->\n```\nif(arr == null || arr.length < 2){\n    return arr;\n}\nfor(int i=1;i<arr.length;i++){\n    for(intj=i;j>0;j--){\n        if(arr[j]<arr[j-1]){\n            int temp=arr[j];\n            arr[j]=arr[j-1];\n            arr[j-1]=temp;\n        }else{\n            //接下来是无用功\n            break;\n        }\n    }\n}\nreturn arr;\n```\n\n2、冒泡排序\n在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。\n```\nint temp = 0;\nfor (int i = a.length - 1; i > 0; --i)\n{\n    for (int j = 0; j < i; ++j)\n    {\n        if (a[j + 1] < a[j])\n        {\n            temp = a[j];\n            a[j] = a[j + 1];\n            a[j + 1] = temp;\n        }\n    }\n}\n```\n\n3、快速排序\n快速排序是对冒泡排序的一种本质改进。它的基本思想是通过一趟扫描后，使得排序序列的长度能大幅度地减少。在冒泡排序中，一次扫描只能确保最大数值的数移到正确位置，而待排序序列的长度可能只减少1。快速排序通过一趟扫描，就能确保以某个数为基准点的左边各数都比它小，右边各数都比它大。然后又用同样的方法处理它左右两边的数，直到基准点的左右只有一个元素为止。\n```\nmain()\n{\n    if(left >= right)/*如果左边索引大于或者等于右边的索引就代表已经整理完成一个组了*/\n    {\n        return ;\n    }\n    int i = left;\n    int j = right;\n    int key = a[left];\n\n    while(i < j)                               /*控制在当组内寻找一遍*/\n    {\n        while(i < j && key <= a[j])\n        /*而寻找结束的条件就是，1，找到一个小于或者大于key的数（大于或小于取决于你想升\n        序还是降序）2，没有符合条件1的，并且i与j的大小没有反转*/ \n        {\n            j--;/*向前寻找*/\n        }\n\n        a[i] = a[j];\n        /*找到一个这样的数后就把它赋给前面的被拿走的i的值（如果第一次循环且key是\n        a[left]，那么就是给key）*/\n\n        while(i < j && key >= a[i])\n        /*这是i在当组内向前寻找，同上，不过注意与key的大小关系停止循环和上面相反，\n        因为排序思想是把数往两边扔，所以左右两边的数大小与key的关系相反*/\n        {\n            i++;\n        }\n\n        a[j] = a[i];        \n    }\n\n    a[i] = key;/*当在当组内找完一遍以后就把中间数key回归*/\n    sort(a, left, i - 1);/*最后用同样的方式对分出来的左边的小组进行同上的做法*/\n    sort(a, i + 1, right);/*用同样的方式对分出来的右边的小组进行同上的做法*/\n    /*当然最后可能会出现很多分左右，直到每一组的i = j 为止*/\n}\n```\n\n4、选择排序\n在要排序的一组数中，选出最小的一个数与第一个位置的数交换；然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。\n```\nmain()\n{\nint i,j,min,t;\nfor(i=0;i<n-1;i++)\n{\n    min=i;//查找最小值\n    for(j=i+1;j<n;j++)\n        if(a[min]>a[j])\n        min=j;//交换\n\n        if(min!=i)\n        {\n            t=a[min];\n            a[min]=a[i];\n            a[i]=t;\n        }\n    }\n}\n```\n\n## 二分法\n二分法查找只适用与已排序的数列。\n思路：首先将值 x 与数组 v 的中间元素比较，如果 x 小于中间的元素，则将 end 值设为 中间元素-1，同理，若 x 大于中间元素，则将中间元素 + 1作为 start，再在 start 与 end 之间进行查找。\n```\nint start = 0;\nint end = data.length-1;\nint mid = (start+end)/2;//a\nwhile(data[mid]!=aim&&end>start){\n    if(data[mid]>aim){\n        end = mid-1;\n    }else if(data[mid]<aim){\n        start = mid+1;\n    }\n    mid = (start+end)/2;\n}\nreturn (data[mid]!=aim)?-1:mid;\n```\n\n## 斐波那契数列\n数列：1,1,2,3,5,8,13,21...  求第n项的值\n```\nint f1,f2,f,i,n;    \nf1=f2=1;\nif(n<=2)    \n    printf(\"%d\",1);    \nelse \n{                        //加上括号\n    for(i=3;i<=n;i++)      \n{   \nf=f1+f2;         \nf1=f2;   \nf2=f;             \n```\n\n\n\n","source":"_posts/几种常见算法.md","raw":"---\ntitle: 几种常见算法\ndate: 2017-06-09 11:02:24\ncategories: 笔记\ntags: [排序,算法]\ncomments: true\n---\n\n## 排序\n1、插入排序\n在要排序的一组数中，假设前面(n-1) [n>=2] 个数已经是排好顺序的，现在要把第n个数插到前面的有序数中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。\n<!--more-->\n```\nif(arr == null || arr.length < 2){\n    return arr;\n}\nfor(int i=1;i<arr.length;i++){\n    for(intj=i;j>0;j--){\n        if(arr[j]<arr[j-1]){\n            int temp=arr[j];\n            arr[j]=arr[j-1];\n            arr[j-1]=temp;\n        }else{\n            //接下来是无用功\n            break;\n        }\n    }\n}\nreturn arr;\n```\n\n2、冒泡排序\n在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。\n```\nint temp = 0;\nfor (int i = a.length - 1; i > 0; --i)\n{\n    for (int j = 0; j < i; ++j)\n    {\n        if (a[j + 1] < a[j])\n        {\n            temp = a[j];\n            a[j] = a[j + 1];\n            a[j + 1] = temp;\n        }\n    }\n}\n```\n\n3、快速排序\n快速排序是对冒泡排序的一种本质改进。它的基本思想是通过一趟扫描后，使得排序序列的长度能大幅度地减少。在冒泡排序中，一次扫描只能确保最大数值的数移到正确位置，而待排序序列的长度可能只减少1。快速排序通过一趟扫描，就能确保以某个数为基准点的左边各数都比它小，右边各数都比它大。然后又用同样的方法处理它左右两边的数，直到基准点的左右只有一个元素为止。\n```\nmain()\n{\n    if(left >= right)/*如果左边索引大于或者等于右边的索引就代表已经整理完成一个组了*/\n    {\n        return ;\n    }\n    int i = left;\n    int j = right;\n    int key = a[left];\n\n    while(i < j)                               /*控制在当组内寻找一遍*/\n    {\n        while(i < j && key <= a[j])\n        /*而寻找结束的条件就是，1，找到一个小于或者大于key的数（大于或小于取决于你想升\n        序还是降序）2，没有符合条件1的，并且i与j的大小没有反转*/ \n        {\n            j--;/*向前寻找*/\n        }\n\n        a[i] = a[j];\n        /*找到一个这样的数后就把它赋给前面的被拿走的i的值（如果第一次循环且key是\n        a[left]，那么就是给key）*/\n\n        while(i < j && key >= a[i])\n        /*这是i在当组内向前寻找，同上，不过注意与key的大小关系停止循环和上面相反，\n        因为排序思想是把数往两边扔，所以左右两边的数大小与key的关系相反*/\n        {\n            i++;\n        }\n\n        a[j] = a[i];        \n    }\n\n    a[i] = key;/*当在当组内找完一遍以后就把中间数key回归*/\n    sort(a, left, i - 1);/*最后用同样的方式对分出来的左边的小组进行同上的做法*/\n    sort(a, i + 1, right);/*用同样的方式对分出来的右边的小组进行同上的做法*/\n    /*当然最后可能会出现很多分左右，直到每一组的i = j 为止*/\n}\n```\n\n4、选择排序\n在要排序的一组数中，选出最小的一个数与第一个位置的数交换；然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。\n```\nmain()\n{\nint i,j,min,t;\nfor(i=0;i<n-1;i++)\n{\n    min=i;//查找最小值\n    for(j=i+1;j<n;j++)\n        if(a[min]>a[j])\n        min=j;//交换\n\n        if(min!=i)\n        {\n            t=a[min];\n            a[min]=a[i];\n            a[i]=t;\n        }\n    }\n}\n```\n\n## 二分法\n二分法查找只适用与已排序的数列。\n思路：首先将值 x 与数组 v 的中间元素比较，如果 x 小于中间的元素，则将 end 值设为 中间元素-1，同理，若 x 大于中间元素，则将中间元素 + 1作为 start，再在 start 与 end 之间进行查找。\n```\nint start = 0;\nint end = data.length-1;\nint mid = (start+end)/2;//a\nwhile(data[mid]!=aim&&end>start){\n    if(data[mid]>aim){\n        end = mid-1;\n    }else if(data[mid]<aim){\n        start = mid+1;\n    }\n    mid = (start+end)/2;\n}\nreturn (data[mid]!=aim)?-1:mid;\n```\n\n## 斐波那契数列\n数列：1,1,2,3,5,8,13,21...  求第n项的值\n```\nint f1,f2,f,i,n;    \nf1=f2=1;\nif(n<=2)    \n    printf(\"%d\",1);    \nelse \n{                        //加上括号\n    for(i=3;i<=n;i++)      \n{   \nf=f1+f2;         \nf1=f2;   \nf2=f;             \n```\n\n\n\n","slug":"几种常见算法","published":1,"updated":"2017-07-14T03:57:06.000Z","layout":"post","photos":[],"link":"","_id":"cj53c1dwm002xh3jj1gdl3gzx","content":"<h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><p>1、插入排序<br>在要排序的一组数中，假设前面(n-1) [n&gt;=2] 个数已经是排好顺序的，现在要把第n个数插到前面的有序数中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。<br><a id=\"more\"></a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">if(arr == null || arr.length &lt; 2)&#123;</div><div class=\"line\">    return arr;</div><div class=\"line\">&#125;</div><div class=\"line\">for(int i=1;i&lt;arr.length;i++)&#123;</div><div class=\"line\">    for(intj=i;j&gt;0;j--)&#123;</div><div class=\"line\">        if(arr[j]&lt;arr[j-1])&#123;</div><div class=\"line\">            int temp=arr[j];</div><div class=\"line\">            arr[j]=arr[j-1];</div><div class=\"line\">            arr[j-1]=temp;</div><div class=\"line\">        &#125;else&#123;</div><div class=\"line\">            //接下来是无用功</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">return arr;</div></pre></td></tr></table></figure></p>\n<p>2、冒泡排序<br>在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">int temp = 0;</div><div class=\"line\">for (int i = a.length - 1; i &gt; 0; --i)</div><div class=\"line\">&#123;</div><div class=\"line\">    for (int j = 0; j &lt; i; ++j)</div><div class=\"line\">    &#123;</div><div class=\"line\">        if (a[j + 1] &lt; a[j])</div><div class=\"line\">        &#123;</div><div class=\"line\">            temp = a[j];</div><div class=\"line\">            a[j] = a[j + 1];</div><div class=\"line\">            a[j + 1] = temp;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>3、快速排序<br>快速排序是对冒泡排序的一种本质改进。它的基本思想是通过一趟扫描后，使得排序序列的长度能大幅度地减少。在冒泡排序中，一次扫描只能确保最大数值的数移到正确位置，而待排序序列的长度可能只减少1。快速排序通过一趟扫描，就能确保以某个数为基准点的左边各数都比它小，右边各数都比它大。然后又用同样的方法处理它左右两边的数，直到基准点的左右只有一个元素为止。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">main()</div><div class=\"line\">&#123;</div><div class=\"line\">    if(left &gt;= right)/*如果左边索引大于或者等于右边的索引就代表已经整理完成一个组了*/</div><div class=\"line\">    &#123;</div><div class=\"line\">        return ;</div><div class=\"line\">    &#125;</div><div class=\"line\">    int i = left;</div><div class=\"line\">    int j = right;</div><div class=\"line\">    int key = a[left];</div><div class=\"line\"></div><div class=\"line\">    while(i &lt; j)                               /*控制在当组内寻找一遍*/</div><div class=\"line\">    &#123;</div><div class=\"line\">        while(i &lt; j &amp;&amp; key &lt;= a[j])</div><div class=\"line\">        /*而寻找结束的条件就是，1，找到一个小于或者大于key的数（大于或小于取决于你想升</div><div class=\"line\">        序还是降序）2，没有符合条件1的，并且i与j的大小没有反转*/ </div><div class=\"line\">        &#123;</div><div class=\"line\">            j--;/*向前寻找*/</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        a[i] = a[j];</div><div class=\"line\">        /*找到一个这样的数后就把它赋给前面的被拿走的i的值（如果第一次循环且key是</div><div class=\"line\">        a[left]，那么就是给key）*/</div><div class=\"line\"></div><div class=\"line\">        while(i &lt; j &amp;&amp; key &gt;= a[i])</div><div class=\"line\">        /*这是i在当组内向前寻找，同上，不过注意与key的大小关系停止循环和上面相反，</div><div class=\"line\">        因为排序思想是把数往两边扔，所以左右两边的数大小与key的关系相反*/</div><div class=\"line\">        &#123;</div><div class=\"line\">            i++;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        a[j] = a[i];        </div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    a[i] = key;/*当在当组内找完一遍以后就把中间数key回归*/</div><div class=\"line\">    sort(a, left, i - 1);/*最后用同样的方式对分出来的左边的小组进行同上的做法*/</div><div class=\"line\">    sort(a, i + 1, right);/*用同样的方式对分出来的右边的小组进行同上的做法*/</div><div class=\"line\">    /*当然最后可能会出现很多分左右，直到每一组的i = j 为止*/</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>4、选择排序<br>在要排序的一组数中，选出最小的一个数与第一个位置的数交换；然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">main()</div><div class=\"line\">&#123;</div><div class=\"line\">int i,j,min,t;</div><div class=\"line\">for(i=0;i&lt;n-1;i++)</div><div class=\"line\">&#123;</div><div class=\"line\">    min=i;//查找最小值</div><div class=\"line\">    for(j=i+1;j&lt;n;j++)</div><div class=\"line\">        if(a[min]&gt;a[j])</div><div class=\"line\">        min=j;//交换</div><div class=\"line\"></div><div class=\"line\">        if(min!=i)</div><div class=\"line\">        &#123;</div><div class=\"line\">            t=a[min];</div><div class=\"line\">            a[min]=a[i];</div><div class=\"line\">            a[i]=t;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"二分法\"><a href=\"#二分法\" class=\"headerlink\" title=\"二分法\"></a>二分法</h2><p>二分法查找只适用与已排序的数列。<br>思路：首先将值 x 与数组 v 的中间元素比较，如果 x 小于中间的元素，则将 end 值设为 中间元素-1，同理，若 x 大于中间元素，则将中间元素 + 1作为 start，再在 start 与 end 之间进行查找。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">int start = 0;</div><div class=\"line\">int end = data.length-1;</div><div class=\"line\">int mid = (start+end)/2;//a</div><div class=\"line\">while(data[mid]!=aim&amp;&amp;end&gt;start)&#123;</div><div class=\"line\">    if(data[mid]&gt;aim)&#123;</div><div class=\"line\">        end = mid-1;</div><div class=\"line\">    &#125;else if(data[mid]&lt;aim)&#123;</div><div class=\"line\">        start = mid+1;</div><div class=\"line\">    &#125;</div><div class=\"line\">    mid = (start+end)/2;</div><div class=\"line\">&#125;</div><div class=\"line\">return (data[mid]!=aim)?-1:mid;</div></pre></td></tr></table></figure></p>\n<h2 id=\"斐波那契数列\"><a href=\"#斐波那契数列\" class=\"headerlink\" title=\"斐波那契数列\"></a>斐波那契数列</h2><p>数列：1,1,2,3,5,8,13,21…  求第n项的值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">int f1,f2,f,i,n;    </div><div class=\"line\">f1=f2=1;</div><div class=\"line\">if(n&lt;=2)    </div><div class=\"line\">    printf(&quot;%d&quot;,1);    </div><div class=\"line\">else </div><div class=\"line\">&#123;                        //加上括号</div><div class=\"line\">    for(i=3;i&lt;=n;i++)      </div><div class=\"line\">&#123;   </div><div class=\"line\">f=f1+f2;         </div><div class=\"line\">f1=f2;   </div><div class=\"line\">f2=f;</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><p>1、插入排序<br>在要排序的一组数中，假设前面(n-1) [n&gt;=2] 个数已经是排好顺序的，现在要把第n个数插到前面的有序数中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。<br>","more":"<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">if(arr == null || arr.length &lt; 2)&#123;</div><div class=\"line\">    return arr;</div><div class=\"line\">&#125;</div><div class=\"line\">for(int i=1;i&lt;arr.length;i++)&#123;</div><div class=\"line\">    for(intj=i;j&gt;0;j--)&#123;</div><div class=\"line\">        if(arr[j]&lt;arr[j-1])&#123;</div><div class=\"line\">            int temp=arr[j];</div><div class=\"line\">            arr[j]=arr[j-1];</div><div class=\"line\">            arr[j-1]=temp;</div><div class=\"line\">        &#125;else&#123;</div><div class=\"line\">            //接下来是无用功</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">return arr;</div></pre></td></tr></table></figure></p>\n<p>2、冒泡排序<br>在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">int temp = 0;</div><div class=\"line\">for (int i = a.length - 1; i &gt; 0; --i)</div><div class=\"line\">&#123;</div><div class=\"line\">    for (int j = 0; j &lt; i; ++j)</div><div class=\"line\">    &#123;</div><div class=\"line\">        if (a[j + 1] &lt; a[j])</div><div class=\"line\">        &#123;</div><div class=\"line\">            temp = a[j];</div><div class=\"line\">            a[j] = a[j + 1];</div><div class=\"line\">            a[j + 1] = temp;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>3、快速排序<br>快速排序是对冒泡排序的一种本质改进。它的基本思想是通过一趟扫描后，使得排序序列的长度能大幅度地减少。在冒泡排序中，一次扫描只能确保最大数值的数移到正确位置，而待排序序列的长度可能只减少1。快速排序通过一趟扫描，就能确保以某个数为基准点的左边各数都比它小，右边各数都比它大。然后又用同样的方法处理它左右两边的数，直到基准点的左右只有一个元素为止。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">main()</div><div class=\"line\">&#123;</div><div class=\"line\">    if(left &gt;= right)/*如果左边索引大于或者等于右边的索引就代表已经整理完成一个组了*/</div><div class=\"line\">    &#123;</div><div class=\"line\">        return ;</div><div class=\"line\">    &#125;</div><div class=\"line\">    int i = left;</div><div class=\"line\">    int j = right;</div><div class=\"line\">    int key = a[left];</div><div class=\"line\"></div><div class=\"line\">    while(i &lt; j)                               /*控制在当组内寻找一遍*/</div><div class=\"line\">    &#123;</div><div class=\"line\">        while(i &lt; j &amp;&amp; key &lt;= a[j])</div><div class=\"line\">        /*而寻找结束的条件就是，1，找到一个小于或者大于key的数（大于或小于取决于你想升</div><div class=\"line\">        序还是降序）2，没有符合条件1的，并且i与j的大小没有反转*/ </div><div class=\"line\">        &#123;</div><div class=\"line\">            j--;/*向前寻找*/</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        a[i] = a[j];</div><div class=\"line\">        /*找到一个这样的数后就把它赋给前面的被拿走的i的值（如果第一次循环且key是</div><div class=\"line\">        a[left]，那么就是给key）*/</div><div class=\"line\"></div><div class=\"line\">        while(i &lt; j &amp;&amp; key &gt;= a[i])</div><div class=\"line\">        /*这是i在当组内向前寻找，同上，不过注意与key的大小关系停止循环和上面相反，</div><div class=\"line\">        因为排序思想是把数往两边扔，所以左右两边的数大小与key的关系相反*/</div><div class=\"line\">        &#123;</div><div class=\"line\">            i++;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        a[j] = a[i];        </div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    a[i] = key;/*当在当组内找完一遍以后就把中间数key回归*/</div><div class=\"line\">    sort(a, left, i - 1);/*最后用同样的方式对分出来的左边的小组进行同上的做法*/</div><div class=\"line\">    sort(a, i + 1, right);/*用同样的方式对分出来的右边的小组进行同上的做法*/</div><div class=\"line\">    /*当然最后可能会出现很多分左右，直到每一组的i = j 为止*/</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>4、选择排序<br>在要排序的一组数中，选出最小的一个数与第一个位置的数交换；然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">main()</div><div class=\"line\">&#123;</div><div class=\"line\">int i,j,min,t;</div><div class=\"line\">for(i=0;i&lt;n-1;i++)</div><div class=\"line\">&#123;</div><div class=\"line\">    min=i;//查找最小值</div><div class=\"line\">    for(j=i+1;j&lt;n;j++)</div><div class=\"line\">        if(a[min]&gt;a[j])</div><div class=\"line\">        min=j;//交换</div><div class=\"line\"></div><div class=\"line\">        if(min!=i)</div><div class=\"line\">        &#123;</div><div class=\"line\">            t=a[min];</div><div class=\"line\">            a[min]=a[i];</div><div class=\"line\">            a[i]=t;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"二分法\"><a href=\"#二分法\" class=\"headerlink\" title=\"二分法\"></a>二分法</h2><p>二分法查找只适用与已排序的数列。<br>思路：首先将值 x 与数组 v 的中间元素比较，如果 x 小于中间的元素，则将 end 值设为 中间元素-1，同理，若 x 大于中间元素，则将中间元素 + 1作为 start，再在 start 与 end 之间进行查找。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">int start = 0;</div><div class=\"line\">int end = data.length-1;</div><div class=\"line\">int mid = (start+end)/2;//a</div><div class=\"line\">while(data[mid]!=aim&amp;&amp;end&gt;start)&#123;</div><div class=\"line\">    if(data[mid]&gt;aim)&#123;</div><div class=\"line\">        end = mid-1;</div><div class=\"line\">    &#125;else if(data[mid]&lt;aim)&#123;</div><div class=\"line\">        start = mid+1;</div><div class=\"line\">    &#125;</div><div class=\"line\">    mid = (start+end)/2;</div><div class=\"line\">&#125;</div><div class=\"line\">return (data[mid]!=aim)?-1:mid;</div></pre></td></tr></table></figure></p>\n<h2 id=\"斐波那契数列\"><a href=\"#斐波那契数列\" class=\"headerlink\" title=\"斐波那契数列\"></a>斐波那契数列</h2><p>数列：1,1,2,3,5,8,13,21…  求第n项的值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">int f1,f2,f,i,n;    </div><div class=\"line\">f1=f2=1;</div><div class=\"line\">if(n&lt;=2)    </div><div class=\"line\">    printf(&quot;%d&quot;,1);    </div><div class=\"line\">else </div><div class=\"line\">&#123;                        //加上括号</div><div class=\"line\">    for(i=3;i&lt;=n;i++)      </div><div class=\"line\">&#123;   </div><div class=\"line\">f=f1+f2;         </div><div class=\"line\">f1=f2;   </div><div class=\"line\">f2=f;</div></pre></td></tr></table></figure></p>"},{"title":"北京十渡","date":"2017-04-16T06:49:48.000Z","_content":"\n### 2017-04-16 北京十渡飞拉达、蹦极\n\n![蹦极](http://o8cfktdb3.bkt.clouddn.com/bengji.jpeg)\n　　今天真是玩嗨了\n<!--more-->\n　　早上六点起床，准备好之后早早出了门，乘地铁赶往公主坟与大家集合。到了集合地，坐着租的面包车开始前往目的地————十渡。\n　　十渡景区位于北京房山，到了景区之后，带队的队长确定参加飞拉达的人数开始买票。之前了解了一下飞拉达就是攀岩（岩壁探险或铁道式攀登），因为之前从来没参与过类似冒险运动，心里有点小紧张。因为人还比较多，所以一块请了一位教练。刚开始教练教授装备的穿戴，之后带领我们来到了攀岩的山脚下，教练说这座山大概有70多米，之后告诉了我们扣锁的使用，然后开始攀爬演示，小伙伴们也开始一个个紧随其后开始了攀爬之路。\n![飞拉达](http://o8cfktdb3.bkt.clouddn.com/feilada.jpeg)\n　　飞拉达历经大约三个小时，穿越了ABCD区，终于到达了终点。教练帮我们把所有锁扣都挂到绳索上，下面是湖水，随着绳索划过去才算再次到达了地面。\n\n　　之后和大家一起腐败吃午餐，吃午餐的餐厅对面正好就是蹦极的跳台，是不是看着一个个挑战者坠落、弹跳...　由于某些原因（吃的有点多了，惭愧...），本来打算不参加蹦极了，但是一想如果不参加，回去之后一定会捶胸顿足，后悔不跌，而且同性的小伙伴除了一对情侣之外都参加了，狠了狠心还是买了票。\n　　来到蹦极门口，工作人员给每个人测量了身高和体重，并把数据写到了手背上。由于蹦极的人很多，等了大约有两三个小时，期间目睹一个一个从跳台自由落体，还有情侣相拥跳下，他们调侃这肯定是他们这辈子抱得最紧的一次了吧~~轮到我们的时候，不知怎么安排的被调到了最后一个，轮到我的时候，工作人员开始给我腿上绑绳，把眼镜粘到了胳膊上，为了避免女生走光把上衣和裤子的连接处也用胶带粘上了，说实话，自从买了票心有一直还挺紧张的，但真到了马上就要跳下去的时候，心里反而没有那么紧张了，还算比较平静。起跳之前冲着镜头挥挥手，然后只要张开双臂就可以了，看着50米下宽阔的湖水，心里还真是怂了，嗯，怂了（幸亏自己还是近视眼，并且还没戴眼镜）...接着工作人员扶着胳膊向前推去，从未有过的自由落体的失重感觉瞬间侵占了大脑，一片空白，只得紧闭双眼，只感觉到达最低点之后又弹跳到了下降高度的三分之二，然后又开始降落，才敢睁开眼睛环顾四周，之后又弹了大概两三次，高度就不是很高了，才开始享受蹦极的乐趣，然后就被放了下来，湖面上又专业人员把我接了下去，整个过程也就是一两分钟的样子，算是真切的感受了一次蹦极的刺激！\n　　今天认识了一个很说的来的朋友，我俩基本上叽叽喳喳聊了一天，感觉很是投缘，遇到很聊得来的人总是感觉心情很舒畅！也认识了一个四川的男生，还在上大学，曾经自己骑行去过云南，还认识了一个广州的女孩（就是下图中的女孩），刚辞了工作专门出来游玩的，很佩服这种勇气！\n\n![brave girl](http://o8cfktdb3.bkt.clouddn.com/braveGirl.jpeg)\n\n　　最后用鹿晗的《某时某刻 Catch me when I fall》结个尾~~~\n\n<!--<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=29771231&auto=1&height=66\"></iframe>-->\n\n<iframe   \nheight=498 width=510   \nsrc=\"http://player.youku.com/embed/XMTc3MjI5NTk3Mg\"   \nframeborder=0 allowfullscreen>  \n</iframe>  \n\n","source":"_posts/北京十渡.md","raw":"---\ntitle: 北京十渡\ndate: 2017-04-16 14:49:48\ncategories: 随笔\ntags: [十渡,蹦极]\n---\n\n### 2017-04-16 北京十渡飞拉达、蹦极\n\n![蹦极](http://o8cfktdb3.bkt.clouddn.com/bengji.jpeg)\n　　今天真是玩嗨了\n<!--more-->\n　　早上六点起床，准备好之后早早出了门，乘地铁赶往公主坟与大家集合。到了集合地，坐着租的面包车开始前往目的地————十渡。\n　　十渡景区位于北京房山，到了景区之后，带队的队长确定参加飞拉达的人数开始买票。之前了解了一下飞拉达就是攀岩（岩壁探险或铁道式攀登），因为之前从来没参与过类似冒险运动，心里有点小紧张。因为人还比较多，所以一块请了一位教练。刚开始教练教授装备的穿戴，之后带领我们来到了攀岩的山脚下，教练说这座山大概有70多米，之后告诉了我们扣锁的使用，然后开始攀爬演示，小伙伴们也开始一个个紧随其后开始了攀爬之路。\n![飞拉达](http://o8cfktdb3.bkt.clouddn.com/feilada.jpeg)\n　　飞拉达历经大约三个小时，穿越了ABCD区，终于到达了终点。教练帮我们把所有锁扣都挂到绳索上，下面是湖水，随着绳索划过去才算再次到达了地面。\n\n　　之后和大家一起腐败吃午餐，吃午餐的餐厅对面正好就是蹦极的跳台，是不是看着一个个挑战者坠落、弹跳...　由于某些原因（吃的有点多了，惭愧...），本来打算不参加蹦极了，但是一想如果不参加，回去之后一定会捶胸顿足，后悔不跌，而且同性的小伙伴除了一对情侣之外都参加了，狠了狠心还是买了票。\n　　来到蹦极门口，工作人员给每个人测量了身高和体重，并把数据写到了手背上。由于蹦极的人很多，等了大约有两三个小时，期间目睹一个一个从跳台自由落体，还有情侣相拥跳下，他们调侃这肯定是他们这辈子抱得最紧的一次了吧~~轮到我们的时候，不知怎么安排的被调到了最后一个，轮到我的时候，工作人员开始给我腿上绑绳，把眼镜粘到了胳膊上，为了避免女生走光把上衣和裤子的连接处也用胶带粘上了，说实话，自从买了票心有一直还挺紧张的，但真到了马上就要跳下去的时候，心里反而没有那么紧张了，还算比较平静。起跳之前冲着镜头挥挥手，然后只要张开双臂就可以了，看着50米下宽阔的湖水，心里还真是怂了，嗯，怂了（幸亏自己还是近视眼，并且还没戴眼镜）...接着工作人员扶着胳膊向前推去，从未有过的自由落体的失重感觉瞬间侵占了大脑，一片空白，只得紧闭双眼，只感觉到达最低点之后又弹跳到了下降高度的三分之二，然后又开始降落，才敢睁开眼睛环顾四周，之后又弹了大概两三次，高度就不是很高了，才开始享受蹦极的乐趣，然后就被放了下来，湖面上又专业人员把我接了下去，整个过程也就是一两分钟的样子，算是真切的感受了一次蹦极的刺激！\n　　今天认识了一个很说的来的朋友，我俩基本上叽叽喳喳聊了一天，感觉很是投缘，遇到很聊得来的人总是感觉心情很舒畅！也认识了一个四川的男生，还在上大学，曾经自己骑行去过云南，还认识了一个广州的女孩（就是下图中的女孩），刚辞了工作专门出来游玩的，很佩服这种勇气！\n\n![brave girl](http://o8cfktdb3.bkt.clouddn.com/braveGirl.jpeg)\n\n　　最后用鹿晗的《某时某刻 Catch me when I fall》结个尾~~~\n\n<!--<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=29771231&auto=1&height=66\"></iframe>-->\n\n<iframe   \nheight=498 width=510   \nsrc=\"http://player.youku.com/embed/XMTc3MjI5NTk3Mg\"   \nframeborder=0 allowfullscreen>  \n</iframe>  \n\n","slug":"北京十渡","published":1,"updated":"2017-07-14T03:57:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj53c1dwo0030h3jjbbp48gqj","content":"<h3 id=\"2017-04-16-北京十渡飞拉达、蹦极\"><a href=\"#2017-04-16-北京十渡飞拉达、蹦极\" class=\"headerlink\" title=\"2017-04-16 北京十渡飞拉达、蹦极\"></a>2017-04-16 北京十渡飞拉达、蹦极</h3><p><img src=\"http://o8cfktdb3.bkt.clouddn.com/bengji.jpeg\" alt=\"蹦极\"><br>　　今天真是玩嗨了<br><a id=\"more\"></a><br>　　早上六点起床，准备好之后早早出了门，乘地铁赶往公主坟与大家集合。到了集合地，坐着租的面包车开始前往目的地————十渡。<br>　　十渡景区位于北京房山，到了景区之后，带队的队长确定参加飞拉达的人数开始买票。之前了解了一下飞拉达就是攀岩（岩壁探险或铁道式攀登），因为之前从来没参与过类似冒险运动，心里有点小紧张。因为人还比较多，所以一块请了一位教练。刚开始教练教授装备的穿戴，之后带领我们来到了攀岩的山脚下，教练说这座山大概有70多米，之后告诉了我们扣锁的使用，然后开始攀爬演示，小伙伴们也开始一个个紧随其后开始了攀爬之路。<br><img src=\"http://o8cfktdb3.bkt.clouddn.com/feilada.jpeg\" alt=\"飞拉达\"><br>　　飞拉达历经大约三个小时，穿越了ABCD区，终于到达了终点。教练帮我们把所有锁扣都挂到绳索上，下面是湖水，随着绳索划过去才算再次到达了地面。</p>\n<p>　　之后和大家一起腐败吃午餐，吃午餐的餐厅对面正好就是蹦极的跳台，是不是看着一个个挑战者坠落、弹跳…　由于某些原因（吃的有点多了，惭愧…），本来打算不参加蹦极了，但是一想如果不参加，回去之后一定会捶胸顿足，后悔不跌，而且同性的小伙伴除了一对情侣之外都参加了，狠了狠心还是买了票。<br>　　来到蹦极门口，工作人员给每个人测量了身高和体重，并把数据写到了手背上。由于蹦极的人很多，等了大约有两三个小时，期间目睹一个一个从跳台自由落体，还有情侣相拥跳下，他们调侃这肯定是他们这辈子抱得最紧的一次了吧~~轮到我们的时候，不知怎么安排的被调到了最后一个，轮到我的时候，工作人员开始给我腿上绑绳，把眼镜粘到了胳膊上，为了避免女生走光把上衣和裤子的连接处也用胶带粘上了，说实话，自从买了票心有一直还挺紧张的，但真到了马上就要跳下去的时候，心里反而没有那么紧张了，还算比较平静。起跳之前冲着镜头挥挥手，然后只要张开双臂就可以了，看着50米下宽阔的湖水，心里还真是怂了，嗯，怂了（幸亏自己还是近视眼，并且还没戴眼镜）…接着工作人员扶着胳膊向前推去，从未有过的自由落体的失重感觉瞬间侵占了大脑，一片空白，只得紧闭双眼，只感觉到达最低点之后又弹跳到了下降高度的三分之二，然后又开始降落，才敢睁开眼睛环顾四周，之后又弹了大概两三次，高度就不是很高了，才开始享受蹦极的乐趣，然后就被放了下来，湖面上又专业人员把我接了下去，整个过程也就是一两分钟的样子，算是真切的感受了一次蹦极的刺激！<br>　　今天认识了一个很说的来的朋友，我俩基本上叽叽喳喳聊了一天，感觉很是投缘，遇到很聊得来的人总是感觉心情很舒畅！也认识了一个四川的男生，还在上大学，曾经自己骑行去过云南，还认识了一个广州的女孩（就是下图中的女孩），刚辞了工作专门出来游玩的，很佩服这种勇气！</p>\n<p><img src=\"http://o8cfktdb3.bkt.clouddn.com/braveGirl.jpeg\" alt=\"brave girl\"></p>\n<p>　　最后用鹿晗的《某时某刻 Catch me when I fall》结个尾~~~</p>\n<!--<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=29771231&auto=1&height=66\"></iframe>-->\n<iframe height=\"498\" width=\"510\" src=\"http://player.youku.com/embed/XMTc3MjI5NTk3Mg\" frameborder=\"0\" allowfullscreen><br></iframe>  \n\n","site":{"data":{}},"excerpt":"<h3 id=\"2017-04-16-北京十渡飞拉达、蹦极\"><a href=\"#2017-04-16-北京十渡飞拉达、蹦极\" class=\"headerlink\" title=\"2017-04-16 北京十渡飞拉达、蹦极\"></a>2017-04-16 北京十渡飞拉达、蹦极</h3><p><img src=\"http://o8cfktdb3.bkt.clouddn.com/bengji.jpeg\" alt=\"蹦极\"><br>　　今天真是玩嗨了<br>","more":"<br>　　早上六点起床，准备好之后早早出了门，乘地铁赶往公主坟与大家集合。到了集合地，坐着租的面包车开始前往目的地————十渡。<br>　　十渡景区位于北京房山，到了景区之后，带队的队长确定参加飞拉达的人数开始买票。之前了解了一下飞拉达就是攀岩（岩壁探险或铁道式攀登），因为之前从来没参与过类似冒险运动，心里有点小紧张。因为人还比较多，所以一块请了一位教练。刚开始教练教授装备的穿戴，之后带领我们来到了攀岩的山脚下，教练说这座山大概有70多米，之后告诉了我们扣锁的使用，然后开始攀爬演示，小伙伴们也开始一个个紧随其后开始了攀爬之路。<br><img src=\"http://o8cfktdb3.bkt.clouddn.com/feilada.jpeg\" alt=\"飞拉达\"><br>　　飞拉达历经大约三个小时，穿越了ABCD区，终于到达了终点。教练帮我们把所有锁扣都挂到绳索上，下面是湖水，随着绳索划过去才算再次到达了地面。</p>\n<p>　　之后和大家一起腐败吃午餐，吃午餐的餐厅对面正好就是蹦极的跳台，是不是看着一个个挑战者坠落、弹跳…　由于某些原因（吃的有点多了，惭愧…），本来打算不参加蹦极了，但是一想如果不参加，回去之后一定会捶胸顿足，后悔不跌，而且同性的小伙伴除了一对情侣之外都参加了，狠了狠心还是买了票。<br>　　来到蹦极门口，工作人员给每个人测量了身高和体重，并把数据写到了手背上。由于蹦极的人很多，等了大约有两三个小时，期间目睹一个一个从跳台自由落体，还有情侣相拥跳下，他们调侃这肯定是他们这辈子抱得最紧的一次了吧~~轮到我们的时候，不知怎么安排的被调到了最后一个，轮到我的时候，工作人员开始给我腿上绑绳，把眼镜粘到了胳膊上，为了避免女生走光把上衣和裤子的连接处也用胶带粘上了，说实话，自从买了票心有一直还挺紧张的，但真到了马上就要跳下去的时候，心里反而没有那么紧张了，还算比较平静。起跳之前冲着镜头挥挥手，然后只要张开双臂就可以了，看着50米下宽阔的湖水，心里还真是怂了，嗯，怂了（幸亏自己还是近视眼，并且还没戴眼镜）…接着工作人员扶着胳膊向前推去，从未有过的自由落体的失重感觉瞬间侵占了大脑，一片空白，只得紧闭双眼，只感觉到达最低点之后又弹跳到了下降高度的三分之二，然后又开始降落，才敢睁开眼睛环顾四周，之后又弹了大概两三次，高度就不是很高了，才开始享受蹦极的乐趣，然后就被放了下来，湖面上又专业人员把我接了下去，整个过程也就是一两分钟的样子，算是真切的感受了一次蹦极的刺激！<br>　　今天认识了一个很说的来的朋友，我俩基本上叽叽喳喳聊了一天，感觉很是投缘，遇到很聊得来的人总是感觉心情很舒畅！也认识了一个四川的男生，还在上大学，曾经自己骑行去过云南，还认识了一个广州的女孩（就是下图中的女孩），刚辞了工作专门出来游玩的，很佩服这种勇气！</p>\n<p><img src=\"http://o8cfktdb3.bkt.clouddn.com/braveGirl.jpeg\" alt=\"brave girl\"></p>\n<p>　　最后用鹿晗的《某时某刻 Catch me when I fall》结个尾~~~</p>\n<!--<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=29771231&auto=1&height=66\"></iframe>-->\n<iframe height=\"498\" width=\"510\" src=\"http://player.youku.com/embed/XMTc3MjI5NTk3Mg\" frameborder=\"0\" allowfullscreen><br></iframe>"},{"title":"将.c文件打包成库文件","date":"2017-03-06T10:43:09.000Z","toc":true,"_content":"\n## 打包.a\n\n1.Cocoa Touch Static Library\n2.添加要打包的文件:.c，.h\n3.将头文件添加到Build Phases -> Copy Files中去\n4.需要修改Build Settings中的 Build Active Architecture Only 以满足运行不同CPU环境的模拟器。 将此设置为NO。\n　选择Edit Scheme--> Buid Configuration设置为release\n<!--more-->\n5.分别选择模拟器和真机编译，生成.a文件，在不同编译环境下编译会生成四种静态库，debug模拟器，debug真机，release模拟器，release真机\n6.查看静态库所支持的CPU环境：lipo -info 静态库文件\n7.合并静态库：lipo -create 静态库1 静态库2 -output 新静态库名称.a\n\n注意：\n1.如果直接拖拽的是一个项目，并将项目当做一个静态库引用需要这样处理：在 Build Phases 中的 Target Dependencies 和 Link Binary With Libraries 中分别添加项目。\n如果仅仅是一个静态库的话，那么Link Binary WithLibraries 是必须添加的。\n2.如果编译的静态库中有分类的话必须在 Build Settings --> Other Linker Flags 中加 -Objc 如果还崩溃，还得加上 -all_load\n\n## 打包.so\n1.编译\n```\ngcc -c -fPIC -o myfile.o myfile.c\n```\n\n2.生成.so文件\n```\ngcc -shared -o libname.so myfile.o\n```\n\n","source":"_posts/将-c文件打包成库文件.md","raw":"---\ntitle: 将.c文件打包成库文件\ndate: 2017-03-06 18:43:09\ncategories: 笔记\ntags: [.c,.a,.so]\ntoc: true\n---\n\n## 打包.a\n\n1.Cocoa Touch Static Library\n2.添加要打包的文件:.c，.h\n3.将头文件添加到Build Phases -> Copy Files中去\n4.需要修改Build Settings中的 Build Active Architecture Only 以满足运行不同CPU环境的模拟器。 将此设置为NO。\n　选择Edit Scheme--> Buid Configuration设置为release\n<!--more-->\n5.分别选择模拟器和真机编译，生成.a文件，在不同编译环境下编译会生成四种静态库，debug模拟器，debug真机，release模拟器，release真机\n6.查看静态库所支持的CPU环境：lipo -info 静态库文件\n7.合并静态库：lipo -create 静态库1 静态库2 -output 新静态库名称.a\n\n注意：\n1.如果直接拖拽的是一个项目，并将项目当做一个静态库引用需要这样处理：在 Build Phases 中的 Target Dependencies 和 Link Binary With Libraries 中分别添加项目。\n如果仅仅是一个静态库的话，那么Link Binary WithLibraries 是必须添加的。\n2.如果编译的静态库中有分类的话必须在 Build Settings --> Other Linker Flags 中加 -Objc 如果还崩溃，还得加上 -all_load\n\n## 打包.so\n1.编译\n```\ngcc -c -fPIC -o myfile.o myfile.c\n```\n\n2.生成.so文件\n```\ngcc -shared -o libname.so myfile.o\n```\n\n","slug":"将-c文件打包成库文件","published":1,"updated":"2017-07-14T03:57:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj53c1dwr0032h3jjotph6558","content":"<h2 id=\"打包-a\"><a href=\"#打包-a\" class=\"headerlink\" title=\"打包.a\"></a>打包.a</h2><p>1.Cocoa Touch Static Library<br>2.添加要打包的文件:.c，.h<br>3.将头文件添加到Build Phases -&gt; Copy Files中去<br>4.需要修改Build Settings中的 Build Active Architecture Only 以满足运行不同CPU环境的模拟器。 将此设置为NO。<br>　选择Edit Scheme–&gt; Buid Configuration设置为release<br><a id=\"more\"></a><br>5.分别选择模拟器和真机编译，生成.a文件，在不同编译环境下编译会生成四种静态库，debug模拟器，debug真机，release模拟器，release真机<br>6.查看静态库所支持的CPU环境：lipo -info 静态库文件<br>7.合并静态库：lipo -create 静态库1 静态库2 -output 新静态库名称.a</p>\n<p>注意：<br>1.如果直接拖拽的是一个项目，并将项目当做一个静态库引用需要这样处理：在 Build Phases 中的 Target Dependencies 和 Link Binary With Libraries 中分别添加项目。<br>如果仅仅是一个静态库的话，那么Link Binary WithLibraries 是必须添加的。<br>2.如果编译的静态库中有分类的话必须在 Build Settings –&gt; Other Linker Flags 中加 -Objc 如果还崩溃，还得加上 -all_load</p>\n<h2 id=\"打包-so\"><a href=\"#打包-so\" class=\"headerlink\" title=\"打包.so\"></a>打包.so</h2><p>1.编译<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">gcc -c -fPIC -o myfile.o myfile.c</div></pre></td></tr></table></figure></p>\n<p>2.生成.so文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">gcc -shared -o libname.so myfile.o</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"打包-a\"><a href=\"#打包-a\" class=\"headerlink\" title=\"打包.a\"></a>打包.a</h2><p>1.Cocoa Touch Static Library<br>2.添加要打包的文件:.c，.h<br>3.将头文件添加到Build Phases -&gt; Copy Files中去<br>4.需要修改Build Settings中的 Build Active Architecture Only 以满足运行不同CPU环境的模拟器。 将此设置为NO。<br>　选择Edit Scheme–&gt; Buid Configuration设置为release<br>","more":"<br>5.分别选择模拟器和真机编译，生成.a文件，在不同编译环境下编译会生成四种静态库，debug模拟器，debug真机，release模拟器，release真机<br>6.查看静态库所支持的CPU环境：lipo -info 静态库文件<br>7.合并静态库：lipo -create 静态库1 静态库2 -output 新静态库名称.a</p>\n<p>注意：<br>1.如果直接拖拽的是一个项目，并将项目当做一个静态库引用需要这样处理：在 Build Phases 中的 Target Dependencies 和 Link Binary With Libraries 中分别添加项目。<br>如果仅仅是一个静态库的话，那么Link Binary WithLibraries 是必须添加的。<br>2.如果编译的静态库中有分类的话必须在 Build Settings –&gt; Other Linker Flags 中加 -Objc 如果还崩溃，还得加上 -all_load</p>\n<h2 id=\"打包-so\"><a href=\"#打包-so\" class=\"headerlink\" title=\"打包.so\"></a>打包.so</h2><p>1.编译<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">gcc -c -fPIC -o myfile.o myfile.c</div></pre></td></tr></table></figure></p>\n<p>2.生成.so文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">gcc -shared -o libname.so myfile.o</div></pre></td></tr></table></figure></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cj53c1dua0001h3jjn1w13gmn","category_id":"cj53c1duw0004h3jjbmh8aqil","_id":"cj53c1dva000ch3jjumxvxwdl"},{"post_id":"cj53c1duu0003h3jjthpdgoeo","category_id":"cj53c1duw0004h3jjbmh8aqil","_id":"cj53c1dve000ih3jj9v988ajh"},{"post_id":"cj53c1dvd000gh3jjloql2all","category_id":"cj53c1dvb000eh3jjy8sl7ucr","_id":"cj53c1dvh000ph3jjj4a04aqm"},{"post_id":"cj53c1duz0006h3jjrljh1lt6","category_id":"cj53c1dvb000eh3jjy8sl7ucr","_id":"cj53c1dvj000sh3jjwpx2d0nh"},{"post_id":"cj53c1dve000jh3jj67zuf972","category_id":"cj53c1dvb000eh3jjy8sl7ucr","_id":"cj53c1dvk000vh3jjvae7o13s"},{"post_id":"cj53c1dvg000nh3jjual13wj6","category_id":"cj53c1dvb000eh3jjy8sl7ucr","_id":"cj53c1dvn000yh3jjc7qv97ps"},{"post_id":"cj53c1dv00007h3jjtnta7sha","category_id":"cj53c1dvb000eh3jjy8sl7ucr","_id":"cj53c1dvo0011h3jjqucimjiv"},{"post_id":"cj53c1dvh000qh3jj8kq8qcty","category_id":"cj53c1dvb000eh3jjy8sl7ucr","_id":"cj53c1dvq0015h3jjc6p8l56n"},{"post_id":"cj53c1dvj000uh3jjk3c6yais","category_id":"cj53c1dvb000eh3jjy8sl7ucr","_id":"cj53c1dvs0019h3jjws1funzj"},{"post_id":"cj53c1dv30008h3jj6sdx9gw5","category_id":"cj53c1dvb000eh3jjy8sl7ucr","_id":"cj53c1dvu001bh3jjjj6m8csl"},{"post_id":"cj53c1dvk000wh3jji6n4ys48","category_id":"cj53c1dvb000eh3jjy8sl7ucr","_id":"cj53c1dvx001eh3jjhp2fnou0"},{"post_id":"cj53c1dvn000zh3jj9a4uk7sr","category_id":"cj53c1dvb000eh3jjy8sl7ucr","_id":"cj53c1dvz001hh3jj49pjjyve"},{"post_id":"cj53c1dv9000bh3jj9lj3ezxy","category_id":"cj53c1dvb000eh3jjy8sl7ucr","_id":"cj53c1dw1001lh3jjubombumv"},{"post_id":"cj53c1dvo0013h3jjtkyim1t7","category_id":"cj53c1dvb000eh3jjy8sl7ucr","_id":"cj53c1dw3001nh3jj7qftiko5"},{"post_id":"cj53c1dvr0017h3jjzuyl23ac","category_id":"cj53c1dvb000eh3jjy8sl7ucr","_id":"cj53c1dw4001ph3jjisuxs58j"},{"post_id":"cj53c1dva000dh3jjf5rwkwss","category_id":"cj53c1dvb000eh3jjy8sl7ucr","_id":"cj53c1dw5001sh3jj120j33p2"},{"post_id":"cj53c1dvs001ah3jjiaclz600","category_id":"cj53c1dvb000eh3jjy8sl7ucr","_id":"cj53c1dw7001uh3jju1o8hoyb"},{"post_id":"cj53c1dvu001ch3jjpb38948x","category_id":"cj53c1dvb000eh3jjy8sl7ucr","_id":"cj53c1dw8001xh3jjm5pujnp2"},{"post_id":"cj53c1dvx001fh3jjb7d4u3ud","category_id":"cj53c1dvb000eh3jjy8sl7ucr","_id":"cj53c1dw90020h3jj9yzug4e2"},{"post_id":"cj53c1dvz001ih3jjbzlhkarv","category_id":"cj53c1dvb000eh3jjy8sl7ucr","_id":"cj53c1dwb0024h3jjnwh1tx7f"},{"post_id":"cj53c1dw1001mh3jjfju3ndt5","category_id":"cj53c1dvb000eh3jjy8sl7ucr","_id":"cj53c1dwc0027h3jjs1eplbqy"},{"post_id":"cj53c1dw3001oh3jjvg2yfimo","category_id":"cj53c1dvb000eh3jjy8sl7ucr","_id":"cj53c1dwd002ah3jjl0kkviq5"},{"post_id":"cj53c1dw5001rh3jj5c312ofk","category_id":"cj53c1dvb000eh3jjy8sl7ucr","_id":"cj53c1dwg002dh3jjvyjceb6e"},{"post_id":"cj53c1dw5001th3jjs6lkjyki","category_id":"cj53c1dvb000eh3jjy8sl7ucr","_id":"cj53c1dwh002hh3jjsj7ip163"},{"post_id":"cj53c1dw7001vh3jjnaic4lv8","category_id":"cj53c1dvb000eh3jjy8sl7ucr","_id":"cj53c1dwi002jh3jjqtd3kp2x"},{"post_id":"cj53c1dw9001zh3jjzkg5t5iy","category_id":"cj53c1dvb000eh3jjy8sl7ucr","_id":"cj53c1dwj002mh3jjfkfokkod"},{"post_id":"cj53c1dwa0022h3jjfvf0lu4z","category_id":"cj53c1dvb000eh3jjy8sl7ucr","_id":"cj53c1dwk002ph3jja65cvo4v"},{"post_id":"cj53c1dwc0026h3jjg1ra45l3","category_id":"cj53c1dvb000eh3jjy8sl7ucr","_id":"cj53c1dwk002sh3jjg87v2ymt"},{"post_id":"cj53c1dwc0028h3jj4iq0w96h","category_id":"cj53c1dvb000eh3jjy8sl7ucr","_id":"cj53c1dwm002wh3jjssvrb0zk"},{"post_id":"cj53c1dwe002bh3jjqeklai2j","category_id":"cj53c1dvb000eh3jjy8sl7ucr","_id":"cj53c1dwn002yh3jjacxu4s3h"},{"post_id":"cj53c1dwg002eh3jjzkvs8ah9","category_id":"cj53c1dvb000eh3jjy8sl7ucr","_id":"cj53c1dwr0031h3jjhcyhiqkp"},{"post_id":"cj53c1dwh002ih3jjzc8it3v5","category_id":"cj53c1dvb000eh3jjy8sl7ucr","_id":"cj53c1dwr0033h3jji3ulb2uj"},{"post_id":"cj53c1dwi002kh3jjrsx7qjxh","category_id":"cj53c1dvb000eh3jjy8sl7ucr","_id":"cj53c1dws0035h3jj33777me4"},{"post_id":"cj53c1dwj002nh3jjcxi5lql3","category_id":"cj53c1dvb000eh3jjy8sl7ucr","_id":"cj53c1dws0037h3jj7yc0hqzb"},{"post_id":"cj53c1dwk002qh3jja7bdozjd","category_id":"cj53c1dvb000eh3jjy8sl7ucr","_id":"cj53c1dws003ah3jj2qwyaajp"},{"post_id":"cj53c1dwm002xh3jj1gdl3gzx","category_id":"cj53c1dvb000eh3jjy8sl7ucr","_id":"cj53c1dwt003bh3jj9bwugevr"},{"post_id":"cj53c1dwo0030h3jjbbp48gqj","category_id":"cj53c1duw0004h3jjbmh8aqil","_id":"cj53c1dwt003dh3jjk0bsh4j4"},{"post_id":"cj53c1dwr0032h3jjotph6558","category_id":"cj53c1dvb000eh3jjy8sl7ucr","_id":"cj53c1dwu003fh3jjt7l85k10"}],"PostTag":[{"post_id":"cj53c1dua0001h3jjn1w13gmn","tag_id":"cj53c1duy0005h3jj01j99ffq","_id":"cj53c1dvd000hh3jjzcjgg3gp"},{"post_id":"cj53c1dua0001h3jjn1w13gmn","tag_id":"cj53c1dv7000ah3jjrmpt3zht","_id":"cj53c1dvf000kh3jjszckteje"},{"post_id":"cj53c1duu0003h3jjthpdgoeo","tag_id":"cj53c1dvc000fh3jjowv68n83","_id":"cj53c1dvh000oh3jjy6uz1uze"},{"post_id":"cj53c1duz0006h3jjrljh1lt6","tag_id":"cj53c1dvg000mh3jjkfpbume5","_id":"cj53c1dvo0012h3jjsiop6n3h"},{"post_id":"cj53c1duz0006h3jjrljh1lt6","tag_id":"cj53c1dvj000th3jj8andet0n","_id":"cj53c1dvq0016h3jjgxkkmc6r"},{"post_id":"cj53c1dv00007h3jjtnta7sha","tag_id":"cj53c1dvo0010h3jjnxxr6o8a","_id":"cj53c1dvz001gh3jjlrd56crq"},{"post_id":"cj53c1dv00007h3jjtnta7sha","tag_id":"cj53c1dvs0018h3jj4y88vjw2","_id":"cj53c1dw0001jh3jjfxip6ac7"},{"post_id":"cj53c1dv30008h3jj6sdx9gw5","tag_id":"cj53c1dvo0010h3jjnxxr6o8a","_id":"cj53c1dw8001yh3jjhxzprm45"},{"post_id":"cj53c1dv30008h3jj6sdx9gw5","tag_id":"cj53c1dw0001kh3jjxjiksmvx","_id":"cj53c1dwa0021h3jjcr2b3kva"},{"post_id":"cj53c1dv30008h3jj6sdx9gw5","tag_id":"cj53c1dw4001qh3jj6pdalch5","_id":"cj53c1dwb0025h3jja6zq2r82"},{"post_id":"cj53c1dv9000bh3jj9lj3ezxy","tag_id":"cj53c1dvo0010h3jjnxxr6o8a","_id":"cj53c1dwg002ch3jj622qu274"},{"post_id":"cj53c1dv9000bh3jj9lj3ezxy","tag_id":"cj53c1dwb0023h3jjvbinba2n","_id":"cj53c1dwh002fh3jjyfvvtta2"},{"post_id":"cj53c1dva000dh3jjf5rwkwss","tag_id":"cj53c1dvg000mh3jjkfpbume5","_id":"cj53c1dwk002oh3jjigc0o39e"},{"post_id":"cj53c1dva000dh3jjf5rwkwss","tag_id":"cj53c1dwh002gh3jja1zwwq9v","_id":"cj53c1dwk002rh3jjwhmarhs0"},{"post_id":"cj53c1dvd000gh3jjloql2all","tag_id":"cj53c1dwj002lh3jjztv7e7zl","_id":"cj53c1dwm002vh3jj6ayarrxu"},{"post_id":"cj53c1dve000jh3jj67zuf972","tag_id":"cj53c1dvo0010h3jjnxxr6o8a","_id":"cj53c1dws0036h3jj87d1r230"},{"post_id":"cj53c1dve000jh3jj67zuf972","tag_id":"cj53c1dwn002zh3jjlrqx3tl9","_id":"cj53c1dws0038h3jjtred0q5x"},{"post_id":"cj53c1dvg000nh3jjual13wj6","tag_id":"cj53c1dws0034h3jjmow1xl29","_id":"cj53c1dwu003eh3jjcf8oqjqm"},{"post_id":"cj53c1dvg000nh3jjual13wj6","tag_id":"cj53c1dws0039h3jjt6p1m9yl","_id":"cj53c1dwu003gh3jj37vntzto"},{"post_id":"cj53c1dvh000qh3jj8kq8qcty","tag_id":"cj53c1dws0034h3jjmow1xl29","_id":"cj53c1dwv003jh3jj73lltc3h"},{"post_id":"cj53c1dvh000qh3jj8kq8qcty","tag_id":"cj53c1dwu003hh3jji1gpry2d","_id":"cj53c1dwv003kh3jjfivdsenp"},{"post_id":"cj53c1dvj000uh3jjk3c6yais","tag_id":"cj53c1dvg000mh3jjkfpbume5","_id":"cj53c1dwv003mh3jj4vy4casw"},{"post_id":"cj53c1dvj000uh3jjk3c6yais","tag_id":"cj53c1dwv003ih3jjkw8mrtzk","_id":"cj53c1dww003nh3jjyie8d8gh"},{"post_id":"cj53c1dvk000wh3jji6n4ys48","tag_id":"cj53c1dvg000mh3jjkfpbume5","_id":"cj53c1dww003ph3jju6cmr9mx"},{"post_id":"cj53c1dvk000wh3jji6n4ys48","tag_id":"cj53c1dwv003lh3jjr4lo7j9e","_id":"cj53c1dwx003qh3jj8mlczwij"},{"post_id":"cj53c1dvn000zh3jj9a4uk7sr","tag_id":"cj53c1dvg000mh3jjkfpbume5","_id":"cj53c1dwy003sh3jjz5pg7rak"},{"post_id":"cj53c1dvn000zh3jj9a4uk7sr","tag_id":"cj53c1dwv003ih3jjkw8mrtzk","_id":"cj53c1dwz003th3jjheuwol5i"},{"post_id":"cj53c1dvo0013h3jjtkyim1t7","tag_id":"cj53c1dvg000mh3jjkfpbume5","_id":"cj53c1dwz003vh3jja1d69pvj"},{"post_id":"cj53c1dvo0013h3jjtkyim1t7","tag_id":"cj53c1dwx003rh3jjuqdobouj","_id":"cj53c1dwz003wh3jj8aqtw0zy"},{"post_id":"cj53c1dvr0017h3jjzuyl23ac","tag_id":"cj53c1dwz003uh3jjzo1wqbja","_id":"cj53c1dwz003yh3jjrp2ronnw"},{"post_id":"cj53c1dvs001ah3jjiaclz600","tag_id":"cj53c1dwz003xh3jjkhw5x9ow","_id":"cj53c1dx00042h3jjlc1tzd6g"},{"post_id":"cj53c1dvs001ah3jjiaclz600","tag_id":"cj53c1dwz003zh3jjp0bb2d6n","_id":"cj53c1dx00043h3jjt2mlj0bv"},{"post_id":"cj53c1dvs001ah3jjiaclz600","tag_id":"cj53c1dwz0040h3jjmbmskqqk","_id":"cj53c1dx10045h3jj30ciibiz"},{"post_id":"cj53c1dvu001ch3jjpb38948x","tag_id":"cj53c1dx00041h3jjeqsz0oms","_id":"cj53c1dx10046h3jj4muc563z"},{"post_id":"cj53c1dvx001fh3jjb7d4u3ud","tag_id":"cj53c1dx00044h3jjf1rlavbx","_id":"cj53c1dx10049h3jjh82noq0s"},{"post_id":"cj53c1dvx001fh3jjb7d4u3ud","tag_id":"cj53c1dx10047h3jjnq13a316","_id":"cj53c1dx1004ah3jjt6uhtvh8"},{"post_id":"cj53c1dvz001ih3jjbzlhkarv","tag_id":"cj53c1dx10048h3jj6j43nt7s","_id":"cj53c1dx1004ch3jj08exadtw"},{"post_id":"cj53c1dw1001mh3jjfju3ndt5","tag_id":"cj53c1dvg000mh3jjkfpbume5","_id":"cj53c1dx2004fh3jjcujxijdn"},{"post_id":"cj53c1dw1001mh3jjfju3ndt5","tag_id":"cj53c1dx1004bh3jjpmiuyg4s","_id":"cj53c1dx2004gh3jj6q5r01vc"},{"post_id":"cj53c1dw1001mh3jjfju3ndt5","tag_id":"cj53c1dx2004dh3jjhtokk58r","_id":"cj53c1dx3004ih3jjfy27xl5o"},{"post_id":"cj53c1dw3001oh3jjvg2yfimo","tag_id":"cj53c1dvg000mh3jjkfpbume5","_id":"cj53c1dx4004jh3jjeios305k"},{"post_id":"cj53c1dw3001oh3jjvg2yfimo","tag_id":"cj53c1dx2004eh3jj4cxldolf","_id":"cj53c1dx4004lh3jjym5fbsbp"},{"post_id":"cj53c1dw5001rh3jj5c312ofk","tag_id":"cj53c1dvg000mh3jjkfpbume5","_id":"cj53c1dx5004nh3jj68lza9uj"},{"post_id":"cj53c1dw5001rh3jj5c312ofk","tag_id":"cj53c1dx3004hh3jjfffofwwh","_id":"cj53c1dx5004oh3jjodnfccx9"},{"post_id":"cj53c1dw5001rh3jj5c312ofk","tag_id":"cj53c1dx4004kh3jj2ph6gtfg","_id":"cj53c1dx6004qh3jjtsrdyz0d"},{"post_id":"cj53c1dw5001th3jjs6lkjyki","tag_id":"cj53c1dvg000mh3jjkfpbume5","_id":"cj53c1dx6004rh3jjjg3l8yjm"},{"post_id":"cj53c1dw5001th3jjs6lkjyki","tag_id":"cj53c1dx4004mh3jjx87hny4q","_id":"cj53c1dx7004th3jjcjflrhrm"},{"post_id":"cj53c1dw7001vh3jjnaic4lv8","tag_id":"cj53c1dvg000mh3jjkfpbume5","_id":"cj53c1dx7004uh3jjvfjal687"},{"post_id":"cj53c1dw7001vh3jjnaic4lv8","tag_id":"cj53c1dx6004ph3jjvcztg3dz","_id":"cj53c1dx7004wh3jjzjyi3md7"},{"post_id":"cj53c1dw9001zh3jjzkg5t5iy","tag_id":"cj53c1dvg000mh3jjkfpbume5","_id":"cj53c1dx7004xh3jj5gg56u01"},{"post_id":"cj53c1dw9001zh3jjzkg5t5iy","tag_id":"cj53c1dx6004sh3jjzd5qxa61","_id":"cj53c1dx7004yh3jjhixrvqrr"},{"post_id":"cj53c1dwa0022h3jjfvf0lu4z","tag_id":"cj53c1dvg000mh3jjkfpbume5","_id":"cj53c1dx90053h3jjknmlsmf4"},{"post_id":"cj53c1dwa0022h3jjfvf0lu4z","tag_id":"cj53c1dx7004vh3jjc7w8zus4","_id":"cj53c1dx90054h3jjursa25zl"},{"post_id":"cj53c1dwa0022h3jjfvf0lu4z","tag_id":"cj53c1dx7004zh3jjwl7ptqe6","_id":"cj53c1dxa0056h3jjromsi20g"},{"post_id":"cj53c1dwa0022h3jjfvf0lu4z","tag_id":"cj53c1dx80050h3jj3c1w29e6","_id":"cj53c1dxa0057h3jji49ppjn8"},{"post_id":"cj53c1dwa0022h3jjfvf0lu4z","tag_id":"cj53c1dx90051h3jj5x45f6op","_id":"cj53c1dxb0059h3jj4keuoyy4"},{"post_id":"cj53c1dwc0026h3jjg1ra45l3","tag_id":"cj53c1dvg000mh3jjkfpbume5","_id":"cj53c1dxb005ah3jjchtacmzh"},{"post_id":"cj53c1dwc0026h3jjg1ra45l3","tag_id":"cj53c1dx90052h3jjpca0imxg","_id":"cj53c1dxb005ch3jjtobo7a0m"},{"post_id":"cj53c1dwc0028h3jj4iq0w96h","tag_id":"cj53c1dvg000mh3jjkfpbume5","_id":"cj53c1dxc005dh3jj0jlo1dg0"},{"post_id":"cj53c1dwc0028h3jj4iq0w96h","tag_id":"cj53c1dx90055h3jjgwrl6rje","_id":"cj53c1dxc005eh3jjxvt7afly"},{"post_id":"cj53c1dwe002bh3jjqeklai2j","tag_id":"cj53c1dvg000mh3jjkfpbume5","_id":"cj53c1dxd005gh3jj873v1elv"},{"post_id":"cj53c1dwe002bh3jjqeklai2j","tag_id":"cj53c1dxa0058h3jjecnrzxoo","_id":"cj53c1dxd005hh3jjsc9m9l6a"},{"post_id":"cj53c1dwg002eh3jjzkvs8ah9","tag_id":"cj53c1dvg000mh3jjkfpbume5","_id":"cj53c1dxd005jh3jj5qusav0x"},{"post_id":"cj53c1dwg002eh3jjzkvs8ah9","tag_id":"cj53c1dxb005bh3jji8qytfxy","_id":"cj53c1dxd005kh3jj6yq7afhn"},{"post_id":"cj53c1dwh002ih3jjzc8it3v5","tag_id":"cj53c1dvg000mh3jjkfpbume5","_id":"cj53c1dxe005mh3jjlt9twdt5"},{"post_id":"cj53c1dwh002ih3jjzc8it3v5","tag_id":"cj53c1dxd005fh3jjddz211v4","_id":"cj53c1dxe005nh3jjdqxoae23"},{"post_id":"cj53c1dwi002kh3jjrsx7qjxh","tag_id":"cj53c1dvo0010h3jjnxxr6o8a","_id":"cj53c1dxe005ph3jjn8o9myiw"},{"post_id":"cj53c1dwi002kh3jjrsx7qjxh","tag_id":"cj53c1dxd005ih3jj6ur896e2","_id":"cj53c1dxe005qh3jjxc7fqhhe"},{"post_id":"cj53c1dwj002nh3jjcxi5lql3","tag_id":"cj53c1dxd005lh3jjs74anql7","_id":"cj53c1dxe005sh3jj1na0mv4m"},{"post_id":"cj53c1dwj002nh3jjcxi5lql3","tag_id":"cj53c1dxe005oh3jjsoowsv6d","_id":"cj53c1dxe005th3jjw8hwicsm"},{"post_id":"cj53c1dwk002qh3jja7bdozjd","tag_id":"cj53c1dvo0010h3jjnxxr6o8a","_id":"cj53c1dxf005vh3jjcqe94bsg"},{"post_id":"cj53c1dwk002qh3jja7bdozjd","tag_id":"cj53c1dxe005rh3jj461yuz7z","_id":"cj53c1dxf005wh3jj08q4o47a"},{"post_id":"cj53c1dwm002xh3jj1gdl3gzx","tag_id":"cj53c1dxe005uh3jjpzkyp9rn","_id":"cj53c1dxf005zh3jjtx7ld437"},{"post_id":"cj53c1dwm002xh3jj1gdl3gzx","tag_id":"cj53c1dxf005xh3jjfjucia7x","_id":"cj53c1dxf0060h3jj4nlg98j9"},{"post_id":"cj53c1dwo0030h3jjbbp48gqj","tag_id":"cj53c1dxf005yh3jj0qogja4g","_id":"cj53c1dxg0063h3jjtkj552oe"},{"post_id":"cj53c1dwo0030h3jjbbp48gqj","tag_id":"cj53c1dxf0061h3jjgpitvozm","_id":"cj53c1dxg0064h3jj7chdxytc"},{"post_id":"cj53c1dwr0032h3jjotph6558","tag_id":"cj53c1dxf0062h3jjbc4wvk2p","_id":"cj53c1dxg0067h3jjnbuew23g"},{"post_id":"cj53c1dwr0032h3jjotph6558","tag_id":"cj53c1dxg0065h3jj6l30z4i1","_id":"cj53c1dxg0068h3jjlpdewrac"},{"post_id":"cj53c1dwr0032h3jjotph6558","tag_id":"cj53c1dxg0066h3jjjdznyh3e","_id":"cj53c1dxg0069h3jjiub5gvm4"}],"Tag":[{"name":"玉渊潭","_id":"cj53c1duy0005h3jj01j99ffq"},{"name":"樱花节","_id":"cj53c1dv7000ah3jjrmpt3zht"},{"name":"798","_id":"cj53c1dvc000fh3jjowv68n83"},{"name":"iOS","_id":"cj53c1dvg000mh3jjkfpbume5"},{"name":"Apple Pay","_id":"cj53c1dvj000th3jj8andet0n"},{"name":"Java","_id":"cj53c1dvo0010h3jjnxxr6o8a"},{"name":"JSP","_id":"cj53c1dvs0018h3jj4y88vjw2"},{"name":"springMVC","_id":"cj53c1dw0001kh3jjxjiksmvx"},{"name":"项目","_id":"cj53c1dw4001qh3jj6pdalch5"},{"name":"语法","_id":"cj53c1dwb0023h3jjvbinba2n"},{"name":"MVVM","_id":"cj53c1dwh002gh3jja1zwwq9v"},{"name":"markdown","_id":"cj53c1dwj002lh3jjztv7e7zl"},{"name":"快捷键","_id":"cj53c1dwn002zh3jjlrqx3tl9"},{"name":"OC","_id":"cj53c1dws0034h3jjmow1xl29"},{"name":"JS","_id":"cj53c1dws0039h3jjt6p1m9yl"},{"name":"block","_id":"cj53c1dwu003hh3jji1gpry2d"},{"name":"RAC","_id":"cj53c1dwv003ih3jjkw8mrtzk"},{"name":"OpenGL","_id":"cj53c1dwv003lh3jjr4lo7j9e"},{"name":"ReactNative","_id":"cj53c1dwx003rh3jjuqdobouj"},{"name":"Swift","_id":"cj53c1dwz003uh3jjzo1wqbja"},{"name":"github","_id":"cj53c1dwz003xh3jjkhw5x9ow"},{"name":"SSH","_id":"cj53c1dwz003zh3jjp0bb2d6n"},{"name":"gitignore","_id":"cj53c1dwz0040h3jjmbmskqqk"},{"name":"Git","_id":"cj53c1dx00041h3jjeqsz0oms"},{"name":"hexo","_id":"cj53c1dx00044h3jjf1rlavbx"},{"name":"个人博客","_id":"cj53c1dx10047h3jjnq13a316"},{"name":"iBeacon","_id":"cj53c1dx10048h3jj6j43nt7s"},{"name":"IM","_id":"cj53c1dx1004bh3jjpmiuyg4s"},{"name":"socket","_id":"cj53c1dx2004dh3jjhtokk58r"},{"name":"runtime","_id":"cj53c1dx2004eh3jj4cxldolf"},{"name":"NSTimer","_id":"cj53c1dx3004hh3jjfffofwwh"},{"name":"后台","_id":"cj53c1dx4004kh3jj2ph6gtfg"},{"name":"动画","_id":"cj53c1dx4004mh3jjx87hny4q"},{"name":"国际化","_id":"cj53c1dx6004ph3jjvcztg3dz"},{"name":"test","_id":"cj53c1dx6004sh3jjzd5qxa61"},{"name":"音频","_id":"cj53c1dx7004vh3jjc7w8zus4"},{"name":"视频","_id":"cj53c1dx7004zh3jjwl7ptqe6"},{"name":"播放","_id":"cj53c1dx80050h3jj3c1w29e6"},{"name":"录制","_id":"cj53c1dx90051h3jj5x45f6op"},{"name":"多线程","_id":"cj53c1dx90052h3jjpca0imxg"},{"name":"app store","_id":"cj53c1dx90055h3jjgwrl6rje"},{"name":"直播","_id":"cj53c1dxa0058h3jjecnrzxoo"},{"name":"优化","_id":"cj53c1dxb005bh3jji8qytfxy"},{"name":"面试","_id":"cj53c1dxd005fh3jjddz211v4"},{"name":"web","_id":"cj53c1dxd005ih3jj6ur896e2"},{"name":"技巧","_id":"cj53c1dxd005lh3jjs74anql7"},{"name":"隐藏文件","_id":"cj53c1dxe005oh3jjsoowsv6d"},{"name":"mysql","_id":"cj53c1dxe005rh3jj461yuz7z"},{"name":"排序","_id":"cj53c1dxe005uh3jjpzkyp9rn"},{"name":"算法","_id":"cj53c1dxf005xh3jjfjucia7x"},{"name":"十渡","_id":"cj53c1dxf005yh3jj0qogja4g"},{"name":"蹦极","_id":"cj53c1dxf0061h3jjgpitvozm"},{"name":".c","_id":"cj53c1dxf0062h3jjbc4wvk2p"},{"name":".a","_id":"cj53c1dxg0065h3jj6l30z4i1"},{"name":".so","_id":"cj53c1dxg0066h3jjjdznyh3e"}]}}