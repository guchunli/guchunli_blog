<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>swift学习笔记 | guchunli</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="待补充Swift" />
  
  
  
  
  <meta name="description" content="在线swift编辑器：IBM Swift Sandbox 基础知识常量和变量let，var分别声明常量，变量">
<meta name="keywords" content="待补充,Swift">
<meta property="og:type" content="article">
<meta property="og:title" content="Swift学习笔记">
<meta property="og:url" content="https://guchunli.github.io/2017/07/14/Swift学习笔记/index.html">
<meta property="og:site_name" content="guchunli">
<meta property="og:description" content="在线swift编辑器：IBM Swift Sandbox 基础知识常量和变量let，var分别声明常量，变量">
<meta property="og:updated_time" content="2018-05-24T09:16:25.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Swift学习笔记">
<meta name="twitter:description" content="在线swift编辑器：IBM Swift Sandbox 基础知识常量和变量let，var分别声明常量，变量">
  
    <link rel="alternate" href="/atom.xml" title="guchunli" type="application/atom+xml">
  

  

  <link rel="icon" href="/css/images/mylogo.jpg">
  <link rel="apple-touch-icon" href="/css/images/mylogo.jpg">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>
  <script src="/js/bootstrap.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >

  
    <link rel="stylesheet" href="/css/dialog.css">
  

  

  
    <link rel="stylesheet" href="/css/header-post.css" >
  

  
  
  
    <link rel="stylesheet" href="/css/vdonate.css" >
  

</head>



  <body data-spy="scroll" data-target="#toc" data-offset="50">


  
  <div id="container">
    <div id="wrap">
      
        <header>

    <div id="allheader" class="navbar navbar-default navbar-static-top" role="navigation">
        <div class="navbar-inner">
          
          <div class="container"> 
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>

            
              <a class="brand" style="
                 margin-top: 0px;"  
                href="#" data-toggle="modal" data-target="#myModal" >
                  <img width="124px" height="124px" alt="Hike News" src="/css/images/mylogo.jpg">
              </a>
            
            
            <div class="navbar-collapse collapse">
              <ul class="hnav navbar-nav">
                
                  <li> <a class="main-nav-link" href="/">Startseite</a> </li>
                
                  <li> <a class="main-nav-link" href="/archives/">Archive</a> </li>
                
                  <li> <a class="main-nav-link" href="/categories/study/">study</a> </li>
                
                  <li> <a class="main-nav-link" href="/categories/other/">other</a> </li>
                
                  <li> <a class="main-nav-link" href="/photos">photos</a> </li>
                
                  <li> <a class="main-nav-link" href="/tags">Tags</a> </li>
                
                  <li> <a class="main-nav-link" href="/about">About</a> </li>
                
                  <li><div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Schreib etwas..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Beiträge',
            PAGES: 'Seiten',
            CATEGORIES: 'Kategorien',
            TAGS: 'Tags',
            UNTITLED: '(Unbenannt)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div></li>
            </div>
          </div>
                
      </div>
    </div>

</header>



      
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-Swift学习笔记" style="width: 75%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      Swift学习笔记
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/07/14/Swift学习笔记/" class="article-date">
	  <time datetime="2017-07-14T09:13:04.000Z" itemprop="datePublished">2017-07-14</time>
	</a>

      
    <a class="article-category-link" href="/categories/study/">学习</a>

      
	<a class="article-views">
	<span id="busuanzi_container_page_pv">
		PV:<span id="busuanzi_value_page_pv"></span>
	</span>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>在线swift编辑器：IBM Swift Sandbox</p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h2><p>let，var分别声明常量，变量<br><a id="more"></a><br><code>代码中有不需要改变的值，使用 let 关键字将它声明为常量</code></p>
<blockquote>
<p>使用 let 修饰 <code>view</code> 并且赋值，表示该常量的内存地址不允许修改，但是可以修改其内部的属性</p>
</blockquote>
<h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><ul>
<li><p>字面量是指像特定的数字，字符串或者是布尔值这样能够直接了当地指出自己的类型并对变量进行赋值的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let aNumber = 3</div><div class="line">let astring = &quot;Hello&quot;</div><div class="line">let aBool = true</div><div class="line"></div><div class="line">let anArray = [1,2,3]</div><div class="line">let aDictionary = [&quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot;]</div></pre></td></tr></table></figure>
</li>
<li><p>数值型字面量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let a = 11</div><div class="line">let b = 0b11</div><div class="line">let c = 0o11</div><div class="line">let d = 0x11</div><div class="line">let e = 2e2     //200</div><div class="line">let f = 2e-2    //0.02</div><div class="line">let g = 0xFp2   //60</div><div class="line">let h = 0xFp-2  //3.75</div><div class="line">let i = 1_000_000</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="类型标注"><a href="#类型标注" class="headerlink" title="类型标注"></a>类型标注</h2><p>很少需要标注，swift会进行类型推断，根据右边的代码，推导出变量的准确类型</p>
<blockquote>
<p>Option + Click 可以查看变量的类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let a:Float = 3.0</div></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>多行注释可嵌套</p>
<h2 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h2><p>swift语句，最后分号可写可不写</p>
<h2 id="打印日志"><a href="#打印日志" class="headerlink" title="打印日志"></a>打印日志</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">print(&quot;item1&quot;,&quot;item2&quot;,&quot;item3&quot;, separator: &quot;,,,&quot;, terminator: &quot;...&quot;)</div><div class="line">//item1,,,item2,,,item3...</div></pre></td></tr></table></figure>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>值永远不会被隐式转换为其他类型，如果要对不同类型的数据进行计算，必须要显式的转换</p>
<ul>
<li>与字面量的加减无关<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let a = &quot;abc&quot;</div><div class="line">let b = 9</div><div class="line">let ab = a + String(b)</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typealias Example = Int</div></pre></td></tr></table></figure>
<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><ul>
<li>元组可通过变量名或下标访问</li>
<li>可在定义元组的时候给元素命名</li>
<li>不需要访问的元素可用<code>_</code>代替</li>
<li>元组可作为函数返回值返回多个值<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let (color,price,_) = (&quot;red&quot;,80,true)</div><div class="line">print(color)</div><div class="line">let pen = (&quot;red&quot;,80,true)</div><div class="line">let (color,price,_) = pen</div><div class="line">print(color)</div><div class="line">print(pen.0)</div><div class="line">let some = (color:&quot;red&quot;,price:80)</div><div class="line">print(some.color)</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="可选类型"><a href="#可选类型" class="headerlink" title="可选类型"></a>可选类型</h2><p>可以是任何类型值的缺失<br>显式类型转换结果是可选类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var s: String = &quot;hello&quot;</div><div class="line">//s = nil //错误</div><div class="line">var s1: String? = &quot;hello&quot;</div><div class="line">s1 = nil</div></pre></td></tr></table></figure></p>
<h2 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h2><p>nil是一个确定的值，表示值缺失，任何类型的可选状态都可以被设置为nil<br>不可用于非可选的常量和变量<br>可选常量或变量不赋值，自动设值为nil</p>
<ul>
<li>在OC中nil是指针，在swift中nil是可选类型。</li>
</ul>
<h2 id="if-语句以及强制解析"><a href="#if-语句以及强制解析" class="headerlink" title="if 语句以及强制解析"></a>if 语句以及强制解析</h2><p>if语句中的条件必须是一个布尔表达式<br>当一个可选常量或变量确定包含值时，可用<code>!</code>强制解析</p>
<blockquote>
<p><code>()</code> 可以省略，但是 <code>{}</code> 不能省略</p>
<ul>
<li>当 if 的嵌套层次很深，可用where<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if let u = url where u.host == &quot;www.baidu.com&quot; &#123;&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>解包：<br>(1)!强行解包,如果 变量 为空，运行时会崩溃<br>(2)判断是否为空<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if str != nil &#123;</div><div class="line">print(str!)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>(3)<code>if let</code>可选绑定</p>
<h2 id="可选绑定"><a href="#可选绑定" class="headerlink" title="可选绑定"></a>可选绑定</h2><ul>
<li>需要改变，用<code>if var</code><br>可以用在if或while语句中<br>可以判断多个可选项是否为空，用<code>,</code>隔开</li>
<li>一旦进入if分支，变量就不再是可选项<blockquote>
<p><code>if let</code> 不能与使用 <code>&amp;</code>、<code>|</code> 等条件判断,可以使用 <code>where</code> 子句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if let constantName = someOptional &#123;</div><div class="line">//constantName</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h2 id="隐式解析可选类型"><a href="#隐式解析可选类型" class="headerlink" title="隐式解析可选类型"></a>隐式解析可选类型</h2><p>可选类型被第一次赋值之后就可以确定之后一直有值，这种类型的可选状态被定义为隐式解析可选类型，可使用!直接声明，之后不需要使用!取值。<br>隐式解析可选类型就是可以自动解析的可选类型。<br>仍然可以可选绑定。</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>抛出错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func canThrowAnError() throws &#123;</div><div class="line">    // 这个函数有可能抛出错误</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>捕获错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">do &#123;</div><div class="line">    try canThrowAnError()</div><div class="line">    // 没有错误消息抛出</div><div class="line">&#125; catch &#123;</div><div class="line">    // 有一个错误消息抛出</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>举个栗子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">enum LoginError : Error &#123;</div><div class="line">case UserNotFound, UserPasswordNotMatch</div><div class="line">&#125;</div><div class="line">func login(user: String, password: String) throws &#123;</div><div class="line"></div><div class="line">if 2 &gt; 1 &#123;</div><div class="line">throw LoginError.UserPasswordNotMatch</div><div class="line">&#125;</div><div class="line">if 1 &lt; 2 &#123;</div><div class="line">throw LoginError.UserNotFound</div><div class="line">&#125;</div><div class="line">print(&quot;Login successfully.&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">do &#123;</div><div class="line">try login(user: &quot;onevcat&quot;, password: &quot;123&quot;)</div><div class="line">&#125; catch LoginError.UserNotFound &#123;</div><div class="line">print(&quot;UserNotFound&quot;)</div><div class="line">&#125; catch LoginError.UserPasswordNotMatch &#123;</div><div class="line">print(&quot;UserPasswordNotMatch&quot;)</div><div class="line">&#125; catch&#123;</div><div class="line">//加入一个空的catch，用于关闭catch。否则会报错：Errors thrown from here are not handled because the enclosing catch is not exhaustive</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>当前面表达式的结果为false时显示后面的消息，应用终止。后面的断言消息也可省略。<br>release配置时，断言被禁用。在代码发布时，我们也不需要刻意去把这些断言手动清除。</p>
<ul>
<li>一般以下情况使用：<ul>
<li>下标越界</li>
<li>传递给函数的参数不符合类型</li>
<li>解析可选类型：一个可选值当前为 nil ，但随后的代码就需要非空的值才能成功执行。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let age = 17</div><div class="line">assert(age&gt;=18,&quot;未成年人&quot;)</div><div class="line">//Assertion failed: 未成年人</div></pre></td></tr></table></figure>
<h2 id="fatalError"><a href="#fatalError" class="headerlink" title="fatalError"></a>fatalError</h2><ul>
<li>因为断言只会在 Debug 环境中有效，而在 Release 编译中所以变得断言都将被禁用。所以我们会考虑以产生致命错误(fatalError)的方式来种植程序。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">required init?(coder aDecoder: NSCoder) &#123;</div><div class="line">    fatalError(&quot;init(coder:) has not been implemented&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class MyClass &#123;</div><div class="line">func methodMustBeImplementedInSubclass() &#123;</div><div class="line">fatalError(&quot;这个方法必须在子类中被重写&quot;) &#125;</div><div class="line">&#125;</div><div class="line">class YourClass: MyClass &#123;</div><div class="line">override func methodMustBeImplementedInSubclass() &#123;</div><div class="line">print(&quot;YourClass 实现了该方法&quot;)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">class TheirClass: MyClass &#123;</div><div class="line">func someOtherMethod() &#123;</div><div class="line">&#125;</div><div class="line">//    override func methodMustBeImplementedInSubclass() &#123;</div><div class="line">//        print(&quot;TheirClass 实现了该方法&quot;)</div><div class="line">//    &#125;</div><div class="line">&#125;</div><div class="line">YourClass().methodMustBeImplementedInSubclass()</div></pre></td></tr></table></figure>
<h1 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let a = 3</div><div class="line">let b = 3.3</div><div class="line">let c = Double(a)*b //或 let c = a*Int(b)</div></pre></td></tr></table></figure>
<h2 id="不可自增自减"><a href="#不可自增自减" class="headerlink" title="不可自增自减"></a>不可自增自减</h2><h2 id="取余"><a href="#取余" class="headerlink" title="取余"></a>取余</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">10 % 6  //4</div><div class="line">10 % -6 //4</div><div class="line">-10 % 6 //-4</div></pre></td></tr></table></figure>
<h2 id="空值合并-空合-运算符"><a href="#空值合并-空合-运算符" class="headerlink" title="空值合并(空合)运算符??"></a>空值合并(空合)运算符??</h2><p>可对可选类型a进行空判断，如果包含值就解封，否则返回默认值b，此默认值b也为可选类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let a = Int(&quot;aaa&quot;)</div><div class="line">let b = 2</div><div class="line">let c = a ?? b  //等同于 let c = a != nil ? a! : b</div></pre></td></tr></table></figure></p>
<h2 id="区间运算符"><a href="#区间运算符" class="headerlink" title="区间运算符"></a>区间运算符</h2><ul>
<li>闭区间：… </li>
<li>半开区间：..&lt;</li>
</ul>
<h1 id="字符与字符串"><a href="#字符与字符串" class="headerlink" title="字符与字符串"></a>字符与字符串</h1><h2 id="初始化空字符串"><a href="#初始化空字符串" class="headerlink" title="初始化空字符串"></a>初始化空字符串</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let s1 = &quot;&quot;</div><div class="line">let s2 = String()</div></pre></td></tr></table></figure>
<h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><p>str.characters<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let c = &quot;a&quot;</div><div class="line"></div><div class="line">let chars:[Character] = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</div><div class="line">let str = String[chars]</div><div class="line">for char in are&#123;</div><div class="line">print(char)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="字符串可变性"><a href="#字符串可变性" class="headerlink" title="字符串可变性"></a>字符串可变性</h2><p>变量可变，常量不可变</p>
<h2 id="连接字符串和字符"><a href="#连接字符串和字符" class="headerlink" title="连接字符串和字符"></a>连接字符串和字符</h2><ul>
<li>+：只能连接字符串，不能连接字符</li>
<li>append<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var str1 = &quot;12&quot;</div><div class="line">let str2 = &quot;34&quot;</div><div class="line">let char1:Character = &quot;5&quot;</div><div class="line">str1 += str2</div><div class="line">//str1 += char1     //+：只能连接字符串，不能连接字符</div><div class="line">str1.append(char1)</div><div class="line">str1.append(str2)</div><div class="line">//str1.append(contentsOf: char1)    //contentsOf：只能连接字符串，不能连接字符</div><div class="line">str1.append(contentsOf: str2)</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h2><p>以下方法也可使用在Array,Dictionary,Set中。</p>
<ul>
<li>str.characters.indices所有索引</li>
<li>在某个索引值之前插入字符：<code>insert(_:at:)</code>，不能越界</li>
<li><p>插入字符串：<code>insert(contentsOf:at:)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var hello = &quot;hello&quot;;</div><div class="line">hello.insert(contentsOf:&quot; world!&quot;.characters, at: hello(before: welcome.endIndex))</div></pre></td></tr></table></figure>
</li>
<li><p>删除字符：<code>remove(at:)</code>，越界返回nil</p>
</li>
<li>removeFirst(2),removeLast()</li>
<li>删除字符串<code>removeSubrange(_:)</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var hello = &quot;hello world!&quot;</div><div class="line">let range = hello.index(hello.endIndex, offsetBy: -7)..&lt;hello.endIndex</div><div class="line">hello.removeSubrange(range)</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="计算字符数量"><a href="#计算字符数量" class="headerlink" title="计算字符数量"></a>计算字符数量</h2><p>str.characters.count</p>
<h2 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h2><ul>
<li><code>startIndex</code>,<code>endIndex</code>,<code>index(before:)</code>,<code>index(after:)</code>,<code>index(_:offsetBy:)</code>,也可以使用在Array,Dictionary,Set中</li>
<li>str.characters.indices所有索引</li>
</ul>
<h2 id="比较字符串"><a href="#比较字符串" class="headerlink" title="比较字符串"></a>比较字符串</h2><ul>
<li>字符串相等：==</li>
<li>前缀相等：<code>hasPrefix(_:)</code></li>
<li>后缀相等：<code>hasSuffix(_:)</code></li>
</ul>
<h2 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h2><p>值转换成字符串：()</p>
<blockquote>
<p>如果变量是可选项，拼接的结果中会有 <code>Optional</code>，<code>??</code> 操作符用于检测可选项是否为 <code>nil</code>， 如果不是 <code>nil</code>，使用当前值，如果是 <code>nil</code>，使用后面的值替代</p>
</blockquote>
<h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><ul>
<li>在实际开发中，如果需要指定字符串格式，可以使用 <code>String(format:...)</code> 的方式<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> h = <span class="number">8</span></div><div class="line"><span class="keyword">let</span> m = <span class="number">23</span></div><div class="line"><span class="keyword">let</span> s = <span class="number">9</span></div><div class="line"><span class="comment">//后面的参数需要放在一个数组中</span></div><div class="line"><span class="keyword">let</span> timeString = <span class="type">String</span>(format: <span class="string">"%02d:%02d:%02d"</span>, arguments: [h, m, s])</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let name = &quot;Tom&quot;</div><div class="line">let date = NSDate()</div><div class="line">let string = NSString(format: &quot;Hello %@. Date: %@&quot;, name, date)</div></pre></td></tr></table></figure>
<h2 id="swift4新增"><a href="#swift4新增" class="headerlink" title="swift4新增"></a>swift4新增</h2><ul>
<li><p>多行字符串字面量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let str1 = &quot;&quot;&quot;</div><div class="line">12\n34</div><div class="line">56</div><div class="line">789</div><div class="line">&quot;&quot;&quot;</div><div class="line">print(str1)</div></pre></td></tr></table></figure>
</li>
<li><p>去掉 characters</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">//swift3</div><div class="line">let values = &quot;one,two,three...&quot;</div><div class="line">print(values.characters.count)</div><div class="line">var i = values.characters.startIndex</div><div class="line"></div><div class="line">while let comma = values.characters[i...&lt;values.characters.endIndex].index(of: &quot;,&quot;) &#123;</div><div class="line">if values.characters[i..&lt;comma] == &quot;two&quot; &#123;</div><div class="line">print(&quot;found it!&quot;)</div><div class="line">&#125;</div><div class="line">i = values.characters.index(after: comma)</div><div class="line">&#125;</div><div class="line"></div><div class="line">//swift4</div><div class="line">let values = &quot;one,two,three...&quot;</div><div class="line">print(values.count)</div><div class="line">var i = values.startIndex</div><div class="line"></div><div class="line">while let comma = values[i...&lt;values.endIndex].index(of: &quot;,&quot;) &#123;</div><div class="line">if values[i..&lt;comma] == &quot;two&quot; &#123;</div><div class="line">print(&quot;found it!&quot;)</div><div class="line">&#125;</div><div class="line">i = values.index(after: comma)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>String 当做 Collection 来用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let abc: String = &quot;abc&quot;</div><div class="line">print(String(abc.reversed()))   // cba</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h1><h2 id="集合的可变性"><a href="#集合的可变性" class="headerlink" title="集合的可变性"></a>集合的可变性</h2><p>变量可变，常量不可变</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li>数组的类型<ul>
<li>如果初始化时，所有内容类型一致，择数组中保存的是该类型的内容</li>
<li>如果初始化时，所有内容类型不一致，择数组中保存的是 <code>NSObject</code></li>
</ul>
</li>
<li>数字可以直接添加到集合，不需要再转换成 <code>NSNumber</code></li>
<li>如果将结构体对象添加到集合，仍然需要转换成 <code>NSValue</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//var array2 = [&quot;zhangsan&quot;, 18]  //会报错:Heterogeneous collection literal could only be inferred to &apos;[Any]&apos;; add explicit type annotation if this is intentional</div><div class="line">let array2 = [&quot;zhangsan&quot;, 18] as [Any]</div><div class="line">array2.append(100)</div><div class="line">array2.append(NSValue(CGPoint: CGPoint(x: 10, y: 10)))</div></pre></td></tr></table></figure>
</li>
</ul>
<p>最后一个元素后面允许有个逗号</p>
<ul>
<li><p>定义数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var arr1:[Int]</div><div class="line">let a:Array&lt;Int&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>创建空数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var arr2 = [Int]()</div><div class="line">//var arr3 = []  //错误</div><div class="line">var a2:[String] = Array&lt;String&gt;()</div></pre></td></tr></table></figure>
</li>
<li><p>给数组赋空值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">arr1 = []</div><div class="line">arr = [Int](repeatElement(3, count: 10))</div><div class="line">arr = Array(repeatElement(2, count: 10))</div><div class="line">var ints = [Int](repeating: &quot;2&quot;, count: 10)</div><div class="line">var ints = Array(repeating: &quot;2&quot;, count: 10)</div></pre></td></tr></table></figure>
</li>
<li><p>判断是否是空数组：isEmpty</p>
</li>
<li><p><code>不可以用下标访问的形式为数组添加新项</code></p>
</li>
<li><p>遍历数组<br>可以使用元组返回索引和元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">for (index, value) in arr.enumerated() &#123;&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>必须是相同类型的数组才能够合并</p>
</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ul>
<li>存储在集合中的数据必须是可哈希化的。<br>可哈希化必须满足三个条件：<ul>
<li>a == a(自反性)</li>
<li>a == b意味着b == a(对称性)</li>
<li>a == b &amp;&amp; b == c意味着a == c(传递性)</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var a = 1</div><div class="line">print(a.hashValue)</div></pre></td></tr></table></figure>
<ul>
<li><p>创建空集合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var set1 = Set&lt;String&gt;()</div></pre></td></tr></table></figure>
</li>
<li><p>集合转数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let arr = set1.sorted()</div></pre></td></tr></table></figure>
</li>
<li><p>集合的交差并补</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let x:Set = [1,2,3]</div><div class="line">let y:Set = [3,4,5]</div><div class="line">x.intersection(y)</div><div class="line">x.subtract(y)</div><div class="line">x.union(y)</div><div class="line">x.symmetricDifference(y)</div></pre></td></tr></table></figure>
</li>
<li><p>集合相等：有完全相同的元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let set1:Set = [1,2,3]</div><div class="line">let set2:Set = [3,2,1]</div><div class="line">set1 == set2</div></pre></td></tr></table></figure>
</li>
<li><p>子集（可以相等），严格子集</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let set1:Set = [1,2,3,4]</div><div class="line">let set2:Set = [3,4]</div><div class="line">set2.isSuperset(of: set1)</div><div class="line">set2.isStrictSuperset(of: set1)</div></pre></td></tr></table></figure>
</li>
<li><p>父集（可以相等），严格父集</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">set1.isSubset(of: set2)</div><div class="line">set1.isStrictSubset(of: set2)</div></pre></td></tr></table></figure>
</li>
<li><p>无交集</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let set1:Set = [1,2]</div><div class="line">let set2:Set = [3,4]</div><div class="line">set1.isDisjoint(with: set2)</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><ul>
<li>存储在集合中的key必须是可哈希化的。</li>
<li><p>创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var dict = [&quot;a&quot;:&quot;b&quot;]</div><div class="line">var dict1 : Dictionary&lt;String,String&gt;</div><div class="line">var dict2 : [String:String]</div></pre></td></tr></table></figure>
</li>
<li><p><code>updateValue(_:forKey:)</code>:设置或更新值，但是返回更新值之前的原值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let oldValue = dic.updateValue(&quot;lisi&quot;, forKey: &quot;name&quot;)</div></pre></td></tr></table></figure>
</li>
<li><p><code>dic[&quot;akey&quot;] = nil</code>，<code>dic.removeValue(forKey: &quot;akey&quot;)</code>：移除键值对</p>
</li>
<li><p>dic.keys,dic.values</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var keyArr = [String](dict.keys)</div><div class="line">var valueArr = Array(dict.values)</div></pre></td></tr></table></figure>
</li>
<li><p>遍历字典时候需要明确指明数组中的数据类型<br>for dict in dictArray  as! [[String:String]]{}</p>
</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="生成器（Generator）"><a href="#生成器（Generator）" class="headerlink" title="生成器（Generator）"></a>生成器（Generator）</h3><ul>
<li>生成器允许遍历所有元素<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">protocol GeneratorType &#123;</div><div class="line">typealias Element</div><div class="line">mutating func next() -&gt; Element?</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="序列（Sequence）"><a href="#序列（Sequence）" class="headerlink" title="序列（Sequence）"></a>序列（Sequence）</h3><ul>
<li>一种可以对其元素进行连续，迭代访问的类型。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">protocol SequenceType &#123;</div><div class="line">    typealias Generator: GeneratorType</div><div class="line">    func generate() -&gt; Generator</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="集合-Collection"><a href="#集合-Collection" class="headerlink" title="集合(Collection)"></a>集合(Collection)</h3><h1 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h1><h2 id="For-In-循环"><a href="#For-In-循环" class="headerlink" title="For-In 循环"></a>For-In 循环</h2><ul>
<li>index 可直接使用，无序声明，不需要的时候可用<code>_</code>忽略</li>
<li>省略下标<ul>
<li><code>_</code> 能够匹配任意类型</li>
<li><code>_</code> 表示忽略对应位置的值<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">for index in 1...5 &#123;&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="while-repeat-while"><a href="#while-repeat-while" class="headerlink" title="while/repeat-while"></a>while/repeat-while</h2><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><ul>
<li>switch支持任意类型的数据比较 </li>
<li>switch不会隐式贯穿，默认有break,不用加</li>
<li>每一个 case 分支都必须包含至少一条语句,没有可用break；必须有default语句,要保证处理所有可能的情况，不然编译器直接报错</li>
<li>每一个 <code>case</code> 中定义的变量仅在当前 <code>case</code> 中有效</li>
<li>复合匹配，可以用逗号隔开匹配多个值</li>
<li>区间匹配：<code>case 1...10:</code></li>
<li>元组匹配：<code>case (_,0):</code></li>
<li>值绑定：<code>case (let x,0):</code></li>
<li>where添加额外条件：<code>case let(x,y) where x==y:</code></li>
</ul>
<h2 id="控制转移语句"><a href="#控制转移语句" class="headerlink" title="控制转移语句"></a>控制转移语句</h2><ul>
<li>continue</li>
<li>break：可用于switch语句或循环体中</li>
<li><p>label</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var i = 1</div><div class="line">myLabel: while i&lt;100&#123;</div><div class="line">    switch i &#123;</div><div class="line">        case 10:</div><div class="line">            print(&quot;case-10&quot;)</div><div class="line">            break myLabel</div><div class="line">        case 20:</div><div class="line">            print(&quot;case-20&quot;)</div><div class="line">        default:</div><div class="line">            print(&quot;default&quot;)</div><div class="line">    &#125;</div><div class="line">    i+=1</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>fallthrough：贯穿到下一个case中的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">let i = 3</div><div class="line">switch i &#123;</div><div class="line">    case 1:</div><div class="line">        print(&quot;1&quot;)</div><div class="line">    case 2:</div><div class="line">        print(&quot;2&quot;)</div><div class="line">    case 3:</div><div class="line">        print(&quot;3&quot;)</div><div class="line">        fallthrough</div><div class="line">    case 4:</div><div class="line">        print(&quot;4&quot;)</div><div class="line">        fallthrough</div><div class="line">    default:</div><div class="line">        print(&quot;default&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>return</p>
</li>
<li>throw</li>
<li><p>guard:提前退出，后面必须有一个else语句，else中必须包含控制转移语句<br><code>防止代码嵌套过多，if满足条件需要return时就可以用guard，相当于if let</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//只有numOfMyFriend &gt;0 的时候，才可以执行下面的程序。否则(else)就抛出一个异常。</div><div class="line">guard numOfMyFriend &gt; 0 else &#123;</div><div class="line">    throw errorGame.noFriendToGether</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>label标签语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">where labName&#123;</div><div class="line">    if()&#123;</div><div class="line">        break labName</div><div class="line">    &#125;else if()&#123;</div><div class="line">        continue labName</div><div class="line">    &#125;else&#123;</div><div class="line">        ///</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="检测API可用性"><a href="#检测API可用性" class="headerlink" title="检测API可用性"></a>检测API可用性</h2><p>*是必须的，用于指定在所有其它平台中，如果版本号高于你的设备指定的最低版本，if语句的代码块将会运行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if #available(iOS 10, macOS 10.12, *) &#123;</div><div class="line">// 在 iOS 使用 iOS 10 的 API, 在 macOS 使用 macOS 10.12 的 API</div><div class="line">&#125; else &#123;</div><div class="line">// 使用先前版本的 iOS 和 macOS 的 API</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ul>
<li>swift中MARK的使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// MARK: - mark something</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="函数定义与调用"><a href="#函数定义与调用" class="headerlink" title="函数定义与调用"></a>函数定义与调用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">func hello(name:String) -&gt; String&#123;</div><div class="line">    let str = &quot;Hello,&quot;+name+&quot;!&quot;;</div><div class="line">    return str;</div><div class="line">&#125;</div><div class="line">hello(name:&quot;Anna&quot;);</div></pre></td></tr></table></figure>
<h2 id="指定参数标签"><a href="#指定参数标签" class="headerlink" title="指定参数标签"></a>指定参数标签</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">func someFunction(argumentLabel parameterName: Int) &#123;&#125;</div></pre></td></tr></table></figure>
<h2 id="忽略参数标签"><a href="#忽略参数标签" class="headerlink" title="忽略参数标签"></a>忽略参数标签</h2><p>如果一个参数有一个标签，那么在调用的额是很好必须使用标签来标记这个参数，如果不希望为某个参数添加标签，可以使用<code>_</code>来代替一个明确的参数标签。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">func hello(name:String) -&gt; String&#123;&#125;</div><div class="line">//调用 hello(name:&quot;Anna&quot;);</div><div class="line">func hello(_ name:String) -&gt; String&#123;&#125;</div><div class="line">//调用 hello(&quot;Anna&quot;);</div></pre></td></tr></table></figure></p>
<h2 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">func someFunction(parameterWithoutDefault: Int, parameterWithDefault: Int = 12) &#123;</div><div class="line">// 如果你在调用时候不传第二个参数，parameterWithDefault 会值为 12 传入到函数体中。</div><div class="line">&#125;</div><div class="line">someFunction(parameterWithoutDefault: 4) // parameterWithDefault = 12</div></pre></td></tr></table></figure>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">func getMiddle(_ numbers: Double...) -&gt; Double&#123;&#125;</div></pre></td></tr></table></figure>
<h2 id="输入输出参数"><a href="#输入输出参数" class="headerlink" title="输入输出参数"></a>输入输出参数</h2><blockquote>
<p>函数参数默认是常量。试图在函数体中更改参数值将会导致编译错误</p>
<ul>
<li>输入输出参数：可以在函数中修改的参数，并且这些修改在参数调用的时候仍然存在<br>只能传递变量给输入输出参数，不能传入常量或者字面量，并且在传入的时候在参数名前添加<code>&amp;</code>。</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T) &#123;</div><div class="line">    //可以不使用额外空间而使用多元组特性直接交换 a 和 b 的值</div><div class="line">    (a, b) = (b, a)</div><div class="line">&#125;</div><div class="line">var a = 5, b = 6</div><div class="line">swapTwoValues(&amp;a, &amp;b)</div><div class="line">print(a, b)</div></pre></td></tr></table></figure>
<h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><ul>
<li>可作为参数类型或返回值类型<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func calculate(x: Int,y: Int,method: (Int,Int)-&gt;Int) -&gt; Int&#123;</div><div class="line">return method(x,y)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func add(x: Int,y: Int)-&gt;Int&#123;</div><div class="line">return x+y</div><div class="line">&#125;</div><div class="line">func multiply(x: Int,y: Int)-&gt;Int&#123;</div><div class="line">return x*y</div><div class="line">&#125;</div><div class="line">calculate(x: 3, y: 4, method: add)</div><div class="line">calculate(x: 3, y: 4, method: multiply)</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int &#123;</div><div class="line">func stepForward(input: Int) -&gt; Int &#123; return input + 1 &#125;</div><div class="line">func stepBackward(input: Int) -&gt; Int &#123; return input - 1 &#125;</div><div class="line">return backward ? stepBackward : stepForward</div><div class="line">&#125;</div><div class="line">var currentValue = 4</div><div class="line">let moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)</div><div class="line">while currentValue != 0 &#123;</div><div class="line">print(&quot;\(currentValue)... &quot;)</div><div class="line">currentValue = moveNearerToZero(currentValue)</div><div class="line">&#125;</div><div class="line">print(&quot;zero!&quot;)</div></pre></td></tr></table></figure>
<h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><blockquote>
<p>把接受多个参数的方法变换成接受第一个参数的方法，并且返回接受余下的参数并且返回结果的新方法。</p>
</blockquote>
<!--
* 不使用柯里化
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">func addTwoNumbers(a: Int, num: Int) -&gt; Int &#123;</div><div class="line">return a + num</div><div class="line">&#125;</div><div class="line">let result = addTwoNumbers(a:4, num: 6)</div><div class="line">print(result)</div><div class="line"></div><div class="line">func greaterThan(comparator: Int, input: Int) -&gt; Bool &#123;</div><div class="line">return input &gt; comparator;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let greaterThan10 = greaterThan(comparator: 10, input: 13)</div><div class="line">print(greaterThan10)</div><div class="line">let littleThan10 = greaterThan(comparator: 10, input: 9)</div><div class="line">print(littleThan10)</div></pre></td></tr></table></figure>
<ul>
<li>使用柯里化<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">func addTwoNumbers(a: Int)(num: Int) -&gt; Int &#123;</div><div class="line">return a + num</div><div class="line">&#125;</div><div class="line"></div><div class="line">//等同于</div><div class="line">//func addTwoNumbers(a: Int)-&gt;((Int) -&gt; Int) &#123;</div><div class="line">//    func incrementor(num: Int) -&gt; Int &#123;</div><div class="line">//        return a + num</div><div class="line">//    &#125;</div><div class="line">//    return incrementor</div><div class="line">//&#125;</div><div class="line"></div><div class="line"></div><div class="line">let addToFour = addTwoNumbers(a: 4)</div><div class="line">let result = addToFour(num: 6)</div><div class="line"></div><div class="line"></div><div class="line">func greaterThan(comparator: Int)(input: Int) -&gt; Bool &#123;</div><div class="line">return input &gt; comparator;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let greaterThan10 = greaterThan(comparator:10)</div><div class="line">greaterThan10(input: 13)    //true</div><div class="line">greaterThan10(input: 9)     //false</div></pre></td></tr></table></figure>
</li>
</ul>
<p>–&gt;</p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>闭包的三种形式：</p>
<ul>
<li>全局函数是一个有名字但不会捕获任何值的闭包</li>
<li>嵌套函数是一个有名字并可以捕获其封闭函数域内值的闭包</li>
<li>闭包表达式是一个利用轻量级语法所写的可以捕获其上下文中变量或常量值的匿名闭包<h2 id="闭包表达式"><a href="#闭包表达式" class="headerlink" title="闭包表达式"></a>闭包表达式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123; (parameters) -&gt; returnType in</div><div class="line">statements</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>排序闭包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reversedNames = names.sorted(by: &#123; (s1: String, s2: String) -&gt; Bool in return s1 &gt; s2 &#125; )</div></pre></td></tr></table></figure></p>
<blockquote>
<p>排序闭包函数类型需为<code>(String, String) -&gt; Bool</code></p>
<ul>
<li>所有的参数和返回值类型都可以被正确推断，则返回箭头（-&gt;）和围绕在参数周围的括号也可以被省略<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reversedNames = names.sorted(by: &#123; s1, s2 in return s1 &gt; s2 &#125; )</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<ul>
<li><p>单表达式闭包隐式返回,可以省略 return 关键字，把语句的值作为结果返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reversedNames = names.sorted(by: &#123; s1, s2 in s1 &gt; s2 &#125; )</div></pre></td></tr></table></figure>
</li>
<li><p>可以通过参数位置引用参数，通过 $0，$1来顺序调用闭包的参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reversedNames = names.sorted(by: &#123; $0 &gt; $1 &#125; )</div></pre></td></tr></table></figure>
</li>
<li><p>运算符方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reversedNames = names.sorted(by: &gt;)</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="尾随闭包"><a href="#尾随闭包" class="headerlink" title="尾随闭包"></a>尾随闭包</h2><ul>
<li>当一个闭包作为最后一个参数传给函数的时候，闭包可以直接跟在括号后面，不用写出参数标签</li>
<li>如果闭包是函数的唯一参数，则当使用尾随闭包时，可以把()省略掉<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reversedNames = names.sorted &#123; $0 &gt; $1 &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="值捕获"><a href="#值捕获" class="headerlink" title="值捕获"></a>值捕获</h2><ul>
<li>闭包可以在其被定义的上下文中捕获常量或变量。即使定义这些常量和变量的原作用域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。</li>
<li>Swift 中，可以捕获值的闭包的最简单形式是嵌套函数</li>
<li>如果一个值不会被闭包改变，或者在闭包创建后不会改变，Swift 可能会改为捕获并保存一份对值的拷贝。<blockquote>
<p>如果你将闭包赋值给一个类实例的属性，并且该闭包通过访问该实例或其成员而捕获了该实例，你将在闭包和该实例间创建一个循环强引用。Swift 使用捕获列表来打破这种循环强引用</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">func add(num: Int)-&gt;(()-&gt;())&#123;</div><div class="line">    var sum = 0</div><div class="line">    func addNum()&#123;</div><div class="line">        sum+=num</div><div class="line">        print(sum)</div><div class="line">    &#125;</div><div class="line">    return addNum</div><div class="line">&#125;</div><div class="line"></div><div class="line">var a = add(num: 10)</div><div class="line">a() //10</div><div class="line">a() //20</div><div class="line"></div><div class="line">var b = add(num: 8)</div><div class="line">b() //8</div><div class="line">b() //16</div><div class="line">a() //30</div></pre></td></tr></table></figure>
<h2 id="函数和闭包都是引用类型"><a href="#函数和闭包都是引用类型" class="headerlink" title="函数和闭包都是引用类型"></a>函数和闭包都是引用类型</h2><h2 id="逃逸闭包-escaping"><a href="#逃逸闭包-escaping" class="headerlink" title="逃逸闭包 @escaping"></a>逃逸闭包 @escaping</h2><ul>
<li>逃逸闭包：当一个闭包作为参数传到一个函数中，但是这个闭包在函数返回之后才被执行</li>
<li>如何逃逸：将闭包保存在一个函数外部定义的变量中，因为闭包需要在函数返回之后被调用<blockquote>
<p>将一个闭包标记为 @escaping 意味着必须在闭包中显式地引用 self，非逃逸闭包可以隐式引用self</p>
</blockquote>
</li>
</ul>
<h2 id="自动闭包-autoclosure"><a href="#自动闭包-autoclosure" class="headerlink" title="自动闭包 @autoclosure"></a>自动闭包 @autoclosure</h2><blockquote>
<p>自动闭包是一种自动创建的用来把作为实际参数传递给函数的表达式打包的闭包。它不接受任何实际参数，并且当它被调用时，它会返回内部打包的表达式的值。这个语法的好处在于通过写普通表达式代替显式闭包而使你省略包围函数形式参数的括号。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// 在不使用autoclosure的情况下</div><div class="line">func logIfTrue(predicate: () -&gt; Bool) &#123;</div><div class="line">    if predicate() &#123;</div><div class="line">        print(&quot;True&quot;)</div><div class="line">    &#125; else &#123;</div><div class="line">        print(&quot;False&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 第一种调用方式</div><div class="line">logIfTrue &#123; () -&gt; Bool in</div><div class="line">    return 1 &gt; 2</div><div class="line">&#125;</div><div class="line">// 第二种调用方式</div><div class="line">logIfTrue&#123;return 1 &gt; 2&#125;</div><div class="line">// 第三种调用方式</div><div class="line">logIfTrue&#123;1 &gt; 2&#125;</div><div class="line"></div><div class="line"></div><div class="line">// 使用autoclosure</div><div class="line">func logIfTrue( _ predicate: @autoclosure () -&gt; Bool) &#123;</div><div class="line">    if predicate() &#123;</div><div class="line">        print(&quot;True&quot;)</div><div class="line">    &#125; else &#123;</div><div class="line">        print(&quot;False&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 调用方式</div><div class="line">logIfTrue(2 &gt; 1)</div><div class="line">logIfTrue(1 &gt; 2)</div></pre></td></tr></table></figure>
<h1 id="枚举enum"><a href="#枚举enum" class="headerlink" title="枚举enum"></a>枚举enum</h1><h2 id="枚举语法"><a href="#枚举语法" class="headerlink" title="枚举语法"></a>枚举语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">enum Direction &#123;</div><div class="line">    case north</div><div class="line">    case south</div><div class="line">    case east</div><div class="line">    case west</div><div class="line">&#125;</div><div class="line">var d = Direction.west</div><div class="line">d = .west</div><div class="line"></div><div class="line">enum Direction&#123; case East,West,South,North &#125;</div></pre></td></tr></table></figure>
<h2 id="使用-Switch-语句匹配枚举值，如果变量是枚举值，可省略枚举名，还可以在case中加上元组变量"><a href="#使用-Switch-语句匹配枚举值，如果变量是枚举值，可省略枚举名，还可以在case中加上元组变量" class="headerlink" title="使用 Switch 语句匹配枚举值，如果变量是枚举值，可省略枚举名，还可以在case中加上元组变量"></a>使用 Switch 语句匹配枚举值，如果变量是枚举值，可省略枚举名，还可以在case中加上元组变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">enum Direction&#123; case East,West,South,North &#125;</div><div class="line">var d = Direction.North</div><div class="line"></div><div class="line">switch d&#123;</div><div class="line">case Direction.East:</div><div class="line">print(&quot;east&quot;)</div><div class="line">case .West:</div><div class="line">print(&quot;wast&quot;)</div><div class="line">case .South:</div><div class="line">print(&quot;south&quot;)</div><div class="line">case .North:</div><div class="line">print(&quot;north&quot;)</div><div class="line">//default可省略，非枚举必须加default</div><div class="line">//default:</div><div class="line">//print(&quot;other&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">enum Direction&#123; case East,West,South,North,Other &#125;</div><div class="line">var d = Direction.North</div><div class="line"></div><div class="line">switch d&#123;</div><div class="line">case Direction.East:</div><div class="line">print(&quot;east&quot;)</div><div class="line">case .West:</div><div class="line">print(&quot;wast&quot;)</div><div class="line">case .South:</div><div class="line">print(&quot;south&quot;)</div><div class="line">case .North:</div><div class="line">print(&quot;north&quot;)</div><div class="line">//default不可省略</div><div class="line">default:</div><div class="line">print(&quot;other&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="原始值-rawValue"><a href="#原始值-rawValue" class="headerlink" title="原始值 rawValue"></a>原始值 rawValue</h2><p>当使用整数作为原始值时，如果第一个枚举成员没有设置原始值，其原始值将为0,隐式赋值的值依次递增1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//赋初始值，必须有类型说明</div><div class="line">enum Numbers:Int&#123;case A = 1, B, C&#125;</div><div class="line">print(Numbers.A.rawValue)</div><div class="line"></div><div class="line">enum Direction:String&#123;</div><div class="line">    case East = &quot;east&quot;</div><div class="line">    case West = &quot;west&quot;</div><div class="line">    case South = &quot;south&quot;</div><div class="line">    case North = &quot;north&quot;</div><div class="line">&#125;</div><div class="line">print(Direction.West.rawValue)</div></pre></td></tr></table></figure></p>
<h2 id="关联值：枚举成员可以是不同数据类型"><a href="#关联值：枚举成员可以是不同数据类型" class="headerlink" title="关联值：枚举成员可以是不同数据类型"></a>关联值：枚举成员可以是不同数据类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">enum State&#123;</div><div class="line">case Status1(Int,String)</div><div class="line">case Status2(String,String)</div><div class="line">&#125;</div><div class="line">var s = State.Status1(404,&quot;page not found&quot;)</div></pre></td></tr></table></figure>
<h1 id="类和结构体"><a href="#类和结构体" class="headerlink" title="类和结构体"></a>类和结构体</h1><h2 id="类和结构体对比"><a href="#类和结构体对比" class="headerlink" title="类和结构体对比"></a>类和结构体对比</h2><p>相同点：</p>
<ul>
<li>定义属性用于存储值</li>
<li>定义方法用于提供功能</li>
<li>定义下标操作使得可以通过下标语法来访问实例所包含的值</li>
<li>定义构造器用于生成初始化值</li>
<li>通过扩展以增加默认实现的功能</li>
<li>实现协议以提供某种标准功能<br>类的不同点：</li>
<li>继承允许一个类继承另一个类的特征</li>
<li>类型转换允许在运行时检查和解释一个类实例的类型</li>
<li>析构器允许一个类实例释放任何其所被分配的资源</li>
<li><p>引用计数允许对一个类的多次引用</p>
</li>
<li><p>定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class SomeClass &#123;</div><div class="line">// 在这里定义类</div><div class="line">&#125;</div><div class="line">struct SomeStructure &#123;</div><div class="line">// 在这里定义结构体</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>结构体类型的成员逐一构造器，类实例没有默认构造函数，类中的属性必须初始化或设为可选（属性加！或？，或者写init方法）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">class Dog &#123;</div><div class="line"></div><div class="line">var name: String!</div><div class="line">var age :Int!</div><div class="line">init()&#123;</div><div class="line">name = &quot;hua hua&quot;</div><div class="line">age = 2</div><div class="line">&#125;</div><div class="line"></div><div class="line">func show()&#123;</div><div class="line">print(&quot;\(name!):\(age!)&quot;)   //解析</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">var d1 = Dog()</div><div class="line">d1.show()</div><div class="line">d1.name = &quot;xiao hei&quot;</div><div class="line">d1.age = 3</div><div class="line">d1.show()</div><div class="line"></div><div class="line">print(d1 === d2)    //是否是同一对象:true</div><div class="line">var d3 = Dog()</div><div class="line">print(d1 === d3)    //是否是同一对象:false</div></pre></td></tr></table></figure>
</li>
<li><p>结构体和枚举是值类型，函数和闭包是引用类型</p>
<blockquote>
<p>值类型：被赋予给一个变量、常量或者被传递给一个函数的时候，其值会被拷贝。<br>引用类型：在被赋予到一个变量、常量或者被传递到一个函数时，其值不会被拷贝。因此，引用的是已存在的实例本身而不是其拷贝。实际是同一个。<br>结构体和枚举类型都是值类型。这意味着它们的实例，以及实例中所包含的任何值类型属性，在代码中传递的时候都会被复制。两者相互独立，是不同的。<br>在 Swift 中，Integer、floating-point、Boolean、string、array、dictionary 都是值类型，并且在底层都是以结构体的形式所实现。</p>
</blockquote>
</li>
<li><p>恒等运算符（===/!==）：判定两个常量或者变量是否引用同一个类实例</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">//结构体</div><div class="line">struct Point &#123;</div><div class="line">var x: Int</div><div class="line">var y: Int</div><div class="line">&#125;</div><div class="line">var p1 = Point(x: 10, y: 20)</div><div class="line">var p2 = p1</div><div class="line">print(&quot;\(p1.x):\(p1.y)&quot;)</div><div class="line">print(&quot;\(p2.x):\(p2.y)&quot;)</div><div class="line">p1.x = 100</div><div class="line">p1.y = 200</div><div class="line">print(&quot;\(p1.x):\(p1.y)&quot;)</div><div class="line">print(&quot;\(p2.x):\(p2.y)&quot;)</div><div class="line"></div><div class="line">//枚举</div><div class="line">enum Direction&#123;case East,West,North,South&#125;</div><div class="line">var direction1 = Direction.East</div><div class="line">var direction2 = direction1</div><div class="line">print(&quot;\(direction1)&quot;)</div><div class="line">print(&quot;\(direction2)&quot;)</div><div class="line">direction1 = .West</div><div class="line">print(&quot;\(direction1)&quot;)</div><div class="line">print(&quot;\(direction2)&quot;)</div><div class="line"></div><div class="line">//类</div><div class="line">class Dog &#123;</div><div class="line"></div><div class="line">var name: String!</div><div class="line">var age: Int!</div><div class="line">init()&#123;</div><div class="line"></div><div class="line">name = &quot;hua hua&quot;</div><div class="line">age = 2</div><div class="line">&#125;</div><div class="line">func show()&#123;</div><div class="line">print(&quot;\(name):\(age)&quot;)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var d1 = Dog()</div><div class="line">var d2 = d1</div><div class="line">d1.show()</div><div class="line">d2.show()</div><div class="line">d1.name = &quot;xiao hei&quot;</div><div class="line">d1.age = 3</div><div class="line">d1.show()</div><div class="line">d2.show()</div></pre></td></tr></table></figure>
<h2 id="类和结构体的选择"><a href="#类和结构体的选择" class="headerlink" title="类和结构体的选择"></a>类和结构体的选择</h2><p>大部分使用类，以下情形考虑构建结构体：</p>
<ul>
<li>目的是用来封装少量相关简单数据值。</li>
<li>实例在被赋值或传递时，封装的数据将会被拷贝而不是被引用。</li>
<li>储存的值类型属性，也应该被拷贝，而不是被引用。</li>
<li>不需要去继承另一个既有类型的属性或者行为。</li>
</ul>
<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p><code>存储属性只能用于类和结构体，计算属性可以用于类、结构体和枚举。</code></p>
<h2 id="存储属性"><a href="#存储属性" class="headerlink" title="存储属性"></a>存储属性</h2><ul>
<li>定义：存储在特定类或结构体实例里的一个常量或变量，保存单个类型的变量。</li>
<li><code>所有类的存储属性——包括从它的父类继承的所有属性——都必须在初始化期间分配初始值。</code></li>
<li>常量结构体的存储属性：如果创建了一个结构体的实例并将其赋值给一个常量，则无法修改该实例的任何属性，即使有属性被声明为变量也不行(由于结构体（struct）属于值类型。<code>当值类型的实例被声明为常量的时候，它的所有属性也就成了常量</code>。属于引用类型的类（class）则不一样，<code>把一个引用类型的实例赋给一个常量后，仍然可以修改该实例的变量属性</code>。)</li>
<li>延迟存储属性lazy<ul>
<li>定义：在第一次被访问的时候创建</li>
<li>一般用于：<ul>
<li>延迟对象的创建</li>
<li>当属性的值依赖于其他未知类</li>
</ul>
</li>
<li>必须将延迟存储属性声明成变量（使用 var 关键字），而常量属性在构造过程完成之前必须要有初始值，因此无法声明成延迟属性</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">//1)类中的属性必须初始化或设为可选</div><div class="line">class Dog &#123;</div><div class="line">var name: String!</div><div class="line">var age: Int!</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//2）常量结构体的存储属性</div><div class="line">struct Point &#123;</div><div class="line">var x: Int</div><div class="line">var y: Int</div><div class="line">&#125;</div><div class="line"></div><div class="line">let p1 = Point(x: 1, y: 2)</div><div class="line">//结构体常量对象不可以进行修改</div><div class="line">//p1.x = 100</div><div class="line">//p1.y = 200</div><div class="line"></div><div class="line">3）延迟存储属性 lazy：调用时才进行构造</div><div class="line">class A &#123;</div><div class="line">init()&#123;</div><div class="line">print(&quot;A init&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func f1()&#123;</div><div class="line">print(&quot;f1...&quot;)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class B &#123;</div><div class="line">lazy var a: A = A()</div><div class="line">init()&#123;</div><div class="line">print(&quot;B init&quot;)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var b = B()</div><div class="line">//调用时A才进行构造</div><div class="line">print(b.a.f1())</div></pre></td></tr></table></figure>
<h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><ul>
<li>定义：计算属性不直接存储值，而是提供一个 getter 和一个可选的 setter，来间接获取和设置其他属性或变量的值。</li>
<li>新值的参数名默认为newValue</li>
<li>只读计算属性的声明可以去掉get关键字和花括号，直接return<blockquote>
<p>必须使用var定义计算属性，包括只读计算属性</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">struct Rect &#123;</div><div class="line">    var w: Double</div><div class="line">    var h: Double</div><div class="line"></div><div class="line">    var circle: Double&#123;</div><div class="line">        get&#123;</div><div class="line">            print(&quot;get...&quot;)</div><div class="line">            return (w+h)*2</div><div class="line">        &#125;</div><div class="line">        set&#123;</div><div class="line">            //默认newValue，oldValue</div><div class="line">            //newValue就是circle</div><div class="line">            w = newValue/2</div><div class="line">            h = newValue/2</div><div class="line">            print(&quot;newValue=\(newValue)&quot;)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var r = Rect(w: 30, h: 20)</div><div class="line">print(r.circle)</div><div class="line">r.circle = 200</div><div class="line">print(r.circle)</div></pre></td></tr></table></figure>
<h2 id="属性观察器"><a href="#属性观察器" class="headerlink" title="属性观察器"></a>属性观察器</h2><ul>
<li>属性被设置值的时候会调用属性观察器（即使新值与当前值相同）</li>
<li>可添加观察器的情况：<ul>
<li>定义的存储属性（除延迟存储属性之外）</li>
<li>从父类继承的存储属性或计算属性（通过重写属性的方式），不需要为无法重载的计算属性添加属性观察器，因为可以通过setter直接监控和响应值的变化</li>
</ul>
</li>
<li>willSet：传入新属性值，默认为newValue，常量参数</li>
<li>didSet：传入旧属性值，默认为oldValue</li>
<li>willSet和didSet在属性初始化过程中不会被调用</li>
<li>继承：<ul>
<li>父类属性在子类的构造器中赋值，会先调用父类观察器，再调用子类观察器。</li>
<li>在父类初始化方法调用之前，子类给属性赋值时，不会调用观察器方法。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">class Animal &#123;</div><div class="line">    var age: Int = 1&#123;</div><div class="line"></div><div class="line">        //可以不加newValue:willSet(newValue)</div><div class="line">        willSet&#123;</div><div class="line">            print(&quot;newValue:\(newValue)&quot;)</div><div class="line">            //保护属性</div><div class="line">            if newValue &lt;= 0 &#123;</div><div class="line">                print(&quot;非法年龄！&quot;)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //必须加newValue</div><div class="line">        didSet(newValue)&#123;</div><div class="line">            print(&quot;newValue:\(newValue)&quot;)</div><div class="line">            print(&quot;didSet&quot;)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var a = Animal()</div><div class="line">print(a.age)    //1</div><div class="line">a.age = -1</div><div class="line">print(a.age)    //-1</div></pre></td></tr></table></figure>
<h2 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h2><ul>
<li>都属于存储型变量，跟存储属性类似。</li>
<li>都可以定义计算型变量和为存储型变量定义观察器，与计算属性类似。</li>
<li>全局变量或常量都是延迟计算的，与延迟存储属性相似，不需要声明lazy。局部变量或常量从不延迟计算。</li>
</ul>
<h2 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">struct Structname &#123;</div><div class="line">    static var storedTypeProperty = &quot; &quot;</div><div class="line">    static var computedTypeProperty: Int &#123;</div><div class="line">    // 这里返回一个 Int 值</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">enum Enumname &#123;</div><div class="line">    static var storedTypeProperty = &quot; &quot;</div><div class="line">    static var computedTypeProperty: Int &#123;</div><div class="line">    // 这里返回一个 Int 值</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Classname &#123;</div><div class="line">    class var computedTypeProperty: Int &#123;</div><div class="line">    // 这里返回一个 Int 值</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>存储型类型属性可以是变量或常量，计算型类型属性跟实例的计算型属性一样只能定义成变量属性（计算型属性只能声明为变量）。</li>
<li>在为类定义<code>计算型类型属性</code>时，可以改用关键字 <code>class</code> 来支持子类对父类的实现进行重写。</li>
</ul>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><ul>
<li>类、结构体、枚举都可以定义实例方法，也可以定义类型方法。</li>
<li>self<ul>
<li>在一个方法中使用一个已知的属性或者方法名称，可省略self。</li>
<li>实例方法的某个参数名称与实例的某个属性名称相同的时候，参数名称享有优先权，可以使用self属性来区分参数名称和属性名称。</li>
</ul>
</li>
<li>变异mutating<ul>
<li>结构体和枚举是值类型，值类型属性不能在实例方法中被修改，在实例方法中修改值类型：mutating，修改后的值会一直保留</li>
<li>赋给隐含属性self一个全新的实例，新实例在方法结束后将替换原来的实例</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">struct Area &#123;</div><div class="line">    var length = 1</div><div class="line">    var breadth = 1</div><div class="line"></div><div class="line">    func area() -&gt; Int &#123;</div><div class="line">        return length * breadth</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mutating func scaleBy(res: Int) &#123;</div><div class="line">        self.length *= res</div><div class="line">        self.breadth *= res</div><div class="line">        print(length)</div><div class="line">        print(breadth)</div><div class="line"></div><div class="line">        //只有在变异方法中才可以给self赋值</div><div class="line">        //self = Area(length:self.length*res, breadth:self.breadth*res)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//若实例对象为let,不可修改</div><div class="line">var val = Area(length: 3, breadth: 5)</div><div class="line">val.scaleBy(res: 13)</div><div class="line">print(&quot;\(val.length)---\(val.breadth)&quot;)</div></pre></td></tr></table></figure>
<ul>
<li>类型方法：类型方法的方法体中，self指向这个类型本身，而不是类型的某个实例<ul>
<li>静态方法只能访问静态方法和属性</li>
<li>实例方法可以访问实例方法和属性，通过类型调用静态方法和属性</li>
<li>用class修饰的方法可以被子类覆盖（重写）</li>
<li>在方法func关键字之前加上关键字<code>static</code>来指定类型方法，类还可以用关键字<code>class</code>来允许子类重写父类的方法实现</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">class MyClass &#123;</div><div class="line">    var v1: Int!</div><div class="line">    var s1: String!</div><div class="line">    static var ss1: String!</div><div class="line">    class func f1()&#123;</div><div class="line">        print(&quot;static f1&quot;)</div><div class="line"></div><div class="line">        //***静态方法只能访问静态方法和属性</div><div class="line">        ss1 = &quot;hello&quot;</div><div class="line">        //        v1 = 1</div><div class="line">        //        f2()</div><div class="line">    &#125;</div><div class="line">    func f2()&#123;</div><div class="line">        print(&quot;f2&quot;)</div><div class="line"></div><div class="line">        //***实例方法可以访问实例方法和属性，通过类型调用静态方法和属性</div><div class="line">        MyClass.ss1 = &quot;world&quot;</div><div class="line">        MyClass.f1()</div><div class="line">    &#125;</div><div class="line">    //用class修饰的方法可以被子类覆盖（重写）</div><div class="line">    class func f3() &#123;</div><div class="line">        print(&quot;class f3&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class MySubClass: MyClass &#123;</div><div class="line">    //override class：重写   f2不可重写</div><div class="line">    override class func f3()&#123;</div><div class="line">        print(&quot;override f3...&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">MyClass.ss1 = &quot;static ss1&quot;</div><div class="line">print(MyClass.ss1)</div><div class="line">MyClass.f1()</div><div class="line"></div><div class="line">MyClass.f3()</div><div class="line">MySubClass.f3()</div></pre></td></tr></table></figure>
<h1 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h1><p>可以定义在类，结构体，枚举中，是访问对象、集合、序列的快捷方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">subscript(index: Int) -&gt; Int &#123;</div><div class="line">get &#123;</div><div class="line">// 返回一个适当的 Int 类型的值</div><div class="line">&#125;</div><div class="line">set(newValue) &#123;</div><div class="line">// 执行适当的赋值操作</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>下标脚本类似于实例方法((Int)-&gt;Int)和计算型属性（set,get）的混合</li>
<li>可以读写或只读</li>
<li>newValue的类型和下标的返回类型相同，默认newValue<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">struct Matrix &#123;</div><div class="line">    let rows: Int,columns: Int</div><div class="line">    var grid: [Double]</div><div class="line">    init(rows: Int,columns: Int)&#123;</div><div class="line">        self.rows = rows</div><div class="line">        self.columns = columns</div><div class="line">        grid = Array(repeatElement(5.0, count: rows*columns))</div><div class="line">    &#125;</div><div class="line">    func indexIsValidForRow(row: Int,column: Int)-&gt;Bool&#123;</div><div class="line">        return row &gt;= 0 &amp;&amp; column &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; column &lt; columns</div><div class="line">    &#125;</div><div class="line">    subscript(row: Int,column: Int)-&gt;Double&#123;</div><div class="line">        get&#123;</div><div class="line">            print(&quot;get...\((row*columns)+column)&quot;)</div><div class="line">            assert(indexIsValidForRow(row: row, column: column), &quot;Index out of range&quot;)</div><div class="line">            return grid[(row*columns)+column]</div><div class="line">        &#125;</div><div class="line">        set &#123;</div><div class="line">            print(&quot;set...\((row*columns)+column)&quot;)</div><div class="line">            assert(indexIsValidForRow(row: row, column: column), &quot;Index out of range&quot;)</div><div class="line">            grid[(row*columns)+column] = newValue</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var matr = Matrix(rows: 6, columns: 6)</div><div class="line">print(matr.grid)</div><div class="line">print(matr[5,5])</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="基类"><a href="#基类" class="headerlink" title="基类"></a>基类</h2><ul>
<li>如果你不为你定义的类指定一个超类的话，这个类就自动成为基类。</li>
</ul>
<h2 id="重写override"><a href="#重写override" class="headerlink" title="重写override"></a>重写override</h2><ul>
<li>可以重写继承来的实例方法、类方法、实例属性、类型属性，自定义getter和setter或添加属性观察器（可重写计算属性，方法，存储属性不可重写，可重写属性观察器）</li>
<li>重写属性的getter或setter<ul>
<li>可以为任意继承来的属性（存储属性或计算属性）自定义getter或setter</li>
<li>可以将继承来的只读属性重写为读写属性，但是不能将继承来的读写属性重写为只读属性。</li>
<li>如果在重写属性中提供了 setter，那么一定要提供 getter，如果不修改可以调用super方法</li>
</ul>
</li>
<li>重写属性观察器<ul>
<li>不可以为继承来的常量存储属性或只读计算属性添加属性观察器，因为这些属性的值是不可以修改的</li>
<li>不可以同时重写setter和属性观察器，因为在setter中就可以观察到任何值的变化</li>
</ul>
</li>
<li>防止重写 final<ul>
<li>final var,final func,final class fun,final subscript</li>
<li>final class 声明的类不能被继承</li>
</ul>
</li>
</ul>
<h1 id="构造过程"><a href="#构造过程" class="headerlink" title="构造过程"></a>构造过程</h1><ul>
<li>没有返回值</li>
<li>用于类、结构体或枚举<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">init() &#123;</div><div class="line">// 在此处执行构造过程</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="默认属性值"><a href="#默认属性值" class="headerlink" title="默认属性值"></a>默认属性值</h2><ul>
<li>如果一个属性总是使用相同的初始值，为其设置默认值比每次在构造器中赋值要好。</li>
</ul>
<h2 id="存储属性的初始赋值"><a href="#存储属性的初始赋值" class="headerlink" title="存储属性的初始赋值"></a>存储属性的初始赋值</h2><ul>
<li>存储属性在构造器中赋值时，它们的值是被直接设置的，不会触发任何属性观察器。</li>
<li><p>存储属性在构造器中赋值流程</p>
<ul>
<li>创建初始值</li>
<li>在属性定义中指定默认属性值</li>
<li>初始化实例，并调用init()方法</li>
</ul>
</li>
<li><p>可选属性类型：当存储属性声明为可选时，将自动初始化为空 nil</p>
</li>
<li>修改常量属性：<code>在init里可以对let的实例常量进行赋值</code>，可以在构造过程中的任意时间点给常量属性指定一个值，但是它的常量属性只能在定义它的类的构造过程中修改；不能在子类中修改</li>
<li>外部参数名：Swift 会为每个构造器的参数自动生成一个跟内部名字相同的外部名，如果不想提供外部名称可以使用下划线(_)来显式描述它的外部名</li>
<li>默认构造器：如果结构体或类的所有属性都有默认值，且它是没有父类的基类，同时没有自定义的构造器，swift会自动提供默认构造器，默认构造器将简单的创建一个所有属性值都设置为默认值的实例</li>
<li>逐一成员构造器：结构体自动获得一个逐一成员构造器</li>
<li>构造器代理规则<ul>
<li>值类型：不支持继承，可以使用self.init在自定义的构造器中引用其它的属于相同值类型的构造器</li>
<li>类类型：支持集成，类有责任保证其所有继承的存储型属性在构造时也能正确的初始化</li>
</ul>
</li>
</ul>
<h2 id="类的继承和构造过程"><a href="#类的继承和构造过程" class="headerlink" title="类的继承和构造过程"></a>类的继承和构造过程</h2><ul>
<li>类里面的所有存储型属性——包括所有继承自父类的属性——都必须在构造过程中设置初始值，可以通过指定构造器或便利构造器实现。<h3 id="指定构造器-designated"><a href="#指定构造器-designated" class="headerlink" title="指定构造器 designated"></a>指定构造器 designated</h3></li>
<li>初始化类中提供的所有属性，并根据父类链往上调用父类的构造器来实现父类的初始化，每一个类都必须拥有至少一个指定构造器<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">init(parameters) &#123;</div><div class="line">statements</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="便利构造器-convenience"><a href="#便利构造器-convenience" class="headerlink" title="便利构造器 convenience"></a>便利构造器 convenience</h3><ul>
<li>便利构造器可以调用同一个类中的指定构造器，并为其参数提供默认值，必要时创建。</li>
<li><code>convenience 的初始化方法是不能被子类重写或者从子类中以 super 的方式被调用的。</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">convenience init(parameters) &#123;</div><div class="line">statements</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="构造器的继承和重载：当重写一个父类指定构造器时，子类不会默认继承父类的构造器，需要写override，override-convenience"><a href="#构造器的继承和重载：当重写一个父类指定构造器时，子类不会默认继承父类的构造器，需要写override，override-convenience" class="headerlink" title="构造器的继承和重载：当重写一个父类指定构造器时，子类不会默认继承父类的构造器，需要写override，override convenience"></a>构造器的继承和重载：当重写一个父类指定构造器时，子类不会默认继承父类的构造器，需要写override，<code>override convenience</code></h3><h3 id="初始化方法的顺序"><a href="#初始化方法的顺序" class="headerlink" title="初始化方法的顺序"></a>初始化方法的顺序</h3><ul>
<li>设置子类自己需要初始化的参数</li>
<li>调用父类相应的初始化方法，<code>super.init()</code></li>
<li>对父类中需要改变的成员进行设定<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Animal &#123;</div><div class="line">    var name: String?</div><div class="line">    init() &#123;</div><div class="line">        name = &quot;Animal&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let animal = Animal()</div><div class="line">print(animal.name!)</div><div class="line"></div><div class="line">class Dog: Animal &#123;</div><div class="line">    let age: Int</div><div class="line">    override init() &#123;</div><div class="line">        age = 10</div><div class="line">        // 如果不先把子类的成员初始化完成，下面就无法调用父类的初始化方法会报错,Swift 会自动的对父类的对应 init 方法进行调用</div><div class="line">        super.init() // Property &apos;self.age&apos; not initialized at super.init call</div><div class="line">        name = &quot;a dog&quot;  // 根据实际情况修改，如果不需要改变父类属性的话，可以不写</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">print(Dog().name!)</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="初始化方法需要遵循的两个原则"><a href="#初始化方法需要遵循的两个原则" class="headerlink" title="初始化方法需要遵循的两个原则"></a>初始化方法需要遵循的两个原则</h3><ul>
<li>初始化路径必须保证对象<code>完全初始化</code>，这可以通过调用本类型的 designated 初始化方法得到保证。</li>
<li>子类的 designated 初始化方法<code>必须调用父类的 designated 方法</code>，以保证<code>父类成员也完成初始化</code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class ClassAA &#123;</div><div class="line">let numA: Int</div><div class="line">init(num: Int) &#123;</div><div class="line">numA = num</div><div class="line">&#125;</div><div class="line">convenience init(bigNum: Bool) &#123;</div><div class="line">self.init(num: bigNum ? 10000 : 1) // 所有的 convenience 初始化方法都必须调用同一个类中的 designated 初始化完成设置</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class ClassBB: ClassAA &#123;</div><div class="line">let numB: Int</div><div class="line">override init(num: Int) &#123;</div><div class="line">numB = num + 1</div><div class="line">//只要在子类中实现重写了父类 convenience 方法所需要的 init 方法的话，我们在子类中就可以使用父类的 convenience 初始化方法了</div><div class="line">super.init(num: num)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">let anObj = ClassBB(bigNum: true)</div><div class="line">print(anObj.numA, anObj.numB)</div></pre></td></tr></table></figure>
<h3 id="required"><a href="#required" class="headerlink" title="required"></a>required</h3><ul>
<li>对于某些我们希望子类中一定实现的 designated 初始化方法，我们可以通过添加<code>required</code>关键字进行限制，强制子类对这个方法重写实现。这样做的最大的好处是可以保证依赖于某个 designated 初始化方法的 convenience 一直可以被使用。</li>
<li>如果希望初始化方法对于子类一定可用，就将 init(num: Int) 声明为必须。对于 convenience 的初始化方法我们也可以加上 required 以确保子类对其进行实现。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class ClassAAA &#123;</div><div class="line">let numA: Int</div><div class="line">required init(num: Int) &#123;</div><div class="line">numA = num</div><div class="line">&#125;</div><div class="line">required convenience init(bigNum: Bool) &#123;</div><div class="line">self.init(num: bigNum ? 10000 : 1)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">class ClassBBB: ClassAAA &#123;</div><div class="line">let numB: Int</div><div class="line">required init(num: Int) &#123;</div><div class="line">numB = num + 1</div><div class="line">super.init(num: num)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">let sencondObj = ClassBBB(bigNum: true)</div><div class="line">print(sencondObj.numA, sencondObj.numB)</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="可失败构造器（init-init-）"><a href="#可失败构造器（init-init-）" class="headerlink" title="可失败构造器（init?,init!）"></a>可失败构造器（init?,init!）</h2><ul>
<li>非可失败构造器（init），可失败构造器（init?），隐式解包可失败构造器（init!）</li>
<li>可失败构造器：可失败构造器会创建一个类型为自身的可选类型的对象，在init关键字后面添加问号(init?)，通过<code>return nil</code>来表明可失败构造器在何种情况下应该失败。</li>
<li>可失败构造器的参数名和参数类型，<code>不能与其它非可失败构造器的参数名，及其参数类型相同</code>。</li>
<li>变量初始化失败可能的原因有：<ul>
<li>传入无效的参数值</li>
<li>缺少某种所需的外部资源</li>
<li>没有满足特定条件</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct Animal &#123;</div><div class="line">    let species: String</div><div class="line">    init?(species: String) &#123;</div><div class="line">    if species.isEmpty &#123; return nil &#125;</div><div class="line">        self.species = species</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>枚举类型的可失败构造器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">enum TemperatureUnit &#123;</div><div class="line">    // 开尔文，摄氏，华氏</div><div class="line">    case Kelvin, Celsius, Fahrenheit</div><div class="line">    init?(symbol: Character) &#123;</div><div class="line">        switch symbol &#123;</div><div class="line">            case &quot;K&quot;:</div><div class="line">            self = .Kelvin</div><div class="line">            case &quot;C&quot;:</div><div class="line">            self = .Celsius</div><div class="line">            case &quot;F&quot;:</div><div class="line">            self = .Fahrenheit</div><div class="line">            default:</div><div class="line">            return nil</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>何时触发：值类型的可失败构造器何时触发没有限制，类的可失败构造器只能在所有的类属性被初始化后和所有类之间的代理调用发生完后触发失败行为</p>
</li>
<li>覆盖一个可失败构造器：可以用子类的可失败构造器或非失败构造器覆盖基类的可失败构造器</li>
<li>但一个非失败构造器永远不能代理调用一个可失败构造器</li>
<li>init!<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">struct StudRecord &#123;</div><div class="line">    let stname: String</div><div class="line"></div><div class="line">    init!(stname: String) &#123;</div><div class="line">    if stname.isEmpty &#123;return nil &#125;</div><div class="line">    self.stname = stname</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let stmark = StudRecord(stname: &quot;Runoob&quot;)</div><div class="line">if let name = stmark &#123;</div><div class="line">    print(&quot;指定了学生名&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">let blankname = StudRecord(stname: &quot;&quot;)</div><div class="line">if blankname == nil &#123;</div><div class="line">    print(&quot;学生名为空&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="类的构造器代理规则"><a href="#类的构造器代理规则" class="headerlink" title="类的构造器代理规则"></a>类的构造器代理规则</h2><ul>
<li>指定构造器必须调用其直接父类的指定构造器</li>
<li>便利构造器必须调用其同类定义的其他构造器</li>
<li>便利构造器必须最终导致一个指定构造器被调用<blockquote>
<p>指定构造器向上代理，便利构造器横向代理</p>
</blockquote>
</li>
</ul>
<h2 id="两段式构造过程"><a href="#两段式构造过程" class="headerlink" title="两段式构造过程"></a>两段式构造过程</h2><ul>
<li>安全检查1<br>指定构造器必须保证它所在类引入的所有属性都必须先初始化完成，之后才能将其它构造任务向上代理给父类中的构造器。</li>
<li>安全检查2<br>指定构造器必须先向上代理调用父类构造器，然后再为继承的属性设置新值。</li>
<li>安全检查3<br>便利构造器必须先代理调用同一类中的其它构造器，然后再为任意属性赋新值。</li>
<li>安全检查4<br>构造器在第一阶段构造完成之前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用self作为一个值。</li>
</ul>
<h1 id="析构过程"><a href="#析构过程" class="headerlink" title="析构过程"></a>析构过程</h1><p>*<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">deinit &#123;</div><div class="line">// 执行析构过程</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="自动引用计数"><a href="#自动引用计数" class="headerlink" title="自动引用计数"></a>自动引用计数</h1><blockquote>
<p>引用计数仅仅应用于类的实例。结构体和枚举类型是值类型。</p>
</blockquote>
<h2 id="类实例之间的循环强引用"><a href="#类实例之间的循环强引用" class="headerlink" title="类实例之间的循环强引用"></a>类实例之间的循环强引用</h2><h3 id="弱引用-weak"><a href="#弱引用-weak" class="headerlink" title="弱引用 weak"></a>弱引用 weak</h3><ul>
<li>当 ARC 设置弱引用为nil时，属性观察不会被触发</li>
</ul>
<p>1.与OC类似的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">weak var weakSelf = self</div><div class="line">loadData&#123;</div><div class="line">print(&quot;\(weakSelf?.view)&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.swift推荐的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">loadData&#123; [weak self] in</div><div class="line">print(&quot;\(self?.view)&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="无主引用-unowned"><a href="#无主引用-unowned" class="headerlink" title="无主引用 unowned"></a>无主引用 unowned</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">loadData&#123; [unowned self] in</div><div class="line">print(&quot;\(self.view)&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="循环引用总结"><a href="#循环引用总结" class="headerlink" title="循环引用总结"></a>循环引用总结</h3><ul>
<li><code>对于生命周期中会变为nil的实例使用弱引用。相反的，对于初始化赋值后再也不会被赋值为nil的实例，使用无主引用。</code> 当其他的实例有更短的生命周期时，使用弱引用(当其他实例析构在先)，当其他实例有相同的或者更长生命周期时，请使用无主引用</li>
<li>swift<ul>
<li><code>[weak self]</code>：self是可选项，如果self已经被释放，则为nil</li>
<li><code>[unowned self]</code>：self不是可选项，如果self已经被释放，则为野指针访问，使用无主引用，必须确保引用始终指向一个未销毁的实例</li>
</ul>
</li>
<li>Objc<ul>
<li><code>__weak typeof(self) weakSelf;</code>：如果self已经被释放，则为nil</li>
<li><code>__unsafe_unretained typeof(self) weakSelf;</code>：如果self已经被释放，则为野指针访问</li>
</ul>
</li>
</ul>
<h2 id="闭包引起的循环强引用"><a href="#闭包引起的循环强引用" class="headerlink" title="闭包引起的循环强引用"></a>闭包引起的循环强引用</h2><blockquote>
<p>解决闭包引起的循环强引用:闭包捕获列表，在定义闭包时同时定义捕获列表作为闭包的一部分</p>
</blockquote>
<ul>
<li>当闭包和捕获的实例总是互相引用时并且总是<code>同时销毁</code>时，将闭包内的捕获定义为<code>无主引用</code>。<br>相反的，当捕获引用有时<code>可能会是nil</code>时，将闭包内的捕获定义为<code>弱引用</code>。<br>如果捕获的引用<code>绝对不会置为nil</code>，应该用<code>无主引用</code>，而不是弱引用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lazy var someClosure: (Int, String) -&gt; String = &#123;</div><div class="line">[unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -&gt; String in</div><div class="line">// 这里是闭包的函数体</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="可选链"><a href="#可选链" class="headerlink" title="可选链"></a>可选链</h1><blockquote>
<p>可以应用于任意类型，并且能检查调用是否成功。<br><code>多次请求或调用可以被链接成一个链，如果任意一个节点为nil将导致整条链失效</code></p>
</blockquote>
<ul>
<li>通过可选链访问属性，返回两个值：<ul>
<li>如果目标有值，调用成功，返回该值</li>
<li>如果目标为nil，调用返回nil</li>
</ul>
</li>
<li><p>通过可选链调用方法，返回两个值：</p>
<ul>
<li>如果调用成功，返回Void</li>
<li>如果没有称，返回nil</li>
</ul>
</li>
<li><p>可选链可代替强制解析：</p>
<ul>
<li>?：当可选为nil，输出预定的错误信息</li>
<li>! ：当可选为nil，强制展开执行错误</li>
</ul>
</li>
<li><p>连接多层可选链：如果试图通过可选链获得Int值，不论使用了多少层链接返回的总是Int?。</p>
</li>
<li>可以通过可选链调用返回为可空值的方法，并且可以继续对可选值进行链接。</li>
</ul>
<h1 id="错误处理-1"><a href="#错误处理-1" class="headerlink" title="错误处理"></a>错误处理</h1><h2 id="表示并抛出错误-throw"><a href="#表示并抛出错误-throw" class="headerlink" title="表示并抛出错误(throw)"></a>表示并抛出错误(throw)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//枚举构建一组相关的错误状态，枚举的关联值还可以提供错误状态的额外信息</div><div class="line">enum VendingMachineError: Error &#123;</div><div class="line">case invalidSelection                    //选择无效</div><div class="line">case insufficientFunds(coinsNeeded: Int) //金额不足</div><div class="line">case outOfStock                          //缺货</div><div class="line">&#125;</div><div class="line">//抛出一个错误</div><div class="line">throw VendingMachineError. insufficientFunds(coinsNeeded: 5)</div></pre></td></tr></table></figure>
<h2 id="throwing函数"><a href="#throwing函数" class="headerlink" title="throwing函数"></a>throwing函数</h2><ul>
<li><code>throws</code>写在函数声明的参数列表后，<code>-&gt;</code>前。<blockquote>
<p>throwing函数可在其内部抛出错误，将错误传递到函数被调用时的作用域，非throwing函数内部抛出的错误只能在函数内部处理。</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">func canThrowErrors() throws -&gt; String</div></pre></td></tr></table></figure>
<h2 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h2><ul>
<li>处理错误的四种方式：<ul>
<li>把函数抛出的错误传递给调用此函数的代码</li>
<li>do-catch语句</li>
<li>将错误作为可选类型：<code>try?</code></li>
<li>断言此错误根本不会发生</li>
</ul>
</li>
</ul>
<h3 id="do-catch"><a href="#do-catch" class="headerlink" title="do-catch"></a>do-catch</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">do &#123;</div><div class="line">    try expression</div><div class="line">    statements</div><div class="line">&#125; catch pattern 1 &#123;</div><div class="line">    statements</div><div class="line">&#125; catch pattern 2 where condition &#123;</div><div class="line">    statements</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="将错误转换成可选值-try"><a href="#将错误转换成可选值-try" class="headerlink" title="将错误转换成可选值 try?"></a>将错误转换成可选值 try?</h3><ul>
<li>如果在评估try?表达式时一个错误被抛出，那么表达式的值就是nil。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let y = try? someThrowingFunction()</div><div class="line">等价于</div><div class="line">let y: Int?</div><div class="line">do &#123;</div><div class="line">    y = try someThrowingFunction()</div><div class="line">&#125; catch &#123;</div><div class="line">    y = nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="禁用错误传递-try"><a href="#禁用错误传递-try" class="headerlink" title="禁用错误传递 try!"></a>禁用错误传递 try!</h3><ul>
<li>会把调用包装在一个不会有错误抛出的运行时断言中，如果真的抛出，则会发生运行时错误。</li>
</ul>
<h2 id="指定清理操作-defer"><a href="#指定清理操作-defer" class="headerlink" title="指定清理操作 defer"></a>指定清理操作 defer</h2><ul>
<li>defer语句在即将离开当前代码块时（throw,return,break等）执行一系列语句。<br>将代码的执行延迟到当前作用域退出之前，延时执行的操作会按照被指定时的顺序的相反顺序执行，即第一条defer语句中的代码会在第二条defer语句中的代码被执行之后才执行，以此类推。</li>
<li><code>即使没有涉及到错误处理，也可以使用defer语句</code></li>
</ul>
<h1 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h1><h2 id="检查值的类型：is"><a href="#检查值的类型：is" class="headerlink" title="检查值的类型：is"></a>检查值的类型：is</h2><ul>
<li>用类型检查操作符（is）来检查一个实例是否属于特定子类型。</li>
</ul>
<h2 id="向下转型：as"><a href="#向下转型：as" class="headerlink" title="向下转型：as"></a>向下转型：as</h2><ul>
<li>某类型的一个常量或变量可能在幕后实际上属于一个子类，用<code>as</code>向下转到它的子类型。</li>
<li>转换没有真的改变实例或它的值</li>
<li>类型转换的条件转换：as? as!<ul>
<li>可选形式as?：下转成一个可选值</li>
<li>强制形式as!：向下转型+强制解包</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">for item in library&#123;</div><div class="line">    //（1）item不确定是什么类型，所以as?</div><div class="line">    if let movie = item as? Movie&#123;</div><div class="line">        //（2）使用可选绑定类型进行可选解析</div><div class="line">        print(&quot;\(movie.name)--\(movie.director)&quot;)</div><div class="line">    &#125;else if let song = item as? Song&#123;</div><div class="line">        print(&quot;\(song.name)--\(song.artist)&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="获取实例的类型名称"><a href="#获取实例的类型名称" class="headerlink" title="获取实例的类型名称"></a>获取实例的类型名称</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let someStr = &quot;123&quot;</div><div class="line">print(type(of: someStr))    //String</div></pre></td></tr></table></figure>
<h2 id="Any-和-AnyObject-的类型转换"><a href="#Any-和-AnyObject-的类型转换" class="headerlink" title="Any 和 AnyObject 的类型转换"></a>Any 和 AnyObject 的类型转换</h2><ul>
<li>Any 可以表示任何类型，包括函数类型、可选类型。</li>
<li>AnyObject 可以表示任何类型的实例，AnyObject 也是Optional类型的。<blockquote>
<p>Any类型可以表示所有类型的值，包括可选类型。Swift 会在你用Any类型来表示一个可选值的时候，给你一个警告。如果你确实想使用Any类型来承载可选值，你可以使用as操作符显式转换为Any。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 可以存储Any类型的数组</div><div class="line">var arr1 = [Any]()</div><div class="line">// [AnyObject] 类型的数组</div><div class="line">var arr2: [AnyObject]</div></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h1 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h1><ul>
<li>类、枚举、结构体之间可相互嵌套</li>
</ul>
<h1 id="扩展-Extensions"><a href="#扩展-Extensions" class="headerlink" title="扩展 Extensions"></a>扩展 Extensions</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">extension SomeType &#123;</div><div class="line">// 为 SomeType 添加的新功能写到这里</div><div class="line">&#125;</div><div class="line">extension SomeType: SomeProtocol, AnotherProctocol &#123;</div><div class="line">// 协议实现写到这里</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>与OC中的分类类似，但是swift中的扩展没有名字</li>
<li>扩展可以添加新的计算属性，但是不可以添加存储属性，也不可以向已有属性添加属观察器</li>
<li>可用于向已有的类、结构体、枚举或协议添加新功能，但是不能重写已有的功能。</li>
<li>通过为一个已有类型添加新功能，则<code>新功能对该类型的所有实例都有效</code>，即使它们是在扩展定义之前创建的</li>
<li><p>可以实现的功能：</p>
<ul>
<li>添加计算型属性和计算型类型属性</li>
<li>定义实例方法和类型方法</li>
<li>提供新的构造器</li>
<li>定义下标</li>
<li>定义和使用新的嵌套类型</li>
<li>使一个已有类型符合某个协议</li>
</ul>
</li>
<li><p>swift4：extension中可以访问private属性</p>
</li>
</ul>
<h2 id="计算型属性"><a href="#计算型属性" class="headerlink" title="计算型属性"></a>计算型属性</h2><ul>
<li>扩展可以添加新的计算属性，但是不可以添加<code>存储型属性</code>，也不可以为已有属性添加<code>属性观察器</code>。</li>
</ul>
<h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><ul>
<li>扩展可以为类添加新的便利构造器，不可以添加新的指定构造器或析构器。指定构造器和析构器必须由原始类提供。</li>
</ul>
<h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><p>通过扩展添加的实例方法可以修改该实例本身，结构体和枚举类型中修改self或其属性的方法必须将该实例方法标注为mutating</p>
<h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><p>类、枚举、结构体都可以实现协议</p>
<h2 id="协议语法"><a href="#协议语法" class="headerlink" title="协议语法"></a>协议语法</h2><p>定义协议：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">protocol SomeProtocol &#123;</div><div class="line">// 协议的定义部分</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>遵循协议：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct SomeStructure: FirstProtocol, AnotherProtocol &#123;</div><div class="line">// 结构体的定义部分</div><div class="line">&#125;</div><div class="line">class SomeClass: SomeSuperClass, FirstProtocol, AnotherProtocol &#123;</div><div class="line">// 类的内容</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="属性要求"><a href="#属性要求" class="headerlink" title="属性要求"></a>属性要求</h2><ul>
<li><p>协议可以要求遵循协议的类型提供的实例属性或类型属性的<code>名称和类型</code>，还可指定<code>读写性</code>，但不用指定是存储型属性或计算型属性。</p>
<blockquote>
<p>用<code>var</code>声明变量属性，用<code>{set get}</code>声明属性是可读可写的，<code>{get}</code>表示只读属性。</p>
</blockquote>
</li>
<li><p>类属性要求使用static前缀关键字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">protocol AnotherProtocol &#123;</div><div class="line">    static var someTypeProperty: Int &#123; get set &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="方法要求"><a href="#方法要求" class="headerlink" title="方法要求"></a>方法要求</h2><ul>
<li>方法不需要大括号和方法体</li>
<li>不支持为协议中的方法的参数提供默认值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">protocol classa &#123;</div><div class="line">var marks: Int &#123; get set &#125;</div><div class="line">var result: Bool &#123; get &#125;</div><div class="line"></div><div class="line">func attendance() -&gt; String</div><div class="line">func markssecured() -&gt; String</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Mutating-方法要求"><a href="#Mutating-方法要求" class="headerlink" title="Mutating 方法要求"></a>Mutating 方法要求</h2><ul>
<li>表示可以在该方法中修改它所属的实例及其实例属性的值</li>
<li>实现协议中的mutating方法时，若是类类型，则不用写<code>mutating</code>，对于结构体和枚举必须写。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">protocol SomeProtocal &#123;</div><div class="line">    mutating func show()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="构造器要求"><a href="#构造器要求" class="headerlink" title="构造器要求"></a>构造器要求</h2><ul>
<li><p>协议构造器在类中的实现：在遵循该协议的类中实现构造器，并指定其为类的指定构造器或便利构造器，这时必须为构造器实现标上<code>required</code>修饰符，可以确保遵循该协议的子类也能提供此构造器的显式实现或继承实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class SomeClass: SomeProtocol &#123;</div><div class="line">    required init(someParameter: Int) &#123;</div><div class="line">    // 构造器实现</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>如果一个子类重写了父类的指定构造器，并且该构造器满足了某个协议的要求，则构造器的实现需要标上<code>required</code>和<code>override</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">protocol SomeProtocol &#123;</div><div class="line">    init()</div><div class="line">&#125;</div><div class="line"></div><div class="line">class SomeSuperClass &#123;</div><div class="line">    init() &#123;</div><div class="line">    // 这里是构造器的实现部分</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class SomeSubClass: SomeSuperClass, SomeProtocol &#123;</div><div class="line">    // 因为遵循协议，需要加上 required</div><div class="line">    // 因为继承自父类，需要加上 override</div><div class="line">    required override init() &#123;</div><div class="line">    // 这里是构造器的实现部分</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="协议作为类型"><a href="#协议作为类型" class="headerlink" title="协议作为类型"></a>协议作为类型</h2><ul>
<li>作为函数、方法或构造器中的参数类型或返回值类型</li>
<li>作为常量、变量或属性的类型</li>
<li>作为数组、字典或其他容器中的元素类型</li>
</ul>
<h2 id="协议可以继承"><a href="#协议可以继承" class="headerlink" title="协议可以继承"></a>协议可以继承</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">protocol InheritingProtocol: SomeProtocol, AnotherProtocol &#123;</div><div class="line">// 协议定义</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="类专属协议"><a href="#类专属协议" class="headerlink" title="类专属协议"></a>类专属协议</h2><ul>
<li>在协议继承列表添加<code>class</code>关键字，可以限制协议只能适配到类类型</li>
<li><code>该class关键字必须是第一个出现在协议的继承列表中，其后才是其他集继承协议</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">protocol SomeClassOnlyProtocol: class, SomeInheritedProtocol &#123;</div><div class="line">// 协议定义</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="协议的合成"><a href="#协议的合成" class="headerlink" title="协议的合成"></a>协议的合成</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">protocol Stname &#123;</div><div class="line">var name: String &#123; get &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">protocol Stage &#123;</div><div class="line">var age: Int &#123; get &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">struct Person: Stname, Stage &#123;</div><div class="line">var name: String</div><div class="line">var age: Int</div><div class="line">&#125;</div><div class="line"></div><div class="line">func show(celebrator: Stname &amp; Stage) &#123;</div><div class="line">print(&quot;\(celebrator.name) is \(celebrator.age) years old&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">let studname = Person(name: &quot;Priya&quot;, age: 21)</div><div class="line">print(show(celebrator: studname))   //Priya is 21 years old</div></pre></td></tr></table></figure>
<h2 id="协议的组合使用"><a href="#协议的组合使用" class="headerlink" title="协议的组合使用"></a>协议的组合使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">protocol&lt;ProtocolA, ProtocolB, ProtocolC&gt; 等价于</div><div class="line">protocol ProtocolD: ProtocolA, ProtocolB, ProtocolC &#123;</div><div class="line">//...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="检查协议一致性"><a href="#检查协议一致性" class="headerlink" title="检查协议一致性"></a>检查协议一致性</h2><ul>
<li>is：检查实例湿度遵循了某个协议</li>
<li>as?：当实例遵循了协议时，返回该协议类型，否则返回nil</li>
<li>as! ：强制向下转换类型，如果失败，会引起运行时错误</li>
</ul>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><ul>
<li>泛型使用占位类型名（在这里用字母 T 来表示）来代替实际类型名（例如 Int、String 或 Double）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// 定义一个交换两个变量的函数</div><div class="line">func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T) &#123;</div><div class="line">    //可以不使用额外空间而使用多元组特性直接交换 a 和 b 的值</div><div class="line">    (a, b) = (b, a)</div><div class="line">&#125;</div><div class="line">var a = 5, b = 6</div><div class="line">swapTwoValues(&amp;a, &amp;b)</div><div class="line">print(a, b)</div><div class="line"></div><div class="line">//泛型的栈</div><div class="line">struct Stack&lt;Element&gt; &#123;</div><div class="line">    var items = [Element]()</div><div class="line">    mutating func push(_ item: Element) &#123;</div><div class="line">        items.append(item)</div><div class="line">    &#125;</div><div class="line">    mutating func pop() -&gt; Element &#123;</div><div class="line">        return items.removeLast()</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var stackOfStrings = Stack&lt;String&gt;()</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="扩展泛型类型"><a href="#扩展泛型类型" class="headerlink" title="扩展泛型类型"></a>扩展泛型类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">extension Stack &#123;</div><div class="line">    //扩展了一个只读计算型属性</div><div class="line">    var topItem: Element? &#123;</div><div class="line">        return items.isEmpty ? nil : items[items.count - 1]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//T 必须是 SomeClass 子类的类型约束,要求 U 必须符合 SomeProtocol 协议的类型约束</div><div class="line">func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) &#123;</div><div class="line">// 这里是泛型函数的函数体部分</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="关联类-associatedtype"><a href="#关联类-associatedtype" class="headerlink" title="关联类 associatedtype"></a>关联类 associatedtype</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">// Container 协议</div><div class="line">protocol Container &#123;</div><div class="line">    associatedtype ItemType</div><div class="line">    // 添加一个新元素到容器里</div><div class="line">    mutating func append(_ item: ItemType)</div><div class="line">    // 获取容器中元素的数</div><div class="line">    var count: Int &#123; get &#125;</div><div class="line">    // 通过索引值类型为 Int 的下标检索到容器中的每一个元素</div><div class="line">subscript(i: Int) -&gt; ItemType &#123; get &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Stack 结构体遵从 Container 协议</div><div class="line">struct Stack&lt;Element&gt;: Container &#123;</div><div class="line">// Stack&lt;Element&gt; 的原始实现部分</div><div class="line">    var items = [Element]()</div><div class="line">    mutating func push(_ item: Element) &#123;</div><div class="line">    items.append(item)</div><div class="line">    &#125;</div><div class="line">    mutating func pop() -&gt; Element &#123;</div><div class="line">    return items.removeLast()</div><div class="line">    &#125;</div><div class="line">    // Container 协议的实现部分</div><div class="line">    mutating func append(_ item: Element) &#123;</div><div class="line">    self.push(item)</div><div class="line">    &#125;</div><div class="line">    var count: Int &#123;</div><div class="line">    return items.count</div><div class="line">    &#125;</div><div class="line">    subscript(i: Int) -&gt; Element &#123;</div><div class="line">    return items[i]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="where语句"><a href="#where语句" class="headerlink" title="where语句"></a>where语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//用来检查两个Container实例是否包含相同顺序的相同元素</div><div class="line">func allItemsMatch&lt;C1: Container, C2: Container&gt;</div><div class="line">(_ someContainer: C1, _ anotherContainer: C2) -&gt; Bool</div><div class="line">where C1.ItemType == C2.ItemType, C1.ItemType: Equatable &#123;</div><div class="line"></div><div class="line">    // 检查两个容器含有相同数量的元素</div><div class="line">    if someContainer.count != anotherContainer.count &#123;</div><div class="line">        return false</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 检查每一对元素是否相等</div><div class="line">    for i in 0..&lt;someContainer.count &#123;</div><div class="line">        if someContainer[i] != anotherContainer[i] &#123;</div><div class="line">            return false</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 所有元素都匹配，返回 true</div><div class="line">    return true</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h1><ul>
<li>可以给单个类型（类、结构体、枚举）设置访问级别，也可以给这些类型的属性、函数、初始化方法、基本类型、下标、协议等设置访问级别</li>
<li>访问控制基于模块与源文件<ul>
<li>模块：独立单元构建和发布的framework或application</li>
<li>源文件：通常属于一个模块，源文件可以包含多个类和函数的定义</li>
</ul>
</li>
</ul>
<h2 id="四种访问级别"><a href="#四种访问级别" class="headerlink" title="四种访问级别"></a>四种访问级别</h2><ul>
<li>四种访问级别，从高到低，默认为<code>internal</code>：<br>| 访问级别 | 权限  |<br>|:——–:|———-|<br>|   public    | 可以访问自己模块中源文件里的任何实体，别人也可以通过引入该模块来访问源文件里的所有实体   |<br>|   internal   | 可以访问自己模块中源文件里的任何实体，别人不能   |<br>|   fileprivate    | 文件内私有，只能在当前源文件中使用   |<br>|   private    | 只能在类中访问，离开了这个类或者结构体的作用域外面就无法访问   |</li>
</ul>
<h2 id="访问级别的原则"><a href="#访问级别的原则" class="headerlink" title="访问级别的原则"></a>访问级别的原则</h2><ul>
<li><p><code>元组</code>的访问级别与元组中访问级别<code>最低的类型</code>一致（元组 = min（元组中元素））</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">internal class SomeInternalClass &#123;&#125;</div><div class="line">private class SomePrivateClass &#123;&#125;</div><div class="line">//该函数返回类型的访问级别是 private，必须使用 private 修饰符，明确的声明该函数</div><div class="line">func someFunction() -&gt; (SomeInternalClass, SomePrivateClass) &#123;</div><div class="line">// 函数实现</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>枚举中<code>成员</code>的访问级别<code>继承自该枚举</code>，不能为枚举中的成员单独声明不同的访问级别（枚举成员 = 枚举）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public enum Student &#123;</div><div class="line">    case Name(String)</div><div class="line">    case Mark(Int,Int,Int)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>子类的访问级别<code>不得高于父类</code>的访问级别。（子类 &lt;= 父类）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class SuperClass &#123;</div><div class="line">    fileprivate func show() &#123;</div><div class="line">    print(&quot;超类&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 访问级别不能低于超类 internal &gt; public</div><div class="line">internal class SubClass: SuperClass  &#123;</div><div class="line">    override internal func show() &#123;</div><div class="line">    print(&quot;子类&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>常量、变量、属性<code>不能拥有比它们的类型更高</code>的访问级别，下标也不能拥有比索引类型或返回类型更高的访问级别（常量、变量、属性、下标 &lt;= 它的类型）</p>
</li>
<li><p>常量、变量、属性、下标索引的getter和setter的访问级别<code>继承自他们所属成员</code>的访问级别，setter的访问级别可以低于对应的getter的访问级别，这样可以控制常量、变量、下标的读写权限（getter和setter = 常量、变量、属性、下标索引，getter &gt;= setter）</p>
</li>
<li><p>构造器和默认构造器访问级别：</p>
<ul>
<li>自定义的初始化方法 &lt;= 它所属类</li>
<li>必要构造器 = 所属类</li>
<li>函数中，初始化方法参数 &gt;= 初始化方法</li>
<li>默认构造器 = 所属类型</li>
</ul>
</li>
<li><p>协议访问级别（请确保该协议只在声明的访问级别作用域中使用）：实现协议的必要函数 = 协议</p>
</li>
<li><p>扩展访问级别：扩展成员 = 原始类成员，单独成员所声明的访问级别可以覆盖扩展的默认访问级别。</p>
</li>
<li><p>泛型访问级别 = min（泛型类型、函数本身、泛型类型参数）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public struct TOS&lt;T&gt; &#123;</div><div class="line">    var items = [T]()</div><div class="line">    private mutating func push(item: T) &#123;</div><div class="line">        items.append(item)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mutating func pop() -&gt; T &#123;</div><div class="line">        return items.removeLast()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>类型别名 &lt;= 原类型</p>
</li>
</ul>
<h1 id="高级运算符"><a href="#高级运算符" class="headerlink" title="高级运算符"></a>高级运算符</h1><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><ul>
<li>按位取反：~</li>
<li>按位与：&amp;</li>
<li>按位或：|</li>
<li>按位异或：^</li>
<li>按位左移：&lt;&lt;(乘2)</li>
<li>按位右移：&gt;&gt;(除2)</li>
<li>有符号整数的移位运算：0代表证书，1代表负数，负数表示用二进制补码</li>
</ul>
<h2 id="溢出运算符"><a href="#溢出运算符" class="headerlink" title="溢出运算符"></a>溢出运算符</h2><ul>
<li>溢出加法：&amp;+</li>
<li>溢出减法：&amp;-</li>
<li>溢出乘法：&amp;*</li>
</ul>
<h2 id="优先级和结合性"><a href="#优先级和结合性" class="headerlink" title="优先级和结合性"></a>优先级和结合性</h2><ul>
<li>乘法与取余运算都是左结合</li>
</ul>
<h2 id="运算符函数"><a href="#运算符函数" class="headerlink" title="运算符函数"></a>运算符函数</h2><h2 id="重载-自定义运算符"><a href="#重载-自定义运算符" class="headerlink" title="重载/自定义运算符"></a>重载/自定义运算符</h2><ul>
<li><p>重载运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">func +(left: Vector2D, right:Vector2D) -&gt; Vector2D &#123;</div><div class="line">    return Vector2D(x: left.x + right.x, y: left.y + right.y)</div><div class="line">&#125;</div><div class="line"></div><div class="line">let v1 = Vector2D(x: 2, y: 3)</div><div class="line">let v2 = Vector2D(x: 1, y: 4)</div><div class="line">let v3 = Vector2D(x: v1.x+v2.x, y: v1.y+v2.y)</div><div class="line">let v4 = v1 + v2 + v3</div></pre></td></tr></table></figure>
</li>
<li><p>自定义运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">func +*(left: Vector2D, right:Vector2D) -&gt; Double &#123;</div><div class="line">return left.x * right.x + left.y * right.y</div><div class="line">&#125;</div><div class="line">let result1 = v1 +* v2</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// FirstClass.swift</div><div class="line">// 这个文件存在于 MyFramework.framework 中</div><div class="line">public class FirstClass &#123;</div><div class="line">    public class func hello() &#123;</div><div class="line">        print(&quot;hello from first&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// SecondClass.swift</div><div class="line">// 这个文件存在于 app 的主 target 中</div><div class="line">class SecondClass &#123;</div><div class="line">    class func hello() &#123;</div><div class="line">        print(&quot;hello from second&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">FirstClass.MyClass.hello()</div><div class="line">// hello from firsst</div><div class="line">SecondClass.MyClass.hello()</div><div class="line">// hello from second</div></pre></td></tr></table></figure>
<h1 id="Swift-UI部分"><a href="#Swift-UI部分" class="headerlink" title="Swift UI部分"></a>Swift UI部分</h1><p>Q:编译错误：<code>The “Swift Language Version” (SWIFT_VERSION) build setting must be set to a supported value for targets which use Swift. This setting can be set in the build settings editor.</code><br>A:解决：Build Settings-&gt;Swift Language Version 选择一个最新的swift版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var myBtn: UIButton?</div><div class="line">myBtn = UIButton(type:UIButtonType.system)</div><div class="line">myBtn!.frame = CGRect(x: 100, y: 100, width: 100, height: 44)</div><div class="line">myBtn!.backgroundColor = UIColor.red</div><div class="line">myBtn!.setTitle(&quot;注册&quot;, for: UIControlState.normal)</div><div class="line">myBtn!.addTarget(self, action: Selector((&quot;register:&quot;)), for: UIControlEvents.touchUpInside)</div><div class="line">self.view.addSubview(myBtn!)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var myBtn: UIButton!</div><div class="line">myBtn = UIButton(type:UIButtonType.system)</div><div class="line">myBtn!.frame = CGRect(x: 100, y: 100, width: 100, height: 44)</div><div class="line">myBtn!.backgroundColor = UIColor.red</div><div class="line">myBtn!.setTitle(&quot;注册&quot;, for: .normal)</div><div class="line">myBtn!.addTarget(self, action: #selector(register(sender:)), for: .touchUpInside)</div><div class="line">view.addSubview(myBtn!)</div><div class="line"></div><div class="line">@objc func register(sender: UIButton)&#123;</div><div class="line">print(&quot;register click&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><ul>
<li><p>swift中单例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//swift中的let是线程安全的</div><div class="line">static let instance: NetworkTools = NetworkTools()</div><div class="line">class func shareNetworkTools() -&gt; NetworkTools&#123;</div><div class="line">    return instance</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>OC中单例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">+(instancetype)shareNetworkTools&#123;</div><div class="line">    static id instance;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">        //onceToken默认等于0，如果是0就执行block，如果不是就不执行</div><div class="line">        NSLog(@&quot;%ld&quot;,onceToken);</div><div class="line">        dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        instance = [[self alloc] init];</div><div class="line">    &#125;);</div><div class="line">    return instance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="swift的常用内置函数总结"><a href="#swift的常用内置函数总结" class="headerlink" title="swift的常用内置函数总结"></a>swift的常用内置函数总结</h1><ul>
<li>abs</li>
<li>assert</li>
<li>countElements</li>
<li>enumerate</li>
<li>sort</li>
<li>contains(sequence, element)</li>
<li>dropFirst(sequence)</li>
<li>dropLast(sequence)</li>
<li>dump(object)：打印出某个对象object的所有信息</li>
<li>equal(sequence1, sequence2)：判断两个序列是否相等</li>
<li>filter(sequence, includeElementClosure)：对序列sequence中每个元素都执行includeElementClosure闭包，并将所有闭包结果为true的元素合成一个新序列sequence并返回。</li>
<li>find(sequence, element)：返回序列sequence中某元素element的位置index。如果序列中不存在此元素，则返回nil。</li>
<li>indices(sequence)：返回序列sequence中所有元素的位置（indices是index的复数）</li>
<li>join(separator, sequence)：将序列sequence通过分隔符separator连成一个字符串，并返回此字符串。</li>
<li>map(sequence, transformClosure)：对序列sequence中每个元素都执行includeElementClosure闭包，并将所有闭包的结果合成一个新序列sequence并返回。</li>
<li>max(comparable1, comparable2, etc.)  min(comparable1, comparable2, etc.)</li>
<li>maxElement(sequence)：返回序列sequence中的最大值。  minElements(sequence)：返回序列sequence中的最小值。</li>
<li>reverse(sequence)：返回逆序的序列sequence。</li>
</ul>
<p>参考资料：<a href="http://wiki.jikexueyuan.com/project/swift">The Swift Programming Language中文版</a><br><a href="http://www.runoob.com/swift/swift-tutorial.html">菜鸟教程-swift教程</a><br><a href="http://blog.csdn.net/banma2008/article/details/46360333">Swift的74个常用内置函数介绍</a><br><a href="http://www.cocoachina.com/ios/20151218/14716.html">深入探究Swift数组背后的协议、方法、拓展</a><br><a href="http://www.cnblogs.com/Jepson1218/p/5277677.html">swift常用代码</a><br><a href="http://www.swift51.com/openSource.htm">Swift编程</a><br><a href="https://github.com/allenwong/30DaysofSwift">30个swift项目源码</a><br><a href="https://github.com/cjiong/LearnSwift">50个swift项目源码</a><br><a href="https://github.com/yagamis/swift2basic">https://github.com/yagamis/swift2basic</a><br><a href="https://github.com/KeyJohn/Swift">https://github.com/KeyJohn/Swift</a></p>
-->
      
    </div>
    <footer class="article-footer">
      
        <div id="donation_div"></div>

<script src="/js/vdonate.js"></script>
<script>
var a = new Donate({
  title: '如果觉得我的文章对您有用，请随意打赏。您的支持将鼓励我继续创作!', // 可选参数，打赏标题
  btnText: 'Donate', // 可选参数，打赏按钮文字
  el: document.getElementById('donation_div'),
  wechatImage: '/assets/blogImg/weixin.png',
  alipayImage: '/assets/blogImg/zhifubao.png'
});
</script>
      
      
        
	<div id="comment">
		<!-- 来必力City版安装代码 -->
		<div id="lv-container" data-id="city" data-uid="MTAyMC8yOTQ4MS82MDQ5">
		<script type="text/javascript">
		   (function(d, s) {
		       var j, e = d.getElementsByTagName(s)[0];

		       if (typeof LivereTower === 'function') { return; }

		       j = d.createElement(s);
		       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
		       j.async = true;

		       e.parentNode.insertBefore(j, e);
		   })(document, 'script');
		</script>
		<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
		</div>
		<!-- City版安装代码已完成 -->
	</div>



      
      

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/07/21/iOS常用第三方框架/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          iOS常用第三方框架
        
      </div>
    </a>
  
  
    <a href="/2017/07/11/podspec学习笔记/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">podspec学习笔记</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="toc-sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">Inhalt</strong>
    
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#基础知识"><span class="nav-number">1.</span> <span class="nav-text">基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#常量和变量"><span class="nav-number">1.1.</span> <span class="nav-text">常量和变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字面量"><span class="nav-number">1.2.</span> <span class="nav-text">字面量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型标注"><span class="nav-number">1.3.</span> <span class="nav-text">类型标注</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注释"><span class="nav-number">1.4.</span> <span class="nav-text">注释</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分号"><span class="nav-number">1.5.</span> <span class="nav-text">分号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#打印日志"><span class="nav-number">1.6.</span> <span class="nav-text">打印日志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型转换"><span class="nav-number">1.7.</span> <span class="nav-text">类型转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型别名"><span class="nav-number">1.8.</span> <span class="nav-text">类型别名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#元组"><span class="nav-number">1.9.</span> <span class="nav-text">元组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可选类型"><span class="nav-number">1.10.</span> <span class="nav-text">可选类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nil"><span class="nav-number">1.11.</span> <span class="nav-text">nil</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#if-语句以及强制解析"><span class="nav-number">1.12.</span> <span class="nav-text">if 语句以及强制解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可选绑定"><span class="nav-number">1.13.</span> <span class="nav-text">可选绑定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#隐式解析可选类型"><span class="nav-number">1.14.</span> <span class="nav-text">隐式解析可选类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#错误处理"><span class="nav-number">1.15.</span> <span class="nav-text">错误处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#断言"><span class="nav-number">1.16.</span> <span class="nav-text">断言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fatalError"><span class="nav-number">1.17.</span> <span class="nav-text">fatalError</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#基本运算符"><span class="nav-number">2.</span> <span class="nav-text">基本运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#不可自增自减"><span class="nav-number">2.1.</span> <span class="nav-text">不可自增自减</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#取余"><span class="nav-number">2.2.</span> <span class="nav-text">取余</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#空值合并-空合-运算符"><span class="nav-number">2.3.</span> <span class="nav-text">空值合并(空合)运算符??</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#区间运算符"><span class="nav-number">2.4.</span> <span class="nav-text">区间运算符</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#字符与字符串"><span class="nav-number">3.</span> <span class="nav-text">字符与字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#初始化空字符串"><span class="nav-number">3.1.</span> <span class="nav-text">初始化空字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符"><span class="nav-number">3.2.</span> <span class="nav-text">字符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串可变性"><span class="nav-number">3.3.</span> <span class="nav-text">字符串可变性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#连接字符串和字符"><span class="nav-number">3.4.</span> <span class="nav-text">连接字符串和字符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#插入和删除"><span class="nav-number">3.5.</span> <span class="nav-text">插入和删除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计算字符数量"><span class="nav-number">3.6.</span> <span class="nav-text">计算字符数量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串索引"><span class="nav-number">3.7.</span> <span class="nav-text">字符串索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#比较字符串"><span class="nav-number">3.8.</span> <span class="nav-text">比较字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#插值"><span class="nav-number">3.9.</span> <span class="nav-text">插值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#格式化字符串"><span class="nav-number">3.10.</span> <span class="nav-text">格式化字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#swift4新增"><span class="nav-number">3.11.</span> <span class="nav-text">swift4新增</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#集合类型"><span class="nav-number">4.</span> <span class="nav-text">集合类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#集合的可变性"><span class="nav-number">4.1.</span> <span class="nav-text">集合的可变性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组"><span class="nav-number">4.2.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集合"><span class="nav-number">4.3.</span> <span class="nav-text">集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字典"><span class="nav-number">4.4.</span> <span class="nav-text">字典</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他"><span class="nav-number">4.5.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#生成器（Generator）"><span class="nav-number">4.5.1.</span> <span class="nav-text">生成器（Generator）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#序列（Sequence）"><span class="nav-number">4.5.2.</span> <span class="nav-text">序列（Sequence）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合-Collection"><span class="nav-number">4.5.3.</span> <span class="nav-text">集合(Collection)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#控制流"><span class="nav-number">5.</span> <span class="nav-text">控制流</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#For-In-循环"><span class="nav-number">5.1.</span> <span class="nav-text">For-In 循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#while-repeat-while"><span class="nav-number">5.2.</span> <span class="nav-text">while/repeat-while</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#switch"><span class="nav-number">5.3.</span> <span class="nav-text">switch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#控制转移语句"><span class="nav-number">5.4.</span> <span class="nav-text">控制转移语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#检测API可用性"><span class="nav-number">5.5.</span> <span class="nav-text">检测API可用性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数"><span class="nav-number">6.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#函数定义与调用"><span class="nav-number">6.1.</span> <span class="nav-text">函数定义与调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指定参数标签"><span class="nav-number">6.2.</span> <span class="nav-text">指定参数标签</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#忽略参数标签"><span class="nav-number">6.3.</span> <span class="nav-text">忽略参数标签</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#默认参数值"><span class="nav-number">6.4.</span> <span class="nav-text">默认参数值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可变参数"><span class="nav-number">6.5.</span> <span class="nav-text">可变参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#输入输出参数"><span class="nav-number">6.6.</span> <span class="nav-text">输入输出参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数类型"><span class="nav-number">6.7.</span> <span class="nav-text">函数类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#嵌套函数"><span class="nav-number">6.8.</span> <span class="nav-text">嵌套函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#柯里化"><span class="nav-number">6.9.</span> <span class="nav-text">柯里化</span></a></li></ol></li></ol>
    
    </div>
  </aside>
</section>
        
      </div>
      
      <footer id="footer">
  

  <div class="container">
      	<div class="row">
	      <p> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/iTimeTraveler/hexo-theme-hiker" target="_blank">Hexo-theme-hiker</a> </p>
	      <p id="copyRightEn">Copyright &copy; 2016 - 2018 guchunli All Rights Reserved.</p>
	      
	      
    		<p class="busuanzi_uv">
				UV : <span id="busuanzi_value_site_uv"></span> |  
				PV : <span id="busuanzi_value_site_pv"></span>
		    </p>
  		   
		</div>

		
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");
    var allheader = document.getElementById("allheader");

    wrapdiv.style.minHeight = document.body.offsetHeight + "px";
    if (allheader != null) {
      contentdiv.style.minHeight = document.body.offsetHeight - allheader.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    } else {
      contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    }
</script>
    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives/" class="mobile-nav-link">Archives</a>
  
    <a href="/categories/study/" class="mobile-nav-link">Study</a>
  
    <a href="/categories/other/" class="mobile-nav-link">Other</a>
  
    <a href="/photos" class="mobile-nav-link">Photos</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/scripts.js"></script>




  <script src="/js/dialog.js"></script>








	<div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>



	<script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?{{ theme.baidu_analytics }}";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  </div>

  <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true" style="display: none;">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title" id="myModalLabel">设置</h2>
      </div>
      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">


      <div class="modal-body">
          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseOne" onclick="javascript:setFontSize();" aria-expanded="true" aria-controls="collapseOne">
              正文字号大小
            </a>
          </div>
          <div id="collapseOne" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOne">
          <div class="panel-body">
            您已调整页面字体大小
          </div>
        </div>
      


          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseTwo" onclick="javascript:setBackground();" aria-expanded="true" aria-controls="collapseTwo">
              夜间护眼模式
            </a>
        </div>
          <div id="collapseTwo" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
          <div class="panel-body">
            夜间模式已经开启，再次单击按钮即可关闭 
          </div>
        </div>

        <div>
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseThree" aria-expanded="true" aria-controls="collapseThree">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关 于&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
        </div>
         <div id="collapseThree" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingThree">
          <div class="panel-body">
            guchunli
          </div>
          <div class="panel-body">
            Copyright © 2018 谷春丽的小站 All Rights Reserved.
          </div>
        </div>
      </div>


      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <div class="modal-footer">
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
      </div>
    </div>
  </div>
</div>
  
  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
  
    <a id="menu-switch"><i class="fa fa-bars fa-lg"></i></a>
  
</body>
</html>