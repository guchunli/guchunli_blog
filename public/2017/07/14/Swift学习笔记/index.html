<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #FFFF00; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>






<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Swift,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1">






<meta name="description" content="在线swift编辑器：IBM Swift Sandbox 基础知识常量和变量let，var分别声明常量，变量">
<meta name="keywords" content="Swift">
<meta property="og:type" content="article">
<meta property="og:title" content="Swift学习笔记">
<meta property="og:url" content="https://guchunli.github.io/2017/07/14/Swift学习笔记/index.html">
<meta property="og:site_name" content="guchunli">
<meta property="og:description" content="在线swift编辑器：IBM Swift Sandbox 基础知识常量和变量let，var分别声明常量，变量">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-11-29T03:13:54.778Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Swift学习笔记">
<meta name="twitter:description" content="在线swift编辑器：IBM Swift Sandbox 基础知识常量和变量let，var分别声明常量，变量">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://guchunli.github.io/2017/07/14/Swift学习笔记/">





  <title>Swift学习笔记 | guchunli</title>
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">guchunli</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">努力把生活折腾成自己喜欢的样子~</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-photos">
          <a href="/photos/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-image"></i> <br>
            
            相册
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://guchunli.github.io/2017/07/14/Swift学习笔记/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="谷春丽">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="guchunli">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Swift学习笔记</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-14T17:13:04+08:00">
                2017-07-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/note/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  3.9k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  17
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>在线swift编辑器：IBM Swift Sandbox</p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h2><p>let，var分别声明常量，变量<br><a id="more"></a><br><code>代码中有不需要改变的值，使用 let 关键字将它声明为常量</code></p>
<blockquote>
<p>使用 let 修饰 <code>view</code> 并且赋值，表示该常量的内存地址不允许修改，但是可以修改其内部的属性</p>
</blockquote>
<h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><ul>
<li><p>字面量是指像特定的数字，字符串或者是布尔值这样能够直接了当地指出自己的类型并对变量进行赋值的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let aNumber = 3</span><br><span class="line">let astring = &quot;Hello&quot;</span><br><span class="line">let aBool = true</span><br><span class="line"></span><br><span class="line">let anArray = [1,2,3]</span><br><span class="line">let aDictionary = [&quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>数值型字面量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let a = 11</span><br><span class="line">let b = 0b11</span><br><span class="line">let c = 0o11</span><br><span class="line">let d = 0x11</span><br><span class="line">let e = 2e2     //200</span><br><span class="line">let f = 2e-2    //0.02</span><br><span class="line">let g = 0xFp2   //60</span><br><span class="line">let h = 0xFp-2  //3.75</span><br><span class="line">let i = 1_000_000</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="类型标注"><a href="#类型标注" class="headerlink" title="类型标注"></a>类型标注</h2><p>很少需要标注，swift会进行类型推断，根据右边的代码，推导出变量的准确类型</p>
<blockquote>
<p>Option + Click 可以查看变量的类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let a:Float = 3.0</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>多行注释可嵌套</p>
<h2 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h2><p>swift语句，最后分号可写可不写</p>
<h2 id="打印日志"><a href="#打印日志" class="headerlink" title="打印日志"></a>打印日志</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;item1&quot;,&quot;item2&quot;,&quot;item3&quot;, separator: &quot;,,,&quot;, terminator: &quot;...&quot;)</span><br><span class="line">//item1,,,item2,,,item3...</span><br></pre></td></tr></table></figure>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>值永远不会被隐式转换为其他类型，如果要对不同类型的数据进行计算，必须要显式的转换</p>
<ul>
<li>与字面量的加减无关<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a = &quot;abc&quot;</span><br><span class="line">let b = 9</span><br><span class="line">let ab = a + String(b)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typealias Example = Int</span><br></pre></td></tr></table></figure>
<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><ul>
<li>元组可通过变量名或下标访问</li>
<li>可在定义元组的时候给元素命名</li>
<li>不需要访问的元素可用<code>_</code>代替</li>
<li>元组可作为函数返回值返回多个值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let (color,price,_) = (&quot;red&quot;,80,true)</span><br><span class="line">print(color)</span><br><span class="line">let pen = (&quot;red&quot;,80,true)</span><br><span class="line">let (color,price,_) = pen</span><br><span class="line">print(color)</span><br><span class="line">print(pen.0)</span><br><span class="line">let some = (color:&quot;red&quot;,price:80)</span><br><span class="line">print(some.color)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="可选类型"><a href="#可选类型" class="headerlink" title="可选类型"></a>可选类型</h2><p>可以是任何类型值的缺失<br>显式类型转换结果是可选类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var s: String = &quot;hello&quot;</span><br><span class="line">//s = nil //错误</span><br><span class="line">var s1: String? = &quot;hello&quot;</span><br><span class="line">s1 = nil</span><br></pre></td></tr></table></figure></p>
<h2 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h2><p>nil是一个确定的值，表示值缺失，任何类型的可选状态都可以被设置为nil<br>不可用于非可选的常量和变量<br>可选常量或变量不赋值，自动设值为nil</p>
<ul>
<li>在OC中nil是指针，在swift中nil是可选类型。</li>
</ul>
<h2 id="if-语句以及强制解析"><a href="#if-语句以及强制解析" class="headerlink" title="if 语句以及强制解析"></a>if 语句以及强制解析</h2><p>if语句中的条件必须是一个布尔表达式<br>当一个可选常量或变量确定包含值时，可用<code>!</code>强制解析</p>
<blockquote>
<p><code>()</code> 可以省略，但是 <code>{}</code> 不能省略</p>
<ul>
<li>当 if 的嵌套层次很深，可用where<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if let u = url where u.host == &quot;www.baidu.com&quot; &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>解包：<br>(1)!强行解包,如果 变量 为空，运行时会崩溃<br>(2)判断是否为空<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if str != nil &#123;</span><br><span class="line">print(str!)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(3)<code>if let</code>可选绑定</p>
<h2 id="可选绑定"><a href="#可选绑定" class="headerlink" title="可选绑定"></a>可选绑定</h2><ul>
<li>需要改变，用<code>if var</code><br>可以用在if或while语句中<br>可以判断多个可选项是否为空，用<code>,</code>隔开</li>
<li>一旦进入if分支，变量就不再是可选项<blockquote>
<p><code>if let</code> 不能与使用 <code>&amp;</code>、<code>|</code> 等条件判断,可以使用 <code>where</code> 子句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if let constantName = someOptional &#123;</span><br><span class="line">//constantName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h2 id="隐式解析可选类型"><a href="#隐式解析可选类型" class="headerlink" title="隐式解析可选类型"></a>隐式解析可选类型</h2><p>可选类型被第一次赋值之后就可以确定之后一直有值，这种类型的可选状态被定义为隐式解析可选类型，可使用!直接声明，之后不需要使用!取值。<br>隐式解析可选类型就是可以自动解析的可选类型。<br>仍然可以可选绑定。</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>抛出错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func canThrowAnError() throws &#123;</span><br><span class="line">    // 这个函数有可能抛出错误</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>捕获错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    try canThrowAnError()</span><br><span class="line">    // 没有错误消息抛出</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">    // 有一个错误消息抛出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>举个栗子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">enum LoginError : Error &#123;</span><br><span class="line">case UserNotFound, UserPasswordNotMatch</span><br><span class="line">&#125;</span><br><span class="line">func login(user: String, password: String) throws &#123;</span><br><span class="line"></span><br><span class="line">if 2 &gt; 1 &#123;</span><br><span class="line">throw LoginError.UserPasswordNotMatch</span><br><span class="line">&#125;</span><br><span class="line">if 1 &lt; 2 &#123;</span><br><span class="line">throw LoginError.UserNotFound</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;Login successfully.&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line">try login(user: &quot;onevcat&quot;, password: &quot;123&quot;)</span><br><span class="line">&#125; catch LoginError.UserNotFound &#123;</span><br><span class="line">print(&quot;UserNotFound&quot;)</span><br><span class="line">&#125; catch LoginError.UserPasswordNotMatch &#123;</span><br><span class="line">print(&quot;UserPasswordNotMatch&quot;)</span><br><span class="line">&#125; catch&#123;</span><br><span class="line">//加入一个空的catch，用于关闭catch。否则会报错：Errors thrown from here are not handled because the enclosing catch is not exhaustive</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>当前面表达式的结果为false时显示后面的消息，应用终止。后面的断言消息也可省略。<br>release配置时，断言被禁用。在代码发布时，我们也不需要刻意去把这些断言手动清除。</p>
<ul>
<li>一般以下情况使用：<ul>
<li>下标越界</li>
<li>传递给函数的参数不符合类型</li>
<li>解析可选类型：一个可选值当前为 nil ，但随后的代码就需要非空的值才能成功执行。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let age = 17</span><br><span class="line">assert(age&gt;=18,&quot;未成年人&quot;)</span><br><span class="line">//Assertion failed: 未成年人</span><br></pre></td></tr></table></figure>
<h2 id="fatalError"><a href="#fatalError" class="headerlink" title="fatalError"></a>fatalError</h2><ul>
<li>因为断言只会在 Debug 环境中有效，而在 Release 编译中所以变得断言都将被禁用。所以我们会考虑以产生致命错误(fatalError)的方式来种植程序。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">required init?(coder aDecoder: NSCoder) &#123;</span><br><span class="line">    fatalError(&quot;init(coder:) has not been implemented&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">func methodMustBeImplementedInSubclass() &#123;</span><br><span class="line">fatalError(&quot;这个方法必须在子类中被重写&quot;) &#125;</span><br><span class="line">&#125;</span><br><span class="line">class YourClass: MyClass &#123;</span><br><span class="line">override func methodMustBeImplementedInSubclass() &#123;</span><br><span class="line">print(&quot;YourClass 实现了该方法&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class TheirClass: MyClass &#123;</span><br><span class="line">func someOtherMethod() &#123;</span><br><span class="line">&#125;</span><br><span class="line">//    override func methodMustBeImplementedInSubclass() &#123;</span><br><span class="line">//        print(&quot;TheirClass 实现了该方法&quot;)</span><br><span class="line">//    &#125;</span><br><span class="line">&#125;</span><br><span class="line">YourClass().methodMustBeImplementedInSubclass()</span><br></pre></td></tr></table></figure>
<h1 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a = 3</span><br><span class="line">let b = 3.3</span><br><span class="line">let c = Double(a)*b //或 let c = a*Int(b)</span><br></pre></td></tr></table></figure>
<h2 id="不可自增自减"><a href="#不可自增自减" class="headerlink" title="不可自增自减"></a>不可自增自减</h2><h2 id="取余"><a href="#取余" class="headerlink" title="取余"></a>取余</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10 % 6  //4</span><br><span class="line">10 % -6 //4</span><br><span class="line">-10 % 6 //-4</span><br></pre></td></tr></table></figure>
<h2 id="空值合并-空合-运算符"><a href="#空值合并-空合-运算符" class="headerlink" title="空值合并(空合)运算符??"></a>空值合并(空合)运算符??</h2><p>可对可选类型a进行空判断，如果包含值就解封，否则返回默认值b，此默认值b也为可选类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a = Int(&quot;aaa&quot;)</span><br><span class="line">let b = 2</span><br><span class="line">let c = a ?? b  //等同于 let c = a != nil ? a! : b</span><br></pre></td></tr></table></figure></p>
<h2 id="区间运算符"><a href="#区间运算符" class="headerlink" title="区间运算符"></a>区间运算符</h2><ul>
<li>闭区间：… </li>
<li>半开区间：..&lt;</li>
</ul>
<h1 id="字符与字符串"><a href="#字符与字符串" class="headerlink" title="字符与字符串"></a>字符与字符串</h1><h2 id="初始化空字符串"><a href="#初始化空字符串" class="headerlink" title="初始化空字符串"></a>初始化空字符串</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let s1 = &quot;&quot;</span><br><span class="line">let s2 = String()</span><br></pre></td></tr></table></figure>
<h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><p>str.characters<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let c = &quot;a&quot;</span><br><span class="line"></span><br><span class="line">let chars:[Character] = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br><span class="line">let str = String[chars]</span><br><span class="line">for char in are&#123;</span><br><span class="line">print(char)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="字符串可变性"><a href="#字符串可变性" class="headerlink" title="字符串可变性"></a>字符串可变性</h2><p>变量可变，常量不可变</p>
<h2 id="连接字符串和字符"><a href="#连接字符串和字符" class="headerlink" title="连接字符串和字符"></a>连接字符串和字符</h2><ul>
<li>+：只能连接字符串，不能连接字符</li>
<li>append<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var str1 = &quot;12&quot;</span><br><span class="line">let str2 = &quot;34&quot;</span><br><span class="line">let char1:Character = &quot;5&quot;</span><br><span class="line">str1 += str2</span><br><span class="line">//str1 += char1     //+：只能连接字符串，不能连接字符</span><br><span class="line">str1.append(char1)</span><br><span class="line">str1.append(str2)</span><br><span class="line">//str1.append(contentsOf: char1)    //contentsOf：只能连接字符串，不能连接字符</span><br><span class="line">str1.append(contentsOf: str2)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h2><p>以下方法也可使用在Array,Dictionary,Set中。</p>
<ul>
<li>str.characters.indices所有索引</li>
<li>在某个索引值之前插入字符：<code>insert(_:at:)</code>，不能越界</li>
<li><p>插入字符串：<code>insert(contentsOf:at:)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var hello = &quot;hello&quot;;</span><br><span class="line">hello.insert(contentsOf:&quot; world!&quot;.characters, at: hello(before: welcome.endIndex))</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除字符：<code>remove(at:)</code>，越界返回nil</p>
</li>
<li>removeFirst(2),removeLast()</li>
<li>删除字符串<code>removeSubrange(_:)</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var hello = &quot;hello world!&quot;</span><br><span class="line">let range = hello.index(hello.endIndex, offsetBy: -7)..&lt;hello.endIndex</span><br><span class="line">hello.removeSubrange(range)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="计算字符数量"><a href="#计算字符数量" class="headerlink" title="计算字符数量"></a>计算字符数量</h2><p>str.characters.count</p>
<h2 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h2><ul>
<li><code>startIndex</code>,<code>endIndex</code>,<code>index(before:)</code>,<code>index(after:)</code>,<code>index(_:offsetBy:)</code>,也可以使用在Array,Dictionary,Set中</li>
<li>str.characters.indices所有索引</li>
</ul>
<h2 id="比较字符串"><a href="#比较字符串" class="headerlink" title="比较字符串"></a>比较字符串</h2><ul>
<li>字符串相等：==</li>
<li>前缀相等：<code>hasPrefix(_:)</code></li>
<li>后缀相等：<code>hasSuffix(_:)</code></li>
</ul>
<h2 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h2><p>值转换成字符串：()</p>
<blockquote>
<p>如果变量是可选项，拼接的结果中会有 <code>Optional</code>，<code>??</code> 操作符用于检测可选项是否为 <code>nil</code>， 如果不是 <code>nil</code>，使用当前值，如果是 <code>nil</code>，使用后面的值替代</p>
</blockquote>
<h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><ul>
<li>在实际开发中，如果需要指定字符串格式，可以使用 <code>String(format:...)</code> 的方式<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> h = <span class="number">8</span></span><br><span class="line"><span class="keyword">let</span> m = <span class="number">23</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="number">9</span></span><br><span class="line"><span class="comment">//后面的参数需要放在一个数组中</span></span><br><span class="line"><span class="keyword">let</span> timeString = <span class="type">String</span>(format: <span class="string">"%02d:%02d:%02d"</span>, arguments: [h, m, s])</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let name = &quot;Tom&quot;</span><br><span class="line">let date = NSDate()</span><br><span class="line">let string = NSString(format: &quot;Hello %@. Date: %@&quot;, name, date)</span><br></pre></td></tr></table></figure>
<h2 id="swift4新增"><a href="#swift4新增" class="headerlink" title="swift4新增"></a>swift4新增</h2><ul>
<li><p>多行字符串字面量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let str1 = &quot;&quot;&quot;</span><br><span class="line">12\n34</span><br><span class="line">56</span><br><span class="line">789</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">print(str1)</span><br></pre></td></tr></table></figure>
</li>
<li><p>去掉 characters</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//swift3</span><br><span class="line">let values = &quot;one,two,three...&quot;</span><br><span class="line">print(values.characters.count)</span><br><span class="line">var i = values.characters.startIndex</span><br><span class="line"></span><br><span class="line">while let comma = values.characters[i...&lt;values.characters.endIndex].index(of: &quot;,&quot;) &#123;</span><br><span class="line">if values.characters[i..&lt;comma] == &quot;two&quot; &#123;</span><br><span class="line">print(&quot;found it!&quot;)</span><br><span class="line">&#125;</span><br><span class="line">i = values.characters.index(after: comma)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//swift4</span><br><span class="line">let values = &quot;one,two,three...&quot;</span><br><span class="line">print(values.count)</span><br><span class="line">var i = values.startIndex</span><br><span class="line"></span><br><span class="line">while let comma = values[i...&lt;values.endIndex].index(of: &quot;,&quot;) &#123;</span><br><span class="line">if values[i..&lt;comma] == &quot;two&quot; &#123;</span><br><span class="line">print(&quot;found it!&quot;)</span><br><span class="line">&#125;</span><br><span class="line">i = values.index(after: comma)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>String 当做 Collection 来用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let abc: String = &quot;abc&quot;</span><br><span class="line">print(String(abc.reversed()))   // cba</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h1><h2 id="集合的可变性"><a href="#集合的可变性" class="headerlink" title="集合的可变性"></a>集合的可变性</h2><p>变量可变，常量不可变</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li>数组的类型<ul>
<li>如果初始化时，所有内容类型一致，择数组中保存的是该类型的内容</li>
<li>如果初始化时，所有内容类型不一致，择数组中保存的是 <code>NSObject</code></li>
</ul>
</li>
<li>数字可以直接添加到集合，不需要再转换成 <code>NSNumber</code></li>
<li>如果将结构体对象添加到集合，仍然需要转换成 <code>NSValue</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//var array2 = [&quot;zhangsan&quot;, 18]  //会报错:Heterogeneous collection literal could only be inferred to &apos;[Any]&apos;; add explicit type annotation if this is intentional</span><br><span class="line">let array2 = [&quot;zhangsan&quot;, 18] as [Any]</span><br><span class="line">array2.append(100)</span><br><span class="line">array2.append(NSValue(CGPoint: CGPoint(x: 10, y: 10)))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>最后一个元素后面允许有个逗号</p>
<ul>
<li><p>定义数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr1:[Int]</span><br><span class="line">let a:Array&lt;Int&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建空数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr2 = [Int]()</span><br><span class="line">//var arr3 = []  //错误</span><br><span class="line">var a2:[String] = Array&lt;String&gt;()</span><br></pre></td></tr></table></figure>
</li>
<li><p>给数组赋空值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr1 = []</span><br><span class="line">arr = [Int](repeatElement(3, count: 10))</span><br><span class="line">arr = Array(repeatElement(2, count: 10))</span><br><span class="line">var ints = [Int](repeating: &quot;2&quot;, count: 10)</span><br><span class="line">var ints = Array(repeating: &quot;2&quot;, count: 10)</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断是否是空数组：isEmpty</p>
</li>
<li><p><code>不可以用下标访问的形式为数组添加新项</code></p>
</li>
<li><p>遍历数组<br>可以使用元组返回索引和元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (index, value) in arr.enumerated() &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>必须是相同类型的数组才能够合并</p>
</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ul>
<li>存储在集合中的数据必须是可哈希化的。<br>可哈希化必须满足三个条件：<ul>
<li>a == a(自反性)</li>
<li>a == b意味着b == a(对称性)</li>
<li>a == b &amp;&amp; b == c意味着a == c(传递性)</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = 1</span><br><span class="line">print(a.hashValue)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>创建空集合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var set1 = Set&lt;String&gt;()</span><br></pre></td></tr></table></figure>
</li>
<li><p>集合转数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let arr = set1.sorted()</span><br></pre></td></tr></table></figure>
</li>
<li><p>集合的交差并补</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let x:Set = [1,2,3]</span><br><span class="line">let y:Set = [3,4,5]</span><br><span class="line">x.intersection(y)</span><br><span class="line">x.subtract(y)</span><br><span class="line">x.union(y)</span><br><span class="line">x.symmetricDifference(y)</span><br></pre></td></tr></table></figure>
</li>
<li><p>集合相等：有完全相同的元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let set1:Set = [1,2,3]</span><br><span class="line">let set2:Set = [3,2,1]</span><br><span class="line">set1 == set2</span><br></pre></td></tr></table></figure>
</li>
<li><p>子集（可以相等），严格子集</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let set1:Set = [1,2,3,4]</span><br><span class="line">let set2:Set = [3,4]</span><br><span class="line">set2.isSuperset(of: set1)</span><br><span class="line">set2.isStrictSuperset(of: set1)</span><br></pre></td></tr></table></figure>
</li>
<li><p>父集（可以相等），严格父集</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set1.isSubset(of: set2)</span><br><span class="line">set1.isStrictSubset(of: set2)</span><br></pre></td></tr></table></figure>
</li>
<li><p>无交集</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let set1:Set = [1,2]</span><br><span class="line">let set2:Set = [3,4]</span><br><span class="line">set1.isDisjoint(with: set2)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><ul>
<li>存储在集合中的key必须是可哈希化的。</li>
<li><p>创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var dict = [&quot;a&quot;:&quot;b&quot;]</span><br><span class="line">var dict1 : Dictionary&lt;String,String&gt;</span><br><span class="line">var dict2 : [String:String]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>updateValue(_:forKey:)</code>:设置或更新值，但是返回更新值之前的原值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let oldValue = dic.updateValue(&quot;lisi&quot;, forKey: &quot;name&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>dic[&quot;akey&quot;] = nil</code>，<code>dic.removeValue(forKey: &quot;akey&quot;)</code>：移除键值对</p>
</li>
<li><p>dic.keys,dic.values</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var keyArr = [String](dict.keys)</span><br><span class="line">var valueArr = Array(dict.values)</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历字典时候需要明确指明数组中的数据类型<br>for dict in dictArray  as! [[String:String]]{}</p>
</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="生成器（Generator）"><a href="#生成器（Generator）" class="headerlink" title="生成器（Generator）"></a>生成器（Generator）</h3><ul>
<li>生成器允许遍历所有元素<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protocol GeneratorType &#123;</span><br><span class="line">typealias Element</span><br><span class="line">mutating func next() -&gt; Element?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="序列（Sequence）"><a href="#序列（Sequence）" class="headerlink" title="序列（Sequence）"></a>序列（Sequence）</h3><ul>
<li>一种可以对其元素进行连续，迭代访问的类型。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protocol SequenceType &#123;</span><br><span class="line">    typealias Generator: GeneratorType</span><br><span class="line">    func generate() -&gt; Generator</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="集合-Collection"><a href="#集合-Collection" class="headerlink" title="集合(Collection)"></a>集合(Collection)</h3><h1 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h1><h2 id="For-In-循环"><a href="#For-In-循环" class="headerlink" title="For-In 循环"></a>For-In 循环</h2><ul>
<li>index 可直接使用，无序声明，不需要的时候可用<code>_</code>忽略</li>
<li>省略下标<ul>
<li><code>_</code> 能够匹配任意类型</li>
<li><code>_</code> 表示忽略对应位置的值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for index in 1...5 &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="while-repeat-while"><a href="#while-repeat-while" class="headerlink" title="while/repeat-while"></a>while/repeat-while</h2><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><ul>
<li>switch支持任意类型的数据比较 </li>
<li>switch不会隐式贯穿，默认有break,不用加</li>
<li>每一个 case 分支都必须包含至少一条语句,没有可用break；必须有default语句,要保证处理所有可能的情况，不然编译器直接报错</li>
<li>每一个 <code>case</code> 中定义的变量仅在当前 <code>case</code> 中有效</li>
<li>复合匹配，可以用逗号隔开匹配多个值</li>
<li>区间匹配：<code>case 1...10:</code></li>
<li>元组匹配：<code>case (_,0):</code></li>
<li>值绑定：<code>case (let x,0):</code></li>
<li>where添加额外条件：<code>case let(x,y) where x==y:</code></li>
</ul>
<h2 id="控制转移语句"><a href="#控制转移语句" class="headerlink" title="控制转移语句"></a>控制转移语句</h2><ul>
<li>continue</li>
<li>break：可用于switch语句或循环体中</li>
<li><p>label</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var i = 1</span><br><span class="line">myLabel: while i&lt;100&#123;</span><br><span class="line">    switch i &#123;</span><br><span class="line">        case 10:</span><br><span class="line">            print(&quot;case-10&quot;)</span><br><span class="line">            break myLabel</span><br><span class="line">        case 20:</span><br><span class="line">            print(&quot;case-20&quot;)</span><br><span class="line">        default:</span><br><span class="line">            print(&quot;default&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    i+=1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>fallthrough：贯穿到下一个case中的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let i = 3</span><br><span class="line">switch i &#123;</span><br><span class="line">    case 1:</span><br><span class="line">        print(&quot;1&quot;)</span><br><span class="line">    case 2:</span><br><span class="line">        print(&quot;2&quot;)</span><br><span class="line">    case 3:</span><br><span class="line">        print(&quot;3&quot;)</span><br><span class="line">        fallthrough</span><br><span class="line">    case 4:</span><br><span class="line">        print(&quot;4&quot;)</span><br><span class="line">        fallthrough</span><br><span class="line">    default:</span><br><span class="line">        print(&quot;default&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>return</p>
</li>
<li>throw</li>
<li><p>guard:提前退出，后面必须有一个else语句，else中必须包含控制转移语句<br><code>防止代码嵌套过多，if满足条件需要return时就可以用guard，相当于if let</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//只有numOfMyFriend &gt;0 的时候，才可以执行下面的程序。否则(else)就抛出一个异常。</span><br><span class="line">guard numOfMyFriend &gt; 0 else &#123;</span><br><span class="line">    throw errorGame.noFriendToGether</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>label标签语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">where labName&#123;</span><br><span class="line">    if()&#123;</span><br><span class="line">        break labName</span><br><span class="line">    &#125;else if()&#123;</span><br><span class="line">        continue labName</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        ///</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="检测API可用性"><a href="#检测API可用性" class="headerlink" title="检测API可用性"></a>检测API可用性</h2><p>*是必须的，用于指定在所有其它平台中，如果版本号高于你的设备指定的最低版本，if语句的代码块将会运行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if #available(iOS 10, macOS 10.12, *) &#123;</span><br><span class="line">// 在 iOS 使用 iOS 10 的 API, 在 macOS 使用 macOS 10.12 的 API</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// 使用先前版本的 iOS 和 macOS 的 API</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ul>
<li>swift中MARK的使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// MARK: - mark something</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="函数定义与调用"><a href="#函数定义与调用" class="headerlink" title="函数定义与调用"></a>函数定义与调用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func hello(name:String) -&gt; String&#123;</span><br><span class="line">    let str = &quot;Hello,&quot;+name+&quot;!&quot;;</span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br><span class="line">hello(name:&quot;Anna&quot;);</span><br></pre></td></tr></table></figure>
<h2 id="指定参数标签"><a href="#指定参数标签" class="headerlink" title="指定参数标签"></a>指定参数标签</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func someFunction(argumentLabel parameterName: Int) &#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="忽略参数标签"><a href="#忽略参数标签" class="headerlink" title="忽略参数标签"></a>忽略参数标签</h2><p>如果一个参数有一个标签，那么在调用的额是很好必须使用标签来标记这个参数，如果不希望为某个参数添加标签，可以使用<code>_</code>来代替一个明确的参数标签。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func hello(name:String) -&gt; String&#123;&#125;</span><br><span class="line">//调用 hello(name:&quot;Anna&quot;);</span><br><span class="line">func hello(_ name:String) -&gt; String&#123;&#125;</span><br><span class="line">//调用 hello(&quot;Anna&quot;);</span><br></pre></td></tr></table></figure></p>
<h2 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func someFunction(parameterWithoutDefault: Int, parameterWithDefault: Int = 12) &#123;</span><br><span class="line">// 如果你在调用时候不传第二个参数，parameterWithDefault 会值为 12 传入到函数体中。</span><br><span class="line">&#125;</span><br><span class="line">someFunction(parameterWithoutDefault: 4) // parameterWithDefault = 12</span><br></pre></td></tr></table></figure>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func getMiddle(_ numbers: Double...) -&gt; Double&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="输入输出参数"><a href="#输入输出参数" class="headerlink" title="输入输出参数"></a>输入输出参数</h2><blockquote>
<p>函数参数默认是常量。试图在函数体中更改参数值将会导致编译错误</p>
<ul>
<li>输入输出参数：可以在函数中修改的参数，并且这些修改在参数调用的时候仍然存在<br>只能传递变量给输入输出参数，不能传入常量或者字面量，并且在传入的时候在参数名前添加<code>&amp;</code>。</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T) &#123;</span><br><span class="line">    //可以不使用额外空间而使用多元组特性直接交换 a 和 b 的值</span><br><span class="line">    (a, b) = (b, a)</span><br><span class="line">&#125;</span><br><span class="line">var a = 5, b = 6</span><br><span class="line">swapTwoValues(&amp;a, &amp;b)</span><br><span class="line">print(a, b)</span><br></pre></td></tr></table></figure>
<h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><ul>
<li>可作为参数类型或返回值类型<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func calculate(x: Int,y: Int,method: (Int,Int)-&gt;Int) -&gt; Int&#123;</span><br><span class="line">return method(x,y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func add(x: Int,y: Int)-&gt;Int&#123;</span><br><span class="line">return x+y</span><br><span class="line">&#125;</span><br><span class="line">func multiply(x: Int,y: Int)-&gt;Int&#123;</span><br><span class="line">return x*y</span><br><span class="line">&#125;</span><br><span class="line">calculate(x: 3, y: 4, method: add)</span><br><span class="line">calculate(x: 3, y: 4, method: multiply)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int &#123;</span><br><span class="line">func stepForward(input: Int) -&gt; Int &#123; return input + 1 &#125;</span><br><span class="line">func stepBackward(input: Int) -&gt; Int &#123; return input - 1 &#125;</span><br><span class="line">return backward ? stepBackward : stepForward</span><br><span class="line">&#125;</span><br><span class="line">var currentValue = 4</span><br><span class="line">let moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)</span><br><span class="line">while currentValue != 0 &#123;</span><br><span class="line">print(&quot;\(currentValue)... &quot;)</span><br><span class="line">currentValue = moveNearerToZero(currentValue)</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;zero!&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><blockquote>
<p>把接受多个参数的方法变换成接受第一个参数的方法，并且返回接受余下的参数并且返回结果的新方法。</p>
</blockquote>
<!--
* 不使用柯里化
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func addTwoNumbers(a: Int, num: Int) -&gt; Int &#123;</span><br><span class="line">return a + num</span><br><span class="line">&#125;</span><br><span class="line">let result = addTwoNumbers(a:4, num: 6)</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">func greaterThan(comparator: Int, input: Int) -&gt; Bool &#123;</span><br><span class="line">return input &gt; comparator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let greaterThan10 = greaterThan(comparator: 10, input: 13)</span><br><span class="line">print(greaterThan10)</span><br><span class="line">let littleThan10 = greaterThan(comparator: 10, input: 9)</span><br><span class="line">print(littleThan10)</span><br></pre></td></tr></table></figure>
<ul>
<li>使用柯里化<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">func addTwoNumbers(a: Int)(num: Int) -&gt; Int &#123;</span><br><span class="line">return a + num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//等同于</span><br><span class="line">//func addTwoNumbers(a: Int)-&gt;((Int) -&gt; Int) &#123;</span><br><span class="line">//    func incrementor(num: Int) -&gt; Int &#123;</span><br><span class="line">//        return a + num</span><br><span class="line">//    &#125;</span><br><span class="line">//    return incrementor</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let addToFour = addTwoNumbers(a: 4)</span><br><span class="line">let result = addToFour(num: 6)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func greaterThan(comparator: Int)(input: Int) -&gt; Bool &#123;</span><br><span class="line">return input &gt; comparator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let greaterThan10 = greaterThan(comparator:10)</span><br><span class="line">greaterThan10(input: 13)    //true</span><br><span class="line">greaterThan10(input: 9)     //false</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>–&gt;</p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>闭包的三种形式：</p>
<ul>
<li>全局函数是一个有名字但不会捕获任何值的闭包</li>
<li>嵌套函数是一个有名字并可以捕获其封闭函数域内值的闭包</li>
<li>闭包表达式是一个利用轻量级语法所写的可以捕获其上下文中变量或常量值的匿名闭包<h2 id="闭包表达式"><a href="#闭包表达式" class="headerlink" title="闭包表达式"></a>闭包表达式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; (parameters) -&gt; returnType in</span><br><span class="line">statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>排序闭包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames = names.sorted(by: &#123; (s1: String, s2: String) -&gt; Bool in return s1 &gt; s2 &#125; )</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>排序闭包函数类型需为<code>(String, String) -&gt; Bool</code></p>
<ul>
<li>所有的参数和返回值类型都可以被正确推断，则返回箭头（-&gt;）和围绕在参数周围的括号也可以被省略<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames = names.sorted(by: &#123; s1, s2 in return s1 &gt; s2 &#125; )</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<ul>
<li><p>单表达式闭包隐式返回,可以省略 return 关键字，把语句的值作为结果返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames = names.sorted(by: &#123; s1, s2 in s1 &gt; s2 &#125; )</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以通过参数位置引用参数，通过 $0，$1来顺序调用闭包的参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames = names.sorted(by: &#123; $0 &gt; $1 &#125; )</span><br></pre></td></tr></table></figure>
</li>
<li><p>运算符方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames = names.sorted(by: &gt;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="尾随闭包"><a href="#尾随闭包" class="headerlink" title="尾随闭包"></a>尾随闭包</h2><ul>
<li>当一个闭包作为最后一个参数传给函数的时候，闭包可以直接跟在括号后面，不用写出参数标签</li>
<li>如果闭包是函数的唯一参数，则当使用尾随闭包时，可以把()省略掉<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames = names.sorted &#123; $0 &gt; $1 &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="值捕获"><a href="#值捕获" class="headerlink" title="值捕获"></a>值捕获</h2><ul>
<li>闭包可以在其被定义的上下文中捕获常量或变量。即使定义这些常量和变量的原作用域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。</li>
<li>Swift 中，可以捕获值的闭包的最简单形式是嵌套函数</li>
<li>如果一个值不会被闭包改变，或者在闭包创建后不会改变，Swift 可能会改为捕获并保存一份对值的拷贝。<blockquote>
<p>如果你将闭包赋值给一个类实例的属性，并且该闭包通过访问该实例或其成员而捕获了该实例，你将在闭包和该实例间创建一个循环强引用。Swift 使用捕获列表来打破这种循环强引用</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func add(num: Int)-&gt;(()-&gt;())&#123;</span><br><span class="line">    var sum = 0</span><br><span class="line">    func addNum()&#123;</span><br><span class="line">        sum+=num</span><br><span class="line">        print(sum)</span><br><span class="line">    &#125;</span><br><span class="line">    return addNum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = add(num: 10)</span><br><span class="line">a() //10</span><br><span class="line">a() //20</span><br><span class="line"></span><br><span class="line">var b = add(num: 8)</span><br><span class="line">b() //8</span><br><span class="line">b() //16</span><br><span class="line">a() //30</span><br></pre></td></tr></table></figure>
<h2 id="函数和闭包都是引用类型"><a href="#函数和闭包都是引用类型" class="headerlink" title="函数和闭包都是引用类型"></a>函数和闭包都是引用类型</h2><h2 id="逃逸闭包-escaping"><a href="#逃逸闭包-escaping" class="headerlink" title="逃逸闭包 @escaping"></a>逃逸闭包 @escaping</h2><ul>
<li>逃逸闭包：当一个闭包作为参数传到一个函数中，但是这个闭包在函数返回之后才被执行</li>
<li>如何逃逸：将闭包保存在一个函数外部定义的变量中，因为闭包需要在函数返回之后被调用<blockquote>
<p>将一个闭包标记为 @escaping 意味着必须在闭包中显式地引用 self，非逃逸闭包可以隐式引用self</p>
</blockquote>
</li>
</ul>
<h2 id="自动闭包-autoclosure"><a href="#自动闭包-autoclosure" class="headerlink" title="自动闭包 @autoclosure"></a>自动闭包 @autoclosure</h2><blockquote>
<p>自动闭包是一种自动创建的用来把作为实际参数传递给函数的表达式打包的闭包。它不接受任何实际参数，并且当它被调用时，它会返回内部打包的表达式的值。这个语法的好处在于通过写普通表达式代替显式闭包而使你省略包围函数形式参数的括号。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 在不使用autoclosure的情况下</span><br><span class="line">func logIfTrue(predicate: () -&gt; Bool) &#123;</span><br><span class="line">    if predicate() &#123;</span><br><span class="line">        print(&quot;True&quot;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        print(&quot;False&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 第一种调用方式</span><br><span class="line">logIfTrue &#123; () -&gt; Bool in</span><br><span class="line">    return 1 &gt; 2</span><br><span class="line">&#125;</span><br><span class="line">// 第二种调用方式</span><br><span class="line">logIfTrue&#123;return 1 &gt; 2&#125;</span><br><span class="line">// 第三种调用方式</span><br><span class="line">logIfTrue&#123;1 &gt; 2&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 使用autoclosure</span><br><span class="line">func logIfTrue( _ predicate: @autoclosure () -&gt; Bool) &#123;</span><br><span class="line">    if predicate() &#123;</span><br><span class="line">        print(&quot;True&quot;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        print(&quot;False&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 调用方式</span><br><span class="line">logIfTrue(2 &gt; 1)</span><br><span class="line">logIfTrue(1 &gt; 2)</span><br></pre></td></tr></table></figure>
<h1 id="枚举enum"><a href="#枚举enum" class="headerlink" title="枚举enum"></a>枚举enum</h1><h2 id="枚举语法"><a href="#枚举语法" class="headerlink" title="枚举语法"></a>枚举语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line">    case north</span><br><span class="line">    case south</span><br><span class="line">    case east</span><br><span class="line">    case west</span><br><span class="line">&#125;</span><br><span class="line">var d = Direction.west</span><br><span class="line">d = .west</span><br><span class="line"></span><br><span class="line">enum Direction&#123; case East,West,South,North &#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用-Switch-语句匹配枚举值，如果变量是枚举值，可省略枚举名，还可以在case中加上元组变量"><a href="#使用-Switch-语句匹配枚举值，如果变量是枚举值，可省略枚举名，还可以在case中加上元组变量" class="headerlink" title="使用 Switch 语句匹配枚举值，如果变量是枚举值，可省略枚举名，还可以在case中加上元组变量"></a>使用 Switch 语句匹配枚举值，如果变量是枚举值，可省略枚举名，还可以在case中加上元组变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">enum Direction&#123; case East,West,South,North &#125;</span><br><span class="line">var d = Direction.North</span><br><span class="line"></span><br><span class="line">switch d&#123;</span><br><span class="line">case Direction.East:</span><br><span class="line">print(&quot;east&quot;)</span><br><span class="line">case .West:</span><br><span class="line">print(&quot;wast&quot;)</span><br><span class="line">case .South:</span><br><span class="line">print(&quot;south&quot;)</span><br><span class="line">case .North:</span><br><span class="line">print(&quot;north&quot;)</span><br><span class="line">//default可省略，非枚举必须加default</span><br><span class="line">//default:</span><br><span class="line">//print(&quot;other&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">enum Direction&#123; case East,West,South,North,Other &#125;</span><br><span class="line">var d = Direction.North</span><br><span class="line"></span><br><span class="line">switch d&#123;</span><br><span class="line">case Direction.East:</span><br><span class="line">print(&quot;east&quot;)</span><br><span class="line">case .West:</span><br><span class="line">print(&quot;wast&quot;)</span><br><span class="line">case .South:</span><br><span class="line">print(&quot;south&quot;)</span><br><span class="line">case .North:</span><br><span class="line">print(&quot;north&quot;)</span><br><span class="line">//default不可省略</span><br><span class="line">default:</span><br><span class="line">print(&quot;other&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="原始值-rawValue"><a href="#原始值-rawValue" class="headerlink" title="原始值 rawValue"></a>原始值 rawValue</h2><p>当使用整数作为原始值时，如果第一个枚举成员没有设置原始值，其原始值将为0,隐式赋值的值依次递增1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//赋初始值，必须有类型说明</span><br><span class="line">enum Numbers:Int&#123;case A = 1, B, C&#125;</span><br><span class="line">print(Numbers.A.rawValue)</span><br><span class="line"></span><br><span class="line">enum Direction:String&#123;</span><br><span class="line">    case East = &quot;east&quot;</span><br><span class="line">    case West = &quot;west&quot;</span><br><span class="line">    case South = &quot;south&quot;</span><br><span class="line">    case North = &quot;north&quot;</span><br><span class="line">&#125;</span><br><span class="line">print(Direction.West.rawValue)</span><br></pre></td></tr></table></figure></p>
<h2 id="关联值：枚举成员可以是不同数据类型"><a href="#关联值：枚举成员可以是不同数据类型" class="headerlink" title="关联值：枚举成员可以是不同数据类型"></a>关联值：枚举成员可以是不同数据类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum State&#123;</span><br><span class="line">case Status1(Int,String)</span><br><span class="line">case Status2(String,String)</span><br><span class="line">&#125;</span><br><span class="line">var s = State.Status1(404,&quot;page not found&quot;)</span><br></pre></td></tr></table></figure>
<h1 id="类和结构体"><a href="#类和结构体" class="headerlink" title="类和结构体"></a>类和结构体</h1><h2 id="类和结构体对比"><a href="#类和结构体对比" class="headerlink" title="类和结构体对比"></a>类和结构体对比</h2><p>相同点：</p>
<ul>
<li>定义属性用于存储值</li>
<li>定义方法用于提供功能</li>
<li>定义下标操作使得可以通过下标语法来访问实例所包含的值</li>
<li>定义构造器用于生成初始化值</li>
<li>通过扩展以增加默认实现的功能</li>
<li>实现协议以提供某种标准功能<br>类的不同点：</li>
<li>继承允许一个类继承另一个类的特征</li>
<li>类型转换允许在运行时检查和解释一个类实例的类型</li>
<li>析构器允许一个类实例释放任何其所被分配的资源</li>
<li><p>引用计数允许对一个类的多次引用</p>
</li>
<li><p>定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class SomeClass &#123;</span><br><span class="line">// 在这里定义类</span><br><span class="line">&#125;</span><br><span class="line">struct SomeStructure &#123;</span><br><span class="line">// 在这里定义结构体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结构体类型的成员逐一构造器，类实例没有默认构造函数，类中的属性必须初始化或设为可选（属性加！或？，或者写init方法）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Dog &#123;</span><br><span class="line"></span><br><span class="line">var name: String!</span><br><span class="line">var age :Int!</span><br><span class="line">init()&#123;</span><br><span class="line">name = &quot;hua hua&quot;</span><br><span class="line">age = 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func show()&#123;</span><br><span class="line">print(&quot;\(name!):\(age!)&quot;)   //解析</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var d1 = Dog()</span><br><span class="line">d1.show()</span><br><span class="line">d1.name = &quot;xiao hei&quot;</span><br><span class="line">d1.age = 3</span><br><span class="line">d1.show()</span><br><span class="line"></span><br><span class="line">print(d1 === d2)    //是否是同一对象:true</span><br><span class="line">var d3 = Dog()</span><br><span class="line">print(d1 === d3)    //是否是同一对象:false</span><br></pre></td></tr></table></figure>
</li>
<li><p>结构体和枚举是值类型，函数和闭包是引用类型</p>
<blockquote>
<p>值类型：被赋予给一个变量、常量或者被传递给一个函数的时候，其值会被拷贝。<br>引用类型：在被赋予到一个变量、常量或者被传递到一个函数时，其值不会被拷贝。因此，引用的是已存在的实例本身而不是其拷贝。实际是同一个。<br>结构体和枚举类型都是值类型。这意味着它们的实例，以及实例中所包含的任何值类型属性，在代码中传递的时候都会被复制。两者相互独立，是不同的。<br>在 Swift 中，Integer、floating-point、Boolean、string、array、dictionary 都是值类型，并且在底层都是以结构体的形式所实现。</p>
</blockquote>
</li>
<li><p>恒等运算符（===/!==）：判定两个常量或者变量是否引用同一个类实例</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">//结构体</span><br><span class="line">struct Point &#123;</span><br><span class="line">var x: Int</span><br><span class="line">var y: Int</span><br><span class="line">&#125;</span><br><span class="line">var p1 = Point(x: 10, y: 20)</span><br><span class="line">var p2 = p1</span><br><span class="line">print(&quot;\(p1.x):\(p1.y)&quot;)</span><br><span class="line">print(&quot;\(p2.x):\(p2.y)&quot;)</span><br><span class="line">p1.x = 100</span><br><span class="line">p1.y = 200</span><br><span class="line">print(&quot;\(p1.x):\(p1.y)&quot;)</span><br><span class="line">print(&quot;\(p2.x):\(p2.y)&quot;)</span><br><span class="line"></span><br><span class="line">//枚举</span><br><span class="line">enum Direction&#123;case East,West,North,South&#125;</span><br><span class="line">var direction1 = Direction.East</span><br><span class="line">var direction2 = direction1</span><br><span class="line">print(&quot;\(direction1)&quot;)</span><br><span class="line">print(&quot;\(direction2)&quot;)</span><br><span class="line">direction1 = .West</span><br><span class="line">print(&quot;\(direction1)&quot;)</span><br><span class="line">print(&quot;\(direction2)&quot;)</span><br><span class="line"></span><br><span class="line">//类</span><br><span class="line">class Dog &#123;</span><br><span class="line"></span><br><span class="line">var name: String!</span><br><span class="line">var age: Int!</span><br><span class="line">init()&#123;</span><br><span class="line"></span><br><span class="line">name = &quot;hua hua&quot;</span><br><span class="line">age = 2</span><br><span class="line">&#125;</span><br><span class="line">func show()&#123;</span><br><span class="line">print(&quot;\(name):\(age)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var d1 = Dog()</span><br><span class="line">var d2 = d1</span><br><span class="line">d1.show()</span><br><span class="line">d2.show()</span><br><span class="line">d1.name = &quot;xiao hei&quot;</span><br><span class="line">d1.age = 3</span><br><span class="line">d1.show()</span><br><span class="line">d2.show()</span><br></pre></td></tr></table></figure>
<h2 id="类和结构体的选择"><a href="#类和结构体的选择" class="headerlink" title="类和结构体的选择"></a>类和结构体的选择</h2><p>大部分使用类，以下情形考虑构建结构体：</p>
<ul>
<li>目的是用来封装少量相关简单数据值。</li>
<li>实例在被赋值或传递时，封装的数据将会被拷贝而不是被引用。</li>
<li>储存的值类型属性，也应该被拷贝，而不是被引用。</li>
<li>不需要去继承另一个既有类型的属性或者行为。</li>
</ul>
<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p><code>存储属性只能用于类和结构体，计算属性可以用于类、结构体和枚举。</code></p>
<h2 id="存储属性"><a href="#存储属性" class="headerlink" title="存储属性"></a>存储属性</h2><ul>
<li>定义：存储在特定类或结构体实例里的一个常量或变量，保存单个类型的变量。</li>
<li><code>所有类的存储属性——包括从它的父类继承的所有属性——都必须在初始化期间分配初始值。</code></li>
<li>常量结构体的存储属性：如果创建了一个结构体的实例并将其赋值给一个常量，则无法修改该实例的任何属性，即使有属性被声明为变量也不行(由于结构体（struct）属于值类型。<code>当值类型的实例被声明为常量的时候，它的所有属性也就成了常量</code>。属于引用类型的类（class）则不一样，<code>把一个引用类型的实例赋给一个常量后，仍然可以修改该实例的变量属性</code>。)</li>
<li>延迟存储属性lazy<ul>
<li>定义：在第一次被访问的时候创建</li>
<li>一般用于：<ul>
<li>延迟对象的创建</li>
<li>当属性的值依赖于其他未知类</li>
</ul>
</li>
<li>必须将延迟存储属性声明成变量（使用 var 关键字），而常量属性在构造过程完成之前必须要有初始值，因此无法声明成延迟属性</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//1)类中的属性必须初始化或设为可选</span><br><span class="line">class Dog &#123;</span><br><span class="line">var name: String!</span><br><span class="line">var age: Int!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//2）常量结构体的存储属性</span><br><span class="line">struct Point &#123;</span><br><span class="line">var x: Int</span><br><span class="line">var y: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p1 = Point(x: 1, y: 2)</span><br><span class="line">//结构体常量对象不可以进行修改</span><br><span class="line">//p1.x = 100</span><br><span class="line">//p1.y = 200</span><br><span class="line"></span><br><span class="line">3）延迟存储属性 lazy：调用时才进行构造</span><br><span class="line">class A &#123;</span><br><span class="line">init()&#123;</span><br><span class="line">print(&quot;A init&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func f1()&#123;</span><br><span class="line">print(&quot;f1...&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">lazy var a: A = A()</span><br><span class="line">init()&#123;</span><br><span class="line">print(&quot;B init&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var b = B()</span><br><span class="line">//调用时A才进行构造</span><br><span class="line">print(b.a.f1())</span><br></pre></td></tr></table></figure>
<h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><ul>
<li>定义：计算属性不直接存储值，而是提供一个 getter 和一个可选的 setter，来间接获取和设置其他属性或变量的值。</li>
<li>新值的参数名默认为newValue</li>
<li>只读计算属性的声明可以去掉get关键字和花括号，直接return<blockquote>
<p>必须使用var定义计算属性，包括只读计算属性</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">struct Rect &#123;</span><br><span class="line">    var w: Double</span><br><span class="line">    var h: Double</span><br><span class="line"></span><br><span class="line">    var circle: Double&#123;</span><br><span class="line">        get&#123;</span><br><span class="line">            print(&quot;get...&quot;)</span><br><span class="line">            return (w+h)*2</span><br><span class="line">        &#125;</span><br><span class="line">        set&#123;</span><br><span class="line">            //默认newValue，oldValue</span><br><span class="line">            //newValue就是circle</span><br><span class="line">            w = newValue/2</span><br><span class="line">            h = newValue/2</span><br><span class="line">            print(&quot;newValue=\(newValue)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var r = Rect(w: 30, h: 20)</span><br><span class="line">print(r.circle)</span><br><span class="line">r.circle = 200</span><br><span class="line">print(r.circle)</span><br></pre></td></tr></table></figure>
<h2 id="属性观察器"><a href="#属性观察器" class="headerlink" title="属性观察器"></a>属性观察器</h2><ul>
<li>属性被设置值的时候会调用属性观察器（即使新值与当前值相同）</li>
<li>可添加观察器的情况：<ul>
<li>定义的存储属性（除延迟存储属性之外）</li>
<li>从父类继承的存储属性或计算属性（通过重写属性的方式），不需要为无法重载的计算属性添加属性观察器，因为可以通过setter直接监控和响应值的变化</li>
</ul>
</li>
<li>willSet：传入新属性值，默认为newValue，常量参数</li>
<li>didSet：传入旧属性值，默认为oldValue</li>
<li>willSet和didSet在属性初始化过程中不会被调用</li>
<li>继承：<ul>
<li>父类属性在子类的构造器中赋值，会先调用父类观察器，再调用子类观察器。</li>
<li>在父类初始化方法调用之前，子类给属性赋值时，不会调用观察器方法。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    var age: Int = 1&#123;</span><br><span class="line"></span><br><span class="line">        //可以不加newValue:willSet(newValue)</span><br><span class="line">        willSet&#123;</span><br><span class="line">            print(&quot;newValue:\(newValue)&quot;)</span><br><span class="line">            //保护属性</span><br><span class="line">            if newValue &lt;= 0 &#123;</span><br><span class="line">                print(&quot;非法年龄！&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //必须加newValue</span><br><span class="line">        didSet(newValue)&#123;</span><br><span class="line">            print(&quot;newValue:\(newValue)&quot;)</span><br><span class="line">            print(&quot;didSet&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var a = Animal()</span><br><span class="line">print(a.age)    //1</span><br><span class="line">a.age = -1</span><br><span class="line">print(a.age)    //-1</span><br></pre></td></tr></table></figure>
<h2 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h2><ul>
<li>都属于存储型变量，跟存储属性类似。</li>
<li>都可以定义计算型变量和为存储型变量定义观察器，与计算属性类似。</li>
<li>全局变量或常量都是延迟计算的，与延迟存储属性相似，不需要声明lazy。局部变量或常量从不延迟计算。</li>
</ul>
<h2 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct Structname &#123;</span><br><span class="line">    static var storedTypeProperty = &quot; &quot;</span><br><span class="line">    static var computedTypeProperty: Int &#123;</span><br><span class="line">    // 这里返回一个 Int 值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum Enumname &#123;</span><br><span class="line">    static var storedTypeProperty = &quot; &quot;</span><br><span class="line">    static var computedTypeProperty: Int &#123;</span><br><span class="line">    // 这里返回一个 Int 值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Classname &#123;</span><br><span class="line">    class var computedTypeProperty: Int &#123;</span><br><span class="line">    // 这里返回一个 Int 值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>存储型类型属性可以是变量或常量，计算型类型属性跟实例的计算型属性一样只能定义成变量属性（计算型属性只能声明为变量）。</li>
<li>在为类定义<code>计算型类型属性</code>时，可以改用关键字 <code>class</code> 来支持子类对父类的实现进行重写。</li>
</ul>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><ul>
<li>类、结构体、枚举都可以定义实例方法，也可以定义类型方法。</li>
<li>self<ul>
<li>在一个方法中使用一个已知的属性或者方法名称，可省略self。</li>
<li>实例方法的某个参数名称与实例的某个属性名称相同的时候，参数名称享有优先权，可以使用self属性来区分参数名称和属性名称。</li>
</ul>
</li>
<li>变异mutating<ul>
<li>结构体和枚举是值类型，值类型属性不能在实例方法中被修改，在实例方法中修改值类型：mutating，修改后的值会一直保留</li>
<li>赋给隐含属性self一个全新的实例，新实例在方法结束后将替换原来的实例</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">struct Area &#123;</span><br><span class="line">    var length = 1</span><br><span class="line">    var breadth = 1</span><br><span class="line"></span><br><span class="line">    func area() -&gt; Int &#123;</span><br><span class="line">        return length * breadth</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutating func scaleBy(res: Int) &#123;</span><br><span class="line">        self.length *= res</span><br><span class="line">        self.breadth *= res</span><br><span class="line">        print(length)</span><br><span class="line">        print(breadth)</span><br><span class="line"></span><br><span class="line">        //只有在变异方法中才可以给self赋值</span><br><span class="line">        //self = Area(length:self.length*res, breadth:self.breadth*res)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//若实例对象为let,不可修改</span><br><span class="line">var val = Area(length: 3, breadth: 5)</span><br><span class="line">val.scaleBy(res: 13)</span><br><span class="line">print(&quot;\(val.length)---\(val.breadth)&quot;)</span><br></pre></td></tr></table></figure>
<ul>
<li>类型方法：类型方法的方法体中，self指向这个类型本身，而不是类型的某个实例<ul>
<li>静态方法只能访问静态方法和属性</li>
<li>实例方法可以访问实例方法和属性，通过类型调用静态方法和属性</li>
<li>用class修饰的方法可以被子类覆盖（重写）</li>
<li>在方法func关键字之前加上关键字<code>static</code>来指定类型方法，类还可以用关键字<code>class</code>来允许子类重写父类的方法实现</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">    var v1: Int!</span><br><span class="line">    var s1: String!</span><br><span class="line">    static var ss1: String!</span><br><span class="line">    class func f1()&#123;</span><br><span class="line">        print(&quot;static f1&quot;)</span><br><span class="line"></span><br><span class="line">        //***静态方法只能访问静态方法和属性</span><br><span class="line">        ss1 = &quot;hello&quot;</span><br><span class="line">        //        v1 = 1</span><br><span class="line">        //        f2()</span><br><span class="line">    &#125;</span><br><span class="line">    func f2()&#123;</span><br><span class="line">        print(&quot;f2&quot;)</span><br><span class="line"></span><br><span class="line">        //***实例方法可以访问实例方法和属性，通过类型调用静态方法和属性</span><br><span class="line">        MyClass.ss1 = &quot;world&quot;</span><br><span class="line">        MyClass.f1()</span><br><span class="line">    &#125;</span><br><span class="line">    //用class修饰的方法可以被子类覆盖（重写）</span><br><span class="line">    class func f3() &#123;</span><br><span class="line">        print(&quot;class f3&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MySubClass: MyClass &#123;</span><br><span class="line">    //override class：重写   f2不可重写</span><br><span class="line">    override class func f3()&#123;</span><br><span class="line">        print(&quot;override f3...&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass.ss1 = &quot;static ss1&quot;</span><br><span class="line">print(MyClass.ss1)</span><br><span class="line">MyClass.f1()</span><br><span class="line"></span><br><span class="line">MyClass.f3()</span><br><span class="line">MySubClass.f3()</span><br></pre></td></tr></table></figure>
<h1 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h1><p>可以定义在类，结构体，枚举中，是访问对象、集合、序列的快捷方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">subscript(index: Int) -&gt; Int &#123;</span><br><span class="line">get &#123;</span><br><span class="line">// 返回一个适当的 Int 类型的值</span><br><span class="line">&#125;</span><br><span class="line">set(newValue) &#123;</span><br><span class="line">// 执行适当的赋值操作</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>下标脚本类似于实例方法((Int)-&gt;Int)和计算型属性（set,get）的混合</li>
<li>可以读写或只读</li>
<li>newValue的类型和下标的返回类型相同，默认newValue<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">struct Matrix &#123;</span><br><span class="line">    let rows: Int,columns: Int</span><br><span class="line">    var grid: [Double]</span><br><span class="line">    init(rows: Int,columns: Int)&#123;</span><br><span class="line">        self.rows = rows</span><br><span class="line">        self.columns = columns</span><br><span class="line">        grid = Array(repeatElement(5.0, count: rows*columns))</span><br><span class="line">    &#125;</span><br><span class="line">    func indexIsValidForRow(row: Int,column: Int)-&gt;Bool&#123;</span><br><span class="line">        return row &gt;= 0 &amp;&amp; column &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; column &lt; columns</span><br><span class="line">    &#125;</span><br><span class="line">    subscript(row: Int,column: Int)-&gt;Double&#123;</span><br><span class="line">        get&#123;</span><br><span class="line">            print(&quot;get...\((row*columns)+column)&quot;)</span><br><span class="line">            assert(indexIsValidForRow(row: row, column: column), &quot;Index out of range&quot;)</span><br><span class="line">            return grid[(row*columns)+column]</span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            print(&quot;set...\((row*columns)+column)&quot;)</span><br><span class="line">            assert(indexIsValidForRow(row: row, column: column), &quot;Index out of range&quot;)</span><br><span class="line">            grid[(row*columns)+column] = newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var matr = Matrix(rows: 6, columns: 6)</span><br><span class="line">print(matr.grid)</span><br><span class="line">print(matr[5,5])</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="基类"><a href="#基类" class="headerlink" title="基类"></a>基类</h2><ul>
<li>如果你不为你定义的类指定一个超类的话，这个类就自动成为基类。</li>
</ul>
<h2 id="重写override"><a href="#重写override" class="headerlink" title="重写override"></a>重写override</h2><ul>
<li>可以重写继承来的实例方法、类方法、实例属性、类型属性，自定义getter和setter或添加属性观察器（可重写计算属性，方法，存储属性不可重写，可重写属性观察器）</li>
<li>重写属性的getter或setter<ul>
<li>可以为任意继承来的属性（存储属性或计算属性）自定义getter或setter</li>
<li>可以将继承来的只读属性重写为读写属性，但是不能将继承来的读写属性重写为只读属性。</li>
<li>如果在重写属性中提供了 setter，那么一定要提供 getter，如果不修改可以调用super方法</li>
</ul>
</li>
<li>重写属性观察器<ul>
<li>不可以为继承来的常量存储属性或只读计算属性添加属性观察器，因为这些属性的值是不可以修改的</li>
<li>不可以同时重写setter和属性观察器，因为在setter中就可以观察到任何值的变化</li>
</ul>
</li>
<li>防止重写 final<ul>
<li>final var,final func,final class fun,final subscript</li>
<li>final class 声明的类不能被继承</li>
</ul>
</li>
</ul>
<h1 id="构造过程"><a href="#构造过程" class="headerlink" title="构造过程"></a>构造过程</h1><ul>
<li>没有返回值</li>
<li>用于类、结构体或枚举<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init() &#123;</span><br><span class="line">// 在此处执行构造过程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="默认属性值"><a href="#默认属性值" class="headerlink" title="默认属性值"></a>默认属性值</h2><ul>
<li>如果一个属性总是使用相同的初始值，为其设置默认值比每次在构造器中赋值要好。</li>
</ul>
<h2 id="存储属性的初始赋值"><a href="#存储属性的初始赋值" class="headerlink" title="存储属性的初始赋值"></a>存储属性的初始赋值</h2><ul>
<li>存储属性在构造器中赋值时，它们的值是被直接设置的，不会触发任何属性观察器。</li>
<li><p>存储属性在构造器中赋值流程</p>
<ul>
<li>创建初始值</li>
<li>在属性定义中指定默认属性值</li>
<li>初始化实例，并调用init()方法</li>
</ul>
</li>
<li><p>可选属性类型：当存储属性声明为可选时，将自动初始化为空 nil</p>
</li>
<li>修改常量属性：<code>在init里可以对let的实例常量进行赋值</code>，可以在构造过程中的任意时间点给常量属性指定一个值，但是它的常量属性只能在定义它的类的构造过程中修改；不能在子类中修改</li>
<li>外部参数名：Swift 会为每个构造器的参数自动生成一个跟内部名字相同的外部名，如果不想提供外部名称可以使用下划线(_)来显式描述它的外部名</li>
<li>默认构造器：如果结构体或类的所有属性都有默认值，且它是没有父类的基类，同时没有自定义的构造器，swift会自动提供默认构造器，默认构造器将简单的创建一个所有属性值都设置为默认值的实例</li>
<li>逐一成员构造器：结构体自动获得一个逐一成员构造器</li>
<li>构造器代理规则<ul>
<li>值类型：不支持继承，可以使用self.init在自定义的构造器中引用其它的属于相同值类型的构造器</li>
<li>类类型：支持集成，类有责任保证其所有继承的存储型属性在构造时也能正确的初始化</li>
</ul>
</li>
</ul>
<h2 id="类的继承和构造过程"><a href="#类的继承和构造过程" class="headerlink" title="类的继承和构造过程"></a>类的继承和构造过程</h2><ul>
<li>类里面的所有存储型属性——包括所有继承自父类的属性——都必须在构造过程中设置初始值，可以通过指定构造器或便利构造器实现。<h3 id="指定构造器-designated"><a href="#指定构造器-designated" class="headerlink" title="指定构造器 designated"></a>指定构造器 designated</h3></li>
<li>初始化类中提供的所有属性，并根据父类链往上调用父类的构造器来实现父类的初始化，每一个类都必须拥有至少一个指定构造器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init(parameters) &#123;</span><br><span class="line">statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="便利构造器-convenience"><a href="#便利构造器-convenience" class="headerlink" title="便利构造器 convenience"></a>便利构造器 convenience</h3><ul>
<li>便利构造器可以调用同一个类中的指定构造器，并为其参数提供默认值，必要时创建。</li>
<li><code>convenience 的初始化方法是不能被子类重写或者从子类中以 super 的方式被调用的。</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">convenience init(parameters) &#123;</span><br><span class="line">statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="构造器的继承和重载：当重写一个父类指定构造器时，子类不会默认继承父类的构造器，需要写override，override-convenience"><a href="#构造器的继承和重载：当重写一个父类指定构造器时，子类不会默认继承父类的构造器，需要写override，override-convenience" class="headerlink" title="构造器的继承和重载：当重写一个父类指定构造器时，子类不会默认继承父类的构造器，需要写override，override convenience"></a>构造器的继承和重载：当重写一个父类指定构造器时，子类不会默认继承父类的构造器，需要写override，<code>override convenience</code></h3><h3 id="初始化方法的顺序"><a href="#初始化方法的顺序" class="headerlink" title="初始化方法的顺序"></a>初始化方法的顺序</h3><ul>
<li>设置子类自己需要初始化的参数</li>
<li>调用父类相应的初始化方法，<code>super.init()</code></li>
<li>对父类中需要改变的成员进行设定<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    var name: String?</span><br><span class="line">    init() &#123;</span><br><span class="line">        name = &quot;Animal&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let animal = Animal()</span><br><span class="line">print(animal.name!)</span><br><span class="line"></span><br><span class="line">class Dog: Animal &#123;</span><br><span class="line">    let age: Int</span><br><span class="line">    override init() &#123;</span><br><span class="line">        age = 10</span><br><span class="line">        // 如果不先把子类的成员初始化完成，下面就无法调用父类的初始化方法会报错,Swift 会自动的对父类的对应 init 方法进行调用</span><br><span class="line">        super.init() // Property &apos;self.age&apos; not initialized at super.init call</span><br><span class="line">        name = &quot;a dog&quot;  // 根据实际情况修改，如果不需要改变父类属性的话，可以不写</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">print(Dog().name!)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="初始化方法需要遵循的两个原则"><a href="#初始化方法需要遵循的两个原则" class="headerlink" title="初始化方法需要遵循的两个原则"></a>初始化方法需要遵循的两个原则</h3><ul>
<li>初始化路径必须保证对象<code>完全初始化</code>，这可以通过调用本类型的 designated 初始化方法得到保证。</li>
<li>子类的 designated 初始化方法<code>必须调用父类的 designated 方法</code>，以保证<code>父类成员也完成初始化</code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class ClassAA &#123;</span><br><span class="line">let numA: Int</span><br><span class="line">init(num: Int) &#123;</span><br><span class="line">numA = num</span><br><span class="line">&#125;</span><br><span class="line">convenience init(bigNum: Bool) &#123;</span><br><span class="line">self.init(num: bigNum ? 10000 : 1) // 所有的 convenience 初始化方法都必须调用同一个类中的 designated 初始化完成设置</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ClassBB: ClassAA &#123;</span><br><span class="line">let numB: Int</span><br><span class="line">override init(num: Int) &#123;</span><br><span class="line">numB = num + 1</span><br><span class="line">//只要在子类中实现重写了父类 convenience 方法所需要的 init 方法的话，我们在子类中就可以使用父类的 convenience 初始化方法了</span><br><span class="line">super.init(num: num)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let anObj = ClassBB(bigNum: true)</span><br><span class="line">print(anObj.numA, anObj.numB)</span><br></pre></td></tr></table></figure>
<h3 id="required"><a href="#required" class="headerlink" title="required"></a>required</h3><ul>
<li>对于某些我们希望子类中一定实现的 designated 初始化方法，我们可以通过添加<code>required</code>关键字进行限制，强制子类对这个方法重写实现。这样做的最大的好处是可以保证依赖于某个 designated 初始化方法的 convenience 一直可以被使用。</li>
<li>如果希望初始化方法对于子类一定可用，就将 init(num: Int) 声明为必须。对于 convenience 的初始化方法我们也可以加上 required 以确保子类对其进行实现。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class ClassAAA &#123;</span><br><span class="line">let numA: Int</span><br><span class="line">required init(num: Int) &#123;</span><br><span class="line">numA = num</span><br><span class="line">&#125;</span><br><span class="line">required convenience init(bigNum: Bool) &#123;</span><br><span class="line">self.init(num: bigNum ? 10000 : 1)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class ClassBBB: ClassAAA &#123;</span><br><span class="line">let numB: Int</span><br><span class="line">required init(num: Int) &#123;</span><br><span class="line">numB = num + 1</span><br><span class="line">super.init(num: num)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let sencondObj = ClassBBB(bigNum: true)</span><br><span class="line">print(sencondObj.numA, sencondObj.numB)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="可失败构造器（init-init-）"><a href="#可失败构造器（init-init-）" class="headerlink" title="可失败构造器（init?,init!）"></a>可失败构造器（init?,init!）</h2><ul>
<li>非可失败构造器（init），可失败构造器（init?），隐式解包可失败构造器（init!）</li>
<li>可失败构造器：可失败构造器会创建一个类型为自身的可选类型的对象，在init关键字后面添加问号(init?)，通过<code>return nil</code>来表明可失败构造器在何种情况下应该失败。</li>
<li>可失败构造器的参数名和参数类型，<code>不能与其它非可失败构造器的参数名，及其参数类型相同</code>。</li>
<li>变量初始化失败可能的原因有：<ul>
<li>传入无效的参数值</li>
<li>缺少某种所需的外部资源</li>
<li>没有满足特定条件</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct Animal &#123;</span><br><span class="line">    let species: String</span><br><span class="line">    init?(species: String) &#123;</span><br><span class="line">    if species.isEmpty &#123; return nil &#125;</span><br><span class="line">        self.species = species</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>枚举类型的可失败构造器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">enum TemperatureUnit &#123;</span><br><span class="line">    // 开尔文，摄氏，华氏</span><br><span class="line">    case Kelvin, Celsius, Fahrenheit</span><br><span class="line">    init?(symbol: Character) &#123;</span><br><span class="line">        switch symbol &#123;</span><br><span class="line">            case &quot;K&quot;:</span><br><span class="line">            self = .Kelvin</span><br><span class="line">            case &quot;C&quot;:</span><br><span class="line">            self = .Celsius</span><br><span class="line">            case &quot;F&quot;:</span><br><span class="line">            self = .Fahrenheit</span><br><span class="line">            default:</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>何时触发：值类型的可失败构造器何时触发没有限制，类的可失败构造器只能在所有的类属性被初始化后和所有类之间的代理调用发生完后触发失败行为</p>
</li>
<li>覆盖一个可失败构造器：可以用子类的可失败构造器或非失败构造器覆盖基类的可失败构造器</li>
<li>但一个非失败构造器永远不能代理调用一个可失败构造器</li>
<li>init!<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct StudRecord &#123;</span><br><span class="line">    let stname: String</span><br><span class="line"></span><br><span class="line">    init!(stname: String) &#123;</span><br><span class="line">    if stname.isEmpty &#123;return nil &#125;</span><br><span class="line">    self.stname = stname</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let stmark = StudRecord(stname: &quot;Runoob&quot;)</span><br><span class="line">if let name = stmark &#123;</span><br><span class="line">    print(&quot;指定了学生名&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let blankname = StudRecord(stname: &quot;&quot;)</span><br><span class="line">if blankname == nil &#123;</span><br><span class="line">    print(&quot;学生名为空&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="类的构造器代理规则"><a href="#类的构造器代理规则" class="headerlink" title="类的构造器代理规则"></a>类的构造器代理规则</h2><ul>
<li>指定构造器必须调用其直接父类的指定构造器</li>
<li>便利构造器必须调用其同类定义的其他构造器</li>
<li>便利构造器必须最终导致一个指定构造器被调用<blockquote>
<p>指定构造器向上代理，便利构造器横向代理</p>
</blockquote>
</li>
</ul>
<h2 id="两段式构造过程"><a href="#两段式构造过程" class="headerlink" title="两段式构造过程"></a>两段式构造过程</h2><ul>
<li>安全检查1<br>指定构造器必须保证它所在类引入的所有属性都必须先初始化完成，之后才能将其它构造任务向上代理给父类中的构造器。</li>
<li>安全检查2<br>指定构造器必须先向上代理调用父类构造器，然后再为继承的属性设置新值。</li>
<li>安全检查3<br>便利构造器必须先代理调用同一类中的其它构造器，然后再为任意属性赋新值。</li>
<li>安全检查4<br>构造器在第一阶段构造完成之前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用self作为一个值。</li>
</ul>
<h1 id="析构过程"><a href="#析构过程" class="headerlink" title="析构过程"></a>析构过程</h1><p>*<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deinit &#123;</span><br><span class="line">// 执行析构过程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="自动引用计数"><a href="#自动引用计数" class="headerlink" title="自动引用计数"></a>自动引用计数</h1><blockquote>
<p>引用计数仅仅应用于类的实例。结构体和枚举类型是值类型。</p>
</blockquote>
<h2 id="类实例之间的循环强引用"><a href="#类实例之间的循环强引用" class="headerlink" title="类实例之间的循环强引用"></a>类实例之间的循环强引用</h2><h3 id="弱引用-weak"><a href="#弱引用-weak" class="headerlink" title="弱引用 weak"></a>弱引用 weak</h3><ul>
<li>当 ARC 设置弱引用为nil时，属性观察不会被触发</li>
</ul>
<p>1.与OC类似的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">weak var weakSelf = self</span><br><span class="line">loadData&#123;</span><br><span class="line">print(&quot;\(weakSelf?.view)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.swift推荐的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loadData&#123; [weak self] in</span><br><span class="line">print(&quot;\(self?.view)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="无主引用-unowned"><a href="#无主引用-unowned" class="headerlink" title="无主引用 unowned"></a>无主引用 unowned</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loadData&#123; [unowned self] in</span><br><span class="line">print(&quot;\(self.view)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="循环引用总结"><a href="#循环引用总结" class="headerlink" title="循环引用总结"></a>循环引用总结</h3><ul>
<li><code>对于生命周期中会变为nil的实例使用弱引用。相反的，对于初始化赋值后再也不会被赋值为nil的实例，使用无主引用。</code> 当其他的实例有更短的生命周期时，使用弱引用(当其他实例析构在先)，当其他实例有相同的或者更长生命周期时，请使用无主引用</li>
<li>swift<ul>
<li><code>[weak self]</code>：self是可选项，如果self已经被释放，则为nil</li>
<li><code>[unowned self]</code>：self不是可选项，如果self已经被释放，则为野指针访问，使用无主引用，必须确保引用始终指向一个未销毁的实例</li>
</ul>
</li>
<li>Objc<ul>
<li><code>__weak typeof(self) weakSelf;</code>：如果self已经被释放，则为nil</li>
<li><code>__unsafe_unretained typeof(self) weakSelf;</code>：如果self已经被释放，则为野指针访问</li>
</ul>
</li>
</ul>
<h2 id="闭包引起的循环强引用"><a href="#闭包引起的循环强引用" class="headerlink" title="闭包引起的循环强引用"></a>闭包引起的循环强引用</h2><blockquote>
<p>解决闭包引起的循环强引用:闭包捕获列表，在定义闭包时同时定义捕获列表作为闭包的一部分</p>
</blockquote>
<ul>
<li>当闭包和捕获的实例总是互相引用时并且总是<code>同时销毁</code>时，将闭包内的捕获定义为<code>无主引用</code>。<br>相反的，当捕获引用有时<code>可能会是nil</code>时，将闭包内的捕获定义为<code>弱引用</code>。<br>如果捕获的引用<code>绝对不会置为nil</code>，应该用<code>无主引用</code>，而不是弱引用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lazy var someClosure: (Int, String) -&gt; String = &#123;</span><br><span class="line">[unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -&gt; String in</span><br><span class="line">// 这里是闭包的函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="可选链"><a href="#可选链" class="headerlink" title="可选链"></a>可选链</h1><blockquote>
<p>可以应用于任意类型，并且能检查调用是否成功。<br><code>多次请求或调用可以被链接成一个链，如果任意一个节点为nil将导致整条链失效</code></p>
</blockquote>
<ul>
<li>通过可选链访问属性，返回两个值：<ul>
<li>如果目标有值，调用成功，返回该值</li>
<li>如果目标为nil，调用返回nil</li>
</ul>
</li>
<li><p>通过可选链调用方法，返回两个值：</p>
<ul>
<li>如果调用成功，返回Void</li>
<li>如果没有称，返回nil</li>
</ul>
</li>
<li><p>可选链可代替强制解析：</p>
<ul>
<li>?：当可选为nil，输出预定的错误信息</li>
<li>! ：当可选为nil，强制展开执行错误</li>
</ul>
</li>
<li><p>连接多层可选链：如果试图通过可选链获得Int值，不论使用了多少层链接返回的总是Int?。</p>
</li>
<li>可以通过可选链调用返回为可空值的方法，并且可以继续对可选值进行链接。</li>
</ul>
<h1 id="错误处理-1"><a href="#错误处理-1" class="headerlink" title="错误处理"></a>错误处理</h1><h2 id="表示并抛出错误-throw"><a href="#表示并抛出错误-throw" class="headerlink" title="表示并抛出错误(throw)"></a>表示并抛出错误(throw)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//枚举构建一组相关的错误状态，枚举的关联值还可以提供错误状态的额外信息</span><br><span class="line">enum VendingMachineError: Error &#123;</span><br><span class="line">case invalidSelection                    //选择无效</span><br><span class="line">case insufficientFunds(coinsNeeded: Int) //金额不足</span><br><span class="line">case outOfStock                          //缺货</span><br><span class="line">&#125;</span><br><span class="line">//抛出一个错误</span><br><span class="line">throw VendingMachineError. insufficientFunds(coinsNeeded: 5)</span><br></pre></td></tr></table></figure>
<h2 id="throwing函数"><a href="#throwing函数" class="headerlink" title="throwing函数"></a>throwing函数</h2><ul>
<li><code>throws</code>写在函数声明的参数列表后，<code>-&gt;</code>前。<blockquote>
<p>throwing函数可在其内部抛出错误，将错误传递到函数被调用时的作用域，非throwing函数内部抛出的错误只能在函数内部处理。</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func canThrowErrors() throws -&gt; String</span><br></pre></td></tr></table></figure>
<h2 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h2><ul>
<li>处理错误的四种方式：<ul>
<li>把函数抛出的错误传递给调用此函数的代码</li>
<li>do-catch语句</li>
<li>将错误作为可选类型：<code>try?</code></li>
<li>断言此错误根本不会发生</li>
</ul>
</li>
</ul>
<h3 id="do-catch"><a href="#do-catch" class="headerlink" title="do-catch"></a>do-catch</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    try expression</span><br><span class="line">    statements</span><br><span class="line">&#125; catch pattern 1 &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125; catch pattern 2 where condition &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="将错误转换成可选值-try"><a href="#将错误转换成可选值-try" class="headerlink" title="将错误转换成可选值 try?"></a>将错误转换成可选值 try?</h3><ul>
<li>如果在评估try?表达式时一个错误被抛出，那么表达式的值就是nil。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let y = try? someThrowingFunction()</span><br><span class="line">等价于</span><br><span class="line">let y: Int?</span><br><span class="line">do &#123;</span><br><span class="line">    y = try someThrowingFunction()</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">    y = nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="禁用错误传递-try"><a href="#禁用错误传递-try" class="headerlink" title="禁用错误传递 try!"></a>禁用错误传递 try!</h3><ul>
<li>会把调用包装在一个不会有错误抛出的运行时断言中，如果真的抛出，则会发生运行时错误。</li>
</ul>
<h2 id="指定清理操作-defer"><a href="#指定清理操作-defer" class="headerlink" title="指定清理操作 defer"></a>指定清理操作 defer</h2><ul>
<li>defer语句在即将离开当前代码块时（throw,return,break等）执行一系列语句。<br>将代码的执行延迟到当前作用域退出之前，延时执行的操作会按照被指定时的顺序的相反顺序执行，即第一条defer语句中的代码会在第二条defer语句中的代码被执行之后才执行，以此类推。</li>
<li><code>即使没有涉及到错误处理，也可以使用defer语句</code></li>
</ul>
<h1 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h1><h2 id="检查值的类型：is"><a href="#检查值的类型：is" class="headerlink" title="检查值的类型：is"></a>检查值的类型：is</h2><ul>
<li>用类型检查操作符（is）来检查一个实例是否属于特定子类型。</li>
</ul>
<h2 id="向下转型：as"><a href="#向下转型：as" class="headerlink" title="向下转型：as"></a>向下转型：as</h2><ul>
<li>某类型的一个常量或变量可能在幕后实际上属于一个子类，用<code>as</code>向下转到它的子类型。</li>
<li>转换没有真的改变实例或它的值</li>
<li>类型转换的条件转换：as? as!<ul>
<li>可选形式as?：下转成一个可选值</li>
<li>强制形式as!：向下转型+强制解包</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for item in library&#123;</span><br><span class="line">    //（1）item不确定是什么类型，所以as?</span><br><span class="line">    if let movie = item as? Movie&#123;</span><br><span class="line">        //（2）使用可选绑定类型进行可选解析</span><br><span class="line">        print(&quot;\(movie.name)--\(movie.director)&quot;)</span><br><span class="line">    &#125;else if let song = item as? Song&#123;</span><br><span class="line">        print(&quot;\(song.name)--\(song.artist)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取实例的类型名称"><a href="#获取实例的类型名称" class="headerlink" title="获取实例的类型名称"></a>获取实例的类型名称</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let someStr = &quot;123&quot;</span><br><span class="line">print(type(of: someStr))    //String</span><br></pre></td></tr></table></figure>
<h2 id="Any-和-AnyObject-的类型转换"><a href="#Any-和-AnyObject-的类型转换" class="headerlink" title="Any 和 AnyObject 的类型转换"></a>Any 和 AnyObject 的类型转换</h2><ul>
<li>Any 可以表示任何类型，包括函数类型、可选类型。</li>
<li>AnyObject 可以表示任何类型的实例，AnyObject 也是Optional类型的。<blockquote>
<p>Any类型可以表示所有类型的值，包括可选类型。Swift 会在你用Any类型来表示一个可选值的时候，给你一个警告。如果你确实想使用Any类型来承载可选值，你可以使用as操作符显式转换为Any。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 可以存储Any类型的数组</span><br><span class="line">var arr1 = [Any]()</span><br><span class="line">// [AnyObject] 类型的数组</span><br><span class="line">var arr2: [AnyObject]</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h1 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h1><ul>
<li>类、枚举、结构体之间可相互嵌套</li>
</ul>
<h1 id="扩展-Extensions"><a href="#扩展-Extensions" class="headerlink" title="扩展 Extensions"></a>扩展 Extensions</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">extension SomeType &#123;</span><br><span class="line">// 为 SomeType 添加的新功能写到这里</span><br><span class="line">&#125;</span><br><span class="line">extension SomeType: SomeProtocol, AnotherProctocol &#123;</span><br><span class="line">// 协议实现写到这里</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>与OC中的分类类似，但是swift中的扩展没有名字</li>
<li>扩展可以添加新的计算属性，但是不可以添加存储属性，也不可以向已有属性添加属观察器</li>
<li>可用于向已有的类、结构体、枚举或协议添加新功能，但是不能重写已有的功能。</li>
<li>通过为一个已有类型添加新功能，则<code>新功能对该类型的所有实例都有效</code>，即使它们是在扩展定义之前创建的</li>
<li><p>可以实现的功能：</p>
<ul>
<li>添加计算型属性和计算型类型属性</li>
<li>定义实例方法和类型方法</li>
<li>提供新的构造器</li>
<li>定义下标</li>
<li>定义和使用新的嵌套类型</li>
<li>使一个已有类型符合某个协议</li>
</ul>
</li>
<li><p>swift4：extension中可以访问private属性</p>
</li>
</ul>
<h2 id="计算型属性"><a href="#计算型属性" class="headerlink" title="计算型属性"></a>计算型属性</h2><ul>
<li>扩展可以添加新的计算属性，但是不可以添加<code>存储型属性</code>，也不可以为已有属性添加<code>属性观察器</code>。</li>
</ul>
<h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><ul>
<li>扩展可以为类添加新的便利构造器，不可以添加新的指定构造器或析构器。指定构造器和析构器必须由原始类提供。</li>
</ul>
<h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><p>通过扩展添加的实例方法可以修改该实例本身，结构体和枚举类型中修改self或其属性的方法必须将该实例方法标注为mutating</p>
<h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><p>类、枚举、结构体都可以实现协议</p>
<h2 id="协议语法"><a href="#协议语法" class="headerlink" title="协议语法"></a>协议语法</h2><p>定义协议：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol SomeProtocol &#123;</span><br><span class="line">// 协议的定义部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>遵循协议：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct SomeStructure: FirstProtocol, AnotherProtocol &#123;</span><br><span class="line">// 结构体的定义部分</span><br><span class="line">&#125;</span><br><span class="line">class SomeClass: SomeSuperClass, FirstProtocol, AnotherProtocol &#123;</span><br><span class="line">// 类的内容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="属性要求"><a href="#属性要求" class="headerlink" title="属性要求"></a>属性要求</h2><ul>
<li><p>协议可以要求遵循协议的类型提供的实例属性或类型属性的<code>名称和类型</code>，还可指定<code>读写性</code>，但不用指定是存储型属性或计算型属性。</p>
<blockquote>
<p>用<code>var</code>声明变量属性，用<code>{set get}</code>声明属性是可读可写的，<code>{get}</code>表示只读属性。</p>
</blockquote>
</li>
<li><p>类属性要求使用static前缀关键字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol AnotherProtocol &#123;</span><br><span class="line">    static var someTypeProperty: Int &#123; get set &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="方法要求"><a href="#方法要求" class="headerlink" title="方法要求"></a>方法要求</h2><ul>
<li>方法不需要大括号和方法体</li>
<li>不支持为协议中的方法的参数提供默认值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protocol classa &#123;</span><br><span class="line">var marks: Int &#123; get set &#125;</span><br><span class="line">var result: Bool &#123; get &#125;</span><br><span class="line"></span><br><span class="line">func attendance() -&gt; String</span><br><span class="line">func markssecured() -&gt; String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Mutating-方法要求"><a href="#Mutating-方法要求" class="headerlink" title="Mutating 方法要求"></a>Mutating 方法要求</h2><ul>
<li>表示可以在该方法中修改它所属的实例及其实例属性的值</li>
<li>实现协议中的mutating方法时，若是类类型，则不用写<code>mutating</code>，对于结构体和枚举必须写。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protocol SomeProtocal &#123;</span><br><span class="line">    mutating func show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="构造器要求"><a href="#构造器要求" class="headerlink" title="构造器要求"></a>构造器要求</h2><ul>
<li><p>协议构造器在类中的实现：在遵循该协议的类中实现构造器，并指定其为类的指定构造器或便利构造器，这时必须为构造器实现标上<code>required</code>修饰符，可以确保遵循该协议的子类也能提供此构造器的显式实现或继承实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class SomeClass: SomeProtocol &#123;</span><br><span class="line">    required init(someParameter: Int) &#123;</span><br><span class="line">    // 构造器实现</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果一个子类重写了父类的指定构造器，并且该构造器满足了某个协议的要求，则构造器的实现需要标上<code>required</code>和<code>override</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">protocol SomeProtocol &#123;</span><br><span class="line">    init()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SomeSuperClass &#123;</span><br><span class="line">    init() &#123;</span><br><span class="line">    // 这里是构造器的实现部分</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SomeSubClass: SomeSuperClass, SomeProtocol &#123;</span><br><span class="line">    // 因为遵循协议，需要加上 required</span><br><span class="line">    // 因为继承自父类，需要加上 override</span><br><span class="line">    required override init() &#123;</span><br><span class="line">    // 这里是构造器的实现部分</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="协议作为类型"><a href="#协议作为类型" class="headerlink" title="协议作为类型"></a>协议作为类型</h2><ul>
<li>作为函数、方法或构造器中的参数类型或返回值类型</li>
<li>作为常量、变量或属性的类型</li>
<li>作为数组、字典或其他容器中的元素类型</li>
</ul>
<h2 id="协议可以继承"><a href="#协议可以继承" class="headerlink" title="协议可以继承"></a>协议可以继承</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol InheritingProtocol: SomeProtocol, AnotherProtocol &#123;</span><br><span class="line">// 协议定义</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类专属协议"><a href="#类专属协议" class="headerlink" title="类专属协议"></a>类专属协议</h2><ul>
<li>在协议继承列表添加<code>class</code>关键字，可以限制协议只能适配到类类型</li>
<li><code>该class关键字必须是第一个出现在协议的继承列表中，其后才是其他集继承协议</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol SomeClassOnlyProtocol: class, SomeInheritedProtocol &#123;</span><br><span class="line">// 协议定义</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="协议的合成"><a href="#协议的合成" class="headerlink" title="协议的合成"></a>协议的合成</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">protocol Stname &#123;</span><br><span class="line">var name: String &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol Stage &#123;</span><br><span class="line">var age: Int &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Person: Stname, Stage &#123;</span><br><span class="line">var name: String</span><br><span class="line">var age: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func show(celebrator: Stname &amp; Stage) &#123;</span><br><span class="line">print(&quot;\(celebrator.name) is \(celebrator.age) years old&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let studname = Person(name: &quot;Priya&quot;, age: 21)</span><br><span class="line">print(show(celebrator: studname))   //Priya is 21 years old</span><br></pre></td></tr></table></figure>
<h2 id="协议的组合使用"><a href="#协议的组合使用" class="headerlink" title="协议的组合使用"></a>协议的组合使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protocol&lt;ProtocolA, ProtocolB, ProtocolC&gt; 等价于</span><br><span class="line">protocol ProtocolD: ProtocolA, ProtocolB, ProtocolC &#123;</span><br><span class="line">//...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="检查协议一致性"><a href="#检查协议一致性" class="headerlink" title="检查协议一致性"></a>检查协议一致性</h2><ul>
<li>is：检查实例湿度遵循了某个协议</li>
<li>as?：当实例遵循了协议时，返回该协议类型，否则返回nil</li>
<li>as! ：强制向下转换类型，如果失败，会引起运行时错误</li>
</ul>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><ul>
<li>泛型使用占位类型名（在这里用字母 T 来表示）来代替实际类型名（例如 Int、String 或 Double）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个交换两个变量的函数</span><br><span class="line">func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T) &#123;</span><br><span class="line">    //可以不使用额外空间而使用多元组特性直接交换 a 和 b 的值</span><br><span class="line">    (a, b) = (b, a)</span><br><span class="line">&#125;</span><br><span class="line">var a = 5, b = 6</span><br><span class="line">swapTwoValues(&amp;a, &amp;b)</span><br><span class="line">print(a, b)</span><br><span class="line"></span><br><span class="line">//泛型的栈</span><br><span class="line">struct Stack&lt;Element&gt; &#123;</span><br><span class="line">    var items = [Element]()</span><br><span class="line">    mutating func push(_ item: Element) &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    mutating func pop() -&gt; Element &#123;</span><br><span class="line">        return items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var stackOfStrings = Stack&lt;String&gt;()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="扩展泛型类型"><a href="#扩展泛型类型" class="headerlink" title="扩展泛型类型"></a>扩展泛型类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">extension Stack &#123;</span><br><span class="line">    //扩展了一个只读计算型属性</span><br><span class="line">    var topItem: Element? &#123;</span><br><span class="line">        return items.isEmpty ? nil : items[items.count - 1]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//T 必须是 SomeClass 子类的类型约束,要求 U 必须符合 SomeProtocol 协议的类型约束</span><br><span class="line">func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) &#123;</span><br><span class="line">// 这里是泛型函数的函数体部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关联类-associatedtype"><a href="#关联类-associatedtype" class="headerlink" title="关联类 associatedtype"></a>关联类 associatedtype</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// Container 协议</span><br><span class="line">protocol Container &#123;</span><br><span class="line">    associatedtype ItemType</span><br><span class="line">    // 添加一个新元素到容器里</span><br><span class="line">    mutating func append(_ item: ItemType)</span><br><span class="line">    // 获取容器中元素的数</span><br><span class="line">    var count: Int &#123; get &#125;</span><br><span class="line">    // 通过索引值类型为 Int 的下标检索到容器中的每一个元素</span><br><span class="line">subscript(i: Int) -&gt; ItemType &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Stack 结构体遵从 Container 协议</span><br><span class="line">struct Stack&lt;Element&gt;: Container &#123;</span><br><span class="line">// Stack&lt;Element&gt; 的原始实现部分</span><br><span class="line">    var items = [Element]()</span><br><span class="line">    mutating func push(_ item: Element) &#123;</span><br><span class="line">    items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    mutating func pop() -&gt; Element &#123;</span><br><span class="line">    return items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">    // Container 协议的实现部分</span><br><span class="line">    mutating func append(_ item: Element) &#123;</span><br><span class="line">    self.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">    var count: Int &#123;</span><br><span class="line">    return items.count</span><br><span class="line">    &#125;</span><br><span class="line">    subscript(i: Int) -&gt; Element &#123;</span><br><span class="line">    return items[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="where语句"><a href="#where语句" class="headerlink" title="where语句"></a>where语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//用来检查两个Container实例是否包含相同顺序的相同元素</span><br><span class="line">func allItemsMatch&lt;C1: Container, C2: Container&gt;</span><br><span class="line">(_ someContainer: C1, _ anotherContainer: C2) -&gt; Bool</span><br><span class="line">where C1.ItemType == C2.ItemType, C1.ItemType: Equatable &#123;</span><br><span class="line"></span><br><span class="line">    // 检查两个容器含有相同数量的元素</span><br><span class="line">    if someContainer.count != anotherContainer.count &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 检查每一对元素是否相等</span><br><span class="line">    for i in 0..&lt;someContainer.count &#123;</span><br><span class="line">        if someContainer[i] != anotherContainer[i] &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 所有元素都匹配，返回 true</span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h1><ul>
<li>可以给单个类型（类、结构体、枚举）设置访问级别，也可以给这些类型的属性、函数、初始化方法、基本类型、下标、协议等设置访问级别</li>
<li>访问控制基于模块与源文件<ul>
<li>模块：独立单元构建和发布的framework或application</li>
<li>源文件：通常属于一个模块，源文件可以包含多个类和函数的定义</li>
</ul>
</li>
</ul>
<h2 id="四种访问级别"><a href="#四种访问级别" class="headerlink" title="四种访问级别"></a>四种访问级别</h2><ul>
<li>四种访问级别，从高到低，默认为<code>internal</code>：<br>| 访问级别 | 权限  |<br>|:——–:|———-|<br>|   public    | 可以访问自己模块中源文件里的任何实体，别人也可以通过引入该模块来访问源文件里的所有实体   |<br>|   internal   | 可以访问自己模块中源文件里的任何实体，别人不能   |<br>|   fileprivate    | 文件内私有，只能在当前源文件中使用   |<br>|   private    | 只能在类中访问，离开了这个类或者结构体的作用域外面就无法访问   |</li>
</ul>
<h2 id="访问级别的原则"><a href="#访问级别的原则" class="headerlink" title="访问级别的原则"></a>访问级别的原则</h2><ul>
<li><p><code>元组</code>的访问级别与元组中访问级别<code>最低的类型</code>一致（元组 = min（元组中元素））</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">internal class SomeInternalClass &#123;&#125;</span><br><span class="line">private class SomePrivateClass &#123;&#125;</span><br><span class="line">//该函数返回类型的访问级别是 private，必须使用 private 修饰符，明确的声明该函数</span><br><span class="line">func someFunction() -&gt; (SomeInternalClass, SomePrivateClass) &#123;</span><br><span class="line">// 函数实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>枚举中<code>成员</code>的访问级别<code>继承自该枚举</code>，不能为枚举中的成员单独声明不同的访问级别（枚举成员 = 枚举）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public enum Student &#123;</span><br><span class="line">    case Name(String)</span><br><span class="line">    case Mark(Int,Int,Int)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子类的访问级别<code>不得高于父类</code>的访问级别。（子类 &lt;= 父类）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class SuperClass &#123;</span><br><span class="line">    fileprivate func show() &#123;</span><br><span class="line">    print(&quot;超类&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 访问级别不能低于超类 internal &gt; public</span><br><span class="line">internal class SubClass: SuperClass  &#123;</span><br><span class="line">    override internal func show() &#123;</span><br><span class="line">    print(&quot;子类&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>常量、变量、属性<code>不能拥有比它们的类型更高</code>的访问级别，下标也不能拥有比索引类型或返回类型更高的访问级别（常量、变量、属性、下标 &lt;= 它的类型）</p>
</li>
<li><p>常量、变量、属性、下标索引的getter和setter的访问级别<code>继承自他们所属成员</code>的访问级别，setter的访问级别可以低于对应的getter的访问级别，这样可以控制常量、变量、下标的读写权限（getter和setter = 常量、变量、属性、下标索引，getter &gt;= setter）</p>
</li>
<li><p>构造器和默认构造器访问级别：</p>
<ul>
<li>自定义的初始化方法 &lt;= 它所属类</li>
<li>必要构造器 = 所属类</li>
<li>函数中，初始化方法参数 &gt;= 初始化方法</li>
<li>默认构造器 = 所属类型</li>
</ul>
</li>
<li><p>协议访问级别（请确保该协议只在声明的访问级别作用域中使用）：实现协议的必要函数 = 协议</p>
</li>
<li><p>扩展访问级别：扩展成员 = 原始类成员，单独成员所声明的访问级别可以覆盖扩展的默认访问级别。</p>
</li>
<li><p>泛型访问级别 = min（泛型类型、函数本身、泛型类型参数）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public struct TOS&lt;T&gt; &#123;</span><br><span class="line">    var items = [T]()</span><br><span class="line">    private mutating func push(item: T) &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutating func pop() -&gt; T &#123;</span><br><span class="line">        return items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类型别名 &lt;= 原类型</p>
</li>
</ul>
<h1 id="高级运算符"><a href="#高级运算符" class="headerlink" title="高级运算符"></a>高级运算符</h1><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><ul>
<li>按位取反：~</li>
<li>按位与：&amp;</li>
<li>按位或：|</li>
<li>按位异或：^</li>
<li>按位左移：&lt;&lt;(乘2)</li>
<li>按位右移：&gt;&gt;(除2)</li>
<li>有符号整数的移位运算：0代表证书，1代表负数，负数表示用二进制补码</li>
</ul>
<h2 id="溢出运算符"><a href="#溢出运算符" class="headerlink" title="溢出运算符"></a>溢出运算符</h2><ul>
<li>溢出加法：&amp;+</li>
<li>溢出减法：&amp;-</li>
<li>溢出乘法：&amp;*</li>
</ul>
<h2 id="优先级和结合性"><a href="#优先级和结合性" class="headerlink" title="优先级和结合性"></a>优先级和结合性</h2><ul>
<li>乘法与取余运算都是左结合</li>
</ul>
<h2 id="运算符函数"><a href="#运算符函数" class="headerlink" title="运算符函数"></a>运算符函数</h2><h2 id="重载-自定义运算符"><a href="#重载-自定义运算符" class="headerlink" title="重载/自定义运算符"></a>重载/自定义运算符</h2><ul>
<li><p>重载运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func +(left: Vector2D, right:Vector2D) -&gt; Vector2D &#123;</span><br><span class="line">    return Vector2D(x: left.x + right.x, y: left.y + right.y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let v1 = Vector2D(x: 2, y: 3)</span><br><span class="line">let v2 = Vector2D(x: 1, y: 4)</span><br><span class="line">let v3 = Vector2D(x: v1.x+v2.x, y: v1.y+v2.y)</span><br><span class="line">let v4 = v1 + v2 + v3</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func +*(left: Vector2D, right:Vector2D) -&gt; Double &#123;</span><br><span class="line">return left.x * right.x + left.y * right.y</span><br><span class="line">&#125;</span><br><span class="line">let result1 = v1 +* v2</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// FirstClass.swift</span><br><span class="line">// 这个文件存在于 MyFramework.framework 中</span><br><span class="line">public class FirstClass &#123;</span><br><span class="line">    public class func hello() &#123;</span><br><span class="line">        print(&quot;hello from first&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// SecondClass.swift</span><br><span class="line">// 这个文件存在于 app 的主 target 中</span><br><span class="line">class SecondClass &#123;</span><br><span class="line">    class func hello() &#123;</span><br><span class="line">        print(&quot;hello from second&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">FirstClass.MyClass.hello()</span><br><span class="line">// hello from firsst</span><br><span class="line">SecondClass.MyClass.hello()</span><br><span class="line">// hello from second</span><br></pre></td></tr></table></figure>
<h1 id="Swift-UI部分"><a href="#Swift-UI部分" class="headerlink" title="Swift UI部分"></a>Swift UI部分</h1><p>Q:编译错误：<code>The “Swift Language Version” (SWIFT_VERSION) build setting must be set to a supported value for targets which use Swift. This setting can be set in the build settings editor.</code><br>A:解决：Build Settings-&gt;Swift Language Version 选择一个最新的swift版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var myBtn: UIButton?</span><br><span class="line">myBtn = UIButton(type:UIButtonType.system)</span><br><span class="line">myBtn!.frame = CGRect(x: 100, y: 100, width: 100, height: 44)</span><br><span class="line">myBtn!.backgroundColor = UIColor.red</span><br><span class="line">myBtn!.setTitle(&quot;注册&quot;, for: UIControlState.normal)</span><br><span class="line">myBtn!.addTarget(self, action: Selector((&quot;register:&quot;)), for: UIControlEvents.touchUpInside)</span><br><span class="line">self.view.addSubview(myBtn!)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var myBtn: UIButton!</span><br><span class="line">myBtn = UIButton(type:UIButtonType.system)</span><br><span class="line">myBtn!.frame = CGRect(x: 100, y: 100, width: 100, height: 44)</span><br><span class="line">myBtn!.backgroundColor = UIColor.red</span><br><span class="line">myBtn!.setTitle(&quot;注册&quot;, for: .normal)</span><br><span class="line">myBtn!.addTarget(self, action: #selector(register(sender:)), for: .touchUpInside)</span><br><span class="line">view.addSubview(myBtn!)</span><br><span class="line"></span><br><span class="line">@objc func register(sender: UIButton)&#123;</span><br><span class="line">print(&quot;register click&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><ul>
<li><p>swift中单例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//swift中的let是线程安全的</span><br><span class="line">static let instance: NetworkTools = NetworkTools()</span><br><span class="line">class func shareNetworkTools() -&gt; NetworkTools&#123;</span><br><span class="line">    return instance</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>OC中单例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+(instancetype)shareNetworkTools&#123;</span><br><span class="line">    static id instance;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">        //onceToken默认等于0，如果是0就执行block，如果不是就不执行</span><br><span class="line">        NSLog(@&quot;%ld&quot;,onceToken);</span><br><span class="line">        dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        instance = [[self alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="swift的常用内置函数总结"><a href="#swift的常用内置函数总结" class="headerlink" title="swift的常用内置函数总结"></a>swift的常用内置函数总结</h1><ul>
<li>abs</li>
<li>assert</li>
<li>countElements</li>
<li>enumerate</li>
<li>sort</li>
<li>contains(sequence, element)</li>
<li>dropFirst(sequence)</li>
<li>dropLast(sequence)</li>
<li>dump(object)：打印出某个对象object的所有信息</li>
<li>equal(sequence1, sequence2)：判断两个序列是否相等</li>
<li>filter(sequence, includeElementClosure)：对序列sequence中每个元素都执行includeElementClosure闭包，并将所有闭包结果为true的元素合成一个新序列sequence并返回。</li>
<li>find(sequence, element)：返回序列sequence中某元素element的位置index。如果序列中不存在此元素，则返回nil。</li>
<li>indices(sequence)：返回序列sequence中所有元素的位置（indices是index的复数）</li>
<li>join(separator, sequence)：将序列sequence通过分隔符separator连成一个字符串，并返回此字符串。</li>
<li>map(sequence, transformClosure)：对序列sequence中每个元素都执行includeElementClosure闭包，并将所有闭包的结果合成一个新序列sequence并返回。</li>
<li>max(comparable1, comparable2, etc.)  min(comparable1, comparable2, etc.)</li>
<li>maxElement(sequence)：返回序列sequence中的最大值。  minElements(sequence)：返回序列sequence中的最小值。</li>
<li>reverse(sequence)：返回逆序的序列sequence。</li>
</ul>
<p>参考资料：<a href="http://wiki.jikexueyuan.com/project/swift">The Swift Programming Language中文版</a><br><a href="http://blog.csdn.net/banma2008/article/details/46360333">Swift的74个常用内置函数介绍</a><br><a href="http://www.cocoachina.com/ios/20151218/14716.html">深入探究Swift数组背后的协议、方法、拓展</a><br><a href="https://github.com/allenwong/30DaysofSwift">30个swift项目源码</a><br><a href="https://github.com/cjiong/LearnSwift">50个swift项目源码</a><br><a href="https://github.com/yagamis/swift2basic">https://github.com/yagamis/swift2basic</a><br><a href="https://github.com/KeyJohn/Swift">https://github.com/KeyJohn/Swift</a></p>
<p><a href="http://www.swift51.com/openSource.htm">Swift编程</a><br><a href="http://lib.csdn.net/article/swift/52339">swift 框架大全</a></p>
-->
      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Swift/" rel="tag"># Swift</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/07/11/podspec学习笔记/" rel="next" title="podspec学习笔记">
                <i class="fa fa-chevron-left"></i> podspec学习笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/07/21/iOS常用第三方框架/" rel="prev" title="iOS常用第三方框架">
                iOS常用第三方框架 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="谷春丽">
          <p class="site-author-name" itemprop="name">谷春丽</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">114</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">52</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        <div id="days"></div>
<script>
function show_date_time(){
window.setTimeout("show_date_time()", 1000);
BirthDay=new Date("05/27/2017 15:13:14");
today=new Date();
timeold=(today.getTime()-BirthDay.getTime());
sectimeold=timeold/1000
secondsold=Math.floor(sectimeold);
msPerDay=24*60*60*1000
e_daysold=timeold/msPerDay
daysold=Math.floor(e_daysold);
e_hrsold=(e_daysold-daysold)*24;
hrsold=setzero(Math.floor(e_hrsold));
e_minsold=(e_hrsold-hrsold)*60;
minsold=setzero(Math.floor((e_hrsold-hrsold)*60));
seconds=setzero(Math.floor((e_minsold-minsold)*60));
document.getElementById('days').innerHTML="已运行"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒";
}
function setzero(i){
if (i<10)
{i="0" + i};
return i;
}
show_date_time();
</script>


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#基础知识"><span class="nav-number">1.</span> <span class="nav-text">基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#常量和变量"><span class="nav-number">1.1.</span> <span class="nav-text">常量和变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字面量"><span class="nav-number">1.2.</span> <span class="nav-text">字面量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型标注"><span class="nav-number">1.3.</span> <span class="nav-text">类型标注</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注释"><span class="nav-number">1.4.</span> <span class="nav-text">注释</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分号"><span class="nav-number">1.5.</span> <span class="nav-text">分号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#打印日志"><span class="nav-number">1.6.</span> <span class="nav-text">打印日志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型转换"><span class="nav-number">1.7.</span> <span class="nav-text">类型转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型别名"><span class="nav-number">1.8.</span> <span class="nav-text">类型别名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#元组"><span class="nav-number">1.9.</span> <span class="nav-text">元组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可选类型"><span class="nav-number">1.10.</span> <span class="nav-text">可选类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nil"><span class="nav-number">1.11.</span> <span class="nav-text">nil</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#if-语句以及强制解析"><span class="nav-number">1.12.</span> <span class="nav-text">if 语句以及强制解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可选绑定"><span class="nav-number">1.13.</span> <span class="nav-text">可选绑定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#隐式解析可选类型"><span class="nav-number">1.14.</span> <span class="nav-text">隐式解析可选类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#错误处理"><span class="nav-number">1.15.</span> <span class="nav-text">错误处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#断言"><span class="nav-number">1.16.</span> <span class="nav-text">断言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fatalError"><span class="nav-number">1.17.</span> <span class="nav-text">fatalError</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#基本运算符"><span class="nav-number">2.</span> <span class="nav-text">基本运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#不可自增自减"><span class="nav-number">2.1.</span> <span class="nav-text">不可自增自减</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#取余"><span class="nav-number">2.2.</span> <span class="nav-text">取余</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#空值合并-空合-运算符"><span class="nav-number">2.3.</span> <span class="nav-text">空值合并(空合)运算符??</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#区间运算符"><span class="nav-number">2.4.</span> <span class="nav-text">区间运算符</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#字符与字符串"><span class="nav-number">3.</span> <span class="nav-text">字符与字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#初始化空字符串"><span class="nav-number">3.1.</span> <span class="nav-text">初始化空字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符"><span class="nav-number">3.2.</span> <span class="nav-text">字符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串可变性"><span class="nav-number">3.3.</span> <span class="nav-text">字符串可变性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#连接字符串和字符"><span class="nav-number">3.4.</span> <span class="nav-text">连接字符串和字符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#插入和删除"><span class="nav-number">3.5.</span> <span class="nav-text">插入和删除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计算字符数量"><span class="nav-number">3.6.</span> <span class="nav-text">计算字符数量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串索引"><span class="nav-number">3.7.</span> <span class="nav-text">字符串索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#比较字符串"><span class="nav-number">3.8.</span> <span class="nav-text">比较字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#插值"><span class="nav-number">3.9.</span> <span class="nav-text">插值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#格式化字符串"><span class="nav-number">3.10.</span> <span class="nav-text">格式化字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#swift4新增"><span class="nav-number">3.11.</span> <span class="nav-text">swift4新增</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#集合类型"><span class="nav-number">4.</span> <span class="nav-text">集合类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#集合的可变性"><span class="nav-number">4.1.</span> <span class="nav-text">集合的可变性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组"><span class="nav-number">4.2.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集合"><span class="nav-number">4.3.</span> <span class="nav-text">集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字典"><span class="nav-number">4.4.</span> <span class="nav-text">字典</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他"><span class="nav-number">4.5.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#生成器（Generator）"><span class="nav-number">4.5.1.</span> <span class="nav-text">生成器（Generator）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#序列（Sequence）"><span class="nav-number">4.5.2.</span> <span class="nav-text">序列（Sequence）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合-Collection"><span class="nav-number">4.5.3.</span> <span class="nav-text">集合(Collection)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#控制流"><span class="nav-number">5.</span> <span class="nav-text">控制流</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#For-In-循环"><span class="nav-number">5.1.</span> <span class="nav-text">For-In 循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#while-repeat-while"><span class="nav-number">5.2.</span> <span class="nav-text">while/repeat-while</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#switch"><span class="nav-number">5.3.</span> <span class="nav-text">switch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#控制转移语句"><span class="nav-number">5.4.</span> <span class="nav-text">控制转移语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#检测API可用性"><span class="nav-number">5.5.</span> <span class="nav-text">检测API可用性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数"><span class="nav-number">6.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#函数定义与调用"><span class="nav-number">6.1.</span> <span class="nav-text">函数定义与调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指定参数标签"><span class="nav-number">6.2.</span> <span class="nav-text">指定参数标签</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#忽略参数标签"><span class="nav-number">6.3.</span> <span class="nav-text">忽略参数标签</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#默认参数值"><span class="nav-number">6.4.</span> <span class="nav-text">默认参数值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可变参数"><span class="nav-number">6.5.</span> <span class="nav-text">可变参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#输入输出参数"><span class="nav-number">6.6.</span> <span class="nav-text">输入输出参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数类型"><span class="nav-number">6.7.</span> <span class="nav-text">函数类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#嵌套函数"><span class="nav-number">6.8.</span> <span class="nav-text">嵌套函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#柯里化"><span class="nav-number">6.9.</span> <span class="nav-text">柯里化</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">谷春丽</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共166.3k字</span>
</div>
        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  









  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/three/three.min.js"></script>

  
  <script type="text/javascript" src="/lib/three/three-waves.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (search_path.endsWith("json")) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  


  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/src/clicklove.js"></script>
  <!--  -->

<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"tagMode":false});</script></body>
</html>
