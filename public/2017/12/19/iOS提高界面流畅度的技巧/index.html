<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #FFFF00; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>






<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="优化,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1">






<meta name="description" content="屏幕显示图像原理App 主线程在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待信号到来时显示到屏幕上。">
<meta name="keywords" content="优化">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS提高界面流畅度的技巧">
<meta property="og:url" content="https://guchunli.github.io/2017/12/19/iOS提高界面流畅度的技巧/index.html">
<meta property="og:site_name" content="guchunli">
<meta property="og:description" content="屏幕显示图像原理App 主线程在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待信号到来时显示到屏幕上。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-11-29T03:13:54.786Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS提高界面流畅度的技巧">
<meta name="twitter:description" content="屏幕显示图像原理App 主线程在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待信号到来时显示到屏幕上。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://guchunli.github.io/2017/12/19/iOS提高界面流畅度的技巧/">





  <title>iOS提高界面流畅度的技巧 | guchunli</title>
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">guchunli</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">努力把生活折腾成自己喜欢的样子~</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-photos">
          <a href="/photos/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-image"></i> <br>
            
            相册
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://guchunli.github.io/2017/12/19/iOS提高界面流畅度的技巧/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="谷春丽">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="guchunli">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">iOS提高界面流畅度的技巧</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-19T19:10:30+08:00">
                2017-12-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/note/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  4.5k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  17
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="屏幕显示图像原理"><a href="#屏幕显示图像原理" class="headerlink" title="屏幕显示图像原理"></a>屏幕显示图像原理</h2><p>App 主线程在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待信号到来时显示到屏幕上。<br><a id="more"></a></p>
<h2 id="CPU资源消耗原因和解决方案"><a href="#CPU资源消耗原因和解决方案" class="headerlink" title="CPU资源消耗原因和解决方案"></a>CPU资源消耗原因和解决方案</h2><h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><p>对象的创建会分配内存、调整属性、甚至还有读取文件等操作。</p>
<ul>
<li>尽量用轻量的对象代替重量的对象</li>
<li>使用storyboard创建对象比通过代码消耗资源多</li>
<li>尽量推迟对象创建的时间，并把对象的创建分散到多个任务中去</li>
<li>能复用的对象尽量使用复用</li>
</ul>
<h3 id="对象调整"><a href="#对象调整" class="headerlink" title="对象调整"></a>对象调整</h3><ul>
<li>尽量减少不必要的属性修改，UIView 的关于显示相关的属性（比如 frame/bounds/transform）等实际上都是 CALayer 属性映射来的</li>
<li>尽量避免调整视图层次，添加或移除视图</li>
</ul>
<h3 id="对象销毁"><a href="#对象销毁" class="headerlink" title="对象销毁"></a>对象销毁</h3><ul>
<li>如果对象可以放到后台线程去释放，那就挪到后台线程去。<code>把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译器警告，就可以让对象在后台线程销毁了。</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSArray *tmp = self.array;</span><br><span class="line">self.array = nil;</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">[tmp class];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="布局计算"><a href="#布局计算" class="headerlink" title="布局计算"></a>布局计算</h3><ul>
<li>视图布局的计算是APP中最常见消耗CPU的地方，尽量在<code>后台线程</code>计算好视图布局并对视图布局进行<code>缓存</code>，尽量<code>提前</code>算好布局，在需要时一次性调整好对应属性，而不要多次，频繁的计算、调整这些属性</li>
</ul>
<h3 id="autolayout"><a href="#autolayout" class="headerlink" title="autolayout"></a>autolayout</h3><ul>
<li>autolayout对于复杂视图来说常常会产生严重的性能问题，尽量手动调整 frame 等属性，可以使用category来快捷地获取视图的width,height等属性。</li>
</ul>
<h3 id="文本计算"><a href="#文本计算" class="headerlink" title="文本计算"></a>文本计算</h3><ul>
<li>可以参考UILabel 内部的实现方式：用 [NSAttributedString boundingRectWithSize:options:context:] 来计算文本宽高，用 -[NSAttributedString drawWithRect:options:context:] 来绘制文本，注意需要放到后台线程进行以避免阻塞主线程。</li>
</ul>
<h3 id="文本渲染"><a href="#文本渲染" class="headerlink" title="文本渲染"></a>文本渲染</h3><ul>
<li>用 TextKit 或最底层的 CoreText 对文本异步绘制。CoreText 对象占用内存较少，可以缓存下来以备稍后多次渲染。屏幕上能看到的所有文本内容控件，在底层都是通过 CoreText 排版、绘制为 Bitmap 显示的。</li>
</ul>
<h3 id="图片解码"><a href="#图片解码" class="headerlink" title="图片解码"></a>图片解码</h3><p>当你用 UIImage 或 CGImageSource 的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。如果想要绕开这个机制，常见的做法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。</p>
<h3 id="图片绘制"><a href="#图片绘制" class="headerlink" title="图片绘制"></a>图片绘制</h3><p>图像的绘制通常是指用那些以 CG 开头的方法把图像绘制到画布中，然后从画布创建图片并显示这样一个过程。这个最常见的地方就是 [UIView drawRect:] 里面了。由于 CoreGraphic 方法通常都是线程安全的，所以图像的绘制可以很容易的放到后台线程进行。一个简单异步绘制的过程大致如下（实际情况会比这个复杂得多，但原理基本一致）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)display &#123;</span><br><span class="line">    dispatch_async(backgroundQueue, ^&#123;</span><br><span class="line">        CGContextRef ctx = CGBitmapContextCreate(...);</span><br><span class="line">        // draw in context...</span><br><span class="line">        CGImageRef img = CGBitmapContextCreateImage(ctx);</span><br><span class="line">        CFRelease(ctx);</span><br><span class="line">        dispatch_async(mainQueue, ^&#123;</span><br><span class="line">            layer.contents = img;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="GPU资源消耗原因和解决方案"><a href="#GPU资源消耗原因和解决方案" class="headerlink" title="GPU资源消耗原因和解决方案"></a>GPU资源消耗原因和解决方案</h2><ul>
<li>GPU的作用：接收提交的纹理和顶点描绘，应用变换，混合和渲染，并且输出到屏幕上。</li>
</ul>
<h3 id="纹理的渲染"><a href="#纹理的渲染" class="headerlink" title="纹理的渲染"></a>纹理的渲染</h3><ul>
<li>尽量减少在短时间内大量图片的显示，尽可能多张图片合成为一张进行显示。</li>
<li>尽量不要让图片和视图的大小超过4096*4096</li>
</ul>
<h3 id="视图的混合"><a href="#视图的混合" class="headerlink" title="视图的混合"></a>视图的混合</h3><ul>
<li>尽量减少视图数量和层次，并在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成</li>
</ul>
<h3 id="图形的生成"><a href="#图形的生成" class="headerlink" title="图形的生成"></a>图形的生成</h3><ul>
<li>CALayer 的 border、圆角、阴影、遮罩（mask），CASharpLayer 的矢量图形显示，通常会触发离屏渲染，离屏渲染通常发生在 GPU 中，可以尝试开启 CALayer.shouldRasterize 属性，但这会把原本离屏渲染的操作转嫁到 CPU 上去，也可以用一张已经绘制好的圆角图片覆盖到原本视图上面来模拟相同的视觉效果。最彻底的解决办法，就是把需要显示的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性。</li>
</ul>
<h2 id="AsyncDisplayKit-ASDK"><a href="#AsyncDisplayKit-ASDK" class="headerlink" title="AsyncDisplayKit(ASDK)"></a>AsyncDisplayKit(ASDK)</h2><p>ASDK 认为，阻塞主线程的任务，主要分为三大类：<br>1.文本宽高计算，视图布局计算<br>2.文本渲染，图片解码，图形绘制<br>3.对象创建，对象调整，对象销毁</p>
<p>与 UIView 和 CALayer 不同，ASDisplayNode 是线程安全的，它可以在后台线程创建和修改。</p>
<ul>
<li>ASDK 的图层预合成：那些并不需要响应触摸事件，也不需要进行动画和位置调整的 sub-layer，可以合成渲染为一张图片</li>
<li>ASDK 异步并发操作：利用 GCD 异步并发执行</li>
<li>Runloop 任务分发</li>
</ul>
<h2 id="预排版"><a href="#预排版" class="headerlink" title="预排版"></a>预排版</h2><ul>
<li>当获取到 API JSON 数据后，把每条 Cell 需要的数据都在后台线程计算并封装为一个布局对象 CellLayout。</li>
<li>FDTemplateLayoutCell</li>
</ul>
<h2 id="product-gt-profile"><a href="#product-gt-profile" class="headerlink" title="product-&gt;profile"></a>product-&gt;profile</h2><h1 id="提高列表滚动流畅度"><a href="#提高列表滚动流畅度" class="headerlink" title="提高列表滚动流畅度"></a>提高列表滚动流畅度</h1><h2 id="避免重复多次计算-cell-行高"><a href="#避免重复多次计算-cell-行高" class="headerlink" title="避免重复多次计算 cell 行高"></a>避免重复多次计算 cell 行高</h2><ul>
<li><p>获取数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (InfoModel *model in data) &#123;</span><br><span class="line">    FrameModel *frameModel = [FrameModel new];</span><br><span class="line">    frameModel.model = model;</span><br><span class="line">    [self.data addObject:frameModel];</span><br><span class="line">&#125;</span><br><span class="line">[self.tabView reloadData];</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算 frame 、cell 行高</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@interface FrameModel : NSObject</span><br><span class="line"></span><br><span class="line">@property (assign, nonatomic, readonly) CGRect titleFrame;</span><br><span class="line">@property (assign, nonatomic, readonly) CGFloat cellHeight;</span><br><span class="line">@property (strong, nonatomic) InfoModel *model;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation FrameModel</span><br><span class="line"></span><br><span class="line">- (void)setModel:(InfoModel *)model &#123;</span><br><span class="line">if (!model) return;</span><br><span class="line"></span><br><span class="line">_model = model;</span><br><span class="line"></span><br><span class="line">CGFloat maxLayout = ([UIScreen mainScreen].bounds.size.width - 20.f);</span><br><span class="line">CGFloat bottom = 4.f;</span><br><span class="line"></span><br><span class="line">//title</span><br><span class="line">CGFloat titleX = 10.f;</span><br><span class="line">CGFloat titleY = 10.f;</span><br><span class="line">CGSize titleSize = [model.title boundingRectWithSize:CGSizeMake(maxLayout, CGFLOAT_MAX) options:NSStringDrawingUsesLineFragmentOrigin|NSStringDrawingUsesFontLeading attributes:@&#123;NSFontAttributeName : Font(16.f)&#125; context:nil].size;</span><br><span class="line">_titleFrame = CGRectMake(titleX, titleY, titleSize.width, titleSize.height);</span><br><span class="line"></span><br><span class="line">//cell Height</span><br><span class="line">_cellHeight = (CGRectGetMaxY(_titleFrame) + bottom);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>行高取值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">    TableCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;identifier&quot; forIndexPath:indexPath];</span><br><span class="line">    FrameModel *frameModel = self.data[indexPath.row];</span><br><span class="line">    cell.frameModel = frameModel;</span><br><span class="line">    return cell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">    FrameModel *frameModel = self.data[indexPath.row];</span><br><span class="line">    return frameModel.cellHeight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>控件赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)setFrameModel:(FrameModel *)frameModel &#123;</span><br><span class="line">    if (!frameModel) return;</span><br><span class="line"></span><br><span class="line">    _frameModel = frameModel;</span><br><span class="line"></span><br><span class="line">    InfoModel *model = frameModel.model;</span><br><span class="line"></span><br><span class="line">    self.titleLabel.frame = frameModel.titleFrame;</span><br><span class="line">    self.titleLabel.text = model.title;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="文本异步渲染"><a href="#文本异步渲染" class="headerlink" title="文本异步渲染"></a>文本异步渲染</h2><p>用 TextKit 或最底层的 CoreText 对文本异步绘制，支持文本异步渲染也有现成的库 YYText 。* 计算 frame 、cell 行高<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@interface FrameModel : NSObject</span><br><span class="line"></span><br><span class="line">@property (assign, nonatomic, readonly) CGRect titleFrame;</span><br><span class="line">@property (strong, nonatomic, readonly) YYTextLayout *titleLayout;</span><br><span class="line">@property (assign, nonatomic, readonly) CGFloat cellHeight;</span><br><span class="line">@property (strong, nonatomic) InfoModel *model;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation FrameModel</span><br><span class="line"></span><br><span class="line">- (void)setModel:(InfoModel *)model &#123;</span><br><span class="line">if (!model) return;</span><br><span class="line"></span><br><span class="line">_model = model;</span><br><span class="line"></span><br><span class="line">CGFloat maxLayout = ([UIScreen mainScreen].bounds.size.width - 20.f);</span><br><span class="line">CGFloat bottom = 4.f;</span><br><span class="line"></span><br><span class="line">//title</span><br><span class="line">NSMutableAttributedString *title = [[NSMutableAttributedString alloc] initWithString:entity.title];</span><br><span class="line">title.yy_font = Font(16.f);</span><br><span class="line">title.yy_color = [UIColor blackColor];</span><br><span class="line"></span><br><span class="line">YYTextContainer *titleContainer = [YYTextContainer containerWithSize:CGSizeMake(maxLayout, CGFLOAT_MAX)];</span><br><span class="line">_titleLayout = [YYTextLayout layoutWithContainer:titleContainer text:title];</span><br><span class="line"></span><br><span class="line">CGFloat titleX = 10.f;</span><br><span class="line">CGFloat titleY = 10.f;</span><br><span class="line">CGSize titleSize = _titleLayout.textBoundingSize;</span><br><span class="line">//CGSize titleSize = [model.title boundingRectWithSize:CGSizeMake(maxLayout, CGFLOAT_MAX) options:NSStringDrawingUsesLineFragmentOrigin|NSStringDrawingUsesFontLeading attributes:@&#123;NSFontAttributeName : Font(16.f)&#125; context:nil].size;</span><br><span class="line">_titleFrame = (CGRect)&#123;titleX,titleY,CGSizeMake(titleSize.width, titleSize.height)&#125;;</span><br><span class="line"></span><br><span class="line">//cell Height</span><br><span class="line">_cellHeight = (CGRectGetMaxY(_titleFrame) + bottom);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>UITableViewCell 处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier &#123;</span><br><span class="line">    self = [super initWithStyle:style reuseIdentifier:reuseIdentifier];</span><br><span class="line">    if (!self) return nil;</span><br><span class="line"></span><br><span class="line">    YYLabel *title = [YYLabel new];</span><br><span class="line">    title.displaysAsynchronously = YES; //开启异步渲染</span><br><span class="line">    title.ignoreCommonProperties = YES; //忽略属性</span><br><span class="line">    title.layer.borderColor = [UIColor brownColor].CGColor;</span><br><span class="line">    title.layer.cornerRadius = 1.f;</span><br><span class="line">    title.layer.borderWidth = 1.f;</span><br><span class="line">    [self.contentView addSubview:_titleLabel = title];</span><br><span class="line"></span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>控件赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)setFrameModel:(FrameModel *)frameModel &#123;</span><br><span class="line">if (!frameModel) return;</span><br><span class="line"></span><br><span class="line">_frameModel = frameModel;</span><br><span class="line"></span><br><span class="line">self.titleLabel.frame = frameModel.titleFrame;</span><br><span class="line">self.titleLabel.textLayout = model.titleLayout; //直接取 YYTextLayout</span><br><span class="line">//InfoModel *model = frameModel.model;</span><br><span class="line">//self.titleLabel.text = model.title;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="离屏渲染"><a href="#离屏渲染" class="headerlink" title="离屏渲染"></a>离屏渲染</h2><ul>
<li><p>On-Screen Rendering<br>当前屏幕渲染，指的是在当前用于显示的屏幕缓冲区中进行渲染操作。</p>
</li>
<li><p>Off-Screen Rendering<br>离屏渲染，指的是 GPU 或 CPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。过程中需要切换 contexts (上下文环境),先从当前屏幕切换到离屏的contexts，渲染结束后，又要将 contexts 切换回来，而切换过程十分耗费性能。</p>
</li>
</ul>
<p>GPU 产生的离屏渲染主要是当 CALayer 使用圆角，阴影，遮罩等属性的的时候，图层属性的混合体被指定为在未预合成之前不能直接在屏幕中渲染，则过程中需要进行离屏渲染。<br>实际项目中 CPU 产生的离屏渲染主要由Core Graphics API(核心绘图)的使用导致。</p>
<h3 id="离屏渲染的检测手段"><a href="#离屏渲染的检测手段" class="headerlink" title="离屏渲染的检测手段"></a>离屏渲染的检测手段</h3><p>模拟器的 debug -&gt; 选取 color Offscreen-Rendered.</p>
<h3 id="离屏渲染的优化手段"><a href="#离屏渲染的优化手段" class="headerlink" title="离屏渲染的优化手段"></a>离屏渲染的优化手段</h3><h4 id="shadows（阴影）"><a href="#shadows（阴影）" class="headerlink" title="shadows（阴影）"></a>shadows（阴影）</h4><p>解决方案:设置阴影后，设置CALayer的 shadowPath<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view.layer.shadowPath = [UIBezierPath pathWithCGRect:view.bounds].CGPath;</span><br></pre></td></tr></table></figure></p>
<h4 id="masksToBounds-true-cornerRadius-gt-0"><a href="#masksToBounds-true-cornerRadius-gt-0" class="headerlink" title="masksToBounds = true +  cornerRadius &gt; 0"></a>masksToBounds = true +  cornerRadius &gt; 0</h4><p>解决方案:后台绘制圆角图片，前台进行设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (void)setCircleImage</span><br><span class="line">&#123;</span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">UIImage * circleImage = [image imageWithCircle];</span><br><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">imageView.image = circleImage;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#import &quot;UIImage+Addtions.h&quot;</span><br><span class="line">@implementation UIImage (Addtions)</span><br><span class="line">//返回一张圆形图片</span><br><span class="line">- (instancetype)imageWithCircle</span><br><span class="line">&#123;</span><br><span class="line">UIGraphicsBeginImageContextWithOptions(self.size, NO, 0);</span><br><span class="line">UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(0, 0, self.size.width, self.size.height)];</span><br><span class="line">[path addClip];</span><br><span class="line">[self drawAtPoint:CGPointZero];</span><br><span class="line">UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">UIGraphicsEndImageContext();</span><br><span class="line">return image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于 contents 无内容或者内容的背景透明(无涉及到圆角以外的区域)的layer，直接设置layer的 backgroundColor 和 cornerRadius 属性来绘制圆角。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//不要直接设置控件的 backgroundColor</span><br><span class="line">//部分控件(如 UILabel )设置背景色是对CALayer的 contents 设置颜色而不是 backgroundColor </span><br><span class="line">label.layer.backgroundColor = aColor</span><br><span class="line">label.layer.cornerRadius = 5</span><br></pre></td></tr></table></figure></p>
<p>使用混合图层，在layer上方叠加相应mask形状的半透明layer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sublayer.contents = (id)[UIImage imageNamed:@&quot;xxx&quot;].CGImage;</span><br><span class="line">[view.layer addSublayer:sublayer];</span><br></pre></td></tr></table></figure></p>
<h4 id="mask（遮罩）"><a href="#mask（遮罩）" class="headerlink" title="mask（遮罩）"></a>mask（遮罩）</h4><p>解决方案:</p>
<ul>
<li>不使用mask</li>
<li>使用混合图层，具体同上方圆角第二解决方案</li>
</ul>
<h4 id="allowsGroupOpacity（组不透明）"><a href="#allowsGroupOpacity（组不透明）" class="headerlink" title="allowsGroupOpacity（组不透明）"></a>allowsGroupOpacity（组不透明）</h4><p>开启CALayer的 allowsGroupOpacity 属性后，子 layer 在视觉上的透明度的上限是其父 layer 的 opacity (对应UIView的 alpha )，并且从 iOS 7 以后默认全局开启了这个功能，这样做是为了让子视图与其容器视图保持同样的透明度。<br>解决方案:关闭 allowsGroupOpacity 属性，按产品需求自己控制layer透明度。</p>
<h4 id="edge-antialiasing（抗锯齿）"><a href="#edge-antialiasing（抗锯齿）" class="headerlink" title="edge antialiasing（抗锯齿）"></a>edge antialiasing（抗锯齿）</h4><p>解决方案:不设置 allowsEdgeAntialiasing 属性为YES(默认为NO)</p>
<h4 id="CALayer离屏渲染终极解决方案"><a href="#CALayer离屏渲染终极解决方案" class="headerlink" title="CALayer离屏渲染终极解决方案"></a>CALayer离屏渲染终极解决方案</h4><p>当视图内容是静态不变时，设置 shouldRasterize(光栅化)为YES，此方案最为实用方便。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">view.layer.shouldRasterize = true;</span><br><span class="line">view.layer.rasterizationScale = view.layer.contentsScale;</span><br></pre></td></tr></table></figure></p>
<p>但当视图内容是动态变化(如后台下载图片完毕后切换到主线程设置)时，使用此方案反而为增加系统负荷。</p>
<h4 id="CPU离屏渲染的优化手段"><a href="#CPU离屏渲染的优化手段" class="headerlink" title="CPU离屏渲染的优化手段"></a>CPU离屏渲染的优化手段</h4><p>将Core Graphics API(核心绘图)的绘制操作放到后台线程中进行。</p>
<h1 id="解决界面卡顿"><a href="#解决界面卡顿" class="headerlink" title="解决界面卡顿"></a>解决界面卡顿</h1><h2 id="离屏渲染-1"><a href="#离屏渲染-1" class="headerlink" title="离屏渲染"></a>离屏渲染</h2><h3 id="界面显示的原理"><a href="#界面显示的原理" class="headerlink" title="界面显示的原理"></a>界面显示的原理</h3><p>iOS设备通常是60fps(每秒60帧)，也就是说两帧相隔的时间是1/60秒，大概16.7ms。在这16.7ms中，为了显示一帧，需要如下工作：</p>
<ul>
<li>CPU计算好各个视图的位置，大小，对图片进行解码等，绘制成纹理交给GPU</li>
<li>GPU对收到的纹理进行混合，顶点变换，渲染到帧缓冲区</li>
<li>每16.7ms,一个时钟信号到达，帧缓冲区取出一帧，显示到屏幕。<br>也就是说，CPU或者GPU被大量占用的时候，都有可能在16.7ms中没办法完成一帧的绘制，导致时钟信号到来的时候，取得还是上一帧的内容，也就都有可能导致界面卡顿</li>
</ul>
<h3 id="渲染-amp-离屏渲染"><a href="#渲染-amp-离屏渲染" class="headerlink" title="渲染 &amp; 离屏渲染"></a>渲染 &amp; 离屏渲染</h3><p>在iOS中，渲染通常分为CPU和GPU渲染两种，而GPU渲染又分为在GPU缓冲区和非GPU缓冲区两种</p>
<ul>
<li>CPU渲染（软件渲染）,CPU绘制成bitmap，交给GPU</li>
<li>GPU渲染（硬件渲染） <ul>
<li>GPU缓冲区渲染</li>
<li>非GPU缓冲区渲染（额外开辟缓冲区）<br>通常，CPU渲染，和GPU非帧缓冲区内渲染统称为离屏渲染。因为，CPU和帧缓冲区是为图形图像显示做了高度优化的，速度较快。</li>
</ul>
</li>
</ul>
<p>什么情况下会触发离屏幕渲染？</p>
<p>用CoreGraphics的CGContext绘制的<br>在drawRect中绘制的，即使drawRect是空的<br>Layer具有Mask（比如圆角）或者Shadow<br>Layer的隔栅化shouldRasterize为True<br>文本(UILabel,UITextfield,UITextView,CoreText,UITextLayer等)</p>
<h3 id="CoreGraphics-VS-CALayer"><a href="#CoreGraphics-VS-CALayer" class="headerlink" title="CoreGraphics VS CALayer"></a>CoreGraphics VS CALayer</h3><p>上文提到了，CoreGraphics通常是CPU渲染成bitmap交给GPU，假如频繁的大量的绘制出现，往往会导致界面卡顿。而CALayer是对GPU做过优化的，能够硬件加速。所以，对于性能要求较高的绘制，尝试用CALayer替代CoreGraphics</p>
<h2 id="Core-Animation-获取图形绘制情况，FPS，离屏渲染等"><a href="#Core-Animation-获取图形绘制情况，FPS，离屏渲染等" class="headerlink" title="Core Animation(获取图形绘制情况，FPS，离屏渲染等)"></a>Core Animation(获取图形绘制情况，FPS，离屏渲染等)</h2><ul>
<li>Color Blended Layers：图层混合情况，没有混合的部分会是绿色，混合最严重的部分会是红色</li>
<li>Color Hits Green and Misses Red：隔栅化情况，当使用shouldRasterize属性的时候，耗时的图层绘制会被缓存，然后当做一个简单的扁平图片呈现。当缓存无法使用必须重建的时候，会被高亮为红色。</li>
<li>Color Copied Images：拷贝图片情况，有时候寄宿图片的生成意味着Core Animation被强制生成一些图片，然后发送到渲染服务器，而不是简单的指向原始指针。这个选项把这些图片渲染成蓝色。复制图片对内存和CPU使用来说都是一项非常昂贵的操作，所以应该尽可能的避免。</li>
<li>Color Misaligned Images：图片如果有像素不对齐，拉伸和缩放情况，会被高亮成黄色</li>
<li>Color Offscreen-Rendered Yellow：离屏渲染的部分会被高亮成黄色</li>
<li>Color Immediately：设置每帧都更新，通常Core Animation Instruments以每毫秒10次的频率更新图层调试颜色。</li>
<li>Color OpenGL Fast Path Blue ：对任何直接使用OpenGL绘制的图层进行高亮</li>
<li>Flash Updated Region ：对重绘的内容高亮成黄色</li>
</ul>
<h2 id="界面卡顿原因"><a href="#界面卡顿原因" class="headerlink" title="界面卡顿原因"></a>界面卡顿原因</h2><h3 id="CPU限制"><a href="#CPU限制" class="headerlink" title="CPU限制"></a>CPU限制</h3><ul>
<li>对象的创建，释放，属性调整。这里尤其要提一下属性调整，CALayer的属性调整的时候是会创建隐式动画的，是比较损耗性能的。</li>
<li>视图和文本的布局计算，AutoLayout的布局计算都是在主线程上的，所以占用CPU时间也很多 。</li>
<li>文本渲染，诸如UILabel和UITextview都是在主线程渲染的</li>
<li>图片的解码，这里要提到的是，通常UIImage只有在交给GPU之前的一瞬间，CPU才会对其解码。<h3 id="GPU限制"><a href="#GPU限制" class="headerlink" title="GPU限制"></a>GPU限制</h3></li>
<li>视图的混合。比如一个界面十几层的视图叠加到一起，GPU不得不计算每个像素点药显示的像素</li>
<li>离屏渲染。视图的Mask，圆角，阴影。</li>
<li>半透明，GPU不得不进行数学计算，如果是不透明的，CPU只需要取上层的就可以了</li>
<li>浮点数像素</li>
</ul>
<h2 id="界面卡顿优化"><a href="#界面卡顿优化" class="headerlink" title="界面卡顿优化"></a>界面卡顿优化</h2><h3 id="AsyncDisplayKit"><a href="#AsyncDisplayKit" class="headerlink" title="AsyncDisplayKit"></a>AsyncDisplayKit</h3><h3 id="图文混排引擎"><a href="#图文混排引擎" class="headerlink" title="图文混排引擎"></a>图文混排引擎</h3><ul>
<li>YYKit</li>
<li>DTCoreText</li>
</ul>
<h3 id="异步绘制"><a href="#异步绘制" class="headerlink" title="异步绘制"></a>异步绘制</h3><p>把复杂的界面，放到后台线程里绘制成一个bitmap，然后再显示。虽然有些延迟，不过换来的却是平滑的界面。</p>
<h3 id="图片的解码"><a href="#图片的解码" class="headerlink" title="图片的解码"></a>图片的解码</h3><p>建议使用成熟的库，比如SDWebImage等，能够在后台进行图片解码，减少CPU的使用。</p>
<h3 id="预加载与缓存"><a href="#预加载与缓存" class="headerlink" title="预加载与缓存"></a>预加载与缓存</h3><p>对于复杂的TableView，可以对Cell视图的各个控件的大小，位置后台进行预计算，并且缓存起来。这样保证在heightForRow和cellForRow中不进行大量的计算。</p>
<h3 id="尽量使用CALayer"><a href="#尽量使用CALayer" class="headerlink" title="尽量使用CALayer"></a>尽量使用CALayer</h3><p>因为Layer是一个轻量级的视图结构，它不接受通知，不接受触摸，不在响应链。所以，相对于UIView来说，它的性能较好。并且CALayer及其子类是可以使用GPU渲染的，能够硬件加速。</p>
<h3 id="图层预合成"><a href="#图层预合成" class="headerlink" title="图层预合成"></a>图层预合成</h3><p>将两个CALayer的内容合成到一个Bitmap里，然后显示。能够减轻GPU的压力</p>
<h1 id="Texture-AsyncDisplayKit"><a href="#Texture-AsyncDisplayKit" class="headerlink" title="Texture(AsyncDisplayKit)"></a>Texture(AsyncDisplayKit)</h1><p>一些影响流畅性的关键点：</p>
<ul>
<li>网络请求，大部分网络请求都应该使用后台线程完成，如果你使用的是 AFNetworking、 SDWebImage 这些开源缓存库，那么切换到后台去请求网络资源的操作都已经默认完成。</li>
<li>本地数据读写和计算，当你需要从闪存中读取文件的时候，这些操作都应该使用GCD或者NSThread切换至后台线程中完成。</li>
<li>图像的处理，尽量使用合适的UIImage给予UIImageView使用</li>
<li>Layer 属性的谨慎选择，不合理的 Layer 特效（阴影、圆角）都会使流畅的滑动变成卡顿（非常重要）。</li>
<li>少用 UIView.backgroundColor = UIColor.clearColor()，透明的背景会加剧卡顿。</li>
<li>文字的渲染，你可能不知道，文字的渲染也是需要开销的。一般来说，文字渲染的开销非常小，甚至不能察觉到。但是，当一个UILabel被赋予大段富文本文字后，开销就会非常大。</li>
<li>图像的渲染，一个任何开发者、几乎所有库（包括SDWebImage）都无法解决的问题，图像在UIImageView中的渲染开销，并且图像的渲染只能在主线程中执行。</li>
</ul>
<p>控件对应关系：<br>UIKit —— AsyncDisplayKit<br>UIView —— ASDisplayNode<br>UILabel —— ASTextNode ：在TextKit上支持所有的富文本特性<br>UIImageView —— ASImageNode：异步的图像解码<br>UIButton —— ASButtonNode<br>UITableView —— ASTableView<br>UICollectionView —— ASCollectionView<br>UITableViewCell —— ASCellNode<br>UICollectionViewCell —— ASCellNode</p>
<h2 id="Layout-Specs（布局规则）"><a href="#Layout-Specs（布局规则）" class="headerlink" title="Layout Specs（布局规则）"></a>Layout Specs（布局规则）</h2><p>ASInsetLayoutSpec（插入布局规则）<br>ASOverlayLayoutSpec（覆盖布局规则）<br>ASBackgroundLayoutSpec（背景布局规则）<br>ASCenterLayoutSpec（中心布局规则）<br>ASRatioLayoutSpec（比例布局规则）<br>ASRelativeLayoutSpec（相对布局规则）<br>ASStackLayoutSpec（堆叠布局规则）<br>ASAbsoluteLayoutSpec（绝对布局约束)<br>ASLayoutSpec（布局规则）<br>Layout Element Properties（布局元素属性）<br>ASStackLayoutElement Properties（堆叠布局元素属性）<br>ASAbsoluteLayoutElement Properties（绝对布局元素属性）<br>ASLayoutElement Properties（布局元素属性）</p>
<p><a href="https://www.jianshu.com/p/afc69cd9e824" target="_blank" rel="noopener">AsyncDisplaykit2.0(Texture)使用「复杂界面流畅性」</a></p>
<p>参考文章：<a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">iOS 保持界面流畅的技巧</a><br><a href="https://www.jianshu.com/p/ca51c9d3575b" target="_blank" rel="noopener">离屏渲染优化详解：实例示范+性能测试</a><br><a href="https://blog.csdn.net/shaobo8910/article/details/66975785" target="_blank" rel="noopener">iOS性能优化：Instrument 调试界面卡顿</a><br><a href="https://zsisme.gitbooks.io/ios-/content/chapter12/instruments.html" target="_blank" rel="noopener">ios核心动画高级技巧</a><br><a href="https://didee.cn/2018/01/29/iOS-ASDK/" target="_blank" rel="noopener">iOS 开发一定要尝试的 Texture(ASDK)</a></p>

      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/优化/" rel="tag"># 优化</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/12/18/iOS富文本的使用/" rel="next" title="iOS富文本的使用">
                <i class="fa fa-chevron-left"></i> iOS富文本的使用
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/01/04/Leetcode笔记/" rel="prev" title="Leetcode笔记">
                Leetcode笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="谷春丽">
          <p class="site-author-name" itemprop="name">谷春丽</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">114</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">52</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        <div id="days"></div>
<script>
function show_date_time(){
window.setTimeout("show_date_time()", 1000);
BirthDay=new Date("05/27/2017 15:13:14");
today=new Date();
timeold=(today.getTime()-BirthDay.getTime());
sectimeold=timeold/1000
secondsold=Math.floor(sectimeold);
msPerDay=24*60*60*1000
e_daysold=timeold/msPerDay
daysold=Math.floor(e_daysold);
e_hrsold=(e_daysold-daysold)*24;
hrsold=setzero(Math.floor(e_hrsold));
e_minsold=(e_hrsold-hrsold)*60;
minsold=setzero(Math.floor((e_hrsold-hrsold)*60));
seconds=setzero(Math.floor((e_minsold-minsold)*60));
document.getElementById('days').innerHTML="已运行"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒";
}
function setzero(i){
if (i<10)
{i="0" + i};
return i;
}
show_date_time();
</script>


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#屏幕显示图像原理"><span class="nav-number">1.</span> <span class="nav-text">屏幕显示图像原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU资源消耗原因和解决方案"><span class="nav-number">2.</span> <span class="nav-text">CPU资源消耗原因和解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对象创建"><span class="nav-number">2.1.</span> <span class="nav-text">对象创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象调整"><span class="nav-number">2.2.</span> <span class="nav-text">对象调整</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象销毁"><span class="nav-number">2.3.</span> <span class="nav-text">对象销毁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#布局计算"><span class="nav-number">2.4.</span> <span class="nav-text">布局计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#autolayout"><span class="nav-number">2.5.</span> <span class="nav-text">autolayout</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文本计算"><span class="nav-number">2.6.</span> <span class="nav-text">文本计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文本渲染"><span class="nav-number">2.7.</span> <span class="nav-text">文本渲染</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图片解码"><span class="nav-number">2.8.</span> <span class="nav-text">图片解码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图片绘制"><span class="nav-number">2.9.</span> <span class="nav-text">图片绘制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GPU资源消耗原因和解决方案"><span class="nav-number">3.</span> <span class="nav-text">GPU资源消耗原因和解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#纹理的渲染"><span class="nav-number">3.1.</span> <span class="nav-text">纹理的渲染</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#视图的混合"><span class="nav-number">3.2.</span> <span class="nav-text">视图的混合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图形的生成"><span class="nav-number">3.3.</span> <span class="nav-text">图形的生成</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AsyncDisplayKit-ASDK"><span class="nav-number">4.</span> <span class="nav-text">AsyncDisplayKit(ASDK)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#预排版"><span class="nav-number">5.</span> <span class="nav-text">预排版</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#product-gt-profile"><span class="nav-number">6.</span> <span class="nav-text">product-&gt;profile</span></a></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#提高列表滚动流畅度"><span class="nav-number"></span> <span class="nav-text">提高列表滚动流畅度</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#避免重复多次计算-cell-行高"><span class="nav-number">1.</span> <span class="nav-text">避免重复多次计算 cell 行高</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文本异步渲染"><span class="nav-number">2.</span> <span class="nav-text">文本异步渲染</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#离屏渲染"><span class="nav-number">3.</span> <span class="nav-text">离屏渲染</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#离屏渲染的检测手段"><span class="nav-number">3.1.</span> <span class="nav-text">离屏渲染的检测手段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#离屏渲染的优化手段"><span class="nav-number">3.2.</span> <span class="nav-text">离屏渲染的优化手段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#shadows（阴影）"><span class="nav-number">3.2.1.</span> <span class="nav-text">shadows（阴影）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#masksToBounds-true-cornerRadius-gt-0"><span class="nav-number">3.2.2.</span> <span class="nav-text">masksToBounds = true +  cornerRadius &gt; 0</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mask（遮罩）"><span class="nav-number">3.2.3.</span> <span class="nav-text">mask（遮罩）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#allowsGroupOpacity（组不透明）"><span class="nav-number">3.2.4.</span> <span class="nav-text">allowsGroupOpacity（组不透明）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#edge-antialiasing（抗锯齿）"><span class="nav-number">3.2.5.</span> <span class="nav-text">edge antialiasing（抗锯齿）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CALayer离屏渲染终极解决方案"><span class="nav-number">3.2.6.</span> <span class="nav-text">CALayer离屏渲染终极解决方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CPU离屏渲染的优化手段"><span class="nav-number">3.2.7.</span> <span class="nav-text">CPU离屏渲染的优化手段</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#解决界面卡顿"><span class="nav-number"></span> <span class="nav-text">解决界面卡顿</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#离屏渲染-1"><span class="nav-number">1.</span> <span class="nav-text">离屏渲染</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#界面显示的原理"><span class="nav-number">1.1.</span> <span class="nav-text">界面显示的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#渲染-amp-离屏渲染"><span class="nav-number">1.2.</span> <span class="nav-text">渲染 &amp; 离屏渲染</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CoreGraphics-VS-CALayer"><span class="nav-number">1.3.</span> <span class="nav-text">CoreGraphics VS CALayer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Core-Animation-获取图形绘制情况，FPS，离屏渲染等"><span class="nav-number">2.</span> <span class="nav-text">Core Animation(获取图形绘制情况，FPS，离屏渲染等)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#界面卡顿原因"><span class="nav-number">3.</span> <span class="nav-text">界面卡顿原因</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU限制"><span class="nav-number">3.1.</span> <span class="nav-text">CPU限制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GPU限制"><span class="nav-number">3.2.</span> <span class="nav-text">GPU限制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#界面卡顿优化"><span class="nav-number">4.</span> <span class="nav-text">界面卡顿优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AsyncDisplayKit"><span class="nav-number">4.1.</span> <span class="nav-text">AsyncDisplayKit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图文混排引擎"><span class="nav-number">4.2.</span> <span class="nav-text">图文混排引擎</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异步绘制"><span class="nav-number">4.3.</span> <span class="nav-text">异步绘制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图片的解码"><span class="nav-number">4.4.</span> <span class="nav-text">图片的解码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#预加载与缓存"><span class="nav-number">4.5.</span> <span class="nav-text">预加载与缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#尽量使用CALayer"><span class="nav-number">4.6.</span> <span class="nav-text">尽量使用CALayer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图层预合成"><span class="nav-number">4.7.</span> <span class="nav-text">图层预合成</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Texture-AsyncDisplayKit"><span class="nav-number"></span> <span class="nav-text">Texture(AsyncDisplayKit)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Layout-Specs（布局规则）"><span class="nav-number">1.</span> <span class="nav-text">Layout Specs（布局规则）</span></a></li></ol></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">谷春丽</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共166.3k字</span>
</div>
        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  









  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/three/three.min.js"></script>

  
  <script type="text/javascript" src="/lib/three/three-waves.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (search_path.endsWith("json")) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  


  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/src/clicklove.js"></script>
  <!--  -->

<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"tagMode":false});</script></body>
</html>
