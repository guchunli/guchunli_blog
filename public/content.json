[{"title":"iOS使定时器NSTimer在程序进入后台仍然运行的方法","date":"2017-07-05T08:16:46.000Z","path":"2017/07/05/iOS使定时器NSTimer在程序进入后台仍然运行的方法/","text":"1.Info.plist中，Required background modes添加App plays audio or streams audio/video using AirPlay2.- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions中添加以下代码：12345678910NSError *setCategoryErr = nil;NSError *activationErr = nil;[[AVAudioSession sharedInstance]setCategory: AVAudioSessionCategoryPlaybackerror: &amp;setCategoryErr];[[AVAudioSession sharedInstance]setActive: YESerror: &amp;activationErr];self.window.backgroundColor = [UIColor whiteColor];[self.window makeKeyAndVisible]; 3.程序进入后台进行以下操作12345678910111213141516171819202122232425262728- (void)applicationDidEnterBackground:(UIApplication *)application &#123; UIApplication* app = [UIApplication sharedApplication]; __block UIBackgroundTaskIdentifier bgTask; /*注册一个后台任务，告诉系统我们需要向系统借一些事件*/ bgTask = [app beginBackgroundTaskWithExpirationHandler:^&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; if (bgTask != UIBackgroundTaskInvalid) &#123; /*销毁后台任务标识符*/ /*不管有没有完成，结束background_task任务*/ bgTask = UIBackgroundTaskInvalid; &#125; &#125;); &#125;]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; if (bgTask != UIBackgroundTaskInvalid) &#123; /*销毁后台任务标识符*/ /*不管有没有完成，结束background_task任务*/ bgTask = UIBackgroundTaskInvalid; &#125; &#125;); &#125;);&#125;","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"NSTimer","slug":"NSTimer","permalink":"https://guchunli.github.io/tags/NSTimer/"},{"name":"后台","slug":"后台","permalink":"https://guchunli.github.io/tags/后台/"}]},{"title":"iOS动画笔记","date":"2017-07-05T07:15:27.000Z","path":"2017/07/05/iOS动画笔记/","text":"","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"动画","slug":"动画","permalink":"https://guchunli.github.io/tags/动画/"}]},{"title":"OC与JS交互的几种方法","date":"2017-07-04T03:59:35.000Z","path":"2017/07/04/OC与JS交互的几种方法/","text":"OC与JS交互的几种方法1.JavaScriptCore2.WebViewJavascriptBridge JavaScriptCore通过JSContext实现OC与JS的交互1.在webViewDidFinishLoad方法中创建JSContext对象,获取该UIWebview的javascript执行环境1234567891011- (void)webViewDidFinishLoad:(UIWebView *)webView &#123; //通过当前webView的键获取到jscontext self.jsContext = [webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;]; //以后JS就可以通过 OCModel 调用OC方法 self.jsContext[@&quot;OCModel&quot;] = self; self.jsContext.exceptionHandler = ^(JSContext *context, JSValue *exceptionValue) &#123; context.exception = exceptionValue; NSLog(@&quot;异常信息：%@&quot;, exceptionValue); &#125;;&#125;; 2.OC调用JS方法并传递一个参数JS方法：123function getImg(path)&#123; //document.getElementById(&quot;test&quot;).src=path;&#125; OC通过evaluateScript调用JS方法：12NSString *alertJS=[NSString stringWithFormat:@&quot;getImg(&apos;%@&apos;)&quot;,@&quot;abc&quot;]; //准备执行的js代码[self.jsContext evaluateScript:alertJS]; 3.JS调用OC方法并传递一个参数OC方法：123- (void)getImg:(NSString *)source&#123; NSLog(@&quot;%@&quot;,source);&#125; JS通过OCModel调用OC方法：123function getGalleryImg()&#123; OCModel.getImg(&apos;gallery&apos;);&#125; 通过request的URL实现交互JS代码:1234567891011&lt;script&gt;//触发该方法，调用OC中webview的`shouldStartLoadWithRequest`方法实现与OC交互function goCamera()&#123; window.location.href=&quot;js-call://camera/cameraCallback&quot;;&#125;//OC回调的JS方法function cameraCallback(data) &#123; //获取到OC传递过来的参数 alert(data);&#125;&lt;/script&gt; OC代码:123456789101112131415161718192021222324- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType&#123; NSString *requestString = [[request URL] absoluteString]; //jS协议头 NSString *protocol = @&quot;js-call://&quot;; //请求的字符串符合协议头 if ([requestString hasPrefix:protocol]) &#123; //从协议头后的位置截取字符串到最后 NSString *requestContent = [requestString substringFromIndex:[protocol length]]; //将/分隔的字符串转换成数组 NSArray *vals = [requestContent componentsSeparatedByString:@&quot;/&quot;]; if ([[vals objectAtIndex:0] isEqualToString:@&quot;camera&quot;]) &#123; //获取到回调方法：cameraCallback callback = [vals objectAtIndex:1]; //OC回调JS方法，并传递一个参数 [_webView stringByEvaluatingJavaScriptFromString:[NSString stringWithFormat:@&quot;%@(&apos;%@&apos;);&quot;, callback, @&quot;abc&quot;]]; &#125; else &#123; [webView stringByEvaluatingJavaScriptFromString:@&quot;alert(&apos;未定义&apos;);&quot;]; &#125; return NO; &#125; return YES;&#125; WebViewJavascriptBridge1.通过cocoapods或手动导入WebViewJavascriptBridge框架2.OC端:创建webview,与bridge对象建立联系123456// 开启日志[WebViewJavascriptBridge enableLogging];// 指定webview，建立JS与OjbC的沟通桥梁self.bridge = [WebViewJavascriptBridge bridgeForWebView:webView];[self.bridge setWebViewDelegate:self]; 3.JS端：创建setupWebViewJavascriptBridge1234567891011121314151617181920212223242526272829303132333435&lt;script&gt;window.onerror = function(err) &#123;log(&apos;window.onerror: &apos; + err)&#125;/*这段代码是固定的，必须要放到js中*/function setupWebViewJavascriptBridge(callback) &#123;if (window.WebViewJavascriptBridge) &#123; return callback(WebViewJavascriptBridge); &#125;if (window.WVJBCallbacks) &#123; return window.WVJBCallbacks.push(callback); &#125;window.WVJBCallbacks = [callback];var WVJBIframe = document.createElement(&apos;iframe&apos;);WVJBIframe.style.display = &apos;none&apos;;WVJBIframe.src = &apos;wvjbscheme://__BRIDGE_LOADED__&apos;;document.documentElement.appendChild(WVJBIframe);setTimeout(function() &#123; document.documentElement.removeChild(WVJBIframe) &#125;, 0)&#125;/*与OC交互的所有JS方法都要放在此处注册，才能调用通过JS调用OC方法或者让OC调用这里的JS方法*/setupWebViewJavascriptBridge(function(bridge) &#123; //在这注册OC调用JS的方法，可以接收OC传过来的参数 data ，还可以通过 responseCallback 回调OC /* bridge.registerHandler(&apos;JSFunction&apos;, function(data, responseCallback) &#123; responseCallback(&#123;&apos;&apos;: &apos;&apos;&#125;) &#125; */ //这里可以调用OC方法，OC端在处理完成后，反馈给JS，这样写是在载入页面完成时就先调用 document.getElementById(&apos;btn&apos;).onclick = function (e) &#123; bridge.callHandler(&apos;OCFunction&apos;, &#123;&apos;js&apos;: &apos;abc&apos;&#125;, function(response) &#123; alert(response) &#125;)&#125;&lt;/script&gt; 3.JS调用OC方法bridge通过registerHandler注册提供给JS调用的方法OC端通过responseCallback回调JS，JS就可以得到所需要的数据OC方法：1234567[self.bridge registerHandler:@&quot;JSCallOC&quot; handler:^(id data, WVJBResponseCallback responseCallback) &#123; NSLog(@&quot;%@&quot;, data); //js-oc,abc if (responseCallback) &#123; // 回调给JS responseCallback(@&#123;@&quot;oc-js&quot;: @&quot;123&quot;&#125;); &#125;&#125;]; JS调用OC方法：123bridge.callHandler(&apos;JSCallOC&apos;, &#123;&apos;js-oc&apos;: &apos;abc&apos;&#125;, function(responseData) &#123; alert(responseData) //oc-js,123&#125;) 4.OC调用JS方法JS方法：12345/*JS给ObjC提供公开的API，在ObjC端可以手动调用JS的这个API。接收ObjC传过来的参数，且可以回调ObjC*/bridge.registerHandler(&apos;OCCallJS&apos;, function(data, responseCallback) &#123; alert(data) //oc-js,123 responseCallback(&#123;&apos;a&apos;: &apos;1&apos;, &apos;b&apos;: &apos;2&apos;&#125;)&#125;) OC调用JS方法：123[self.bridge callHandler:@&quot;OCCallJS&quot; data:@&#123;@&quot;oc-js&quot;: @&quot;123&quot;&#125; responseCallback:^(id responseData) &#123; NSLog(@&quot;%@&quot;, responseData); //&apos;a&apos;: &apos;1&apos;, &apos;b&apos;: &apos;2&apos;&#125;];","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"OC","slug":"OC","permalink":"https://guchunli.github.io/tags/OC/"},{"name":"JS","slug":"JS","permalink":"https://guchunli.github.io/tags/JS/"}]},{"title":"OpenGL学习笔记","date":"2017-07-03T10:23:19.000Z","path":"2017/07/03/OpenGL学习笔记/","text":"1.GPUImage底层使用的是OPENGL,操控GPU来实现屏幕展示 01-自定义图层类型02-初始化CAEAGLLayer图层属性03-创建EAGLContext04-创建渲染缓冲区05-创建帧缓冲区06-创建着色器07-创建着色器程序08-创建纹理对象09-YUV转RGB绘制纹理10-渲染缓冲区到屏幕11-清理内存","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"OpenGL","slug":"OpenGL","permalink":"https://guchunli.github.io/tags/OpenGL/"}]},{"title":"iBeacon学习笔记","date":"2017-07-03T03:05:55.000Z","path":"2017/07/03/iBeacon学习笔记/","text":"","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"iBeacon","slug":"iBeacon","permalink":"https://guchunli.github.io/tags/iBeacon/"}]},{"title":"OC中的block","date":"2017-07-01T06:59:03.000Z","path":"2017/07/01/OC中的block/","text":"1.block定义：returnType(^blockName)(parameterTypes) = ^(parameters) {};2.block用copy修饰，delegate用weak修饰3.MRC环境下：(1)block引用局部变量局部变量a:block代码块中使用局部变量,会自动拷贝一份到常量区,所以不可改变量如果要修改局部变量，需要加__block修饰变量12345__block int number = 10;void (^myBlock)(void) = ^(void) &#123;number = 20; //不用__block，则不能修改NSLog(@&quot;%d&quot;,number);;&#125;; (2)block中引用一个局部OC对象该对象会被retain，如果局部变量使用__block修饰，则不会retain12345__block NSObject *obj = [[NSObject alloc]init];void (^myBlock)(void) = ^(void) &#123;NSLog(@&quot;%ld&quot;,obj.retainCount); //不用__block，则为2&#125;;myBlock(); (3)block中引用一个全局变量在block代码块中使用全局变量或方法时,会将这个变量或方法所在的对象self引用计数加1,引起循环引用解决方法:使用__block修饰self1__block SecondViewController *weakSelf =self; 4.ARC环境下：(1)在block中引用局部变量，同MRC需要__block修饰(2)在block中引用局部对象，不用加__block(3)在block中引用全局变量，1234567891011121314151617_index = 1;__weak SecondViewController *weakThis = self;[btn addTapAction:^(UIButton *btn) &#123;//可修改值,但控制器不销毁,发生了循环引用// _index = 2;// NSLog(@&quot;index:%ld&quot;,_index);//属性__strong SecondViewController *strongThis = weakThis;strongThis-&gt;_index = 2;NSLog(@&quot;index:%ld&quot;,strongThis-&gt;_index);//方法//[weakThis test];[strongThis test];&#125;]; 5.weak与block区别MRC，block 修饰，可以避免循环引用；ARC，block 修饰，同样会引起循环引用问题；block不管是ARC还是MRC模式下都可以使用，可以修饰对象，还可以修饰基本数据类型； weak只能在ARC模式下使用，也只能修饰对象，不能修饰基本数据类型；(1)block下循环引用的问题block本身并不能避免循环引用，避免循环引用需要在block内部把block修饰的obj置为nilweak可以避免循环引用，但是其会导致外部对象释放了之后，block 内部也访问不到这个对象的问题，我们可以通过在 block 内部声明一个 strong的变量来指向 weakObj，使外部对象既能在 block 内部保持住，又能避免循环引用的问题(2)block与weak功能上的区别。block会持有该对象，即使超出了该对象的作用域，该对象还是会存在的，直到block对象从堆上销毁；而weak仅仅是将该对象赋值给weak对象，当该对象销毁时，weak对象将指向nil；block可以让block修改局部变量，而weak不能。另外，MRC中block是不会引起retain；但在ARC中block则会引起retain。所以ARC中应该使用__weak。","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"OC","slug":"OC","permalink":"https://guchunli.github.io/tags/OC/"},{"name":"block","slug":"block","permalink":"https://guchunli.github.io/tags/block/"}]},{"title":"iOS多线程学习笔记","date":"2017-06-30T08:45:27.000Z","path":"2017/06/30/iOS多线程学习笔记/","text":"多线程的三种使用方式：NSThread，NSOperationQueue和NSOperation，GCD。一、NSThread1.创建线程的三种方式（1）创建、启动线程123NSThread* myThread = [[NSThread alloc] initWithTarget:self selector:@selector(doSomething:) object:nil]; //设置线程优先级、线程名称等信息[myThread start]; （2）创建线程后自动启动线程1[NSThread detachNewThreadSelector:@selector(doSomething:) toTarget:self withObject:nil]; （3）隐式创建并启动线程1[self performSelectorInBackground:@selector(doSomething) withObject:nil]; 注意：三种创建方式都只能传一个参数，如果需要传递多参数，可以封装一个对象将多个参数保存起来。 2.回到主线程1[self performSelectorOnMainThread:@selector(updateUI:) withObject:image waitUntilDone:YES]; 获取主线程：[NSThread mainThread]3.线程间通讯使用performSelector: onThread: withObject: waitUntilDone: 方法4.线程同步加锁，三种方式：（1）NSLock注意：lock和unlock之间的”加锁代码“应该是抢占资源的读取和修改代码，不要将过多的其他操作代码放到里面，否则一个线程执行的时候另一个线程就一直在等待，就无法发挥多线程的作用了。1234theLock = [[NSLock alloc] init]; [theLock lock]; //dosomething[theLock unlock]; （2）NSCondition12345ticketsCondition = [[NSCondition alloc] init]; [ticketsCondition lock]; //dosomething[ticketsCondition unlock]; // [ticketsCondition signal]; 发送信号的方式，在一个线程唤醒另外一个线程的等待，即[ticketsCondition wait]。 （3）@synchronized：更简单，推荐1234@synchronized(anObj)&#123;// Everything between the braces is protected by the @synchronized directive.&#125; （4）iOS中的其他类型锁NSRecursiveLock ：递归锁，有时候“加锁代码”中存在递归调用，递归开始前加锁，递归调用开始后会重复执行此方法以至于反复执行加锁代码最终造成死锁，这个时候可以使用递归锁来解决。使用递归锁可以在一个线程中反复获取锁而不造成死锁，这个过程中会记录获取锁和释放锁的次数，只有最后两者平衡锁才被最终释放。NSDistributedLock：分布锁，它本身是一个互斥锁，基于文件方式实现锁机制，可以跨进程访问。pthread_mutex_t：同步锁，基于C语言的同步锁机制，使用方法与其他同步锁机制类似。 5.延迟执行（1）调用NSObject的方法:1[self performSelector:@selector(run) withObject:nil afterDelay:2.0]; （2）12[NSThread sleepForTimeInterval:2.0];[NSThread sleepUntilDate:(NSDate*)date] (6)死亡：+ (void)exit() 二、NSOperationQueue和NSOperation1.创建NSOperation的两个子类：NSInvocationOperation 和 NSBlockOperation。（1）NSInvocationOperation1234567891011/*创建一个调用操作object:调用方法参数*/NSInvocationOperation *invocationOperation=[[NSInvocationOperation alloc]initWithTarget:self selector:@selector(loadImage) object:nil];//创建完NSInvocationOperation对象并不会调用，它由一个start方法启动操作，但是注意如果直接调用start方法，则此操作会在主线程中调用，一般不会这么操作,而是添加到NSOperationQueue中// [invocationOperation start];//创建操作队列NSOperationQueue *operationQueue=[[NSOperationQueue alloc]init];//注意添加到操作队后，队列会开启一个线程执行此操作[operationQueue addOperation:invocationOperation]; （2）NSBlockOperation：相比NSInvocationOperation 更简单，推荐12345678910111213//方法1：创建操作块添加到队列// //创建多线程操作// NSBlockOperation *blockOperation=[NSBlockOperation blockOperationWithBlock:^&#123;// [self loadImage:[NSNumber numberWithInt:i]];// &#125;];// //创建操作队列//// [operationQueue addOperation:blockOperation];//方法2：直接使用操队列添加操作[operationQueue addOperationWithBlock:^&#123;[self loadImage:[NSNumber numberWithInt:i]];&#125;]; （3）继承NSOperation在.m文件中实现main方法，main方法编写要执行的代码。 2.设置并发数1[queue setMaxConcurrentOperationCount:5]; 默认情况下是-1，-1表示没有限制，这样会同时运行队列中的全部的操作。 3.线程执行顺序每个NSOperation可以设置依赖线程。假设操作A依赖于操作B，线程操作队列在启动线程时就会首先执行B操作，然后执行A。以下代码实现了优先加载最后一张图片：1234567891011121314151617181920212223-(void)loadImageWithMultiThread&#123;int count=ROW_COUNT*COLUMN_COUNT;//创建操作队列NSOperationQueue *operationQueue=[[NSOperationQueue alloc]init];operationQueue.maxConcurrentOperationCount=5;//设置最大并发线程数NSBlockOperation *lastBlockOperation=[NSBlockOperation blockOperationWithBlock:^&#123; [self loadImage:[NSNumber numberWithInt:(count-1)]];&#125;];//创建多个线程用于填充图片for (int i=0; i&lt;count-1; ++i) &#123;//方法1：创建操作块添加到队列//创建多线程操作NSBlockOperation *blockOperation=[NSBlockOperation blockOperationWithBlock:^&#123;[self loadImage:[NSNumber numberWithInt:i]];&#125;];//设置依赖操作为最后一张图片加载操作[blockOperation addDependency:lastBlockOperation];[operationQueue addOperation:blockOperation];&#125;//将最后一个图片的加载操作加入线程队列[operationQueue addOperation:lastBlockOperation];&#125; 三、GCD1.dispatch queuedispatch queue分为下面三种：Serial，Concurrent，main，global（1）Serial又称为private dispatch queues，同时只执行一个任务。通常用于同步访问特定的资源或数据。当你创建多个Serial queue时，虽然它们各自是同步执行的，但Serial queue与Serial queue之间是并发执行的。（2）Concurrent可以并发地执行多个任务，但是执行完成的顺序是随机的。（3）Main dispatch queue主线程，它是全局可用的serial queue。1dispatch_queue_t mainQ = dispatch_get_main_queue(); （4）global dispatch queue系统给每一个应用程序提供了三个concurrent dispatch queues。这三个并发调度队列是全局的，它们只有优先级的不同。因为是全局的，我们不需要去创建。我们只需要通过使用函数dispath_get_global_queue去得到队列。1dispatch_queue_t globalQ = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); 2.dispatch_group_async可以实现监听一组任务是否完成，完成后得到通知执行其他的操作1234567891011121314151617dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_group_t group = dispatch_group_create(); dispatch_group_async(group, queue, ^&#123; [NSThread sleepForTimeInterval:1]; NSLog(@&quot;group1&quot;); &#125;); dispatch_group_async(group, queue, ^&#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;group2&quot;); &#125;); dispatch_group_async(group, queue, ^&#123; [NSThread sleepForTimeInterval:3]; NSLog(@&quot;group3&quot;); &#125;); dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; NSLog(@&quot;updateUi&quot;); &#125;); 3.dispatch_barrier_async在前面的任务执行结束后它才执行，而且它后面的任务等它执行完成之后才会执行123456789101112131415161718dispatch_queue_t queue = dispatch_queue_create(&quot;gcdtest.rongfzh.yc&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^&#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;dispatch_async1&quot;); &#125;); dispatch_async(queue, ^&#123; [NSThread sleepForTimeInterval:4]; NSLog(@&quot;dispatch_async2&quot;); &#125;); dispatch_barrier_async(queue, ^&#123; NSLog(@&quot;dispatch_barrier_async&quot;); [NSThread sleepForTimeInterval:4]; &#125;); dispatch_async(queue, ^&#123; [NSThread sleepForTimeInterval:1]; NSLog(@&quot;dispatch_async3&quot;); &#125;); 4.dispatch_apply执行某个代码片段N次。注意：这个方法没有办法异步执行（为了不阻塞线程可以使用dispatch_async()包装一下再执行）123dispatch_apply(5, globalQ, ^(size_t index) &#123;// 执行5次&#125;); 5.dispatch_time()： 延迟一定的时间后执行。123456789dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 3*NSEC_PER_SEC);dispatch_after(time, dispatch_get_main_queue(), ^&#123;NSLog(@&quot;3秒后添加到队列&quot;);&#125;); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;// 2秒后异步执行这里的代码... &#125;); 6.一次性代码1234static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123;// 只执行1次的代码(这里面默认是线程安全的)&#125;); 7.dispatch_suspend(myQueue)： 挂起队列8.dispatch_resume(myQueue)：恢复队列 注意：调用dispatch_suspend会增加队列挂起的引用计数，而调用dispatch_resume则会减少引用计数，当引用计数大于0时，队列会保持挂起状态。因此，这队列的挂起和恢复中，我们需要小心使用以避免引用计数计算错误的出现。参考链接：荣芳志专栏中的文章 iOS开发系列–并行开发其实很容易","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"多线程","slug":"多线程","permalink":"https://guchunli.github.io/tags/多线程/"}]},{"title":"iOS面试知识点总结","date":"2017-06-30T06:31:59.000Z","path":"2017/06/30/iOS面试知识点总结/","text":"1.category与extension的区别 category可以不用继承系统类，直接给系统类添加方法，最大程度的体现了Objective-C的动态语言特性。可以用来定义私有方法。 extension为一个类增加私有方法,属性或成员变量,并且新添加的方法一定要予以实现。Extension都是放在.m文件中@implementation的上方。区别：Extension可以添加属性。另外Extension添加的方法是必须要实现的。2.OC中的私有变量用@private修饰，私有方法用category 3.NSInteger是基本数据类型Int或者Long的别名(NSInteger的定义typedef long NSInteger)，它的区别在于，NSInteger会根据系统是32位还是64位来决定是本身是int还是Long。 4.block 5.Objective-C的内存管理(1)主要有三种方式ARC(自动内存计数)、手动内存计数、内存池内存管理机制；当使用new,alloc和copy方法创建一个对象时,该对象的保留计数器值为1.当不再使用该对象时,要负责向该对象发送一条release或autorelease消息.这样,该对象将在使用寿命结束时被销毁.(2)堆与栈 栈:是由编译器自动管理，无需我们手工控制； 堆:释放工作由程序员控制，容易产生memory leak。6.属性关键字(1)atomic/nonatomic atomic提供多线程安全。是防止在未写完的时候被另外一个线程读取，造成数据错误 non-atomic:在自己管理内存的环境中，解析的访问器保留并自动释放返回的值，如果指定了 nonatomic ，那么访问器只是简单地返回这个值(2)assign/weak 用assign声明的变量在栈中可能不会自动赋值为nil，就会造成野指针错误 用weak声明的变量在栈中会自动清空，赋值为nilassigin 可以用非OC对象,而weak必须用于OC对象在ARC中,在有可能出现循环引用的时候,往往要通过让其中一端使用weak来解决,比如:delegate代理属性(3)浅复制和深复制的区别? 浅层复制：只复制指向对象的指针，而不复制引用对象本身。 深层复制：复制引用对象本身。(4)copy/mutableCopy copy是指针复制（浅拷贝） mutableCopy就是对象复制（深拷贝） 7.多态：不同对象以自己的方式响应相同的消息的能力叫做多态。子类指针可以赋值给父类对象。主要是将数据类型的确定由编译时，推迟到了运行时。(1)对于语句NSString*obj = [[NSData alloc] init]; obj在编译时和运行时分别时什么类型的对象?答：编译时是NSString的类型;运行时是NSData类型的对象。(2)id声明的对象具有运行时的特性，即可以指向任意类型的objcetive-c的对象.8.NSObject方法类方法：alloc,class,description实例方法：init,dealloc,performSelector 9.通知与协议 协议有控制链(has-a)的关系，通知没有。 通知：一对多。代理/block：一对一。 OC中的多继承用委托代理实现 10.事件的传递与响应传递：application-&gt;window-&gt;controller-&gt;view响应：view-&gt;controller-&gt;window-&gt;application重写hitTest:withEvent:方法 11.延迟加载：用到的时候才去初始化。延迟加载可以避免内存过高，异步加载可以避免线程堵塞。 多线程(1)Object C中创建线程的方法是什么?如果在主线程中执行代码，方法是什么?如果想延时执行代码、方法又是什么?答：线程创建有三种方法 使用NSThread创建 使用GCD的dispatch 使用子类化的NSOperation,然后将其加入NSOperationQueue;(2)在主线程执行代码，方法是performSelectorOnMainThread如果想延时执行代码可以用performSelector:onThread:withObject:waitUntilDone:(3)进程与线程进程有独立的地址空间线程有自己的堆栈和局部变量(4)队列：串行、并行、全局、主队列 13.持久化存储机制：存到文件，存到NSUserDeaults(plist文件)，sqlite数据库NSUserDeaults数据存储在沙盒library下的Preferences文件夹。沙盒目录：documents、library(chches,preferences),tmpSDWebImage原理：内存中找-&gt;沙盒中找，缓存到内存-&gt;网络上获取，缓存到内存，缓存到沙盒 14.网络(1)发起网络请求的对象：AFHTTPSessionManager、ASIHTTPRequest与NSURLConnection(2)http与socket http:短连接，请求方式为客户端主动发起请求，服务器才能给响应，一次请求完毕后则断开连接，以节省资源。服务器不能主动给客户端响应（除非采取http长连接 技术） socket:长连接，客户端和服务器可以保持连接通道，双方 都可以主动发送数据 15.fmmpeg框架答：音视频编解码框架，内部使用UDP协议针对流媒体开发，内部开辟了六个端口来接受流媒体数据，完成快速接受之目的。16.Cocoa Touch中一小部分可用的框架： 音频和视频：Core Audio ，OpenAL ，Media Library ，AV Foundation 数据管理 ：Core Data ，SQLite 图形和动画 ：Core Animation ，OpenGL ES ，Quartz 2D 网络：Bonjour ，WebKit ，BSD Sockets 用户应用：Address Book ，Core Location ，Map Kit ，Store Kit 17.isMemberOfClass 与 isKindOfClassisKindOfClass 不仅用来确定一个对象是否是一个类的成员,也可以用来确定一个对象是否派生自该类的类的成员,而isMemberOfClass 只能做到第一点 18.UIViewController的生命周期-[ViewController initWithNibName:bundle:]；-[ViewController init]；-[ViewController loadView]；-[ViewController viewDidLoad]；-[ViewController viewWillDisappear:]；-[ViewController viewWillAppear:]；-[ViewController viewDidAppear:]；-[ViewController viewDidDisappear:]； Received simulated memory warning.-[ViewController viewVillUnload]-[ViewController viewDidUnload] (1)创建Controller： 通过storyBoard: [UIStoryboard storyboardWithName:@”” bundle:nil]instantiateInitialViewController`此处bundle:nil 等价于 [NSBundle mainBundle] 通过XIB 加载与控制器同名的XIB文件:使用init或initWithNibName加载 加载与控制器不同名的XIB Controller文件,通过loadNibNamed加载控制器（不同名需要修改file owner） 1SecondViewController *secondVc = [[[NSBundle mainBundle]loadNibNamed:@&quot;SecondVC&quot; owner:nil options:nil] lastObject] 加载与控制器不同名的XIB View文件,通过loadNibNamed加载控制器的view（不同名需要修改file owner） 12SecondViewController *secondVc = [[SecondViewController alloc]init];secondVc.view = [[[NSBundle mainBundle]loadNibNamed:@&quot;SecondViewController&quot; owner:nil options:nil] lastObject]; 在创建控制器的时候直接指定要加载xib作为控制器的view,名称不相干 需要修改xib文件的fileOwner进行关联需要将fileOwner里面的view指向xib里面的view(2)创建View: 通过XIB：[[NSBundle alloc]loadNibNamed:@”” owner:self options:nil]; 19.OC单例12345678910+(instancetype)shareNetworkTools&#123; static id instance; static dispatch_once_t onceToken; //onceToken默认等于0，如果是0就执行block，如果不是就不执行 NSLog(@&quot;%ld&quot;,onceToken); dispatch_once(&amp;onceToken, ^&#123; instance = [[self alloc] init]; &#125;); return instance;&#125; swift单例123456789101112131415161718192021222324/*//在swift中，类方法中不允许定义静态变量static var once_t: dispatch_once_t = 0static var instance: NetworkTools?//用于获取单例对象的类方法class func shareNetworkTools() -&gt; NetworkTools&#123; print(once_t) dispatch_once(&amp;once_t) &#123; () -&gt; Void in instance = NetworkTools() &#125; return instance!&#125;*///swift中的let是线程安全的static let instance: NetworkTools = NetworkTools()class func shareNetworkTools() -&gt; NetworkTools&#123; return instance&#125;//init方法在需要的时候才创建override init()&#123;super.init()print(&quot;----------&quot;)&#125;","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"面试","slug":"面试","permalink":"https://guchunli.github.io/tags/面试/"}]},{"title":"iOS直播学习笔记","date":"2017-06-29T09:14:34.000Z","path":"2017/06/29/iOS直播学习笔记/","text":"推流//LFLiveKit,librtmp 1.安装Homebrew查看是否已经安装了Homebrew1man brew 安装Homebrew1ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 2.安装nginx12345678//从github下载Nginx到本地,增加home-brew对nginx的扩展brew tap homebrew/nginx//安装Nginx服务器和rtmp模块brew install nginx-full --with-rtmp-module查看是否安装成功nginx 在浏览器地址栏输入：http://localhost:8080如果出现Welcome to nginx!，则表示安装成功 3.配置rtmp查看nginx配置文件安装在哪brew info nginx-full 前往/usr/local/etc/nginx/nginx.conf，在最后添加以下代码：123456789rtmp &#123; server &#123; listen 1990; application liveApp &#123; live on; record off; &#125; &#125;&#125; 重新加载nginx的配置文件nginx -s reload 4.安装ffmpeg进行推流brew install ffmpeg 5.使用ffmepg推流测试12ffmpeg -re -i (视频全路径) -vcodec copy -f flv (rtmp路径)ffmpeg -re -i /Users/xxx/Downloads/4.mp4 -vcodec copy -f flv rtmp://localhost:1990/liveApp/room 出现错误：1234[tcp @ 0x7ffd66e08440] Connection to tcp://localhost:1990 failed (Connection refused), trying next address[flv @ 0x7ffd68005400] FLV does not support sample rate 48000, choose from (44100, 22050, 11025)[flv @ 0x7ffd68005400] Audio codec mp3 not compatible with flvCould not write header for output file #0 (incorrect codec parameters ?): Function not implemented 原因：flv格式不支持音频码率为48000的，只支持44100，22050，11025的，你得找一个音频码率为这三个中的其中一个的视频或者利用ffmpeg修改音频的码率 6.使用VLC播放rtmp推流VLC 7.用ffmpeg抓取桌面以及摄像头推流进行直播1234//查看ffmpeg是否支持对应的设备ffmpeg -f avfoundation -list_devices true -i &quot;&quot;//抓取桌面和摄像头进行推流ffmpeg -f avfoundation -framerate 30 -i &quot;1:0&quot; -f avfoundation -framerate 30 -video_size 640x480 -i &quot;0&quot; -c:v libx264 -preset slow -filter_complex &apos;overlay=main_w-overlay_w-10:main_h-overlay_h-10&apos; -acodec libmp3lame -ar 44100 -ac 1 -f flv rtmp://localhost:1990/liveApp/room 搭建WEB服务器1.安装node.js,NPM2.利用NPM下载第三方模块（Express和Socket.IO）创建package.json:1234&quot;dependencies&quot;: &#123;&quot;express&quot;: &quot;^4.14.0&quot;,&quot;socket.io&quot;: &quot;^1.4.8&quot;&#125; 执行npm install 3.http服务器搭建创建xxx.js文件，然后执行node xxx.js即可`// require// 加载http模块var http = require(‘http’); // 创建http服务器var server = http.createServer(function(request,response){// response.write(‘Hello world’);// response.end();}); // 监听服务器server.listen(8080,’192.168.0.101’); console.log(‘监听8080’);` 4.express框架Express框架建立在node.js内置的http模块上，可以快速地搭建一个Web服务器123456789101112131415161718// 引入express模块var express = require(&apos;express&apos;);// 创建express服务器，创建服务器没有对访问服务器进行处理var app = express();// 监听get请求，请求根目录，输出Hello worldapp.get(&apos;/&apos;,function(request,response)&#123;response.send(&apos;Hello world&apos;);&#125;);app.post(&apos;/&apos;,function(request,response)&#123;response.send(&apos;Hello world&apos;);&#125;);app.listen(8080,&quot;192.168.0.101&quot;);console.log(&quot;监听8080&quot;); 5.上传下载服务器搭建 搭建socket即时通讯服务器1.WebSocketWebSocket：服务器和 客户端 都能主动的向对方发送或接收数据websocket协议头:wsSocket.IO:是一个完全由JavaScript实现、基于Node.js、支持WebSocket的协议用于实时通信、跨平台的开源框架。2.导入Socket.IO3.创建socket （1）面向express框架开发，加载express框架，方便处理get,post请求 （2）因为socket依赖http,创建http服务器，使用http模块. （3）可以通过express创建http服务器http.server(express) （4）通过http服务器创建socket （5）监听http服务器4.建立socket连接12345// 监听socket连接// function参数必填socketsocket.on(&apos;connection&apos;,function(clientSocket)&#123;console.log(&apos;建立连接&apos;,clientSocket);&#125;); 5.SocketIO发送事件","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"直播","slug":"直播","permalink":"https://guchunli.github.io/tags/直播/"}]},{"title":"JSP学习笔记","date":"2017-06-12T01:22:10.000Z","path":"2017/06/12/JSP学习笔记/","text":"cookies 存储在浏览器。而会话存储在服务器端","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://guchunli.github.io/tags/Java/"},{"name":"JSP","slug":"JSP","permalink":"https://guchunli.github.io/tags/JSP/"}]},{"title":"几种常见算法","date":"2017-06-09T03:02:24.000Z","path":"2017/06/09/几种常见算法/","text":"排序1、插入排序在要排序的一组数中，假设前面(n-1) [n&gt;=2] 个数已经是排好顺序的，现在要把第n个数插到前面的有序数中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。12345678910111213141516if(arr == null || arr.length &lt; 2)&#123; return arr;&#125;for(int i=1;i&lt;arr.length;i++)&#123; for(intj=i;j&gt;0;j--)&#123; if(arr[j]&lt;arr[j-1])&#123; int temp=arr[j]; arr[j]=arr[j-1]; arr[j-1]=temp; &#125;else&#123; //接下来是无用功 break; &#125; &#125;&#125;return arr; 2、冒泡排序在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。12345678910111213int temp = 0;for (int i = a.length - 1; i &gt; 0; --i)&#123; for (int j = 0; j &lt; i; ++j) &#123; if (a[j + 1] &lt; a[j]) &#123; temp = a[j]; a[j] = a[j + 1]; a[j + 1] = temp; &#125; &#125;&#125; 3、快速排序快速排序是对冒泡排序的一种本质改进。它的基本思想是通过一趟扫描后，使得排序序列的长度能大幅度地减少。在冒泡排序中，一次扫描只能确保最大数值的数移到正确位置，而待排序序列的长度可能只减少1。快速排序通过一趟扫描，就能确保以某个数为基准点的左边各数都比它小，右边各数都比它大。然后又用同样的方法处理它左右两边的数，直到基准点的左右只有一个元素为止。1234567891011121314151617181920212223242526272829303132333435363738main()&#123; if(left &gt;= right)/*如果左边索引大于或者等于右边的索引就代表已经整理完成一个组了*/ &#123; return ; &#125; int i = left; int j = right; int key = a[left]; while(i &lt; j) /*控制在当组内寻找一遍*/ &#123; while(i &lt; j &amp;&amp; key &lt;= a[j]) /*而寻找结束的条件就是，1，找到一个小于或者大于key的数（大于或小于取决于你想升 序还是降序）2，没有符合条件1的，并且i与j的大小没有反转*/ &#123; j--;/*向前寻找*/ &#125; a[i] = a[j]; /*找到一个这样的数后就把它赋给前面的被拿走的i的值（如果第一次循环且key是 a[left]，那么就是给key）*/ while(i &lt; j &amp;&amp; key &gt;= a[i]) /*这是i在当组内向前寻找，同上，不过注意与key的大小关系停止循环和上面相反， 因为排序思想是把数往两边扔，所以左右两边的数大小与key的关系相反*/ &#123; i++; &#125; a[j] = a[i]; &#125; a[i] = key;/*当在当组内找完一遍以后就把中间数key回归*/ sort(a, left, i - 1);/*最后用同样的方式对分出来的左边的小组进行同上的做法*/ sort(a, i + 1, right);/*用同样的方式对分出来的右边的小组进行同上的做法*/ /*当然最后可能会出现很多分左右，直到每一组的i = j 为止*/&#125; 4、选择排序在要排序的一组数中，选出最小的一个数与第一个位置的数交换；然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。123456789101112131415161718main()&#123;int i,j,min,t;for(i=0;i&lt;n-1;i++)&#123; min=i;//查找最小值 for(j=i+1;j&lt;n;j++) if(a[min]&gt;a[j]) min=j;//交换 if(min!=i) &#123; t=a[min]; a[min]=a[i]; a[i]=t; &#125; &#125;&#125; 二分法二分法查找只适用与已排序的数列。思路：首先将值 x 与数组 v 的中间元素比较，如果 x 小于中间的元素，则将 end 值设为 中间元素-1，同理，若 x 大于中间元素，则将中间元素 + 1作为 start，再在 start 与 end 之间进行查找。123456789101112int start = 0;int end = data.length-1;int mid = (start+end)/2;//awhile(data[mid]!=aim&amp;&amp;end&gt;start)&#123; if(data[mid]&gt;aim)&#123; end = mid-1; &#125;else if(data[mid]&lt;aim)&#123; start = mid+1; &#125; mid = (start+end)/2;&#125;return (data[mid]!=aim)?-1:mid; 斐波那契数列数列：1,1,2,3,5,8,13,21… 求第n项的值1234567891011int f1,f2,f,i,n; f1=f2=1;if(n&lt;=2) printf(&quot;%d&quot;,1); else &#123; //加上括号 for(i=3;i&lt;=n;i++) &#123; f=f1+f2; f1=f2; f2=f;","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://guchunli.github.io/tags/排序/"},{"name":"算法","slug":"算法","permalink":"https://guchunli.github.io/tags/算法/"}]},{"title":"Java语言学习笔记","date":"2017-06-09T01:59:09.000Z","path":"2017/06/09/Java语言学习笔记/","text":"##JAVA基础 1.public类 一个源文件中只能有一个public类 一个源文件可以有多个非public类 2.package/import编译java包： $ javac -d directory javafilename1234E:\\sources&gt; javac -d c:\\classes Simple.java//运行e:\\sources&gt; set classpath=c:\\classes;.;e:\\sources&gt; java mypack.Simple OR1e:\\sources&gt; java -classpath c:\\classes mypack.Simple 加载类文件或jar文件的方式: 加载临时类文件 通过在命令提示符中设置类路径 通过 -classpath 开关选项 永久加载类文件 通过在环境变量中设置类路径 通过创建jar文件，其中包含所有类文件，并将jar文件复制到JDK安装目录的jre/lib/ext文件夹中。 3.引用类型对象、数组都是引用数据类型。所有引用类型的默认值都是null。 4.JAVA常量在 Java 中使用 final 关键字来修饰常量，通常使用大写字母表示常量 5. 基本数据类型 不能对boolean类型进行类型转换。 在把容量大的类型转换为容量小的类型时必须使用强制类型转换 double-&gt;float 6.自动类型转换转换前的数据类型的位数要低于转换后的数据类型。Float-&gt;double Java语言支持的变量类型类变量：独立于方法之外的变量，用 static 修饰。 在类中以static关键字声明，但必须在方法构造方法和语句块之外 静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。 静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。 为了对类的使用者可见，大多数静态变量声明为public类型 默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。 类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。 静态块在类加载时main之前执行实例变量：独立于方法之外的变量，不过没有 static 修饰。 当一个对象被实例化之后，每个实例变量的值就跟着确定； 实例变量可以声明在使用前或者使用后； 一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见； 实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定； 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名局部变量：类的方法中的变量。 访问修饰符不能用于局部变量； 局部变量是在栈上分配的。 局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。 实例初始化块主要有三个规则。 它们如下： 在创建类的实例时创建实例初始化程序块。 在父类构造函数被调用之后(即在super()构造函数调用之后)调用实例初始化块。 实例初始化程序块按它们显示的顺序排列。 8．修饰符：访问修饰符、非访问修饰符 修饰符用来定义类、方法或者变量，通常放在语句的最前端，默认default访问修饰符（1） public/protected/default/private（2） private: 只能通过类中公共的 getter 方法被外部类访问（3） protected: 同一个包中的任何其他类访问，也能够被不同包中的子类访问 public: 如果几个相互访问的 public 类分布在不同的包中，则需要导入相应 public 类所在的包 注意：父类中声明为 public 的方法在子类中也必须为 public。 父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。 父类中声明为 private 的方法，不能够被继承。 非访问修饰符static,abstract,final,synchronized,volatile（1）final：用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。 final 变量：能被显式地初始化并且只能初始化一次。被声明为 final 的对象的引用不能指向不同的对象。但是 final 对象里的数据可以被改变。也就是说 final 对象的引用不能改变，但是里面的值可以改变。final 修饰符通常和 static 修饰符一起使用来创建类常量。 final 方法：类中的 final 方法可以被子类继承，但是不能被子类修改。 final 类：final 类不能被继承，没有类能够继承 final 类的任何特性。 被声明为 final 类的方法自动地声明为 final，但是实例变量并不是 final 在声明时未初始化的静态final变量称为静态空白final变量。 它只能在静态块中初始化。（2）abstract: 抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充一个类不能同时被 abstract 和 final 修饰。抽象方法:是一种没有任何实现的方法，该方法的的具体实现由子类提供。 抽象方法不能被声明成 final 和 static。 任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。 如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。抽象类可以包含抽象方法和非抽象方法。 抽象方法的声明以分号结尾，例如：public abstract sample()。在java中有两种实现抽象的方法，它们分别是： 抽象类(部分) 接口 (完全)抽象类实现了部分抽象(0到100％)，而接口实现了完全抽象(100％)。 9.instanceof: name instanceof String增强for循环：for(声明语句 : 表达式)switch支持字符串，直到break退出 10.装箱/拆箱装箱：int-&gt;number 拆箱：number-&gt;intintValue() valueOf() compareo() equals() parseInt()(string-&gt;int) ceil() floor() random() 11.Character char的包装类isLetter() isDigit() isUpperCase() isWhitespace() toUpperCase() toString() 12.Stringlength() s1.concat(s2) s = format(”—%f %d %s”,floatVar,.,.) charAt(index) int compareo()(对象，字符串)boolean contentEquals(StringBuffer) endsWith() equals() indexOf(ch) split substring 13. StringBuffer/StringBuilder当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。StringBuffer(线程安全) StringBuilder(速度优势,不是线程安全的,不能同步访问) 多数情况下建议使用 StringBuilder 类StringBuffer：append(s) reverse dekete(start,end) replace(start,end,str) capacity() charAt() indexOf() toString substring 14.Arrays数组double[] list = new double[10]; 参数：(int[] array) 返回值：int[]fill sort equals binarySearch 15.Datedate.toString() getime() after before equals compareo format parseSimpleDateFormat(E yyyy-MM-dd HH:mm:ss a zzz) PMSleep(1000*3) Calender.getInstance() 16.正则表达式Pattern Matcher\\s+ 多个空格 ^$ 以什么开始 \\d+多个数字 ()? 0/1 可选 * 0/n +1\\n {n} (n,) &gt;=n . 除\\n\\r之外的任何单个字符[xyz] [^xyz] [a-z] \\b字符边界 17.function重载：方法名相同，参数列表不同构造方法：方法名与类名相同，没有返回值，自定义则默认构造方法失效可变参数：一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明（double… numbers）protected void finalize() 18.BufferReaderread() write() scanner() print() println() 19.I/OFileInputStream FileOutputStream File FileReader FileWrite mkdir mkdirs isDirectory delete() 20.Scanner(System.in)next nextLine 21.Exceptionjava.lang.Exception Error ThrowableIOException RuntimeException 22.面向对象继承extends final修饰的类不能被集成，方法不能被重写 单继承 重写与重载Override(返回值和形参都不能改变) Overload(方法名字相同，而参数不同。返回类型可以相同也可以不同)构造方法不能被重写最常用的地方就是构造器的重载 多态父类指向子类对象 Animal a = new Cat() 实现方式：重写，接口，抽象类和抽象方法 变量不能被重写 抽象类抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。 封装修改属性的可见性来限制对属性的访问（一般限制为private）对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问 接口是抽象方法的集合。有静态、final变量和抽象方法（JAVA8还可以有默认方法，静态方法），接口字段默认是public，static和final，方法默认是public和abstract类描述对象的属性和方法。接口则包含类要实现的方法。除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。接口中的方法会被隐式的指定为 public abstract，接口中的变量会被隐式的指定为 public static final类的多重继承是不合法，但接口允许多重继承 包小写开头使用类全名描述 或 import(import 声明必须在包声明之后，类声明之前) java高级1.一些概念理解JVM(Java虚拟机)一个抽象机器。它是一个提供可以执行Java字节码的运行时环境的规范。JVM执行以下主要任务： 加载代码 验证代码 执行代码 提供运行时环境JRE（Java Runtime Environment）用于提供Java运行时环境。它是JVM的实现。它是实际存在的。它包含一组库和JVM在运行时使用的其他文件。JDK（Java Development Kit）它是实际上存在的。它包含JRE+开发工具。 JDK(JRE(JVM+LIB+OTHER)+IDE)","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://guchunli.github.io/tags/Java/"},{"name":"语法","slug":"语法","permalink":"https://guchunli.github.io/tags/语法/"}]},{"title":"MyEclipse快捷键","date":"2017-06-09T01:33:03.000Z","path":"2017/06/09/MyEclipse快捷键/","text":"1.补全：alt+/2.修复：ctrl+13.删除当前行：ctrl+d4.复制当前行到上一行/下一行：ctrl+alt+上/下方向键5.互换位置：alt+上/下方向键6.上/下一个编辑的页面：alt+左/右方向键7.显示工程文件目录：alt+enter8.当前行插入空行：shift+enter(+ctrl 下一行插入)9.格式化：ctrl+shift+f10.重命名：alt+shift+r11.抽取方法：alt+shift+m12.组织导入（自动加入引用）：ctrl+shift+o13.添加导入：Ctrl+Shift+M14.单步返回 F715.单步跳过 F616.单步跳入 F517.单步跳入选择 Ctrl+F518.调试上次启动 F1119.继续 F8","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://guchunli.github.io/tags/Java/"},{"name":"快捷键","slug":"快捷键","permalink":"https://guchunli.github.io/tags/快捷键/"}]},{"title":"mysql学习笔记","date":"2017-06-08T05:41:17.000Z","path":"2017/06/08/mysql学习笔记/","text":"数据库创建数据库1create database db; 删除数据库1drop database db; 查看数据库 1show databases; 使用数据库1use db; 表创建表1234CREATE TABLE db.tb (`id` INT NOT NULL AUTO_INCREMENT,`name` VARCHAR(45) NOT NULL,PRIMARY KEY (`cid`)); 删除表1drop table tb 修改表名12RENAME TABLE tb TO new_tbname;ALTER TABLE tb RENAME TO new_tbname; 初始化表(清空)1TRUNCATE TABLE tb 复制表：1CREATE TABLE tb_name2 SELECT * FROM tb_name; 或者部分复制：1CREATE TABLE tb_name2 SELECT id,name FROM tb_name; 查看数据库中可用的表：1SHOW TABLES; 查看表的结构：12DESCRIBE tb_name;SHOW COLUMNS in tb_name; //from也可以 列/约束ALTER TABLE tb ADD[CHANGE,RENAME,DROP] 增加列/约束1alter table tb add column name VARCHAR(45) not null after id,add primary key(id); 删除列/约束1alter table tb drop col2 drop primary key(id); 修改列/约束ALTER TABLE tb MODIFY col2 int NOT NULL DEFAULT 100 add col1 int identity(1,1);ALTER TABLE tb ALTER col2 SET DEFAULT 1000;ALTER TABLE tb ALTER col2 DROP DEFAULT; 约束primary key,not null,unique,asc/desc/default 0/AUTO_INCREMENT/zerofill 单表操作插入1insert into tb(col1,col2) values(value1,value2) 删除1delete from tb [WHERE Clause] 更新1update tb set col1=value1 [WHERE Clause] 使用MySQL执行update的时候报错：1Error Code: 1175. You are using safe update mode and you tried to update a table without a WHERE that uses a KEY column To disable safe mode, toggle the option in Preferences -&gt; SQL Queries and reconnect. 解决方法：执行命令 SET SQL_SAFE_UPDATES = 0; //修改下数据库模式如果想要提高数据库安全等级，可以在恢复回原有的设置，执行命令：SET SQL_SAFE_UPDATES = 1; 查找1select * from tb [WHERE Clause] where =、&gt;、&lt;、&lt;&gt; and/not and or is null/is not null 分组查询：order by/group by/having 1select * from tb order by col1,col2 asc/desc like 123SELECT field1, field2,...fieldN FROM tbWHERE field1 LIKE condition1 [AND [OR]] filed2 = &apos;somevalue&apos; in/not in 1select * from tb1 where a [not] in (value1,value2,value3) between/not between exists/not exists 全选/全不选where 1=1 表示选择全部where 1=2 表示全部不选， 分页 1234declare @start int,@end int@sql nvarchar(600)set @sql=’select top’+str(@end-@start+1)+’+from T where rid not in(select top’+str(@str-1)+’Rid from T where Rid&gt;-1)’exec sp_executesql @sql 删除重复记录 12341),delete from tablename where id not in (select max(id) from tablename group by col1,col2,...)2),select distinct * into temp from tablenamedelete from tablenameinsert into tablename select * from temp 列出数据库里所有的表名 1select name from sysobjects where type=&apos;U&apos; // U代表用户 列出表里的所有的列名 123select name from syscolumns where id=object_id(&apos;TableName&apos;)select column_name,data_type from information_schema.columnswhere table_name = &apos;表名&apos; //查询某一个表的字段和数据类型 获取当前数据库中的所有用户表 1select Name from sysobjects where xtype=&apos;u&apos; and status&gt;=0 多表操作union通过组合其他两个结果表（例如 TABLE1 和 TABLE2）并消去表中任何重复行而派生出一个结果表。当 ALL 随 UNION 一起使用时（即 UNION ALL），不消除重复行。两种情况下，派生表的每一行不是来自 TABLE1 就是来自 TABLE2。12345678910SELECT expression1, expression2, ... expression_nFROM tb1[WHERE conditions]UNION [ALL | DISTINCT]SELECT expression1, expression2, ... expression_nFROM tb2[WHERE conditions];DISTINCT: 可选，删除结果集中重复的数据。默认情况下 UNION 操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没啥影响。ALL: 可选，返回所有结果集，包含重复数据。 EXCEPT通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个结果表。当 ALL 随 EXCEPT 一起使用时 (EXCEPT ALL)，不消除重复行。 INTERSECT通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表。当 ALL 随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。 注：使用运算词的几个查询结果行必须是一致的。 分组：group bycount,sum,max,min,avg 连接：join INNER JOIN（内连接,或等值连接）：获取两个表中字段匹配关系的记录。 12345SELECT a.col1, a.col2, b.col3 FROM tb1 a INNER JOIN tb2 bON a.col1 = b.col1;等价于SELECT a.col1, a.col2, b.col3 FROM tb1 a, tb2 b WHERE a.col1 = b.col1; LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。 12SELECT a.col1, a.col2, b.col3 FROM tb1 a LEFT JOIN tb2 b ON a.col1 = b.col1; RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。 12SELECT a.col1, a.col2, b.col3 FROM tb1 a RIGHT JOIN tb2 b ON a.col1 = b.col1; 高级用法索引临时表视图","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://guchunli.github.io/tags/Java/"},{"name":"mysql","slug":"mysql","permalink":"https://guchunli.github.io/tags/mysql/"}]},{"title":"Java搭建springMVC项目笔记","date":"2017-06-08T01:44:19.000Z","path":"2017/06/08/Java搭建springMVC项目笔记/","text":"MyEclipse搭建项目 创建命名空间namespace 新建项目 new -&gt; project 添加tomcat,jdk 运行 访问：http://localhost:8080/project_name/ 12345...nested exception is org.springframework.core.NestedIOException: ASM ClassReader failed to parse class file - probably due to a new Java class file version that isn&apos;t supported yet...nested exception is java.lang.IllegalArgumentException... 解决方法：在项目上右键–properties–java Compile–compiler compliance level 在工程目录下添加config文件夹，下面添加文件：jdbc.properties,spring-mvc.xml,spring-mybatis.xml jdbc.properties：mysql配置 spring-mvc.xml context -&gt; base-package: 包的跟路径 bean -&gt; prefix: /WEB-INF/page/下放.jsp文件 mvc -&gt; bean: utl 的根路径 spring-mybatis.xml: context -&gt; base-package: 包的根路径 bean -&gt; base-package: dao的根路径 aop -&gt; expression: service的根路径","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://guchunli.github.io/tags/Java/"},{"name":"springMVC","slug":"springMVC","permalink":"https://guchunli.github.io/tags/springMVC/"},{"name":"项目","slug":"项目","permalink":"https://guchunli.github.io/tags/项目/"}]},{"title":"java开发环境配置","date":"2017-06-06T03:27:51.000Z","path":"2017/06/06/java开发环境配置/","text":"Java开发需要：1.JDK (Java Deverlopment Kit)Java开发工具包(JDK)是一个用于开发Java应用程序和小程序的软件开发环境。它包括Java运行时环境(JRE)，编译器/加载程序(JAVA)，编译器(javac)，归档器(jar)，文档生成(Javadoc)以及 Java 开发的其他工具。2.IDE (Integrated Development Environment)集成开发环境：MyEclipse,IDEA tomcat1.下载：http://tomcat.apache.org2.修改权限，否则会提示permission denny错误：1sudo chmod 755 xxx/bin/*.sh (xxx表示你tomcat放至的路径) 3.将Tomcat写入系统的环境变量PATH中。 1$ pico .bash_profile 在打开的页面中，输入以下：12export PATH=$PATH:tomcat_dir/bin; export PATH=$PATH:tomcat_dir/logs; 其中tomcat_dir为tomcat根目录接着按下 control+x，再按 y 表示确定修改，最后回车。 验证是否成功 $ echo $PATH显示如下:$ -bash: /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Users/fuhua/Documents/Tomcat/apache-tomcat-8.0.30/bin: No such file or directory需要重新启动计算机，以便完成系统环境变量的配置。 4.启动Tomcat. 如果你完成将Tomcat写入系统的环境变量PATH中，你可以直接在终端输入 startup.sh ； 如果你没有完成，那么就要定位到Tomcat的bin目录中，如在终端输入 123$ cd tomcat_dir/bin$ startup.shTomcat started. 在浏览器中输入http://localhost:8080/如果出现Apache Tomcat界面，代表 tomcat 启动成功。 MySQL安装MySQL 下载：MySQL官网 安装完成时记得保存弹出框中的密码，这是mysql root账号和密码 系统偏好设置中，点击MySQL开启MySQL Server服务修改root账户密码 关闭MySQL Server服务 终端输入12345678910111213141516171819202122232425262728// 苹果系统下 mysql server 的安装地址$ cd /usr/local/mysql/bin/// 登录管理员权限$ sudo su// 禁止 mysql 验证功能sh-3.2# ./mysqld_safe --skip-grant-tables &amp;//终端输出[1] 2487sh-3.2# Logging to &apos;/usr/local/mysql-5.7.18-macos10.12-x86_64/data/192.168.1.143.err&apos;.2017-06-06T06:35:36.6NZ mysqld_safe Starting mysqld daemon with databases from /usr/local/mysql-5.7.18-macos10.12-x86_64/datash-3.2# ./mysqlWelcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 3Server version: 5.7.18 MySQL Community Server (GPL)Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\\h&apos; for help. Type &apos;\\c&apos; to clear the current input statement.mysql&gt; FLUSH PRIVILEGES;Query OK, 0 rows affected (0.00 sec)mysql&gt; SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos; = PASSWORD(&apos;123456&apos;);Query OK, 0 rows affected, 1 warning (0.00 sec) 安装MySQL Workbenchhttps://dev.mysql.com/downloads/workbench/MySQL connections + ：输入connection name创建新链接 加入系统环境变量12345678910111213141516171819$ cd /usr/local/mysql/bin$ ls//查看目录中是否有mysql$ vim ~/.bash_profile//在该文件中添加 PATH=$PATH:/usr/local/mysql/bin$ source ~/.bash_profile$ mysql -uroot -p //登录mysql//输入密码后，登录成功会显示：Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 22Server version: 5.7.18 MySQL Community Server (GPL)Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\\h&apos; for help. Type &apos;\\c&apos; to clear the current input statement. 可以通过以下名录修改密码： $ $ SET PASSWORD FOR ‘root’@’localhost’ = PASSWORD(‘newpass’); JDK安装JDK下载：JDK官网安装 mac自带jdk，安装目录：/System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home 自己安装目录：/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home配置jdk环境变量\u0010\u0010（1）只针对当前用户12$ touch ~/.bash_profile $ vim ~/.bash_profile 在编辑器中添加如下内容：123456JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/HomeCLASSPAHT=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarPATH=$JAVA_HOME/bin:$PATH:export JAVA_HOMEexport CLASSPATHexport PATH 使系统变量生效，使用以下命令或重启电脑：1$ source .bash_profile 查看java版本：1$ java -version 检查系统变量是否生效：1$ echo $JAVA_HOME （2）针对所有用户12$ cd /etc$ sudo vi profile 在编辑器最下面添加如下内容：123JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/HomeCLASSPAHT=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarPATH=$JAVA_HOME/bin:$PATH: 接下来同上：123$ source .bash_profile$ java -version$ echo $JAVA_HOME","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://guchunli.github.io/tags/Java/"},{"name":"web","slug":"web","permalink":"https://guchunli.github.io/tags/web/"}]},{"title":"iOS调试与性能优化学习笔记","date":"2017-06-05T10:31:25.000Z","path":"2017/06/05/iOS调试与性能优化学习笔记/","text":"1.全局断点2.条件断点 condational3.符号断点 symbolic -[NSObject(NSObject) doesNotRecognizeSelector:]4.NSLog5.僵尸对象6.lldb LLVM GCC:p po expr callimage lookup –address 0x0000000100004af87.instruments-profile:analyze：发现release问题，以及继承过程中的父类方法缺失等leaks:自动加载Allocations，监控程序运行过程中的内存变化《How to Use Instruments in Xcode》： https://www.raywenderlich.com/97886/instruments-tutorial-with-swift-getting-started《与调试器共舞 - LLDB 的华尔兹》：https://objccn.io/issue-19-2/《LLDB调试命令初探》：http://www.starfelix.com/blog/2014/03/17/lldbdiao-shi-ming-ling-chu-tan/《The LLDB Debugger》：http://lldb.llvm.org/tutorial.html《About LLDB and Xcode》：https://developer.apple.com/library/mac/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/Introduction.htmlhttp://www.cnblogs.com/daiweilai/p/4234336.html8.Debug View Hierarchy9.预编译指令://swift语言 #if DEBUGfunc dlog(object: T) {println(object)} #elsefunc dlog(object: T) {} #endif #warning #error #pragma message","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"优化","slug":"优化","permalink":"https://guchunli.github.io/tags/优化/"}]},{"title":"798艺术区","date":"2017-06-04T07:30:49.000Z","path":"2017/06/04/798艺术区/","text":"2017-06-04 北京798艺术区 抽象画 各种小陶瓷 猫咪，卡哇伊 brain red people 未名 孤独的小孩 恋人","comments":true,"categories":[{"name":"随笔","slug":"other","permalink":"https://guchunli.github.io/categories/other/"}],"tags":[{"name":"798","slug":"798","permalink":"https://guchunli.github.io/tags/798/"}]},{"title":"ReactNative学习笔记","date":"2017-05-21T03:39:45.000Z","path":"2017/05/21/ReactNative学习笔记/","text":"直接通过ReactNative方式创建项目安装必须安装：Xcode，Homebrew，node,npmnpm其实是Node.js的包管理工具,已经在Node.js安装的时候顺带装好了。可选：React Native的命令行工具,IDE(Atom/Nuclide/Webstorm/Sublime),watchman,Flow1234567891011//brewruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;brew -v//nodebrew install node//React Native的命令行工具npm install -g react-native-cli//watchmanbrew install watchman//flowbrew install flow 创建项目1$ react-native init RNDemo 运行项目:使用命令行或Xcode12345678$ react-native run-ios$ react-native run-android......React packager ready.Loading dependency graph, done.` 运行项目时如果遇到&lt;React/RCTBundleURLProvider.h&gt;” file not found问题，可按如下方法试着解决： 把项目里面的 node_modules 文件夹删除掉 npm install react-native upgrade clean,run JavaScript基础(1){}表示定义一个对象(2)var,let,function,弱类型,typeof(),isNaN()数据类型：Boolean,null,undefined,Number,String,Symbol,Objectfalse:false,undefined,NaN,null,””,0显式类型转换：parseInt()隐式类型转换：==,-,*,/数组：var a = [“1”,”2”,”3”] var a = new Array(“1”,”2”,”3”) var a = Array(“1”,”2”,”3”)字典：{} JS:基于原型(所有对象均为实例,通过构造器函数来定义和创建一组对象)OC：基于类(3)Promises(ES6)JS本身是单线程的语言，它要实现异步都是通过回调函数来实现的，JS中引入了Promises来处理异步和延迟操作。 promise有以下几种状态： * pending，最初的状态 * fulfilled，执行成功 * rejected，执行出错 * settled，执行结束了，失败(rejected)或者成功(fulfilled) (4)箭头函数(ES6)1(s) =&gt; s.length 等同于 function(s)&#123; return s.length &#125; 普通函数.bind(this) 来把内部函数中的this绑定到了外部函数去。箭头函数里的this还是原来的this，不需要额外绑定。(5)模板字符串(ES6)1234567var html = `公司名：$&#123;name&#125; 简介：$&#123;desc&#125;`;等同于var tpl = &apos;公司名：&apos; + name + &apos;\\n&apos;+&apos;简介：&apos;+ desc; React基础组件（component）是React类的基类，进行视图展示。 组件的属性(prop)：组件之前通过标签的属性来传递数据，由父组件传递给子组件(单向的属性传递) 组件的状态(state) 每次调用setState时都会更新组件的状态，触发render函数进行渲染更新界面（render方法是被异步调用的，这可以保证同步的多个setState方法只会触发一次render） 组件自己不可以自己修改props（即：props可认为是只读的），只可由其他组件调用它时在外部修改 createClass：创建一个component render()：返回的的 JSX 模板需要一个根元素包裹起来返回一个根的视图，用来渲染实际的Component可视部分 getInitialState()：只能在用React.createClass创建的时候使用在Component被加载之前调用一次，这个方法的返回值会被设置为this.state getDefaultProps()：在Class 创建的时候，调用一次，这个方法在调用的时候，任何实例还没有被创建返回的任何Object 对象，在各个实例中是共享的 组件的生命周期 (1)创建：getDefaultProps(ES6:defaultProps)-&gt;(2)实例化：getInitialState(ES6:constructor)-&gt;componentWillMount-&gt;render-&gt;componentDidMount-&gt;(3)运行更新阶段： + 运行中-&gt;props改变-&gt;componentWillReceiveProps-&gt; + 运行中-&gt;state改变-&gt; shouldComponentUpdate-&gt; + false-&gt;运行中 + true-&gt;componentWillUpdate-&gt;render-&gt;componentDidUpdate-&gt;运行中 (4)销毁阶段：Unmount(卸载)-&gt;componentWillUnmount 生命周期 调用次数 能否使用 setSate() defaultProps / getDefaultProps 1(全局调用一次) 否 constructor / getInitialState 1 否 componentWillMount 1 是 render &gt;=1 否 componentDidMount 1 是 componentWillReceiveProps &gt;=0 是 shouldComponentUpdate &gt;=0 否 componentWillUpdate &gt;=0 否 componentDidUpdate &gt;=0 否 componentWillUnmount 1 否 (1)getDefaultProps(ES6:defaultProps):初始化一些默认的属性，一个控件可以利用this.props获取并初始化它的属性 + ES5:getDefaultProps:function(){},propTypes:{}, + ES6:static defaultProps={};static propTypes={}; (2)constructor(props) / getInitialState():状态初始化 + ES5:getInitialState: function(){} + ES6:constructor(props){} (3)componentWillMount():准备加载组件，业务初始化操作，也可以设置组件状态(4)render():渲染界面，返回JSX或其它组件来构成DOM，只能返回一个顶级元素(5)componentDidMount():组件加载成功并被成功渲染，一般会做一些网络请求等加载数据的操作 (6)componentWillReceiveProps():组件接收到新的props会触发，可以调用setState()来完成对state的修改，nextProps 是即将被设置的属性，旧的属性还是可以通过 this.props 来获取(7)shouldComponentUpdate():返回布尔值（决定是否需要更新组件）(8)componentWillUpdate():shouldComponentUpdate返回true或者调用forceUpdate之后触发此方法，会把 nextProps 和 nextState 分别设置到 this.props 和 this.state 中，开始准备更新组件。不能使用 this.setState 来修改状态。(9)render()：再确定需要更新组件时，调用render，根据diff算法，渲染界面，生成需要更新的虚拟DOM数据。(10)componentDidUpdate():可以在这个方法中做DOM操作，首次render之后调用componentDidMount，其它render结束之后都是调用componentDidUpdate。(11)componentWillUnmount():组件从DOM中移除，可以做一些组件相关的清理工作，例如取消计时器、网络请求。1注意：绝对不要在componentWillUpdate和componentDidUpdate中调用this.setState方法，否则将导致无限循环调用。 组件更新的四种方式(1)首次Initial Render，即首次加载组件(2)调用this.setState(3)父组件发生更新(4)调用this.forceUpdate强制更新 statics定义Components可以调用的静态方法 RN与原生项目先创建iOS项目，再集成React Native到原生项目(1) 先通过Xcode创建项目(2) 在项目目录下创建一个reactivenative文件夹存放react native相关文件，再创建一个package.json文件，用于初始化react-nativepackage.json内容如下：123456789&#123;&quot;name&quot;: &quot;RNDemo&quot;,&quot;version&quot;: &quot;1.0.0&quot;,&quot;private&quot;: true,&quot;dependencies&quot;: &#123;&quot;react&quot;: &quot;^15.6.1&quot;,&quot;react-native&quot;: &quot;^0.45.1&quot;&#125;&#125; (3) 在reactivenative目录下执行命令1$ npm install 或者安装指定版本的react/react-native12$ npm install --save react-native@0.45.1$ npm install --save react@15.6.1 (4) 创建index.ios.js文件注意当前项目名称为RNDemo，修改为实际项目名称。1234567891011121314151617181920212223242526&apos;use strict&apos;;var React = require(&apos;react-native&apos;); var &#123; Text,View&#125; = React;var styles = React.StyleSheet.create(&#123; container: &#123;flex: 1,backgroundColor: &apos;red&apos;&#125;&#125;);class RNDemo extends React.Component &#123; render() &#123;return (&lt;View style=&#123;styles.container&#125;&gt;&lt;Text&gt;This is a simple application.&lt;/Text&gt;&lt;/View&gt;)&#125;&#125;React.AppRegistry.registerComponent(&apos;RNDemo&apos;, () =&gt; RNDemo); (5) Cocoapods集成react-native在工程目录下创建Podfile文件，内容如下：123456789101112# 请将:path后面的内容为node_modules文件夹路径。plateform :ios, &apos;8.0&apos;target &quot;RNDemo&quot; dopod &apos;React&apos;, :path =&gt; &apos;./reactivenative/node_modules/react-native&apos;, :subspecs =&gt; [&apos;Core&apos;,&apos;RCTImage&apos;,&apos;RCTNetwork&apos;,&apos;RCTText&apos;,&apos;RCTWebSocket&apos;,# 添加其他你想在工程中使用的依赖。]end 执行pod install即可如果出现如下问题：1The dependency `React/Core (from `./reactivenative/node_modules/react-native`)` is not used in any concrete target. 在项目首尾请添加上target即可12target &quot;RNDemo&quot; do end (6)添加react native应用创建一个ReactView视图文件1234567891011121314151617- (instancetype)initWithFrame:(CGRect)frame&#123;if (self = [super initWithFrame:frame]) &#123;NSString * strUrl = @&quot;http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true&quot;;NSURL * jsCodeLocation = [NSURL URLWithString:strUrl];RCTRootView * rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocationmoduleName:@&quot;SimpleApp&quot;initialProperties:nillaunchOptions:nil];[self addSubview:rootView];rootView.frame = self.bounds;&#125;return self;&#125; ReactView.m 中通过 http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true 加载bundle文件 在ViewController中加载这个视图123ReactView * reactView = [[ReactView alloc] initWithFrame:CGRectMake(0, 40, CGRectGetWidth(self.view.bounds), 100)];[self.view addSubview:reactView]; (7)启动开发服务器12$ cd reactivenative$ react-native start (8)Info.list中修改NSAppTransportSecurity配置(9)在Xcode中运行项目，完成 升级Xcode8后遇到的错误Q1:’React/RCTBundleURLProvider.h’ file not foundA1:进入react native所在目录，将node_modules文件夹删除，执行12$ npm install$ react-native upgrade clean，重新运行 Q2:RCTSCrollView.m 中_refreshControl找不到A2:在@implementation RCTCustomScrollView下添加如下代码：1234@implementation RCTCustomScrollView&#123;RCTRefreshControl *_refreshControl;&#125; Q3:控制台不断输出[] nw_connection_get_connected_socket_block_invoke 710 Connection has no connected handlerA3:edit scheme-&gt;arguments-&gt;Environment Variables-&gt;添加Name: “OS_ACTIVITY_MODE”, Value:”disable” 原生和React Native之间的通信方式主要包括三部分： 属性 原生模块 原生UI组件封装 属性原生给JS传数据，主要依靠属性。(1)原生-&gt;React Native 传递属性initialProperties必须是NSDictionary的一个实例。这一字典参数会在内部被转化为一个可供JS组件调用的JSON对象。(2)原生-&gt;React Native 更新属性RCTRootView同样提供了一个可读写的属性appProperties,可以通过componentWillMount访问新的属性值。 更新必须在主线程中进行，读取则可以在任何线程中进行。 更新属性时并不能做到只更新一部分属性。建议自己封装一个函数来构造属性。(3)React Native-&gt;原生宏RCT_CUSTOM_VIEW_PROPERTY 原生模块原生模块是JS中也可以使用的Objective-C类。一个“原生模块”就是一个实现了“RCTBridgeModule”协议的Objective-C类。 原生UI组件封装FlexBox1.flexDirection:row|row-reverse|column|column-reverse2.flexWrap:wrap|no-wrap3.justifyContent:flex-start|flex-end|center|space-between|space-around4.alignItems:flex-start|flex-end|center|stretch5.alignSelf:auto|flex-start|flex-end|center|stretch6.flex:子控件在主轴中占据几等分 props,stateprops:在父组件中指定，而且一经指定，在整个组件的生命周期中都不再改变。state:constructor中声明(ES6)，在setState中修改数据定义state:123this.state = &#123;num:1,&#125;; 修改state:123this.setState(&#123;num : number&#125;) 父子组件传值1.父传子(1)props:this.props.name(2)ref:this.refs.son.receiveMsg(“msg”)2.子传父(1)方法回调父组件：定义一个处理接收到值的方法，把这个方法传递给子组件，并且绑定this子组件：通过this.props拿到这个方法调用3.无关联组件间传值(1)通知:组件1传值给组件2组件1：123&lt;Text onPress=&#123;()=&gt;&#123;DeviceEventEmitter.emit(&apos;NotificationName&apos;,123);&#125;&#125;&gt;&lt;/Text&gt; 组件2：12345this.lister = DeviceEventEmitter.addListener(&apos;NotificationName&apos;,(value)=&gt;&#123;this.setState(&#123;value:value&#125;);&#125;) 组件生命周期实例化1.constructor:初始化state（只调用一次）2.componentWillMount:即将加载组件调用，render前（只调用一次）3.render:渲染组件4.componentDidMount:组件加载完成调用，render后（只调用一次）运行5.componentWillReceiveProps:props改变调用6.shouldComponentUpdate:props/state改变调用，可控制是否刷新界面7.componentWillUpdate:组件即将更新调用（调用this.setState会循环）8.render9.componentDidUpdate:组件更新完成（调用this.setState会循环）销毁10.componentWillUnmount:组件即将销毁，可移除观察者，清空数据等 propTypes必须要用static修饰，否则无效static：用来定义类方法或者类属性，定义类的方法和属性，生成的对象就自动有这样的属性了。1.类型检查：当传入错误的属性值，会报警告，但是不会报错&gt; 数组类型PropTypes.array 布尔类型PropTypes.bool 函数类型PropTypes.func 数值类型PropTypes.number 对象类型PropTypes.object 字符串类型PropTypes.string 规定prop为必传字段PropTypes.func.isRequired prop可为任意类型PropTypes.any.isRequired&gt; 12345// 定义属性static propTypes = &#123; name:PropTypes.string, age:PropTypes.number&#125; 2.设置初始化值1234static defaultProps = &#123; name:&apos;xiaoming&apos;, age:20&#125; 基本组件1.View2.TouchableOpacity默认点击区域是所有子控件的区域,因为默认一个组件的尺寸由子控件决定 点击事件：onPress|onLongPress|onPressIn|onPressOut disabled:true|false3.Text numberOfLines selectable:true|false 是否允许长按选择文本 suppressHighlighting:true|false 是否允许按下时有灰色阴影 onPress:文字点击事件 ListView1.创建数据源，给数据源设置数据使用state保存数据源 不分组使用：cloneWithRows 分组使用：cloneWithRowsAndSections1234var dataSource = new ListView.DataSource(&#123;rowHasChanged: (r1, r2) =&gt; r1 !== r2&#125;);this.state = &#123;ds: dataSource.cloneWithRows([&apos;row 1&apos;, &apos;row 2&apos;]),&#125;; 12345678var dataSource = new ListView.DataSource(&#123;rowHasChanged:(r1,r2)=&gt;r1 !== r2,sectionHeaderHasChanged:(s1,s2)=&gt;s1 !== s2&#125;);var sectionData = &#123;&#125;;this.state = &#123;ds : dataSource.cloneWithRowsAndSections(sectionData)&#125;; 2.实现数据源方法123456789101112131415161718192021&lt;ListView dataSource=&#123;this.state.ds&#125;renderRow=&#123;this._renderRow.bind(this)&#125;renderSectionHeader=&#123;this._renderSectionHeader.bind(this)&#125;//renderSeparator=&#123;this._renderSeparator.bind(this)&#125;/&gt;_renderRow(rowData, sectionID, rowID, highlightRow) &#123;return (&lt;View&gt;&lt;Text&gt;&#123;rowData&#125;&lt;/Text&gt;&lt;/View&gt;);&#125;//如果是组视图，设置组数据_renderSectionHeader(sectionData, sectionID) &#123;return (&lt;View&gt;&lt;Text&gt;&#123;sectionID&#125;&lt;/Text&gt;&lt;/View&gt;)&#125; 导航Navigator如果找不到Navigator，安装Navigator所在的库：12npm install react-native-deprecated-custom-components --save//yarn add react-native-deprecated-custom-components 项目导入：1import &#123;Navigator&#125; from &apos;react-native-deprecated-custom-components&apos; 参考链接：React Native开发React Native 简介与入门reactnative集成到原生ios项目袁峥-系列","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"ReactNative","slug":"ReactNative","permalink":"https://guchunli.github.io/tags/ReactNative/"}]},{"title":"MVVM学习笔记","date":"2017-05-20T03:38:51.000Z","path":"2017/05/20/MVVM学习笔记/","text":"MVVM的四个组件： view ：由 MVC 中的 view 和 controller 组成，负责 UI 的展示，绑定 viewModel 中的属性，触发 viewModel 中的命令； viewModel ：从 MVC 的 controller 中抽取出来的展示逻辑，负责从 model 中获取 view 所需的数据，转换成 view 可以展示的数据，并暴露公开的属性和命令供 view 进行绑定； model ：与 MVC 中的 model 一致，包括数据模型、访问数据库的操作和网络请求等； binder ：在 MVVM 中，声明式的数据和命令绑定是一个隐含的约定，它可以让开发者非常方便地实现 view 和 viewModel 的同步，避免编写大量繁杂的样板化代码。在微软的 MVVM 实现中，使用的是一种被称为 XAML 的标记语言。 总结：在 iOS 的 MVVM 实现中，我们可以使用 RAC 来在 view 和 viewModel 之间充当 binder 的角色，优雅地实现两者之间的同步。此外，我们还可以把 RAC 用在 model 层，使用 Signal 来代表异步的数据获取操作，比如读取文件、访问数据库和网络请求等。 实现MVC到MVVM的转变 将 MVC 中的 controller 中的展示逻辑抽取出来，放置到 viewModel 中，然后通过一定的技术手段，比如 RAC 来同步 view 和 viewModel。 MVVM相较于MVM的优势 由于展示逻辑被抽取到了 viewModel 中，所以 view 中的代码将会变得非常轻量级； 由于 viewModel 中的代码是与 UI 无关的，所以它具有良好的可测试性； 对于一个封装了大量业务逻辑的 model 来说，改变它可能会比较困难，并且存在一定的风险。在这种场景下，viewModel 可以作为 model 的适配器使用，从而避免对 model 进行较大的改动。 参考链接：MVVM With ReactiveCocoa","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"MVVM","slug":"MVVM","permalink":"https://guchunli.github.io/tags/MVVM/"}]},{"title":"RAC学习笔记","date":"2017-05-20T02:31:47.000Z","path":"2017/05/20/RAC学习笔记/","text":"ReactiveCocoa(RAC):是函数响应式编程(Functional Reactive Programming:FRP)框架，高聚合、低耦合思想。使用cocoapods导入时加上use_frameworks! ReactiveCocoa常见类RACSiganl:信号类(核心)一般表示将来有数据传递，只要有数据改变，信号内部接收到数据，就会马上发出数据。 注意： 信号类(RACSiganl)，只是表示当数据改变时，信号内部会发出数据，它本身不具备发送信号的能力，而是交给内部一个订阅者去发出。 默认一个信号都是冷信号，也就是值改变了，也不会触发，只有订阅了这个信号，这个信号才会变为热信号，值改变了才会触发。 如何订阅信号：调用信号RACSignal的subscribeNext就能订阅。 RACSiganl简单使用 1.创建信号 1$ + (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe 2.订阅信号,才会激活信号. 1$ - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock 3.发送信号 1$ - (void)sendNext:(id)value RACSignal底层实现 1.创建信号，首先把didSubscribe保存到信号中，还不会触发。 2.当信号被订阅，也就是调用signal的subscribeNext:nextBlock 2.1 subscribeNext内部会创建订阅者subscriber，并且把nextBlock保存到subscriber中。 2.2 subscribeNext内部会调用signal的didSubscribe 3.siganl的didSubscribe中调用[subscriber sendNext:@1]; 3.1 sendNext底层其实就是执行subscriber的nextBlock1234567891011121314151617181920// 1.创建信号RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; // block调用时刻：每当有订阅者订阅信号，就会调用block。 // 2.发送信号 [subscriber sendNext:@1]; // 如果不在发送数据，最好发送信号完成，内部会自动调用[RACDisposable disposable]取消订阅信号。 [subscriber sendCompleted]; return [RACDisposable disposableWithBlock:^&#123; // block调用时刻：当信号发送完成或者发送错误，就会自动执行这个block,取消订阅信号。 // 执行完Block后，当前信号就不在被订阅了。 NSLog(@&quot;信号被销毁&quot;); &#125;];&#125;];// 3.订阅信号,才会激活信号.[siganl subscribeNext:^(id x) &#123; // block调用时刻：每当有信号发出数据，就会调用block. NSLog(@&quot;接收到数据:%@&quot;,x);&#125;]; RACSubscriber表示订阅者的意思，用于发送信号，这是一个协议，不是一个类，只要遵守这个协议，并且实现方法才能成为订阅者。通过create创建的信号，都有一个订阅者，帮助他发送数据。 RACDisposable 用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。 使用场景:不想监听某个信号时，可以通过它主动取消订阅信号。 RACSubject 信号提供者，自己可以充当信号，又能发送信号。 使用场景:通常用来代替代理，有了它，就不必要定义代理了。 RACSubject:底层实现和RACSignal不一样。 1.调用subscribeNext订阅信号，只是把订阅者保存起来，并且订阅者的nextBlock已经赋值了。 2.调用sendNext发送信号，遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。 RACSubject使用步骤: 1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。 2.订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock 3.发送信号 sendNext:(id)value123456789101112131415// 1.创建信号RACSubject *subject = [RACSubject subject];// 2.订阅信号[subject subscribeNext:^(id x) &#123;// block调用时刻：当信号发出新值，就会调用.NSLog(@&quot;第一个订阅者%@&quot;,x);&#125;];[subject subscribeNext:^(id x) &#123;// block调用时刻：当信号发出新值，就会调用.NSLog(@&quot;第二个订阅者%@&quot;,x);&#125;];// 3.发送信号[subject sendNext:@&quot;1&quot;]; RACSubject替换代理需求:1.给当前控制器添加一个按钮，modal到另一个控制器界面2.另一个控制器view中有个按钮，点击按钮，通知当前控制器 步骤一：在第二个控制器.h，添加一个RACSubject代替代理。 123@interface TwoViewController : UIViewController@property (nonatomic, strong) RACSubject *delegateSignal;@end 步骤二：监听第二个控制器按钮点击 123456789101112@implementation TwoViewController- (IBAction)notice:(id)sender &#123;// 通知第一个控制器，告诉它，按钮被点了// 通知代理// 判断代理信号是否有值if (self.delegateSignal) &#123; // 有值，才需要通知 [self.delegateSignal sendNext:nil]; &#125;&#125;@end 步骤三：在第一个控制器中，监听跳转按钮，给第二个控制器的代理信号赋值，并且监听. 1234567891011121314@implementation OneViewController - (IBAction)btnClick:(id)sender &#123; // 创建第二个控制器 TwoViewController *twoVc = [[TwoViewController alloc] init]; // 设置代理信号 twoVc.delegateSignal = [RACSubject subject]; // 订阅代理信号 [twoVc.delegateSignal subscribeNext:^(id x) &#123; NSLog(@&quot;点击了通知按钮&quot;); &#125;]; // 跳转到第二个控制器 [self presentViewController:twoVc animated:YES completion:nil];&#125;@end RACReplaySubject重复提供信号类，是RACSubject的子类。RACReplaySubject与RACSubject区别: RACReplaySubject可以先发送信号，在订阅信号，RACSubject就不可以。 使用场景一:如果一个信号每被订阅一次，就需要把之前的值重复发送一遍，使用重复提供信号类。 使用场景二:可以设置capacity数量来限制缓存的value的数量,即只缓充最新的几个值。RACReplaySubject:底层实现和RACSubject不一样。 1.调用sendNext发送信号，把值保存起来，然后遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。 2.调用subscribeNext订阅信号，遍历保存的所有值，一个一个调用订阅者的nextBlock注意：如果想当一个信号被订阅，就重复播放之前所有值，需要先发送信号，在订阅信号。也就是先保存值，在订阅值。RACReplaySubject使用步骤: 1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。 2.可以先订阅信号，也可以先发送信号。 2.1 订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock 2.2 发送信号 sendNext:(id)value12345678910111213141516// 1.创建信号RACReplaySubject *replaySubject = [RACReplaySubject subject];// 2.发送信号[replaySubject sendNext:@1];[replaySubject sendNext:@2];// 3.订阅信号[replaySubject subscribeNext:^(id x) &#123; NSLog(@&quot;第一个订阅者接收到的数据%@&quot;,x);&#125;];// 订阅信号[replaySubject subscribeNext:^(id x) &#123; NSLog(@&quot;第二个订阅者接收到的数据%@&quot;,x);&#125;]; RACTuple元组类,类似NSArray,用来包装值. RACSequenceRAC中的集合类，用于代替NSArray,NSDictionary,可以使用它来快速遍历数组和字典。使用场景：字典转模型RACSequence和RACTuple简单使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 1.遍历数组NSArray *numbers = @[@1,@2,@3,@4];// 第一步: 把数组转换成集合RACSequence numbers.rac_sequence// 第二步: 把集合RACSequence转换RACSignal信号类,numbers.rac_sequence.signal// 第三步: 订阅信号，激活信号，会自动把集合中的所有值，遍历出来。[numbers.rac_sequence.signal subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x);&#125;];// 2.遍历字典,遍历出来的键值对会包装成RACTuple(元组对象)NSDictionary *dict = @&#123;@&quot;name&quot;:@&quot;zs&quot;,@&quot;age&quot;:@18&#125;;[dict.rac_sequence.signal subscribeNext:^(RACTuple *x) &#123;// 解包元组，会把元组的值，按顺序给参数里面的变量赋值RACTupleUnpack(NSString *key,NSString *value) = x; // 相当于以下写法 // NSString *key = x[0]; // NSString *value = x[1]; NSLog(@&quot;%@ %@&quot;,key,value);&#125;];// 3.字典转模型// 3.1 OC写法NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;flags.plist&quot; ofType:nil];NSArray *dictArr = [NSArray arrayWithContentsOfFile:filePath];NSMutableArray *items = [NSMutableArray array];for (NSDictionary *dict in dictArr) &#123; FlagItem *item = [FlagItem flagWithDict:dict]; [items addObject:item];&#125;// 3.2 RAC写法NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;flags.plist&quot; ofType:nil];NSArray *dictArr = [NSArray arrayWithContentsOfFile:filePath];NSMutableArray *flags = [NSMutableArray array];_flags = flags;// rac_sequence注意点：调用subscribeNext，并不会马上执行nextBlock，而是会等一会。[dictArr.rac_sequence.signal subscribeNext:^(id x) &#123; // 运用RAC遍历字典，x：字典 FlagItem *item = [FlagItem flagWithDict:x]; [flags addObject:item];&#125;];NSLog(@&quot;%@&quot;, NSStringFromCGRect([UIScreen mainScreen].bounds));// 3.3 RAC高级写法:NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;flags.plist&quot; ofType:nil];NSArray *dictArr = [NSArray arrayWithContentsOfFile:filePath];// map:映射的意思，目的：把原始值value映射成一个新值// array: 把集合转换成数组// 底层实现：当信号被订阅，会遍历集合中的原始值，映射成新值，并且保存到新的数组里。NSArray *flags = [[dictArr.rac_sequence map:^id(id value) &#123; return [FlagItem flagWithDict:value];&#125;] array]; RACCommandRAC中用于处理事件的类，可以把事件如何处理,事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。使用场景:监听按钮点击，网络请求 RACCommand使用步骤: 1.创建命令 initWithSignalBlock:(RACSignal * (^)(id input))signalBlock 2.在signalBlock中，创建RACSignal，并且作为signalBlock的返回值 3.执行命令 - (RACSignal *)execute:(id)input RACCommand使用注意 1.signalBlock必须要返回一个信号，不能传nil. 2.如果不想要传递信号，直接创建空的信号[RACSignal empty]; 3.RACCommand中信号如果数据传递完，必须调用[subscriber sendCompleted]，这时命令才会执行完毕，否则永远处于执行中。 4.RACCommand需要被强引用，否则接收不到RACCommand中的信号，因此RACCommand中的信号是延迟发送的。 RACCommand设计思想：内部signalBlock为什么要返回一个信号，这个信号有什么用。 1.在RAC开发中，通常会把网络请求封装到RACCommand，直接执行某个RACCommand就能发送请求。 2.当RACCommand内部请求到数据的时候，需要把请求的数据传递给外界，这时候就需要通过signalBlock返回的信号传递了。 如何拿到RACCommand中返回信号发出的数据。 1.RACCommand有个执行信号源executionSignals，这个是signal of signals(信号的信号),意思是信号发出的数据是信号，不是普通的类型。 2.订阅executionSignals就能拿到RACCommand中返回的信号，然后订阅signalBlock返回的信号，就能获取发出的值。 五、监听当前命令是否正在执行executing 六、使用场景,监听按钮点击，网络请求 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 1.创建命令RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) &#123; NSLog(@&quot;执行命令&quot;); // 创建空信号,必须返回信号 // return [RACSignal empty]; // 2.创建信号,用来传递数据 return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;请求数据&quot;]; // 注意：数据传递完，最好调用sendCompleted，这时命令才执行完毕。 [subscriber sendCompleted]; return nil; &#125;];&#125;];// 强引用命令，不要被销毁，否则接收不到数据_conmmand = command;// 3.订阅RACCommand中的信号[command.executionSignals subscribeNext:^(id x) &#123; [x subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x); &#125;];&#125;];// RAC高级用法// switchToLatest:用于signal of signals，获取signal of signals发出的最新信号,也就是可以直接拿到RACCommand中的信号[command.executionSignals.switchToLatest subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x);&#125;];// 4.监听命令是否执行完毕,默认会来一次，可以直接跳过，skip表示跳过第一次信号。[[command.executing skip:1] subscribeNext:^(id x) &#123; if ([x boolValue] == YES) &#123; // 正在执行 NSLog(@&quot;正在执行&quot;); &#125;else&#123; // 执行完成 NSLog(@&quot;执行完成&quot;); &#125;&#125;];// 5.执行命令[self.conmmand execute:@1]; RACMulticastConnection用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。注意:RACMulticastConnection通过RACSignal的-publish或者-muticast:方法创建. RACMulticastConnection使用步骤: 1.创建信号 + (RACSignal )createSignal:(RACDisposable (^)(id subscriber))didSubscribe 2.创建连接 RACMulticastConnection *connect = [signal publish]; 3.订阅信号,注意：订阅的不在是之前的信号，而是连接的信号。 [connect.signal subscribeNext:nextBlock] 4.连接 [connect connect] RACMulticastConnection底层原理: 1.创建connect，connect.sourceSignal -&gt; RACSignal(原始信号) connect.signal -&gt; RACSubject 2.订阅connect.signal，会调用RACSubject的subscribeNext，创建订阅者，而且把订阅者保存起来，不会执行block。 3.[connect connect]内部会订阅RACSignal(原始信号)，并且订阅者是RACSubject 3.1.订阅原始信号，就会调用原始信号中的didSubscribe 3.2 didSubscribe，拿到订阅者调用sendNext，其实是调用RACSubject的sendNext 4.RACSubject的sendNext,会遍历RACSubject所有订阅者发送信号。 4.1 因为刚刚第二步，都是在订阅RACSubject，因此会拿到第二步所有的订阅者，调用他们的nextBlock 需求：假设在一个信号中发送请求，每次订阅一次都会发送请求，这样就会导致多次请求。解决：使用RACMulticastConnection就能解决. 123456789101112131415// 1.创建请求信号RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@&quot;发送请求&quot;); return nil;&#125;];// 2.订阅信号[signal subscribeNext:^(id x) &#123; NSLog(@&quot;接收数据&quot;);&#125;];// 2.订阅信号[signal subscribeNext:^(id x) &#123; NSLog(@&quot;接收数据&quot;);&#125;];// 3.运行结果，会执行两遍发送请求，也就是每次订阅都会发送一次请求 RACMulticastConnection:解决重复请求问题 12345678910111213141516171819202122// 1.创建信号RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@&quot;发送请求&quot;); [subscriber sendNext:@1]; return nil;&#125;];// 2.创建连接RACMulticastConnection *connect = [signal publish];// 3.订阅信号，// 注意：订阅信号，也不能激活信号，只是保存订阅者到数组，必须通过连接,当调用连接，就会一次性调用所有订阅者的sendNext:[connect.signal subscribeNext:^(id x) &#123; NSLog(@&quot;订阅者一信号&quot;);&#125;];[connect.signal subscribeNext:^(id x) &#123; NSLog(@&quot;订阅者二信号&quot;);&#125;];// 4.连接,激活信号[connect connect]; RACSchedulerRAC中的队列，用GCD封装的。 RACUnit表⽰stream不包含有意义的值,也就是看到这个，可以直接理解为nil. RACEvent把数据包装成信号事件(signal event)。它主要通过RACSignal的-materialize来使用，然并卵。 ReactiveCocoa开发中常见用法。代替代理rac_signalForSelector：用于替代代理。 代替KVOrac_valuesAndChangesForKeyPath：用于监听某个对象的属性改变。 监听事件rac_signalForControlEvents：用于监听某个事件。 代替通知rac_addObserverForName:用于监听某个通知。 监听文本框文字改变rac_textSignal:只要文本框发出改变就会发出这个信号。 处理当界面有多次请求时，需要都获取到数据时，才能展示界面rac_liftSelector:withSignalsFromArray:Signals:当传入的Signals(信号数组)，每一个signal都至少sendNext过一次，就会去触发第一个selector参数的方法。使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据。代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 1.代替代理// 需求：自定义redView,监听红色view中按钮点击// 之前都是需要通过代理监听，给红色View添加一个代理属性，点击按钮的时候，通知代理做事情// rac_signalForSelector:把调用某个对象的方法的信息转换成信号，就要调用这个方法，就会发送信号。// 这里表示只要redV调用btnClick:,就会发出信号，订阅就好了。[[redV rac_signalForSelector:@selector(btnClick:)] subscribeNext:^(id x) &#123; NSLog(@&quot;点击红色按钮&quot;);&#125;];// 2.KVO// 把监听redV的center属性改变转换成信号，只要值改变就会发送信号// observer:可以传入nil[[redV rac_valuesAndChangesForKeyPath:@&quot;center&quot; options:NSKeyValueObservingOptionNew observer:nil] subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x);&#125;];// 3.监听事件// 把按钮点击事件转换为信号，点击按钮，就会发送信号[[self.btn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) &#123; NSLog(@&quot;按钮被点击了&quot;);&#125;];// 4.代替通知// 把监听到的通知转换信号[[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIKeyboardWillShowNotification object:nil] subscribeNext:^(id x) &#123; NSLog(@&quot;键盘弹出&quot;);&#125;];// 5.监听文本框的文字改变[_textField.rac_textSignal subscribeNext:^(id x) &#123; NSLog(@&quot;文字改变了%@&quot;,x);&#125;];// 6.处理多个请求，都返回结果的时候，统一做处理.RACSignal *request1 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;// 发送请求1[subscriber sendNext:@&quot;发送请求1&quot;]; return nil;&#125;];RACSignal *request2 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; // 发送请求2 [subscriber sendNext:@&quot;发送请求2&quot;]; return nil;&#125;];// 使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据。[self rac_liftSelector:@selector(updateUIWithR1:r2:) withSignalsFromArray:@[request1,request2]];&#125;// 更新UI- (void)updateUIWithR1:(id)data r2:(id)data1&#123; NSLog(@&quot;更新UI%@ %@&quot;,data,data1);&#125; ReactiveCocoa常见宏RAC(TARGET, [KEYPATH, [NIL_VALUE]])用于给某个对象的某个属性绑定。12// 只要文本框文字改变，就会修改label的文字RAC(self.labelView,text) = _textField.rac_textSignal; RACObserve(self, name)监听某个对象的某个属性,返回的是信号。123[RACObserve(self.view, center) subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x);&#125;]; @weakify(Obj)和@strongify(Obj)一般两个都是配套使用,在主头文件(ReactiveCocoa.h)中并没有导入，需要自己手动导入，RACEXTScope.h才可以使用。但是每次导入都非常麻烦，只需要在主头文件自己导入就好了。 RACTuplePack把数据包装成RACTuple（元组类）12// 把参数中的数据包装成元组RACTuple *tuple = RACTuplePack(@10,@20); RACTupleUnpack：把RACTuple（元组类）解包成对应的数据。123456// 把参数中的数据包装成元组RACTuple *tuple = RACTuplePack(@&quot;abc&quot;,@20);// 解包元组，会把元组的值，按顺序给参数里面的变量赋值// name = @&quot;abc&quot; age = @20RACTupleUnpack(NSString *name,NSNumber *age) = tuple; 原文链接：最快让你上手ReactiveCocoa之基础篇","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"RAC","slug":"RAC","permalink":"https://guchunli.github.io/tags/RAC/"}]},{"title":"iOS多媒体学习笔记","date":"2017-05-06T03:41:05.000Z","path":"2017/05/06/iOS多媒体学习笔记/","text":"音频音效 AudioToolbox.framework限制： 音频播放时间不能超过30s 数据必须是PCM或者IMA4格式 音频文件必须打包成.caf、.aif、.wav中的一种（注意这是官方文档的说法，实际测试发现一些.mp3也可以播放） 音乐 AVAudioPlayerAVFoundation.framework中的AVAudioPlayerAVAudioPlayer可以看成一个播放器，它支持多种音频格式，而且能够进行进度、音量、播放速度等控制。AVAudioPlayer使用： 初始化AVAudioPlayer对象，此时通常指定本地文件路径。 设置播放器属性，例如重复次数、音量大小等。 调用play方法播放。 MPMusicPlayerController音频会话 AVAudioSession支持后台播放： 1.设置后台运行模式：在plist文件中添加Required background modes，并且设置item 0=App plays audio or streams audio/video using AirPlay（其实可以直接通过Xcode在Project Targets-Capabilities-Background Modes中设置） 2.设置AVAudioSession的类型为AVAudioSessionCategoryPlayback并且调用setActive::方法启动会话。 123AVAudioSession *audioSession=[AVAudioSession sharedInstance];[audioSession setCategory:AVAudioSessionCategoryPlayback error:nil];[audioSession setActive:YES error:nil]; 3.为了能够让应用退到后台之后支持耳机控制，建议添加远程控制事件（这一步不是后台播放必须的）在iOS中每个应用都有一个音频会话，这个会话就通过AVAudioSession来表示。AVAudioSession同样存在于AVFoundation框架中，它是单例模式设计，通过sharedInstance进行访问。在使用Apple设备时大家会发现有些应用只要打开其他音频播放就会终止，而有些应用却可以和其他应用同时播放，在多种音频环境中如何去控制播放的方式就是通过音频会话来完成的。 音频队列服务（Audio Queue Services） AVAudioPlayer只能播放本地文件，并且是一次性加载所以音频数据，初始化AVAudioPlayer时指定的URL也只能是File URL而不能是HTTP URL。 AudioToolbox框架中的音频队列服务Audio Queue Services，支持网络流媒体播放。 FSAudioStream录音AVAudioRecorderAVFoundation框架中的AVAudioRecorder类info.plist 添加 NSMicrophoneUsageDescription 音频队列服务（Audio Queue Services）视频播放MPMoviePlayerControllerMediaPlayer.framework种的MPMoviePlayerController类，它支持本地视频和网络视频播放，如果要在UI中展示视频需要将view属性添加到界面中。 MPMoviePlayerViewController默认全屏播放，开发者在开发的时候直接使用这个视图控制器。注意：由于MPMoviePlayerViewController的初始化方法做了大量工作（例如设置URL、自动播放、添加点击Done完成的监控等），所以当再次点击播放弹出新的模态窗口的时如果不销毁之前的MPMoviePlayerViewController，那么新的对象就无法完成初始化，这样也就不能再次进行播放。 AVPlayerAVPlayer存在于AVFoundation中，它更加接近于底层，所以灵活性也更强。AVPlayer本身并不能显示视频，而且它也不像MPMoviePlayerController有一个view属性。如果AVPlayer要显示必须创建一个播放器层AVPlayerLayer用于展示，播放器层继承于CALayer，有了AVPlayerLayer之添加到控制器视图的layer中即可。几个相关类： AVAsset：主要用于获取多媒体信息，是一个抽象类，不能直接使用。 AVURLAsset：AVAsset的子类，可以根据一个URL路径创建一个包含媒体信息的AVURLAsset对象。 AVPlayerItem：一个媒体资源管理对象，管理者视频的一些基本信息和状态，一个AVPlayerItem对应着一个视频资源。 视频截图MPMoviePlayerControllerAVAssetImageGeneratorAVFundation框架中的AVAssetImageGenerator123456789101112131415161718192021222324252627282930/*** 截取指定时间的视频缩略图** @param timeBySecond 时间点*/-(void)thumbnailImageRequest:(CGFloat )timeBySecond&#123; //创建URL NSURL *url=[self getNetworkUrl]; //根据url创建AVURLAsset AVURLAsset *urlAsset=[AVURLAsset assetWithURL:url]; //根据AVURLAsset创建AVAssetImageGenerator AVAssetImageGenerator *imageGenerator=[AVAssetImageGenerator assetImageGeneratorWithAsset:urlAsset]; /*截图 * requestTime:缩略图创建时间 * actualTime:缩略图实际生成的时间 */ NSError *error=nil; CMTime time=CMTimeMakeWithSeconds(timeBySecond, 10);//CMTime是表示电影时间信息的结构体，第一个参数表示是视频第几秒，第二个参数表示每秒帧数.(如果要活的某一秒的第几帧可以使用CMTimeMake方法) CMTime actualTime; CGImageRef cgImage= [imageGenerator copyCGImageAtTime:time actualTime:&amp;actualTime error:&amp;error]; if(error)&#123; NSLog(@&quot;截取视频缩略图时发生错误，错误信息：%@&quot;,error.localizedDescription); return; &#125; CMTimeShow(actualTime); UIImage *image=[UIImage imageWithCGImage:cgImage];//转化为UIImage //保存到相册 UIImageWriteToSavedPhotosAlbum(image,nil, nil, nil); CGImageRelease(cgImage);&#125; 第三方iOS上常用的视频编码、解码框架有：VLC、ffmpeg 摄像头（拍照和视频录制）UIImagePickerControllerUIImagePickerController继承于UINavigationController AVFoundation（AVCaptureSession/AVCaptureDevice）灵活性强。 参考原文：iOS开发系列–音频播放、录音、视频播放、拍照、视频录制","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"音频","slug":"音频","permalink":"https://guchunli.github.io/tags/音频/"},{"name":"视频","slug":"视频","permalink":"https://guchunli.github.io/tags/视频/"},{"name":"播放","slug":"播放","permalink":"https://guchunli.github.io/tags/播放/"},{"name":"录制","slug":"录制","permalink":"https://guchunli.github.io/tags/录制/"}]},{"title":"RAC与Target-Action、通知、代理、KVO","date":"2017-04-23T03:30:03.000Z","path":"2017/04/23/RAC与Target-Action、通知、代理、KVO/","text":"ReactiveCocoa作用1.target-action:rac_signalForControlEventsrac_textSignal rac_gestureSignal2.代理 rac_signalForSelector:@selector() fromProtocol:()3.通知 rac_addObserverForName4.KVO RACObserve(object, value) 代码示例：1.target-action123456789101112131415161718//1.1 监听textfield文字更改[[self.textfiled rac_signalForControlEvents:UIControlEventEditingChanged] subscribeNext:^(id x)&#123; NSLog(@&quot;change&quot;);&#125;];//简写[[self.textfiled rac_textSignal] subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x);&#125;];//1.2UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] init]; [[tap rac_gestureSignal] subscribeNext:^(id x) &#123; NSLog(@&quot;tap&quot;);&#125;];//注意：如果给label添加手势，需要打开userInteractionEnabledself.lab.userInteractionEnabled = YES;[self.lab addGestureRecognizer:tap]; 2.代理：rac_signalForSelector:@selector() fromProtocol:()* 注意：只能实现返回值为void的代理方法12345678910111213UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@&quot;title&quot; message:@&quot;rac test&quot; delegate:self cancelButtonTitle:@&quot;no&quot; otherButtonTitles:@&quot;yes&quot;, nil]; [[self rac_signalForSelector:@selector(alertView:clickedButtonAtIndex:) fromProtocol:@protocol(UIAlertViewDelegate)] subscribeNext:^(RACTuple *tuple) &#123; //tuple为点击按钮的各个参数 NSLog(@&quot;%ld&quot;,tuple.count); //参数个数 2 NSLog(@&quot;%@&quot;,tuple.first); //alertView NSLog(@&quot;%@&quot;,tuple.second); //buttonIndex NSLog(@&quot;%@&quot;,tuple.third); //null &#125;];//简写[[alertView rac_buttonClickedSignal] subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x); //buttonIndex&#125;];[alertView show]; 3.通知 rac_addObserverForName点击一个页面可以更新另一个页面数据123456[[[NSNotificationCenter defaultCenter] rac_addObserverForName:@&quot;postData&quot; object:nil] subscribeNext:^(NSNotification *notification) &#123; NSLog(@&quot;%@&quot;, notification.name); NSLog(@&quot;%@&quot;, notification.object);&#125;];[self presentViewController:[[SecondViewController alloc]init] animated:YES completion:nil]; SecondViewController代码：123NSMutableArray *dataArray = [[NSMutableArray alloc] initWithObjects:@&quot;1&quot;, @&quot;2&quot;, @&quot;3&quot;, nil];[[NSNotificationCenter defaultCenter] postNotificationName:@&quot;postData&quot; object:dataArray];[self dismissViewControllerAnimated:YES completion:nil]; 4.KVO RACObserve(object, value)1234567UIScrollView *scrolView = [[UIScrollView alloc] initWithFrame:CGRectMake(0, 300, 200, 400)];scrolView.contentSize = CGSizeMake(200, 800);scrolView.backgroundColor = [UIColor greenColor];[self.view addSubview:scrolView];[RACObserve(scrolView, contentOffset) subscribeNext:^(id x) &#123; NSLog(@&quot;success&quot;);&#125;]; 原文链接：学习RAC小记-适合给新手看的RAC用法总结","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"RAC","slug":"RAC","permalink":"https://guchunli.github.io/tags/RAC/"}]},{"title":"iOS IM学习笔记","date":"2017-04-22T03:19:11.000Z","path":"2017/04/22/iOS-IM学习笔记/","text":"客户端需要做如下4件事： 1.客户端调用 socket(…) 创建socket； 2.客户端调用 connect(…) 向服务器发起连接请求以建立连接； 3.客户端与服务器建立连接之后，就可以通过send(…)/receive(…)向客户端发送或从客户端接收数据； 4.客户端调用 close 关闭 socket； 服务端需要做如下5件事： 1.服务器调用 socket(…) 创建socket； 2.服务器调用 listen(…) 设置缓冲区； 3.服务器通过 accept(…)接受客户端请求建立连接； 4.服务器与客户端建立连接之后，就可以通过 send(…)/receive(…)向客户端发送或从客户端接收数据； 5.服务器调用 close 关闭 socket； 可以通过以下几种方式实现： 1.系统socket 2.基于Scoket原生：代表框架 CocoaAsyncSocket 3.基于WebScoket：代表框架 SocketRocket。(npm install ws) 4.MQTTKit：MQTTClient(npm install mosca) 5.XMPP 6.私有协议：基于WebScoket或者Scoket原生进行封装（高效，省流量，安全性高）其中MQTT和XMPP为聊天协议，它们是最上层的协议，而WebScoket是传输通讯协议。 XMPP常用对象：XMPPStream：xmpp基础服务类XMPPRoster：好友列表类XMPPRosterCoreDataStorage：好友列表（用户账号）在core data中的操作类XMPPvCardCoreDataStorage：好友名片（昵称，签名，性别，年龄等信息）在core data中的操作类XMPPvCardTemp：好友名片实体类，从数据库里取出来的都是它xmppvCardAvatarModule：好友头像XMPPReconnect：如果失去连接,自动重连XMPPRoom：提供多用户聊天支持XMPPPubSub：发布订阅 代码传送门：IMWithSocket 参考原文：iOS即时通讯，从入门到“放弃”？iOS - XMPP 的使用","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"IM","slug":"IM","permalink":"https://guchunli.github.io/tags/IM/"},{"name":"socket","slug":"socket","permalink":"https://guchunli.github.io/tags/socket/"}]},{"title":"北京十渡","date":"2017-04-16T06:49:48.000Z","path":"2017/04/16/北京十渡/","text":"2017-04-16 北京十渡飞拉达、蹦极 今天真是玩嗨了 早上六点起床，准备好之后早早出了门，乘地铁赶往公主坟与大家集合。到了集合地，坐着租的面包车开始前往目的地————十渡。 十渡景区位于北京房山，到了景区之后，带队的队长确定参加飞拉达的人数开始买票。之前了解了一下飞拉达就是攀岩（岩壁探险或铁道式攀登），因为之前从来没参与过类似冒险运动，心里有点小紧张。因为人还比较多，所以一块请了一位教练。刚开始教练教授装备的穿戴，之后带领我们来到了攀岩的山脚下，教练说这座山大概有70多米，之后告诉了我们扣锁的使用，然后开始攀爬演示，小伙伴们也开始一个个紧随其后开始了攀爬之路。 飞拉达历经大约三个小时，穿越了ABCD区，终于到达了终点。教练帮我们把所有锁扣都挂到绳索上，下面是湖水，随着绳索划过去才算再次到达了地面。 之后和大家一起腐败吃午餐，吃午餐的餐厅对面正好就是蹦极的跳台，是不是看着一个个挑战者坠落、弹跳… 由于某些原因（吃的有点多了，惭愧…），本来打算不参加蹦极了，但是一想如果不参加，回去之后一定会捶胸顿足，后悔不跌，而且同性的小伙伴除了一对情侣之外都参加了，狠了狠心还是买了票。 来到蹦极门口，工作人员给每个人测量了身高和体重，并把数据写到了手背上。由于蹦极的人很多，等了大约有两三个小时，期间目睹一个一个从跳台自由落体，还有情侣相拥跳下，他们调侃这肯定是他们这辈子抱得最紧的一次了吧~~轮到我们的时候，不知怎么安排的被调到了最后一个，轮到我的时候，工作人员开始给我腿上绑绳，把眼镜粘到了胳膊上，为了避免女生走光把上衣和裤子的连接处也用胶带粘上了，说实话，自从买了票心有一直还挺紧张的，但真到了马上就要跳下去的时候，心里反而没有那么紧张了，还算比较平静。起跳之前冲着镜头挥挥手，然后只要张开双臂就可以了，看着50米下宽阔的湖水，心里还真是怂了，嗯，怂了（幸亏自己还是近视眼，并且还没戴眼镜）…接着工作人员扶着胳膊向前推去，从未有过的自由落体的失重感觉瞬间侵占了大脑，一片空白，只得紧闭双眼，只感觉到达最低点之后又弹跳到了下降高度的三分之二，然后又开始降落，才敢睁开眼睛环顾四周，之后又弹了大概两三次，高度就不是很高了，才开始享受蹦极的乐趣，然后就被放了下来，湖面上又专业人员把我接了下去，整个过程也就是一两分钟的样子，算是真切的感受了一次蹦极的刺激！ 今天认识了一个很说的来的朋友，我俩基本上叽叽喳喳聊了一天，感觉很是投缘，遇到很聊得来的人总是感觉心情很舒畅！也认识了一个四川的男生，还在上大学，曾经自己骑行去过云南，还认识了一个广州的女孩（就是下图中的女孩），刚辞了工作专门出来游玩的，很佩服这种勇气！ 最后用鹿晗的《某时某刻 Catch me when I fall》结个尾~~~","comments":true,"categories":[{"name":"随笔","slug":"other","permalink":"https://guchunli.github.io/categories/other/"}],"tags":[{"name":"十渡","slug":"十渡","permalink":"https://guchunli.github.io/tags/十渡/"},{"name":"蹦极","slug":"蹦极","permalink":"https://guchunli.github.io/tags/蹦极/"}]},{"title":"iOS打包提交APP Store注意事项","date":"2017-04-13T04:20:22.000Z","path":"2017/04/13/iOS打包提交APP-Store注意事项/","text":"1.改为正式环境 接口改成线上服务器 极光推送环境改为生产环境等 2.版本号target -&gt; general：Version和Build版本号3.签名target -&gt; general -&gt; signing 4.删除断点，log 5.本地化，语言包 6.Capabilities -&gt; background modes如果后台使用了位置，提交信息中应用描述添加免责声明 温馨提示：GPS在后台持续运行，会大大降低电池的寿命。 7.edit scheme: run,archive -&gt; debug 改为 release 8.打包ad-hoc，进行内测：clean -&gt; build -&gt; archive 最后，打正式包，提交APP Store。","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"app store","slug":"app-store","permalink":"https://guchunli.github.io/tags/app-store/"}]},{"title":"iOS单元测试学习笔记","date":"2017-04-09T06:16:58.000Z","path":"2017/04/09/iOS单元测试学习笔记/","text":"1.新建项目时注意勾选Unit Tests,UI Tests如果忘记勾选，File–&gt;new–&gt;target–&gt;iOS–&gt;Cocoa Unit Testing Bundle/Cocoa UI Testing Bundle 添加2.setUp是每个测试方法调用前执行，tearDown是每个测试方法调用后执行3.测试方法必须testXXX的格式，且不能有参数4.测试方法的执行顺序是字典序排序,cmd + U进行单元测试，这个快捷键是全部测试，在代码左侧就是平常打断点的地方，有个菱形按钮是单独测试这个方法5.iOS9的http安全问题：现在进行异步请求的网络测试，由于测试方法主线程执行完就会结束，所以需要设置一下，否则没法查看异步返回结果。在方法结束前设置等待，调回回来的时候再让它继续执行。12345678//waitForExpectationsWithTimeout是等待时间，超过了就不再等待往下执行。#define WAIT do &#123;\\[self expectationForNotification:@&quot;RSBaseTest&quot; object:nil handler:nil];\\[self waitForExpectationsWithTimeout:30 handler:nil];\\&#125; while (0);#define NOTIFY \\[[NSNotificationCenter defaultCenter]postNotificationName:@&quot;RSBaseTest&quot; object:nil]; 常用的断言测试函数XCTFail(format…) //生成一个失败的测试；XCTAssertNil(a1, format…) //为空判断，a1为空时通过，反之不通过；XCTAssertNotNil(a1, format…) //不为空判断，a1不为空时通过，反之不通过；XCTAssert(expression, format…) //当expression求值为TRUE时通过；XCTAssertTrue(expression, format…) //当expression求值为TRUE时通过；XCTAssertFalse(expression, format…) //当expression求值为False时通过；XCTAssertEqualObjects(a1, a2, format…) //判断相等，[a1 isEqual:a2]值为TRUE时通过，其中一个不为空时，不通过；XCTAssertNotEqualObjects(a1, a2, format…) //判断不等，[a1 isEqual:a2]值为False时通过；XCTAssertEqual(a1, a2, format…) //判断相等（当a1和a2是 C语言标量、结构体或联合体时使用,实际测试发现NSString也可以）；XCTAssertNotEqual(a1, a2, format…) //判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；XCTAssertEqualWithAccuracy(a1, a2, accuracy, format…) //判断相等，（double或float类型）提供一个误差范围，当在误差范围（+/-accuracy）以内相等时通过测试；XCTAssertNotEqualWithAccuracy(a1, a2, accuracy, format…) //判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试；XCTAssertThrows(expression, format…) //异常测试，当expression发生异常时通过；反之不通过；XCTAssertThrowsSpecific(expression, specificException, format…) //异常测试，当expression发生specificException异常时通过；反之发生其他异常或不发生异常均不通过；XCTAssertThrowsSpecificNamed(expression, specificException, exception_name, format…) //异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过；XCTAssertNoThrow(expression, format…) //异常测试，当expression没有发生异常时通过测试；XCTAssertNoThrowSpecific(expression, specificException, format…) //异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过；XCTAssertNoThrowSpecificNamed(expression, specificException, exception_name, format…) //异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过 示例代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// XCTFail(format…) //生成一个失败的测试；// XCTFail(@&quot;Fail&quot;);// XCTAssertNil(a1, format...) 为空判断， a1 为空时通过，反之不通过；// XCTAssertNil(@&quot;not nil string&quot;, @&quot;string must be nil&quot;);// XCTAssertNotNil(a1, format…) 不为空判断，a1不为空时通过，反之不通过；XCTAssertNotNil(@&quot;not nil string&quot;, @&quot;string can not be nil&quot;);// XCTAssert(expression, format...) 当expression求值为TRUE时通过；// XCTAssert((2 &gt; 2), @&quot;expression must be true&quot;);// XCTAssertTrue(expression, format...) 当expression求值为TRUE时通过；XCTAssertTrue(1, @&quot;Can not be zero&quot;);// XCTAssertFalse(expression, format...) 当expression求值为False时通过；XCTAssertFalse((2 &lt; 2), @&quot;expression must be false&quot;);// XCTAssertEqualObjects(a1, a2, format...) 判断相等， [a1 isEqual:a2] 值为TRUE时通过，其中一个不为空时，不通过；// XCTAssertEqualObjects(@&quot;1&quot;, @&quot;1&quot;, @&quot;[a1 isEqual:a2] should return YES&quot;);// XCTAssertEqualObjects(@&quot;1&quot;, @&quot;2&quot;, @&quot;[a1 isEqual:a2] should return YES&quot;);// XCTAssertNotEqualObjects(a1, a2, format...) 判断不等， [a1 isEqual:a2] 值为False时通过，// XCTAssertNotEqualObjects(@&quot;1&quot;, @&quot;1&quot;, @&quot;[a1 isEqual:a2] should return NO&quot;);// XCTAssertNotEqualObjects(@&quot;1&quot;, @&quot;2&quot;, @&quot;[a1 isEqual:a2] should return NO&quot;);// XCTAssertEqual(a1, a2, format...) 判断相等（当a1和a2是 C语言标量、结构体或联合体时使用,实际测试发现NSString也可以）；// 1.比较基本数据类型变量// XCTAssertEqual(1, 2, @&quot;a1 = a2 shoud be true&quot;); // 无法通过测试// XCTAssertEqual(1, 1, @&quot;a1 = a2 shoud be true&quot;); // 通过测试// 2.比较NSString对象// NSString *str1 = @&quot;1&quot;;// NSString *str2 = @&quot;1&quot;;// NSString *str3 = str1;// XCTAssertEqual(str1, str2, @&quot;a1 and a2 should point to the same object&quot;); // 通过测试// XCTAssertEqual(str1, str3, @&quot;a1 and a2 should point to the same object&quot;); // 通过测试// 3.比较NSArray对象// NSArray *array1 = @[@1];// NSArray *array2 = @[@1];// NSArray *array3 = array1;// XCTAssertEqual(array1, array2, @&quot;a1 and a2 should point to the same object&quot;); // 无法通过测试// XCTAssertEqual(array1, array3, @&quot;a1 and a2 should point to the same object&quot;); // 通过测试// XCTAssertNotEqual(a1, a2, format...) 判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；// XCTAssertEqualWithAccuracy(a1, a2, accuracy, format...) 判断相等，（double或float类型）提供一个误差范围，当在误差范围（+/- accuracy ）以内相等时通过测试；// XCTAssertEqualWithAccuracy(1.0f, 1.5f, 0.25f, @&quot;a1 = a2 in accuracy should return YES&quot;);// XCTAssertNotEqualWithAccuracy(a1, a2, accuracy, format...) 判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试；// XCTAssertNotEqualWithAccuracy(1.0f, 1.5f, 0.25f, @&quot;a1 = a2 in accuracy should return NO&quot;);// XCTAssertThrows(expression, format...) 异常测试，当expression发生异常时通过；反之不通过；（很变态）// XCTAssertThrowsSpecific(expression, specificException, format...) 异常测试，当expression发生 specificException 异常时通过；反之发生其他异常或不发生异常均不通过；// XCTAssertThrowsSpecificNamed(expression, specificException, exception_name, format...) 异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过；// XCTAssertNoThrow(expression, format…) 异常测试，当expression没有发生异常时通过测试；// XCTAssertNoThrowSpecific(expression, specificException, format...)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过；// XCTAssertNoThrowSpecificNamed(expression, specificException, exception_name, format...) 异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过 转自：iOS单元测试(作用及入门提升)(http://www.jianshu.com/p/009844a0b9ed)","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"test","slug":"test","permalink":"https://guchunli.github.io/tags/test/"}]},{"title":"2017玉渊潭樱花节","date":"2017-04-08T11:54:47.000Z","path":"2017/04/08/2017玉渊潭樱花节/","text":"2017-04-08 玉渊潭樱花节 去年就打算去玉渊潭看花的忘了是什么原因错过了花期，没能去成心里总觉得遗憾今年决定不能再错过一定要去看看的虽然今天天气不太好，但是花开尤盛，自以为很是不错也算是了了一个小小心愿 最重要的是去了，并且看到了不是么~~","comments":true,"categories":[{"name":"随笔","slug":"other","permalink":"https://guchunli.github.io/categories/other/"}],"tags":[{"name":"玉渊潭","slug":"玉渊潭","permalink":"https://guchunli.github.io/tags/玉渊潭/"},{"name":"樱花节","slug":"樱花节","permalink":"https://guchunli.github.io/tags/樱花节/"}]},{"title":"iOS runtime学习笔记","date":"2017-03-22T03:39:18.000Z","path":"2017/03/22/iOS-runtime学习笔记/","text":"Objective-C 是一门动态语言，它把很多静态语言在编译和链接时做的事情放到了运行时去处理，它在运行时实现了对类、方法、成员变量、属性等信息的管理机制。 运行时的类与对象 类与对象相关的函数12345678910111213141516171819202122232425262728293031const char *class_getName(Class cls)，获取指定类的类名。BOOL class_isMetaClass(Class cls)，判断指定类是否是一个元类。Class class_getSuperclass(Class cls)，获取指定类的父类。Class class_setSuperclass(Class cls, Class newSuper)，设定指定类的父类。int class_getVersion(Class cls)，获取指定类的版本信息。void class_setVersion(Class cls, int version)，设定指定类的版本信息。size_t class_getInstanceSize(Class cls)，获取实例大小。Ivar class_getInstanceVariable(Class cls, const char *name)，获取指定名字的实例变量。Ivar class_getClassVariable(Class cls, const char *name)，获取指定名字的类变量。Ivar *class_copyIvarList(Class cls, unsigned int *outCount)，获取类的成员变量列表的拷贝。调用后需要自己 free()。Method class_getInstanceMethod(Class cls, SEL name)，获取指定名字的实例方法。Method class_getClassMethod(Class cls, SEL name)，获取指定名字的类方法。IMP class_getMethodImplementation(Class cls, SEL name)，获取指定名字的方法实现。BOOL class_respondsToSelector(Class cls, SEL sel)，类是否响应指定的方法。Method *class_copyMethodList(Class cls, unsigned int *outCount)，获取方法列表的拷贝。调用后需要自己 free()。BOOL class_conformsToProtocol(Class cls, Protocol *protocol)，类是否遵循指定的协议。Protocol * __unsafe_unretained *class_copyProtocolList(Class cls, unsigned int *outCount)，获取协议列表的拷贝。调用后需要自己 free()。objc_property_t class_getProperty(Class cls, const char *name)，获取指定名字的属性。objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)，获取类的属性列表。调用后需要自己 free()。BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)，为类添加方法。IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types)，替代类的方法。BOOL class_addIvar(Class cls, const char *name, size_t size, uint8_t alignment, const char *types)，给指定的类添加成员变量。这个函数只能在 objc_allocateClassPair() 和 objc_registerClassPair() 之间调用，并且不能为一个已经存在的类添加成员变量。BOOL class_addProtocol(Class cls, Protocol *protocol)，为类添加协议。BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)，为类添加属性。void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)，替代类的属性。id class_createInstance(Class cls, size_t extraBytes)，创建指定类的实例。id objc_constructInstance(Class cls, void *bytes)，在指定的位置创建类的实例。void *objc_destructInstance(id obj)，销毁实例。Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)，创建类和元类。void objc_registerClassPair(Class cls)，注册类到 Runtime。void objc_disposeClassPair(Class cls)，销毁类和对应的元类。 类是元类的实例。 isa，在大多面向对象的语言中，都有类和对象的概念，其中，对象是类的实例，是通过类定义的结构生成出来的。而在 Objective-C 中，类本身也是一个对象，类作为对象时的 isa 指针指向的是元类(Meta Class)。 object_getClass() 可以获得当前对象 isa #pragma clang diagnostic...代码，这是用于忽略编译器对于未声明的 @selector 的 warning。因为我们的代码中我们需要动态的为一个类创建方法，所以必然不会事先声明。 class_addMethod() 函数的最后一个参数 types 是描述方法返回值和参数列表的字符串，我们的代码中的用到的 i@:@ 四个字符分别对应着：返回值 int32_t、参数 id self、参数 SEL _cmd、参数 NSDictionary *dic。这个其实就是类型编码(Type Encoding)的概念。在 Objective-C 中，为了协助 Runtime 系统，编译器会将每个方法的返回值和参数列表编码为一个字符串，这个字符串会与方法对应的 selector 关联。更详细的知识可以查阅 Type Encodings。 使用 objc_registerClassPair() 函数需要注意，你不能注册已经注册过的类。 使用 objc_disposeClassPair() 函数需要注意，如果一个类的实例和子类还存在时，不要去销毁一个类。 运行时的成员变量与属性成员变量和属性相关的函数123456789101112131415161718Ivar class_getClassVariable(Class cls, const char *name)，返回指定类的指定名字的成员变量。Ivar *class_copyIvarList(Class cls, unsigned int *outCount)，返回指定类的成员变量列表。调用后需要自己 free()。BOOL class_addIvar(Class cls, const char *name, size_t size, uint8_t alignment, const char *types)，给指定的类添加成员变量。这个函数只能在 objc_allocateClassPair() 和 objc_registerClassPair() 之间调用，并且不能为一个已经存在的类添加成员变量。id object_getIvar(id obj, Ivar ivar)，获得对象的指定成员变量的值。速度比 object_getInstanceVariable() 快。void object_setIvar(id obj, Ivar ivar, id value)，设置对象指定成员变量的值。速度比 object_setInstanceVariable() 快。Ivar object_getInstanceVariable(id obj, const char *name, void **outValue)，获取指定名字的成员变量的值。Ivar object_setInstanceVariable(id obj, const char *name, void *value)，设置指定名字成员变量的值。const char *ivar_getName(Ivar v)，获取成员变量名。const char *ivar_getTypeEncoding(Ivar v)，获取成员变量的类型编码。ptrdiff_t ivar_getOffset(Ivar v)，获取成员变量的偏移量。objc_property_t class_getProperty(Class cls, const char *name), 获取指定类指定名字的属性。objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount), 获取指定类的属性列表。调用后需要自己 free()。BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)， 给指定的类添加属性。void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)，替代指定类的属性。const char *property_getName(objc_property_t property)，获取属性名。const char *property_getAttributes(objc_property_t property)，获取属性特性描述。objc_property_attribute_t *property_copyAttributeList(objc_property_t property, unsigned int *outCount)，获取属性特性列表。调用后需要自己 free()。char *property_copyAttributeValue(objc_property_t property, const char *attributeName)，获取属性特性值。调用后需要自己 free()。 IMP 其实就是 implementation 的缩写，表示方法实现的代码块地址 我们不能用 class_addIvar() 函数为一个已经存在的类添加 Ivar。并且 class_addIvar() 只能在 objc_allocateClassPair() 和 objc_registerClassPair() 之间调用。 添加一个属性及对应的成员变量后，我们还能通过 [obj valueForKey:@”propertyName”]; 获得属性值。 运行时的消息分发objc_msgSend(id self, SEL op, ...)，消息分发。(objc/message.h)1234567891011121314151617id method_invoke(id receiver, Method m, ...);，调用指定方法的实现。void method_invoke_stret(id receiver, Method m, ...);，调用返回一个数据结构的方法的实现。SEL method_getName(Method m);，获取方法名。IMP method_getImplementation(Method m);，返回方法的实现。const char * method_getTypeEncoding(Method m);，获取描述方法参数和返回值类型的字符串。char * method_copyReturnType(Method m);，获取方法的返回值类型的字符串。char * method_copyArgumentType(Method m, unsigned int index);，获取方法的指定位置参数的类型字符串。void method_getReturnType(Method m, char *dst, size_t dst_len);，通过引用返回方法的返回值类型字符串。unsigned int method_getNumberOfArguments(Method m);，返回方法的参数的个数。void method_getArgumentType(Method m, unsigned int index, char *dst, size_t dst_len);，通过引用返回方法指定位置参数的类型字符串。struct objc_method_description * method_getDescription(Method m);，返回指定方法的方法描述结构体。IMP method_setImplementation(Method m, IMP imp);，设置方法的实现。注意该函数返回值是方法之前的实现。void method_exchangeImplementations(Method m1, Method m2);，交换两个方法的实现。const char * sel_getName(SEL sel);，返回给定选择器指定的方法的名称。SEL sel_registerName(const char *str);，在Objective-C Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器。SEL sel_getUid(const char *str);，在Objective-C Runtime系统中注册一个方法。BOOL sel_isEqual(SEL lhs, SEL rhs);，比较两个选择器。 消息转发机制基本上分为三个步骤：第一步：动态方法解析。未知的方法被截获，程序不会崩溃123456789101112131415#import &lt;objc/runtime.h&gt;- (void)viewDidLoad &#123;[super viewDidLoad];[self performSelector:@selector(unknownMethod)];&#125;void dealWithExceptionForUnknownMethod(id self, SEL _cmd) &#123;NSLog(@&quot;%@, %p&quot;, self, _cmd); // Print: &lt;ViewController: 0x7ff96be33e60&gt;, 0x1078259fc&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;NSString *selectorString = NSStringFromSelector(sel);if ([selectorString isEqualToString:@&quot;unknownMethod&quot;]) &#123;class_addMethod(self.class, @selector(unknownMethod), (IMP) dealWithExceptionForUnknownMethod, &quot;v@:&quot;);&#125;return [super resolveInstanceMethod:sel];&#125; 第二步：备用接收者。如果在第一步还是无法处理消息，则 Runtime 会继续调以下方法：1- (id)forwardingTargetForSelector:(SEL)aSelector 这一步适用于当我们只想将消息转发到另一个能处理该消息的对象上的情况，它无法进一步对消息进行处理，比如：操作消息的参数和返回值。 第三步：完整转发。如果第二步：备用接收者还是未能处理好消息，那么接下来只有启用完整的消息转发机制了，这时候会调用以下方法：1- (void)forwardInvocation:(NSInvocation *)anInvocation 运行时系统会在这一步给消息接收者最后一次机会将消息转发给其它对象。另外还有一个重要的问题是我们必须重写下面方法：1- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector 如果不在以上所述的三个步骤中处理未知消息，到了 NSObject 那则会引发一个异常。 代码：RuntimeDemo 转自：Objective-C 的 Runtime","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"runtime","slug":"runtime","permalink":"https://guchunli.github.io/tags/runtime/"}]},{"title":"mac显示隐藏文件","date":"2017-03-21T10:37:39.000Z","path":"2017/03/21/mac显示隐藏文件/","text":"1.显示隐藏文件1defaults write com.apple.finder AppleShowAllFiles Yes &amp;&amp; killall Finder 2.不显示隐藏文件1defaults write com.apple.finder AppleShowAllFiles No &amp;&amp; killall Finder 3.删除文件夹下的所有 .git 文件1find . -name &quot;.git&quot; | xargs rm -Rf","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"https://guchunli.github.io/tags/技巧/"},{"name":"隐藏文件","slug":"隐藏文件","permalink":"https://guchunli.github.io/tags/隐藏文件/"}]},{"title":"Apple Pay学习笔记","date":"2017-03-15T08:37:17.000Z","path":"2017/03/15/Apple-Pay学习笔记/","text":"概述1.支付方式：Touch ID/ Passcode2.设备要求：iPhone6以上（iphone:线上/线下 ipad:线上 watch:线下）3.系统要求：iOS8.0以上，银联（中国）：9.2 4.基于NFC5.2014年10月20日在美国正式上线，2016年2月18日凌晨5：00， Apple Pay 业务在中国上线。6.与微信支付以及支付宝等第三方支付平台的区别： 硬件方面 Apple Pay：必须是iOS设备， 而且是按照线上支付和线下支付区分不同的真机设备（具体参考表1） 微信、支付宝： 基本跟硬件设备无关， 支持大多数的只能手机 网络环境要求 Apple Pay：线上支付需要联网， 线下支付无需联网就可以支付 微信、支付宝： 无论是线上还是线下支付， 都需要联网使用 使用技术 Apple Pay：线下支付使用的是 基于NFC的近场通讯技术 微信、支付宝： 线下支付使用的是 扫码支付（条形码、二维码） 主要功能 Apple Pay：线上支付、线下支付、部分升级后的ATM机可以取款 微信、支付宝： 线上支付、线下支付、转账、理财等 安全性能 Apple Pay：不保留银行卡信息，并且不会暴漏给外界、不分流银行存款（不需要从银行卡转钱到另外一个平台）、不能充值 安全性较高 微信、支付宝： 密码保护，身份验证等手段保护账户 安全性相对稍差 支付时长 Apple Pay：无论是线上支付，还是线下支付， 只需要验证指纹即可支付。非常迅速 微信、支付宝： 需要扫码支付， 流程相对繁琐，所以时长较长 各自弊端 Apple Pay：只适用于苹果设备， 支付场景单一，无转账理财等业务 微信、支付宝： 安全性较差， 必须联网操作，需要充值到对应平台 注册并配置一个商业标示符1.添加一个App ID2.配置Merchant ID3.为Merchant ID 配置证书, 并下载证书安装到钥匙串4.检查安装到钥匙串中的证书是否有效5.绑定Merchant ID 到 APP ID 证书失效，请到以下地址下载重新安装：https://www.apple.com/certificateauthority/ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239//一.判断当前设备是否支持支付if (![PKPaymentAuthorizationViewController canMakePayments]) &#123;NSLog(@&quot;该设备不支持ApplePay&quot;);return;//二.判断Wallet有没有添加该支付网络的储蓄卡/信用卡&#125;else if ([PKPaymentAuthorizationViewController canMakePaymentsUsingNetworks:@[PKPaymentNetworkChinaUnionPay,PKPaymentNetworkVisa]])&#123;NSLog(@&quot;Wallet没有添加该支付网络的储蓄卡/信用卡&quot;);//创建一个添加卡的按钮PKPaymentButton *btn = [PKPaymentButton buttonWithType:PKPaymentButtonTypeSetUp style:PKPaymentButtonStyleBlack];[btn addTarget:self action:@selector(jumpToSetup) forControlEvents:UIControlEventTouchUpInside];[self.payView addSubview:btn]; &#125;else&#123;//创建一个支付按钮PKPaymentButton *btn = [PKPaymentButton buttonWithType:PKPaymentButtonTypeBuy style:PKPaymentButtonStyleWhiteOutline];[btn addTarget:self action:@selector(jumpToPay) forControlEvents:UIControlEventTouchUpInside];[self.payView addSubview:btn];&#125;- (void)jumpToSetup&#123;NSLog(@&quot;跳转到添加银行卡页面&quot;);PKPassLibrary * pk = [[PKPassLibrary alloc]init];[pk openPaymentSetup];&#125;- (void)jumpToPay&#123;//三.创建支付请求并配置各项信息//1.创建支付请求PKPaymentRequest *request = [[PKPaymentRequest alloc]init];//2.配置参数//2.1 商店标识request.merchantIdentifier = @&quot;&quot;;//2.2 国家代码request.countryCode = @&quot;CN&quot;;//2.3 货币代码request.currencyCode = @&quot;CNY&quot;;//2.4 支持的支付网络request.supportedNetworks = @[PKPaymentNetworkChinaUnionPay,PKPaymentNetworkVisa];//2.5 支付请求包含一个支付摘要项目的列表NSDecimalNumber *price1 = [NSDecimalNumber decimalNumberWithString:@&quot;10.0&quot;];PKPaymentSummaryItem *item1 = [PKPaymentSummaryItem summaryItemWithLabel:@&quot;iPhone&quot; amount:price1];NSDecimalNumber *price2 = [NSDecimalNumber decimalNumberWithString:@&quot;20.0&quot;];PKPaymentSummaryItem *item2 = [PKPaymentSummaryItem summaryItemWithLabel:@&quot;iPad&quot; amount:price2 type:PKPaymentSummaryItemTypePending];NSDecimalNumber *totalPrice = [NSDecimalNumber zero];totalPrice = [totalPrice decimalNumberByAdding:price1];totalPrice = [totalPrice decimalNumberByAdding:price2];PKPaymentSummaryItem *total = [PKPaymentSummaryItem summaryItemWithLabel:@&quot;财务中心&quot; amount:totalPrice type:PKPaymentSummaryItemTypePending];//注意：数组最后一个是总价格request.paymentSummaryItems = @[item1,item2,total];//2.6运输方式NSDecimalNumber *shippingPrice = [NSDecimalNumber decimalNumberWithString:@&quot;18.0&quot;];PKShippingMethod *method = [PKShippingMethod summaryItemWithLabel:@&quot;顺风快递&quot; amount:shippingPrice];method.identifier = @&quot;shunfeng&quot;;method.detail = @&quot;24小时内送到&quot;;request.shippingMethods = @[method];request.shippingType = PKShippingTypeServicePickup;//2.7通过指定merchantCapabilities属性来指定你支持的支付处理标准，3DS支付方式是必须支持的，EMV方式是可选的request.merchantCapabilities = PKMerchantCapability3DS | PKMerchantCapabilityEMV | PKMerchantCapabilityCredit | PKMerchantCapabilityDebit;//2.8需要的配送信息和账单信息request.requiredBillingAddressFields = PKAddressFieldAll;request.requiredShippingAddressFields = PKAddressFieldAll;//2.9 存储额外信息request.applicationData = [@&quot;购物车ID：123456&quot; dataUsingEncoding:NSUTF8StringEncoding];//四.弹出授权控制器，让用户给支付授权//开始支付PKPaymentAuthorizationViewController *pkCtrl = [[PKPaymentAuthorizationViewController alloc]initWithPaymentRequest:request];if (pkCtrl == nil) &#123;NSLog(@&quot;授权控制器创建失败&quot;);return;&#125;pkCtrl.delegate = self;[self presentViewController:pkCtrl animated:YES completion:nil];&#125;#pragma mark - PKPaymentAuthorizationViewControllerDelegate//五.处理支付凭证//授权成功- (void)paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)controllerdidAuthorizePayment:(PKPayment *)paymentcompletion:(void (^)(PKPaymentAuthorizationStatus status))completion&#123;/*服务器接收到token后的一般处理流程:1.验证支付数据的哈希表和签名2.为加密过的支付数据解码3.向支付处理系统提交支付数据4.向订单追踪系统提交订单*/NSLog(@&quot;验证授权---%@&quot;,payment.token);/*处理支付请求时，你有两个选择:1.你既可以利用支付平台处理支付请求，2.也可以自己实现支付请求处理流程。一个常用的支付平台可以完成上述大部分操作。*/NSLog(@&quot;验证通过后，需要开发中继续完成交易&quot;);BOOL isSuccess = YES;if (isSuccess) &#123;completion(PKPaymentAuthorizationStatusSuccess);&#125;else&#123;completion(PKPaymentAuthorizationStatusFailure);&#125;&#125;//六.关闭授权控制器//授权成功或者取消授权之后会调用此方法- (void)paymentAuthorizationViewControllerDidFinish:(PKPaymentAuthorizationViewController *)controller&#123;NSLog(@&quot;取消或者交易完成&quot;);[self dismissViewControllerAnimated:YES completion:nil];&#125; 转自：Apple Pay–iOS开发","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"Apple Pay","slug":"Apple-Pay","permalink":"https://guchunli.github.io/tags/Apple-Pay/"}]},{"title":"将.c文件打包成库文件","date":"2017-03-06T10:43:09.000Z","path":"2017/03/06/将-c文件打包成库文件/","text":"打包.a1.Cocoa Touch Static Library2.添加要打包的文件:.c，.h3.将头文件添加到Build Phases -&gt; Copy Files中去4.需要修改Build Settings中的 Build Active Architecture Only 以满足运行不同CPU环境的模拟器。 将此设置为NO。 选择Edit Scheme–&gt; Buid Configuration设置为release5.分别选择模拟器和真机编译，生成.a文件，在不同编译环境下编译会生成四种静态库，debug模拟器，debug真机，release模拟器，release真机6.查看静态库所支持的CPU环境：lipo -info 静态库文件7.合并静态库：lipo -create 静态库1 静态库2 -output 新静态库名称.a 注意：1.如果直接拖拽的是一个项目，并将项目当做一个静态库引用需要这样处理：在 Build Phases 中的 Target Dependencies 和 Link Binary With Libraries 中分别添加项目。如果仅仅是一个静态库的话，那么Link Binary WithLibraries 是必须添加的。2.如果编译的静态库中有分类的话必须在 Build Settings –&gt; Other Linker Flags 中加 -Objc 如果还崩溃，还得加上 -all_load 打包.so1.编译1gcc -c -fPIC -o myfile.o myfile.c 2.生成.so文件1gcc -shared -o libname.so myfile.o","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":".c","slug":"c","permalink":"https://guchunli.github.io/tags/c/"},{"name":".a","slug":"a","permalink":"https://guchunli.github.io/tags/a/"},{"name":".so","slug":"so","permalink":"https://guchunli.github.io/tags/so/"}]},{"title":"github上使用SSH和gitignore","date":"2017-03-03T08:52:02.000Z","path":"2017/03/03/github上使用SSH和gitignore/","text":"1.使用SSH123456$ cd ~/.ssh$ ssh-keygen -t rsa -C &quot;your email address&quot;$ cat ~/.ssh/id_rsa.pub$ ssh -T git@github.com （github） $ ssh -T git@git.oschina.net (oschina)$ Welcome to Git@OSC, nickname! 2.gitignore 123456cd /Users/apple/Desktop/codegit clone git地址cp gitignore路径 .gitignoregit add .git commit -m &quot;添加 gitignore&quot;git push 注意：”cp gitignore路径 .gitignore”一定要加”.gitignore”。","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"github","slug":"github","permalink":"https://guchunli.github.io/tags/github/"},{"name":"SSH","slug":"SSH","permalink":"https://guchunli.github.io/tags/SSH/"},{"name":"gitignore","slug":"gitignore","permalink":"https://guchunli.github.io/tags/gitignore/"}]},{"title":"git学习笔记","date":"2017-03-03T02:49:42.000Z","path":"2017/03/03/git学习笔记/","text":"初始化仓库 $ git init 提交代码 $ git add .$ git commit -m “” 查看状态 $ git status 查看修改 $ git diff12-change something+change $ git diff &gt; 1.diff将diff修改写到1.diff文件中 查看提交历史 $ git log 1234567891011121314151617commit acbcfcfa48c89deb725aae9e03a68a2f5abaa1d4Author: gcl &lt;155@163.com&gt;Date: Tue Feb 7 14:30:11 2017 +0800change 2commit 99f733644454644d90b8ee39c6737dc283c78cecAuthor: gcl &lt;155@163.com&gt;Date: Tue Feb 7 14:27:55 2017 +0800change readme.txtcommit 58110376e350d36c8df095b17ff2ecb44906eae2Author: gcl &lt;155@163.com&gt;Date: Tue Feb 7 14:25:17 2017 +0800add readme.txt 简化版本信息 $ git log –pretty=oneline123acbcfcfa48c89deb725aae9e03a68a2f5abaa1d4 change 299f733644454644d90b8ee39c6737dc283c78cec change readme.txt58110376e350d36c8df095b17ff2ecb44906eae2 add readme.txt 查看命令历史 $ git reflog12345acbcfcf HEAD@&#123;0&#125;: reset: moving to acbcfcfa499f7336 HEAD@&#123;1&#125;: reset: moving to HEAD^acbcfcf HEAD@&#123;2&#125;: commit: change 299f7336 HEAD@&#123;3&#125;: commit: change readme.txt5811037 HEAD@&#123;4&#125;: commit (initial): add readme.txt 回退版本HEAD指向当前版本，HEAD^是上一版本，HEAD^^是上上版本，HEAD~100是上100个版本--hard是强制抹除修改，未提交的修改会丢失。git reset –hard 慎重使用--mixed是保存修改，相当于重新提交。 回到上一版本 $ git reset –hard HEAD^ 回到某一历史 $ git reset –hard commitid 工作区与暂存区 respository文件夹：工作区 .git：版本库，包含了stage（暂存区），分支master，指针HEAD git add是把文件修改放到了暂存区，git commit把暂存区的内容提交到了分支，没有提交到暂存区的修改是不会被提交到分支的提交的事件线：工作区-&gt;git add-&gt;暂存区-&gt;git commit-&gt;分支 撤销修改git管理的是修改，而不是文件 清空工作区的修改，回到最近一次git commit或git add时的状态（用版本库的版本替换工作区的版本）：git checkout – readme.txt （注意：git checkout 是切换分支命令） 撤销add后，commit前在暂存区的修改，将暂存区的修改放回工作区：git reset HEAD readme.txt（注意：reset可以回退版本，还可以撤销add到暂存区的内容，回退到工作区，如果要撤销在工作区的修改，可以再次checkout – file） 撤销commit之后，push之前：版本回退，git reset git push：无法撤销 删除文件确定删除 git rm filenamegit commit 撤销删除，找回文件 git checkout – filename注意：git checkout是使用版本库中的最新版本替换工作区的版本，即撤销git add/rm之前的修改 远程仓库 本地库master与远程库origin关联，origin为远程库的默认叫法 $ git remote add origin git@github.com:XXX/learngit.git（XXX为你的github账户名） 将本地库中的所有内容推送到远程库中，加上-u将本地master分支和远程origin分支关联起来，以后推送就可以直接使用git push简化命令 $ git push -u origin master 以后推送使用以下命令 $ git push origin master 把远程库克隆到本地,使用https速度慢，而且每次都要输入口令 $ git clone ssh或https push与pull push：本地 –&gt; 远程，如果本地超前远程，需要push pull：本地 &lt;– 远程，如果本地落后远程，需要pull 分支管理HEAD指向当前分支--master分支，master指向最新提交 创建分支 创建分支将当前分支中的所有文件拷贝到新分支 $ git branch second 切换到分支 $ git checkout second 创建+切换到分支 $ git checkout -b second 查看当前分支 $ git branch 合并分支 合并指定分支到当前分支(主分支) $ git branch master$ git merge second 撤销合并操作 $ git reset 合并模式 ”fast forward”模式：合并分支默认使用”fast forward”模式，删除分支会丢掉分支信息，合并后看不出做过合并 普通模式：禁用”fast forward” 使用普通模式，合并后的历史可以看出曾经做过合并，在merge时生成一个新的commit。禁用”fast forward”并且加上了commit描述： $ git merge –no-ff -m “merge with no-ff” second 如果出现冲突:git status-&gt;修改冲突-&gt;git add-&gt;git commit git rebase origin master如果出现冲突:git status-&gt;修改冲突-&gt;git add-&gt;git rebase --continue 查看分支 $ git log 查看分支合并图$ git log –graph$ git log –graph –pretty=oneline –abbrev-commit 删除分支 $ git branch -d second$ git branch -D second：强行删除一个没有合并过的分支$ git push origin –delete second 删除远程分支 分支管理策略本地分支：master，dev，bug，feature远程分支：origin，dev 解决冲突 查看冲突 $ git status 查看分支合并图 git log –graph $ git log –graph –pretty=oneline –abbrev-commit 解决冲突合并分支发生冲突后，解决冲突步骤：查看冲突-&gt;修改-&gt;提交-&gt;合并完成 bug分支将当前无法提交到现场先保存起来，使工作区恢复clean状态，修复bug后，再将保存的东西解开 将工作现场先保存起来：git stash 查看保存现场记录：git stash list 恢复工作线程 git stash apply ：stash内容不删除，需要使用git stash drop手动删除 git stash pop：恢复的同时将stash的内容删除 git stash apply stash@{0}：有多个stah时，指定恢复到某个stash feature分支新添加功能时创建feature分支，开发完成合并到主分支，最好在开发新功能时为每一个新功能创建一个分支 多人协作查看远程库 查看远程库的信息 $ git remote 查看远程分支详细信息 $ git remote -v 推送分支将本地某个分支中的所有提交推送到远程库 $ git push origin master一般只推送master和dev分支，其他可以在本地放着 抓取分支创建本地dev分支： $ git checkout -b dev origin/dev git pull提示“no tracking information”,设置dev和origin/dev的链接：$ git branch –set-upstream dev origin/dev$ git pull$ git add/commit/push 注意：如果git pull时提示“no tracking information”，则需要指定本地master/dev分支与远程origin/dev分支的链接后，才能pull $ git branch –set-upstream dev origin/dev 已弃用$ git branch –set-upstream-to=origin/dev dev 最新用法 多⼈人协作的⼯工作模式:（1）git push origin branch-name（2）如果推送失败,则因为远程分⽀支⽐比你的本地更新,需要先⽤用git pull试图合并;（3）如果合并有冲突,则解决冲突,并在本地提交;（4）没有冲突或者解决掉冲突后,再⽤用git push origin branch-name推送就能成功! 标签添加标签 添加标签 $ git tag v1.0 补加标签 $ git log –pretty=oneline –abbrev-commit$ git tag v0.9 commitid 添加说明用-a指定标签名，-m指定说明文字： $ git tag -a v0.1 -m “version 0.1 released” 3628164 私钥签名标签 $ git tag -s v0.2 -m “signed version 0.2 released” fec145a 查看标签 查看所有标签 $ git tag 查看标签信息 $ git show v0.9注意，标签不是按时间顺序列出，而是按字母排序的。 推送标签 推送某一标签 $ git push origin v1.0 推送本地所有未推送标签 $ git push origin –tags 删除标签 删除本地标签 $ git tag -d v1.0 删除远程标签 需要先删除本地标签： $ git tag -d v1.0 推送到远程： $ git push origin :refs/tags/v1.0 github使用SSH123456789$ ssh-keygen -t rsa -C &quot;xxxxx@xxxxx.com&quot;# Creates a new ssh key using the provided email# Generating public/private rsa key pair...$ cat ~/.ssh/id_rsa.pub# ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC6eNtGpNGwstc.... 将public key添加$ ssh -T git@github.com （github）ssh -T git@git.oschina.net (oschina)Welcome to Git@OSC, yourname! 为开源仓库贡献代码fork在GitHub上，可以任意Fork开源仓库 提交修改自己拥有Fork后的仓库的读写权限，从自己帐号克隆仓库，然后提交到自己的仓库 pull request请求官方接受修改 自定义git配置用户名和email如果遇到以下问题：1234567891011*** Please tell me who you are.Rungit config --global user.email &quot;you@example.com&quot;git config --global user.name &quot;Your Name&quot;to set your account&apos;s default identity.Omit --global to set the identity only in this repository.&gt;&gt;&gt;fatal: unable to auto-detect email address (got &apos;xxx@xxx.(none)&apos;) 需要配置用户名和邮箱： $ git config –global user.name “Your Name”$ git config –global user.email “email@example.com” 给git命令添加颜色 $ git config –global color.ui true 忽略特殊文件 忽略文件的原则 忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件； 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。 强制添加被忽略的文件 $ git add -f App.class 查看想添加的文件被.gitignore中的哪条规则忽略了 $ git check-ignore -v App.class 注意：.gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理 配置别名 $ git config –global alias.st status$ git config –global alias.co checkout$ git config –global alias.ci commit$ git config –global alias.br branch$ git config –global alias.unstage ‘reset HEAD’$ git config –global alias.last ‘log -1’$ git config –global alias.lg “log –color –graph – 注意：--global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用 配置文件每个仓库的Git配置文件都放在.git/config文件中，查看配置文件 $ cat .git/config1234567891011121314[core]repositoryformatversion = 0filemode = falsebare = falselogallrefupdates = truesymlinks = falseignorecase = truehideDotFiles = dotGitOnly[remote &quot;origin&quot;]url = git@xxxfetch = +refs/heads/*:refs/remotes/origin/*[branch &quot;master&quot;]remote = originmerge = refs/heads/master $ cat ~/gitconfig1234567891011[user]email = xxxname = xxx[color]ui = true[alias]st = statusco = checkoutbr = branch[gui]encoding = gbk 要删除别名，直接把对应的行删掉即可改错了，可以删掉文件重新通过命令配置 自己搭建git服务器（1）安装gitsudo apt-get install git（2）创建一个git用户，用来运行git服务sudo adduser git（3）创建证书登录收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个（4）初始化Git仓库sudo chown -R git:git sample.git（5）禁用shell登录出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：git:x:1001:1001:,,,:/home/git:/bin/bash改为： git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。（6）克隆远程仓库git clone git@server:/srv/sample.git（7）要方便管理公钥，用Gitosis； 要像SVN那样变态地控制权限，用Gitolite。 git命令汇总git init git addgit commitgit rmgit status git diffgit log (–pretty=oneling)git reflog git checkout – filenamegit reset HEAD filenamegit reset –hard HEAD^(commitid) git add remote origin git/httpsgit push/pull/clone git branch secondgit checkout secondgit checkout -b secondgit branchgit branch -d secondgit log –graph –pretty=oneline –abbrev-commit git stashgit stash listgit stash applygit stash dropgit stash popgit stash apply stash@{0} git remote -vgit checkout -b dev origin/devgit branch –set-upstream-to=origin/dev devgit pull git tag namegit tag tagname commitidgit tag -a tagname -m “description”git taggit show tagnamegit push origin tagnamegit push origin –tagsgit tag -d tagnamegit push origin :refs/tags/tagname ssh-keygen -t rsa -C “xxxxx@xxxxx.com”cat ~/.ssh/id_rsa.pubssh -T git@github.com （github） git add -f App.class git config user.name “username”git config user.email “email”git config –global alias.st status 附Unix命令（1）创建文件夹：mkdir（2）跳到指定路径：cd（3）查看当前完整路径：pwd（4）查看当前路径下的所有文件及文件夹：ls（5）cat：可以显示文件内容，但是不能编辑（6）touch：如果文件存在，使用touch指令可更改这个文件或目录的日期时间，包括存取时间和更改时间；如果文件不存在，touch指令会在当前目录下新建一个空白文件（7）vi/vim：打开文件后可以编辑（8）echo：输出 Git的官方网站 本文为阅读廖雪峰的官方网站中的git教程的学习笔记，仅为自己的一点学习记录，原文写的非常好，作者很厉害，有兴趣的朋友可以阅读原文：廖雪峰的官方网站的git教程","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://guchunli.github.io/tags/Git/"}]},{"title":"Markdown学习笔记","date":"2017-02-19T01:48:39.000Z","path":"2017/02/19/Markdown学习笔记/","text":"基本语法1.换行符： 一行结束时输入两个空格 line1line2 2.段落： 段落之间空一行 p1 p2p3 3.标题： （1）Setext形式：= 大标题 - 中标题 （2）atx形式：# 大标题中标题 一级标题二级标题三级标题四级标题五级标题六级标题 4.区块引用：> 区块1 区块2 区块3 5.列表：*/+/- 前后加空格，tab键或四个空格可分级 列表1 列表2 列表3 6.斜体、粗体、删除线斜体：*斜体* 斜体粗体：**斜体** 粗体粗斜体：***斜体*** 粗斜体删除线：~~删除线~~ 删除线 7.内嵌代码：` 内嵌代码 ` 内嵌代码8.水平线：—— 9.链接： [文字]（url title） ![]（图片 title） 百度一下-你就知道 10.注意：反斜杠\\实现转义效果11.表格12345| title1 | title2 | title3 ||--------|--------|-----------|| a | aa | aaa || b | bb | bbb || c | cc | ccc | title1 title2 title3 a aa aaa b bb bbb c cc ccc","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://guchunli.github.io/tags/markdown/"}]},{"title":"hexo创建个人博客记录","date":"2017-02-18T08:43:01.000Z","path":"2017/02/18/hexo创建个人博客记录/","text":"常见命令1.安装hexo1$ sudo npm install -g hexo 2.初始化1$ hexo init 3.生成静态页面1$ hexo generate（hexo g也可以） 4.启动本地服务，进行文章预览调试,浏览器输入http://localhost:4000即可1$ hexo server（hexo s也可以） 5.发布配置1$ hexo deploy（hexo d也可以） 每次部署的步骤，可按以下三步来进行: hexo clean，hexo generate，hexo deploy，或者 hexo d -g 6.新建文章1$ hexo new&quot;postName&quot; 7.新建页面1$ hexo new page&quot;pageName&quot; 8.添加统计数据在themes/yilia/layout/_partial/footer.ejs文件&lt;style&gt;上添加以下代码：1&lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt; &lt;style&gt;下添加以下代码：123本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次本文总阅读量&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次 hexo填坑历程(1)坑一：hexo命令找不到12ERROR Local hexo not found in E:\\blogERROR Try running: &apos;npm install hexo --save&apos; 解决：按照提示输入npm install hexo --save，如果不可以，可能是：因为安装包中有些内容在墙外，所以可以换淘宝源，或者用 $ npm install -g hexo-cli –no-optional(很重要)有时候只写npm install --no-optional也不行，只能以上命令 如果还是不可以，可能是由于：.gitignore文件里面忽略了node_modules文件夹，所以这个文件夹没有更新上去。所以用npm重新安装即可，输入以下命令：123cd ...\\blognpm installhexo server (2)坑二：ERROR Deployer not found: git $ npm install hexo-deployer-git –save然后重新 deploy 即可 (3)坑三：hexo deploy成功，但是页面不显示解决：到仓库下的settings下修改GitHub Pages，source选择master分支，显示 Your site is published at https://XXX.github.io/即可 (4)坑四：123fatal: Not a git repository (or any of the parent directories): .gitFATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: fatal: Not a git repository (or any of the parent directories): .git 解决：检查_config.yml文件deploy的配置如下：12type: gitrepo: https://github.com/XXX/XXX.github.io.git 如果还是不可以，请看下一解决方案。 (5)坑五：Permission to XXX.github.io.git denied解决：12$ git config --global user.name &quot;yourname&quot;$ git config --global user.email &quot;youremail&quot; 如果以上做完还是出不来，删掉根目录下的文件夹：.deploy_git，重新deploy就可以了。","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://guchunli.github.io/tags/hexo/"},{"name":"个人博客","slug":"个人博客","permalink":"https://guchunli.github.io/tags/个人博客/"}]},{"title":"Swift学习笔记","date":"2017-01-01T09:13:04.000Z","path":"2017/01/01/Swift学习笔记/","text":"待补充","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://guchunli.github.io/tags/Swift/"}]},{"title":"toStudy","date":"2017-01-01T04:04:11.000Z","path":"2017/01/01/toStudy/","text":"","comments":true,"categories":[],"tags":[]},{"title":"iOS国际化学习笔记","date":"2017-01-01T02:30:38.000Z","path":"2017/01/01/iOS国际化学习笔记/","text":"待补充","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"国际化","slug":"国际化","permalink":"https://guchunli.github.io/tags/国际化/"}]}]