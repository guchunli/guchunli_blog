[{"title":"iOS模拟器报错总结","date":"2018-01-11T02:22:34.000Z","path":"2018/01/11/iOS模拟器报错总结/","text":"Verify the Developer App certificate for your account is trusted on your device. Open Settings on iPhoneSE rational and navigate to General -&gt; Device Management, then select your Developer App certificate to trust it. 解决：手机（真机）中点击设置(Settings) -&gt; 通用（General）-&gt; 设备管理（Device Management）-&gt; 点击对应的id -&gt; 信任（Trust） This application’s application-identifier entitlement does not match that of the installed application. These values must match for an upgrade to be allowed. 解决：application-identifier冲突，把手机上的软件卸载重装。 未完待续","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"模拟器","slug":"模拟器","permalink":"https://guchunli.github.io/tags/模拟器/"}]},{"title":"iOS动态更改icon图标","date":"2018-01-05T03:47:40.000Z","path":"2018/01/05/iOS动态更改icon图标/","text":"1.将所有@2x，@3x图标放到项目中 2.配置info.plist123456789101112131415161718192021222324252627282930313233343536373839404142&lt;key&gt;CFBundleIcons&lt;/key&gt;&lt;dict&gt; &lt;key&gt;CFBundlePrimaryIcon&lt;/key&gt; &lt;dict&gt; &lt;key&gt;CFBundleIconFiles&lt;/key&gt; &lt;array&gt; &lt;string&gt;appIcon1&lt;/string&gt; &lt;/array&gt; &lt;/dict&gt; &lt;key&gt;CFBundleAlternateIcons&lt;/key&gt; &lt;dict&gt; &lt;key&gt;appIcon1&lt;/key&gt; &lt;dict&gt; &lt;key&gt;CFBundleIconFiles&lt;/key&gt; &lt;array&gt; &lt;string&gt;appIcon1&lt;/string&gt; &lt;/array&gt; &lt;key&gt;UIPrerenderedIcon&lt;/key&gt; &lt;string&gt;NO&lt;/string&gt; &lt;/dict&gt; &lt;key&gt;appIcon2&lt;/key&gt; &lt;dict&gt; &lt;key&gt;CFBundleIconFiles&lt;/key&gt; &lt;array&gt; &lt;string&gt;appIcon2&lt;/string&gt; &lt;/array&gt; &lt;key&gt;UIPrerenderedIcon&lt;/key&gt; &lt;string&gt;NO&lt;/string&gt; &lt;/dict&gt; &lt;key&gt;appIcon3&lt;/key&gt; &lt;dict&gt; &lt;key&gt;CFBundleIconFiles&lt;/key&gt; &lt;array&gt; &lt;string&gt;appIcon3&lt;/string&gt; &lt;/array&gt; &lt;key&gt;UIPrerenderedIcon&lt;/key&gt; &lt;string&gt;NO&lt;/string&gt; &lt;/dict&gt; &lt;/dict&gt;&lt;/dict&gt; 3.更换图标(仅限于iOS版本10.3以上)1234567891011121314151617181920212223242526272829- (void)changeIcon&#123; if ([UIApplication sharedApplication].supportsAlternateIcons) &#123; NSLog(@&quot;you can change this app&apos;s icon&quot;); &#125;else&#123; NSLog(@&quot;you can not change this app&apos;s icon&quot;); return; &#125; NSString *iconName = [[UIApplication sharedApplication] alternateIconName]; NSLog(@&quot;%@&quot;,iconName); if (iconName) &#123; // change to primary icon [[UIApplication sharedApplication] setAlternateIconName:@&quot;appIcon1&quot; completionHandler:^(NSError * _Nullable error) &#123; if (error) &#123; NSLog(@&quot;set icon error: %@&quot;,error); &#125; NSLog(@&quot;The alternate icon&apos;s name is %@&quot;,iconName); &#125;]; &#125;else&#123; // change to alterante icon [[UIApplication sharedApplication] setAlternateIconName:@&quot;appIcon2&quot; completionHandler:^(NSError * _Nullable error) &#123; if (error) &#123; NSLog(@&quot;set icon error: %@&quot;,error); &#125; NSLog(@&quot;The alternate icon&apos;s name is %@&quot;,iconName); &#125;]; &#125;&#125;","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"icon","slug":"icon","permalink":"https://guchunli.github.io/tags/icon/"},{"name":"图标","slug":"图标","permalink":"https://guchunli.github.io/tags/图标/"}]},{"title":"Lintcode笔记","date":"2018-01-04T02:15:05.000Z","path":"2018/01/04/Lintcode笔记/","text":"","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"Lintcode","slug":"Lintcode","permalink":"https://guchunli.github.io/tags/Lintcode/"}]},{"title":"Leetcode笔记","date":"2018-01-04T01:55:50.000Z","path":"2018/01/04/Leetcode笔记/","text":"算法的复杂度n 为问题的规模 时间复杂度T(n)：总运算次数表达式中受n的变化影响最大的那一项（不含系数）。一个算法花费的时间与算法中语句的执行次数成正比。 空间复杂度S(n)：运行完一个程序所需内存的大小。 常数阶O(1), 对数阶O(log2n), 线性阶O(n), 线性对数阶O(nlog2n), 平方阶O(n^2)， 立方阶O(n^3),…， k次方阶O(n^k), 指数阶O(2^n) 461.Hamming Distance左移&lt;&lt;：丢弃最高位，0补最低位右移&gt;&gt;：向右挪动若干位 ##","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://guchunli.github.io/tags/Leetcode/"}]},{"title":"iOS提高界面流畅度的技巧","date":"2017-12-19T11:10:30.000Z","path":"2017/12/19/iOS提高界面流畅度的技巧/","text":"CPU资源消耗原因和解决方案对象创建 尽量用轻量的对象代替重量的对象 使用storyboard创建对象比通过代码消耗资源多 尽量推迟对象创建的时间 能复用的对象尽量使用复用 对象调整 尽量避免调整视图层次，添加或移除视图 布局计算 视图布局的计算是APP中最常见消耗CPU的地方，尽量在后台线程计算好视图布局并对视图布局进行缓存，尽量提前算好布局，在需要时一次性调整好对应属性，而不要多次，频繁的计算、调整这些属性 autolayout autolayout对于复杂视图来说常常会产生严重的性能问题，尽量使用category来快捷地获取视图的width,height等属性。 文本计算、渲染 可以参考UILabel 内部的实现方式：用 [NSAttributedString boundingRectWithSize:options:context:] 来计算文本宽高，用 -[NSAttributedString drawWithRect:options:context:] 来绘制文本，注意需要放到后台线程进行以避免阻塞主线程。 用 TextKit 或最底层的 CoreText 对文本异步绘制。CoreText 对象占用内存较少，可以缓存下来以备稍后多次渲染。屏幕上能看到的所有文本内容控件，在底层都是通过 CoreText 排版、绘制为 Bitmap 显示的。 GPU资源消耗原因和解决方案 GPU的作用：接收提交的纹理和顶点描绘，应用变换，混合和渲染，并且输出到屏幕上。 纹理的渲染 尽量减少在短时间内大量图片的显示，尽可能多张图片合成为一张进行显示。 视图的混合 尽量减少视图数量和层次 图形的生成 预渲染：避免使用CALayer的边框，圆角，阴影，遮罩等属性，为了避免离屏渲染，尽量在后台线程预先绘制好对应内容。 AsyncDisplayKit(ASDK)FDTemplateLayoutCell 使用 TableView 的预估高度的功能，并把每个 Cell 高度缓存下来。 常用技巧预渲染 在后台线程将头像预先渲染为圆形并单独保存到一个 ImageCache 中去。 异步绘制 当 TableView 快速滑动时，会有大量异步绘制任务提交到后台线程去执行。可参考YYAsyncLayer 全局并发控制 YYDispatchQueuePool 更高效的异步图片加载product-&gt;profile参考文章：iOS 保持界面流畅的技巧","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"流畅","slug":"流畅","permalink":"https://guchunli.github.io/tags/流畅/"}]},{"title":"iOS富文本的使用","date":"2017-12-18T08:38:52.000Z","path":"2017/12/18/iOS富文本的使用/","text":"给文本添加富文本 设置富文本富文本：addAttributes 富文本拼接：appendAttributedString 1.阴影123456789NSMutableAttributedString *text = [NSMutableAttributedString new];NSMutableAttributedString *one = [[NSMutableAttributedString alloc] initWithString:@&quot;Shadow&quot;];NSShadow *shadow = [[NSShadow alloc]init];shadow.shadowBlurRadius = 5;shadow.shadowOffset = CGSizeMake(0, 1);shadow.shadowColor = [UIColor colorWithWhite:0.000 alpha:0.490];[one addAttributes:@&#123;NSShadowAttributeName:shadow,NSForegroundColorAttributeName:[UIColor whiteColor],NSFontAttributeName:[UIFont boldSystemFontOfSize:30]&#125; range:NSMakeRange(0, 6)];[text appendAttributedString:one];label.attributedText = text; 2.空心字1[one addAttributes:@&#123;NSStrokeColorAttributeName:[UIColor redColor],NSStrokeWidthAttributeName:@1.5&#125; range:NSMakeRange(0, 6)]; 3.特殊效果1[one addAttributes:@&#123;NSTextEffectAttributeName:NSTextEffectLetterpressStyle,&#125; range:NSMakeRange(0, 6)]; 4.下划线、中划线 下划线：NSUnderlineColorAttributeName 1[one addAttributes:@&#123;NSUnderlineStyleAttributeName:@(NSUnderlineStyleSingle),NSUnderlineColorAttributeName:[UIColor redColor]]; 中划线 1[one addAttributes:@&#123;NSStrikethroughStyleAttributeName:@(NSUnderlinePatternSolid|NSUnderlineStyleSingle),NSStrikethroughColorAttributeName:[UIColor greenColor]&#125; range:NSMakeRange(0, 6)]; 线样式：1234567891011121314typedef NS_ENUM(NSInteger, NSUnderlineStyle) &#123;NSUnderlineStyleNone = 0x00,NSUnderlineStyleSingle = 0x01,NSUnderlineStyleThick NS_ENUM_AVAILABLE(10_0, 7_0) = 0x02,NSUnderlineStyleDouble NS_ENUM_AVAILABLE(10_0, 7_0) = 0x09,NSUnderlinePatternSolid NS_ENUM_AVAILABLE(10_0, 7_0) = 0x0000,NSUnderlinePatternDot NS_ENUM_AVAILABLE(10_0, 7_0) = 0x0100,NSUnderlinePatternDash NS_ENUM_AVAILABLE(10_0, 7_0) = 0x0200,NSUnderlinePatternDashDot NS_ENUM_AVAILABLE(10_0, 7_0) = 0x0300,NSUnderlinePatternDashDotDot NS_ENUM_AVAILABLE(10_0, 7_0) = 0x0400,NSUnderlineByWord NS_ENUM_AVAILABLE(10_0, 7_0) = 0x8000&#125; NS_ENUM_AVAILABLE(10_0, 6_0); 5.链接 label上的链接点击不了，textView可以，回调函数shouldInteractWithURL中可以响应。1[one addAttributes:@&#123;NSLinkAttributeName:@&quot;https://www.baidu.com&quot;&#125; range:NSMakeRange(0, 6)]; 6.段落123456NSMutableParagraphStyle *paragraph = [[NSMutableParagraphStyle alloc]init];paragraph.lineSpacing = 10.f; //行间距paragraph.firstLineHeadIndent = 30.f; //段落首行缩进paragraph.paragraphSpacing = 30.f; //段落间距paragraph.headIndent = 15.f; //整体缩进[one addAttributes:@&#123;NSParagraphStyleAttributeName:paragraph&#125; 7.图文混排12345NSMutableAttributedString *one = [[NSMutableAttributedString alloc] initWithString:@&quot;红红火火恍恍惚惚&quot;];NSTextAttachment *attachment = [[NSTextAttachment alloc]init];attachment.image = [UIImage imageNamed:@&quot;star_selected&quot;];NSAttributedString *imgAttr = [NSAttributedString attributedStringWithAttachment:attachment];[one insertAttributedString:imgAttr atIndex:4];","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"富文本","slug":"富文本","permalink":"https://guchunli.github.io/tags/富文本/"}]},{"title":"Xcode控制台打印中文","date":"2017-12-15T02:38:53.000Z","path":"2017/12/15/Xcode控制台打印中文/","text":"1.宏定义 1#define NSLog(FORMAT, ...) fprintf(stderr,&quot;\\n %s:%d %s\\n&quot;,[[[NSString stringWithUTF8String:__FILE__] lastPathComponent] UTF8String],__LINE__, [[NSString stringWithFormat:FORMAT, ##__VA_ARGS__] UTF8String]); 2.添加类目，重写description方法：拼接12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#import &lt;Foundation/Foundation.h&gt;@implementation NSDictionary (Log)- (NSString *)description&#123; NSMutableString *string = [NSMutableString string]; // 开头有个&#123; [string appendString:@&quot;&#123;\\n&quot;]; // 遍历所有的键值对 [self enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123; [string appendFormat:@&quot;\\t%@&quot;, key]; [string appendString:@&quot; : &quot;]; [string appendFormat:@&quot;%@,\\n&quot;, obj]; &#125;]; // 结尾有个&#125; [string appendString:@&quot;&#125;&quot;]; // 查找最后一个逗号 NSRange range = [string rangeOfString:@&quot;,&quot; options:NSBackwardsSearch]; if (range.location != NSNotFound) [string deleteCharactersInRange:range]; return string;&#125;@end@implementation NSArray (Log)- (NSString *)description&#123; NSMutableString *string = [NSMutableString string]; // 开头有个[ [string appendString:@&quot;[\\n&quot;]; // 遍历所有的元素 [self enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123; [string appendFormat:@&quot;\\t%@,\\n&quot;, obj]; &#125;]; // 结尾有个] [string appendString:@&quot;]&quot;]; // 查找最后一个逗号 NSRange range = [string rangeOfString:@&quot;,&quot; options:NSBackwardsSearch]; if (range.location != NSNotFound) [string deleteCharactersInRange:range]; return string;&#125;@end 3.添加类目，重写description方法：转换成json格式字符串1234567891011121314151617181920212223#import &lt;Foundation/Foundation.h&gt;@implementation NSDictionary (Log)- (NSString *)description&#123; NSData *jsonData = [NSJSONSerialization dataWithJSONObject:self options:NSJSONWritingPrettyPrinted error:nil]; NSString *jsonStr = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding]; return jsonStr;&#125;@end@implementation NSArray (Log)- (NSString *)description&#123; NSData *jsonData = [NSJSONSerialization dataWithJSONObject:self options:NSJSONWritingPrettyPrinted error:nil]; NSString *jsonStr = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding]; return jsonStr;&#125;@end","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"log","slug":"log","permalink":"https://guchunli.github.io/tags/log/"},{"name":"中文","slug":"中文","permalink":"https://guchunli.github.io/tags/中文/"}]},{"title":"P3图片导致iOS9.3以下崩溃的解决","date":"2017-12-12T05:28:39.000Z","path":"2017/12/12/P3图片导致iOS9-3以下崩溃的解决/","text":"这种问题一般在Xcode上运行正常，真机测试运行正常，打包上传到蒲公英下载安装运行正常，只有上传到AppStore下载安装才会崩溃。 导致这种问题的原因是：在 Xcode 8 中，当你资源文件中[含有16位图]或者[图片显示模式γ值为’P3’]且iOS targets设定为iOS 9.3以下就会出现这个问题. 如果你的app需要支持广色域显示的话，那你必须得把target设置成iOS 9.3+，相反，如果你的app不需要支持广色域且你想兼容 iOS 9.3 之前的项目，你就得把所有的16位的或者显示模式为’P3’图片全都替换成8位模式的SRGB颜色的图片。 解决方案如下：1.导出项目的ipa文件2.修改.ipa后缀为.zip3.解压.zip文件，会生成一个Payload文件夹，文件夹下包含项目的app bundle文件4.打开终端，切换到app bundle文佳夹，定位到Assets.car文件，使用assetutil命令找到包含16-bit或P3的资源文件，将分析结果导出到json文件中，命令如下：12345$ cd /path/Payload/XXX.app/$ find . -name &apos;Assets.car&apos;./Assets.car$ sudo xcrun --sdk iphoneos assetutil --info ./Assets.car &gt; /tmp/Assets.json //./Assets.ca为上一步查找的结果 /tmp/Assets.json为导出的json文件路径$ open /tmp/Assets.json 5.在json文件中查找包含&quot;DisplayGamut&quot; : &quot;P3&quot;的相关内容，&quot;Name&quot; : &quot;picBroken&quot;为对应图片名称，修改替换对应图片文件。json文件格式如下：123456789101112131415161718&#123;&quot;Opaque&quot; : false,&quot;Compression&quot; : &quot;lzfse&quot;,&quot;SizeOnDisk&quot; : 5968,&quot;PixelHeight&quot; : 192,&quot;Name&quot; : &quot;picBroken&quot;,&quot;RenditionName&quot; : &quot;picBroken@3x.png&quot;,&quot;ColorModel&quot; : &quot;Monochrome&quot;,&quot;Scale&quot; : 3,&quot;Idiom&quot; : &quot;universal&quot;,&quot;DisplayGamut&quot; : &quot;P3&quot;,&quot;Encoding&quot; : &quot;GRAY-16&quot;,&quot;BitsPerComponent&quot; : 16,&quot;Image Type&quot; : &quot;kCoreThemeOnePartScale&quot;,&quot;Colorspace&quot; : &quot;extended gray&quot;,&quot;AssetType&quot; : &quot;Image&quot;,&quot;PixelWidth&quot; : 192&#125;, 补充： iOS Console：可以脱离xcode打印log，以及打印ios系统收集的crash 日志。 BashShell：命令行打包 参考文章：P3图片导致iOS9.3以下崩溃问题iOS线上版本图片资源格式的问题导致的闪退","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"P3图片","slug":"P3图片","permalink":"https://guchunli.github.io/tags/P3图片/"}]},{"title":"项目中的实用技巧","date":"2017-12-07T06:50:56.000Z","path":"2017/12/07/项目中的实用技巧/","text":"避免在一个界面上同时点击多个button （整个项目）1[[UIButton appearance] setExclusiveTouch:YES]; AppDelegate中微信、支付宝支付接收到的回调可以分别添加helper处理判断程序是否是从杀死状态进入(接受远程推送)1NSDictionary * userInfo = [launchOptions objectForKey:UIApplicationLaunchOptionsRemoteNotificationKey]; 实例方法调用类方法 [self class]123[[self class] funA];+ (void)funA &#123;&#125; 修改类文件名 在类的.h文件中右击@interface AppDelegate选中类名，选择Refactor-&gt;Rename，修改完成保存即可。 字典拼接addEntriesFromDictionary是NSMutableDictionary的一个方法。1[dic1 addEntriesFromDictionary:dic2]; 用枚举表示状态、选项、状态码typedef NS_ENUM(NSInteger, UITableViewStyle) {UITableViewStylePlain, // regular table viewUITableViewStyleGrouped // preferences style table view};","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"项目","slug":"项目","permalink":"https://guchunli.github.io/tags/项目/"},{"name":"技巧","slug":"技巧","permalink":"https://guchunli.github.io/tags/技巧/"}]},{"title":"使用TestFlight构建APP版本测试","date":"2017-12-06T03:48:55.000Z","path":"2017/12/06/使用TestFlight构建APP版本测试/","text":"1.两种测试 内部测试：测试人员上限25个 无需审核 外部测试：测试人员上限2000个 需要审核，一天左右 一个版本有效期是60天，如果要继续使用，在过期前提交新版本。 2.构建内部beta测试iTunes Connect-&gt;Users and Roles-&gt;add user 角色权限 Admin App Manager Developer Marketer Sales Can be an internal tester Y Y Y Y N can upload a build Y Y Y N N can submit a build for external testing Y Y N N N My Apps-&gt;Activity-&gt;TestFlight-&gt;Select Version to Test-&gt;Start Testing 3.构建外部beta测试My Apps-&gt;Activity-&gt;Test Information-&gt;填写信息-&gt;External Testing-&gt;Add New Testers-&gt;Add Build To Test-&gt;submit通过审核后，External Testing-&gt;build and hit-&gt;Start Testing 4.开始测试内部测试： Apple ID 连接到iTunes Connect，新版本上传到iTunes Connect，收到邮件。外部测试：版本审核通过，Admin或App Manager在iTunes Connect推送给外部测试，收到邮件。 App Store下载TestFlight，打开邮件，点击Start Testing，安装下载。","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"TestFlight","slug":"TestFlight","permalink":"https://guchunli.github.io/tags/TestFlight/"},{"name":"测试","slug":"测试","permalink":"https://guchunli.github.io/tags/测试/"}]},{"title":"iPhoneX适配笔记","date":"2017-12-05T06:10:42.000Z","path":"2017/12/05/iPhoneX适配笔记/","text":"1.设置iPhoneX启动图片 屏幕尺寸：5.8 英寸 屏幕密度：458 ppi 开发尺寸：375*812 pt 像素尺寸：1125*2436 px 倍图：@3x 2.safeArea 顶部有刘海： 状态栏44+导航栏44 底部有手势区域：bottom 34 四周有圆角 控制器生命周期 viewDidLoad viewWillAppear viewSafeAreaInsetsDidChange（NEW） viewWillLayoutSubviews viewDidAppear 可以在viewSafeAreaInsetsDidChange后，设置safe area：123if #available(iOS 11.0, *) &#123;self.additionalSafeAreaInsets = UIEdgeInsetsMake(10, 0, 0, 34)&#125; 宏定义高度 适配iPhone x 导航栏高度 12#define STATUSBAR_HEIGHT [[UIApplication sharedApplication] statusBarFrame].size.height#define NAV_HEIGHT (STATUSBAR_HEIGHT + 44) 适配iPhone x 底栏高度 1#define TabbarHeight ([[UIApplication sharedApplication] statusBarFrame].size.height&gt;20?83:49) 待补充","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"iPhoneX","slug":"iPhoneX","permalink":"https://guchunli.github.io/tags/iPhoneX/"}]},{"title":"iOS分析友盟的错误报告定位错误代码位置","date":"2017-11-06T10:19:13.000Z","path":"2017/11/06/iOS分析友盟的错误报告定位错误代码位置/","text":"命令行方式1.在Xcode的Windows-&gt;Orgnizer-&gt;Archives可以看到每次的打包，找到要查看的错误报告所在的版本。 /Users/&lt;用户名&gt;/Library/Developer/Xcode/Archives 路径下是所有打包文件 2.show in Finder，查看包内容，将.dSYM文件和.app复制保存到一个新的文件夹crash。3.使用终端12cd crashxcrun atos -arch arm64 -o XXX.app/XXX 0x1000e7068 arm64为CPU Type XXX为项目名称 0x1000e7068为错误代码的地址 使用以上命令即可得到错误代码所在的文件以及出错代码的具体行数。 使用工具软件下载地址：dSYMTools 如何将文件一一对应：xxx.app 、 xxx.app.dSYM 和crash 文件都有自己的 UUID，只要这三个文件的 UUID 一致，就可以解析出正确的错误函数信息。 1.查看 xx.app 文件的 UUID：1dwarfdump --uuid xxx.app/xxx (xxx代表项目名) 2.查看 xx.app.dSYM 文件的 UUID：1dwarfdump --uuid xxx.app.dSYM 3.crash 文件内第一行 Incident Identifier 就是 crash 文件的 UUID。 使用xcode自带的工具symbolicatecrash参考文章：如何通过友盟的错误分析报告，定位到错误代码的位置 dSYM 文件分析工具","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"友盟","slug":"友盟","permalink":"https://guchunli.github.io/tags/友盟/"},{"name":"崩溃","slug":"崩溃","permalink":"https://guchunli.github.io/tags/崩溃/"},{"name":"错误","slug":"错误","permalink":"https://guchunli.github.io/tags/错误/"}]},{"title":"iOS报错信息详解","date":"2017-11-06T03:46:41.000Z","path":"2017/11/06/iOS报错信息详解/","text":"duplicate symbols for architecture x86_64 原因：1.在工程中不同路径下重复导入了某个类或文件； 2.引用了.m文件，#import “XXX.m”； 3.多个文件中重复定义了相同的枚举等 解决：1.查找，删除； 2.查找，修改； 3.查找，删除。 如果还是不能解决，试着删除该文件，重新添加。 invalid mode ‘kCFRunLoopCommonModes’ provided to CFRunLoopRunSpecific - break on _CFRunLoopError_RunCalledWithInvalidMode to debug. This message will only appear once per execution. 原因：数组未初始化 解决：初始化数组 “_OBJCCLASS$_XXX”, referenced from 原因：缺少文件，或文件未参与编译，framework 没导入，真机和测试也要注意，.m文件为参与编译 解决：在build Phases-&gt;Compile Sources 中添加相应的类文件 index 0 beyond bounds for empty array 原因：数组越界，index 0 在空数组中也是越界，不存在。取到的值是NSNull 对象。 它表示空值，只有一个方法。调用NSArray的属性方法，程序会dump。 12345@interface NSNull : NSObject &lt;NSCopying,NSSecureCoding&gt;+ (NSNull *)null;@end 解决：判断array 不为空 1if (array != nil &amp;&amp; ![array isKindOfClass:[NSNull class]] &amp;&amp; array.count != 0) 待补充","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"崩溃","slug":"崩溃","permalink":"https://guchunli.github.io/tags/崩溃/"},{"name":"bug","slug":"bug","permalink":"https://guchunli.github.io/tags/bug/"},{"name":"报错","slug":"报错","permalink":"https://guchunli.github.io/tags/报错/"}]},{"title":"iOS-让代码更规范","date":"2017-10-26T07:38:58.000Z","path":"2017/10/26/iOS-让代码更规范/","text":"使用字面量语法换行，空格使用枚举表示状态 使用分类简化代码使用description方法查看日志使用多target区分正式环境和开发环境解耦MVC","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"代码规范","slug":"代码规范","permalink":"https://guchunli.github.io/tags/代码规范/"}]},{"title":"iOS11适配注意点","date":"2017-10-16T01:59:02.000Z","path":"2017/10/16/iOS11适配注意点/","text":"1.UIBarItemlandscapeImagePhone：横屏时，长按item，item放大显示在hud上 2.navigationItemlargeTitleDisplayMode：控制大标题的显示3.UISearchControllernavigationItem.searchController //将UISearchController集成到NavigationnavigationItem.hidesSearchBarWhenScrolling //决定滑动的时候是否隐藏搜索框；iOS 11 新增属性4.automaticallyAdjustsScrollViewInsets在iOS11之前，如果想要scrollView不偏移64p，则需设置automaticallyAdjustsScrollViewInsets=NO，但是这个属性在iOS11直接被遗弃了，解决方法：12345if (@available(iOS 11.0, *)) &#123;self.tableView.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever;&#125; else &#123;self.automaticallyAdjustsScrollViewInsets = NO;&#125; 5.UIScrollView &amp; UITableVIew iOS11开启了Self-Sizing行高估算机制 解决方法一 ：添加实现View的代理方法 123456- (UIView *)tableView:(UITableView *)tableView viewForFooterInSection:(NSInteger)section &#123;return nil;&#125;- (UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section &#123;return nil;&#125; 解决方法二：添加以下代码关闭估算行高： 123self.tableView.estimatedRowHeight = 0;self.tableView.estimatedSectionHeaderHeight = 0;self.tableView.estimatedSectionFooterHeight = 0; 如果使用了Masonry 进行布局，需要适配safeArea12345if ([UIDevice currentDevice].systemVersion.floatValue &gt;= 11.0) &#123;make.edges.equalTo(self.view.safeAreaInsets);&#125; else &#123;make.edges.equalTo(self.view);&#125; 待补充","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"iOS11","slug":"iOS11","permalink":"https://guchunli.github.io/tags/iOS11/"}]},{"title":"cocoapods安装","date":"2017-08-14T07:24:09.000Z","path":"2017/08/14/cocoapods安装/","text":"1.安装过程中如果出现以下错误提示：12ERROR: While executing gem ... (OpenSSL::SSL::SSLError) hostname &quot;rubygems-china.oss.aliyuncs.com&quot; does not match the server certificate 移除镜像：12sources --remove https://ruby.taobao.org/sources --remove https://gems.ruby-china.org/ 使用阿里云镜像：1gem sources -a http://rubygems-china.oss.aliyuncs.com 2.查看镜像：1gem sources -l 3.安装cocoapods：1sudo gem install cocoapods 安装Homebrew123456$ curl -LsSf http://github.com/mxcl/homebrew/tarball/master | sudo tar xvz -C/usr/local --strip 1Error: /usr/local must be writable!$ sudo chown -R $(whoami) /usr/local$ brew update //更新版本$ brew doctor //检查是否安装成功Your system is ready to brew. 安装npm和node123brew install nodenpm -v //查看npm是否安装成功node -v //查看node是否安装成功","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"cocoapods","slug":"cocoapods","permalink":"https://guchunli.github.io/tags/cocoapods/"}]},{"title":"SVN使用","date":"2017-08-04T07:07:57.000Z","path":"2017/08/04/SVN使用/","text":"命令帮助12$ svn help //svn命令帮助$ svn htlp add //svn具体功能帮助 创建svn版本库(1)创建仓库路径12$ svnadmin create svnrepo$ cd svnrepo (2)导入项目源码1$ svn import [本地路径][目标版本库路径] -m [description] (3)修改配置文件 passwd 添加用户名和密码，格式：用户名 = 密码 12$ cd conf/$ vi passwd 修改启动项参数 svnserve.conf 1$ vi svnserve.conf 将下面几行代码打开，将前面的注释#删除123456anon-access = readauth-access = write...password-db = passwd...authz-db = authz 配置用户权限 authz1234567891011121314[groups]# harry_and_sally = harry,sally# harry_sally_and_joe = harry,sally,&amp;joeadmin = admin //配置admin# [/foo/bar]# harry = rw# &amp;joe = r# * =[/]@admin=rw //配置admin读写权限* = r# [repository:/baz/fuz]# @harry_and_sally = rw# * = r (4)启动svn服务1svnserve -d -r svnrepo 导入项目 svn import12$ cd svndemo$ svn import svndemo http://... --message &quot;start&quot; 导出项目 svn checkout 导出的代码在版本控制下 12$ svn checkout https://... --username zhangsan$ svn checkout svn://... --username zhangsan svn export 导出的代码不在版本控制下 1$ svn export [-r version] https://... --username zhangsan 添加新文件1&amp; svn add test.txt 提交修改1&amp; svn commit -m &quot;description&quot; 更新文件1$ svn update [-r version] filename 删除文件1$ svn delete svn://... -m &quot;description&quot; 比较差异12$ svn diff [-r version] filename$ svn diff &gt; file //输出diff信息到文件 加锁/解锁12$ svn lock -m &quot;description&quot; [--force] filename$ svn unlock filename 查看状态1$ svn status 查看日志 可以查看文件的所有修改记录和版本号变化 1$ svn log filename 查看文件详细信息 1$ svn info filename 查看SVN版本库下的文件和目录列表1$ svn list svn://... 创建新目录，加入版本控制 可以查看文件的所有修改记录和版本号变化1$ svn mkdir [-m &quot;description&quot;] svn://... 添加完子目录后，一定要回到根目录下更新一下，否则在该目录下提交文件会提示“提交失败” 丢弃本地修改12$ svn revert [--recursive] filename$ svn revert --recursive . //丢弃整个目录的本地修改 冲突 发生冲突时会生成与冲突文件同名的三个文件：.mine, .rOLDREV, .rNEWREV，例如a.txt发生冲突： 1234a.txta.txt.minea.txt.r1a.txt.r2 解决冲突的三种方式(1)修改冲突，然后执行以下命令： 1$ svn resolved (2)使用库里的新版本代码12$ cp a.txt.r2 a.txt$ svn resolved a.txt (3)撤销修改，使用旧版本代码1$ svn revert a.txt 分支 一般项目创建三个分支：(1)trunk是主分支，是日常开发进行的地方,一般包含： 1234560-Src 源码1-DevelopDoc 开发文档2-ProductDoc 产品文档3-ThirdPartyTools 第三方工具（插件）4-Testing 测试5-DeployDoc 部署文档 (2)branches，开发分支。阶段性的release版本。 (3)tags，标签分支。一般是只读的，存储阶段性的发布版本。 创建分支12$ svn copy branchA branchB -m &quot;make B banch&quot;* 使用分支的两种分支 (1)先拷贝本地分支然后提交：checkout-&gt;copy-&gt;commit123$ svn checkout serverBranchA$ svn copy localBranchA localBranchB$ svn commit -m &quot;make B banch&quot; (2)直接远程拷贝分支：copy-&gt;checkout12$ svn copy serverBranchA serverBranchB -m &quot;make B banch&quot;$ svn checkout serverBranchB 切换分支123456$ svn info | grep URL //branchA$ svn switch serverBranchB$ svn info | grep URL //branchB``### 合并分支 $ svn merge branchA branchB // 把对branchA的修改合并到分支branchB12### 删除分支 $ svn delete serverBranchB -m “delete branch B”``` svn cleanup","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"SVN","slug":"SVN","permalink":"https://guchunli.github.io/tags/SVN/"}]},{"title":"Swift项目中的注意点","date":"2017-08-03T02:16:56.000Z","path":"2017/08/03/Swift项目中的注意点/","text":"swift与OC的区别 注意: Swift开发中定义变量时候先用let(常量), 只有真正需要修改时才用var 由于编译器可以通过赋值的类型自动推导出数据的真实类型, 所以在Swift开发中, 能不写数据类型就不写数据类型 Swift 对类型校验更加严格，不同类型的变量不允许直接计算 Swift语法允许我们直接修改一个对象的结构体属性的成员 一般情况下只有需要区分两个变量, 或者在闭包中访问外界属性才需要加上self，可以提醒程序员主动思考当前self会不会形成循环引用 1titleLabel?.frame.origin.x = 0 一般在本类中的扩展中实现代理方法 1extension QRCodeViewController: UINavigationControllerDelegate, UIImagePickerControllerDelegate day 1创建项目准备工作删除模板文件 ViewController.swift Main.storyboard LaunchScreen.xib 创建项目结构主目录 Classes二级目录 目录名 说明 Main 主要 Home 首页 Message 消息 Discover 发现 Profile 我 Tools 工具类 创建项目文件MainBaseTabbar/BaseNavigation/BaseViewController 功能模块 目录 Controller Home HomeTableViewController.swift Message MessageTableViewController.swift Discover DiscoverTableViewController.swift Profile ProfileTableViewController.swift 设置程序入口 修改 AppDelegate 中的 didFinishLaunchingWithOptions 函数，设置启动控制器 iOS Images Extractor可以获取APP中的所有图片 架构/设计 单一职责原则 这是经常被违背的原则。一个类只能干一个事情，一个方法最好也只干一件事情。比较常见的违背是一个类既干UI的事情，又干逻辑的事情，这个在低质量的客户端代码里很常见 行为是否统一，例如： 缓存是否统一 错误处理是否统一 错误提示是否统一 弹出框是否统一 …… 代码污染 代码有没有对其他模块强耦合 重复代码 开闭原则 面向接口编程 健壮性 是否考虑线程安全 数据访问是否一致性 边界处理是否完整 逻辑是否健壮 是否有内存泄漏 有没有循环依赖 有没有野指针 …… 错误处理 改动是不是对代码的提升 新的改动是打补丁，让代码质量继续恶化，还是对代码质量做了修复 效率/性能 关键算法的时间复杂度多少？有没有可能有潜在的性能瓶颈 客户端程序对频繁消息和较大数据等耗时操作是否处理得当 代码风格 可读性 衡量可读性的可以有很好实践的标准，就是 Reviewer 能否非常容易的理解这个代码。如果不是，那意味着代码的可读性要进行改进 命名对可读性非常重要 英语用词尽量准确一点，必要时可以查字典 函数长度/类长度 函数太长的不好阅读 类太长了，检查是否违反的 单一职责 原则 恰到好处的注释 参数不要太多，一般不要超过 3 个 log QorumLogs 123456789101112131415QorumLogs.enabled = true // 启用QorumLogsQorumLogs.test() // 测试QorumLogs// 设置需要显示的等级QorumLogs.minimumLogLevelShown = 3// 测试的时候，可以限定输出文件QorumLogs.onlyShowThisFile(BaseTabbarController.self)QL1(&quot;mylog&quot;) // debugQL2(&quot;mylog&quot;) // infoQL3(&quot;mylog&quot;) // warningQL4(&quot;mylog&quot;) // errorQLPlusLine() // 打印加号作为分割线QLShortLine() // 打印等号作为分割线 自定义LOGprint(#function) // 打印所在的方法print(#line) // 打印所在的行print(#file) // 打印所在文件的路径 123456789101112131415/*泛型如果想在函数中使用泛型, 那么必须告诉系统者是一个泛型函数func 函数名称&lt;T&gt;(形参列表) -&gt; 返回值类型&#123;&#125;message : TT具体是什么类型由调用者来确定, 调用者传递的是什么类型, T就是什么类型*/func XXLog&lt;T&gt;(_ message: T, method: String = #function, line: Int = #line)&#123;#if DEBUGprint(&quot;\\(method)[\\(line)]: \\(message)&quot;)#endif&#125; 异常处理机制do catch的作用: 一旦方法抛出异常, 那么就会执行catch后面{}中的内容, 如果没有抛出异常, 那么catch后面{}中的内容不执行try : 正常处理异常, 一旦有异常就执行catchtry!: 强制处理异常(忽略异常),也就是说告诉系统一定不会发生异常, 如果真的发生了异常, 那么程序会崩溃try?: 忽略异常, 告诉系统可能有异常也可能没有异常, 如果发生异常返回值就是nil, 如果没有发生异常, 会将返回值包装为一个可选类型的值开发中推举使用try? 和 try , 不推荐使用try!12//序列化JSONguard let dictArray = try? NSJSONSerialization.JSONObjectWithData(jsonData!, options: NSJSONReadingOptions.MutableContainers) else&#123;&#125; 动态加载控制器 命名空间作用: 避免重复不用项目中的命名空间是不一样的, 默认情况下命名空间的名称就是当前项目的名称正是因为Swift可以通过命名空间来解决重名的问题, 所以在做Swift开发时尽量使用cocoapods来集成三方框架, 这样可以有效的避免类名重复正是因为Swift中有命名空间, 所以通过一个字符串来创建一个类和OC中也不太一样了, OC中可以直接通过类名创建一个类, 而Swift中如果想通过类名来创建一个类必须加上命名空间 guard可以有效的解决可选绑定容易形成{}嵌套问题 12345guard 条件表达式 else &#123;// 需要执行的语句// 只有条件为假才会执行&#123;&#125;中的内容return&#125; 动态加载控制器 在 swift 中，类名是包含命名空间的,类名的组成格式是 namespace.类名 命名空间默认是项目名称，同一个命名空间全局共享 从 mainBundle 的 infoDictionary 获取命名空间名称,namespace 对应的是 CFBundleExecutable12345678910111213141516171819202122232425childControllerName = &quot;HomeTableViewController&quot;// 1.动态获取命名空间// 由于字典/数组中只能存储对象, 所以通过一个key从字典中获取值取出来是一个AnyObject类型, 并且如果key写错或者没有对应的值, 那么就取不到值, 所以返回值可能有值也可能没值, 所以最终的类型是AnyObject?guard let name = NSBundle.mainBundle().infoDictionary![&quot;CFBundleExecutable&quot;] as? String else&#123;NJLog(&quot;获取命名空间失败&quot;)return&#125;// 2.根据字符串获取Classlet cls: AnyClass? = NSClassFromString(name + &quot;.&quot; + childControllerName)// 3.告诉编译器真实类型是UITableViewController// Swift中如果想通过一个Class来创建一个对象, 必须告诉系统这个Class的确切类型guard let typeCls = cls as? UITableViewController.Type else&#123;NJLog(&quot;cls不能当做UITableViewController&quot;)return&#125;// 4.实例化控制器// 通过Class创建对象let childController = typeCls.init()NJLog(childController) as 如果某些方法返回的数据类型是 AnyObject/AnyClass，则需要在右侧使用 as 类型 表明类型，并且根据返回值是否是可选项，添加 ! 或者 ?，例如： 1let ns = NSBundle.mainBundle().infoDictionary![\"CFBundleExecutable\"] as! String 如果某些方法返回类型是 AnyObject/AnyClass，但是对象类型是动态生成的，也就是说，编码时同样无法确定改对象的准确类型，可以在左侧使用 : AnyObject 或者 : AnyClass 告诉编译器暂不处理 1let cls: AnyClass = NSClassFromString(ns + \".\" + vcName)! storyboard refrence懒加载懒加载的代码是一个闭包，因此在代码内部需要使用 self.1234567lazy var centerBtn: UIButton = &#123; () -&gt; UIButton in let btn = UIButton() return btn&#125;() @objc 类123@objc class MyHelper:NSObject &#123; // class code &#125; 使用@objc修饰后的类型，可以直接供 Objective-C 调用使用@objc修饰的类，必须继承自NSObject。 方法@objc private func作用：在swift 中 如果一个按钮添加点击方法 如果定义为Private 或者 定义为 FilePrivate 那么会在Addtaget方法中找不到私有方法但是又不想把方法暴露出来，避免外界访问 ，那么可以在私有方法前加 @objc 修饰 那么它就能找到那个方法了, 允许这个函数在“运行时”通过oc的消息机制调用 private/fileprivate private能在同一个类 或者 同一个文件（extension）中访问这个方法 不希望暴露的方法，应该使用 private 修饰符 按钮点击事件的调用是由 运行循环 监听并且以消息机制传递的，因此，按钮监听函数不能设置为 private fileprivate只能在一个类中访问 不能在类扩展中访问 通知/代理/block通知 : 层级结构较深代理 : 父子 , 方法较多时候使用block: 父子, 方法较少时使用(一般情况一个方法) 和OC不一样, Swift中如果简单的调用代理方法, 不用判断代理能否响应 协议 定义协议 12345678/// 访客视图协议protocol VisitorViewDelegate: NSObjectProtocol&#123;/// 将要登录func visitorViewLogin()/// 将要注册func visitorViewRegister()&#125; 定义协议时，需要继承自 NSObjectProtocol，否则无法设置代理的类型 定义代理 12/// 定义代理 - 一定要用 weakweak var delegate: VisitorViewDelegate? 构造器如果构造方法前面没有convenience单词, 代表着是一个初始化构造方法(指定构造方法)如果构造方法前面有convenience单词, 代表着是一个便利构造方法 指定构造方法和便利构造方法的区别1.指定构造方法中必须对所有的属性进行初始化2.便利构造方法中不用对所有的属性进行初始, “因为便利构造方法依赖于指定构造方法”一般情况下如果想给系统的类提供一个快速创建的方法, 就自定义一个便利构造方法 ##// 一般情况下设置全局性的属性, 最好放在AppDelegate中设置, 这样可以保证后续所有的操作都是设置之后的操作12345// 设置全局外观private func setupAppearance() &#123; UINavigationBar.appearance().tintColor = UIColor.orange UITabBar.appearance().tintColor = UIColor.orange&#125; tabbarItemtabBar 的 items 是在 视图将要出现之前 才被创建的 viewDidLoad 方法调用是实例化控制器方法触发的此时只是创建子控制器，而由于界面还没有显示，按照 iOS 开发的延迟创建原则，tabBar 中的 items 还没有被创建 viewWillAppear 方法是由 makeKeyAndVisible 方法触发的此时需要开始准备将控制器的子视图添加到界面上，因此 tabBar 中的 items 已经被创建 day 2UIPresentationController1.自定义转场modal出来的控制器不会移除原有的控制器2.自定义转场modal出来的控制器的尺寸可以自己在containerViewWillLayoutSubviews方法中控制12345override func containerViewWillLayoutSubviews()&#123;// 设置弹出视图的尺寸presentedView()?.frame = CGRect(x: 100, y: 45, width: 200, height: 200)&#125; 3.containerView 非常重要, 容器视图, 所有modal出来的视图都是添加到containerView上的4.presentedView() 非常重要, 通过该方法能够拿到弹出的视图","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"Swift项目","slug":"Swift项目","permalink":"https://guchunli.github.io/tags/Swift项目/"}]},{"title":"github上优秀的iOS开源项目","date":"2017-08-01T09:45:50.000Z","path":"2017/08/01/github上优秀的iOS开源项目/","text":"OC项目JKCategories 对系统各种类的category，很全面，看源码能学到很多东西。链接：JKCategories MiaoShow 高仿&lt;喵播APP&gt;，视频直播相关。链接：MiaoShow SmallHorseLive 小马直播间 - 环信IM &amp; UCloud链接：SmallHorseLive BeautyHour 图片美化，类似美图秀秀，支持图片与文字合成。链接：BeautyHour JHChart 绘制图表，条形图，环形图等，根据具体需求选择链接：JHChart PNChart 绘制图表，条形图，环形图等，根据具体需求选择链接：PNChart MVVMReactiveCocoa 雷纯锋写的关于MVVM，ReactiveCocoa相关。MVVMReactiveCocoa Swift项目TodayNews 模仿今日头条。链接：TodayNews socket.io-client-swift Socket.IO-client for iOS/OS X.socket.io-client-swift ReactNative项目react-zhihu 模仿知乎界面的简单React demoreact-zhihu 未完待续，持续更新中…","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"开源","slug":"开源","permalink":"https://guchunli.github.io/tags/开源/"}]},{"title":"2017张北草原音乐节","date":"2017-07-30T09:58:15.000Z","path":"2017/07/30/2017张北草原音乐节/","text":"2017-07-29 张北草原音乐节张北草原张北草原 音乐节现场 音乐节现场 南征北战–《萨瓦迪卡》《我的天空》 好妹妹–《一个人的北京》《我说今晚月光那么美，你说是的》 许巍 许巍–《曾经的你》","comments":true,"categories":[{"name":"随笔","slug":"other","permalink":"https://guchunli.github.io/categories/other/"}],"tags":[{"name":"张北","slug":"张北","permalink":"https://guchunli.github.io/tags/张北/"},{"name":"音乐节","slug":"音乐节","permalink":"https://guchunli.github.io/tags/音乐节/"}]},{"title":"iOS逆向开发学习笔记","date":"2017-07-27T06:35:20.000Z","path":"2017/07/27/iOS逆向开发学习笔记/","text":"待补充","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"逆向","slug":"逆向","permalink":"https://guchunli.github.io/tags/逆向/"}]},{"title":"iOS可用架构设计","date":"2017-07-21T02:43:44.000Z","path":"2017/07/21/iOS可用架构设计/","text":"项目目录结构 AppDelegate：应用入口 AppDelegate：生命周期 AppDelegate+AppService：推送，IM，支付等 Base：基类 TabbarController NavigationController WebViewController BaseViewController NoDataViewController Modules：功能模块，APP的主要业务逻辑，MVC Home ViewController View Model Logic Service Manager：管理模块，用户登录退出，网络状态监听，广告页，应用介绍页等 AppManager UserManager Utils：工具类，三方框架的二次封装，自己定义的工具类等 Network Category HUD ADPage Frameworks：第三方框架，支付，IM等 Define：全局宏定义，屏幕宽高、接口地址、字体颜色、key、secret Resource：资源文件，图片，音视频等 参考链接：iOS 从0到1搭建高可用App框架","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"架构","slug":"架构","permalink":"https://guchunli.github.io/tags/架构/"}]},{"title":"iOS常用第三方框架","date":"2017-07-21T02:26:37.000Z","path":"2017/07/21/iOS常用第三方框架/","text":"网络1.AFNetworking 2.PPNetworkHelper 对AFNetworking 3.x 与YYCache的二次封装 简单易用，包含了缓存机制，控制台可以直接打印json中文字符 3.YTKNetwork 猿题库研发团队基于AFNetworking封装的iOS网络库 适合稍微复杂一些的项目，不适合个人的小项目 基础组件库YYKit YYModel— 高性能的 iOS JSON 模型框架。 YYCache— 高性能的 iOS 缓存框架。 YYImage— 功能强大的 iOS 图像框架。 YYWebImage— 高性能的 iOS 异步图像加载框架。 YYText— 功能强大的 iOS 富文本框架。 YYKeyboardManager— iOS 键盘监听管理工具。 YYDispatchQueuePool— iOS 全局并发队列管理工具。 YYAsyncLayer— iOS 异步绘制与显示的工具。 YYCategories— 功能丰富的 Category 类型工具库。 图像异步加载使用的NSURLConnection，还是建议使用SDWebImage。 等待加载提示 MBProgressHUD SVProgressHUD UAProgressView 键盘监听管理工具 IQKayboardManager Badge WZLBadge 日历 GFCalendar FSCalendar 直播 LFLiveKit IJKMediaFramework 视频播放 VIMVideoPlayer VR播放器 MDVRLibrary 待补充","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"待补充","slug":"待补充","permalink":"https://guchunli.github.io/tags/待补充/"},{"name":"框架","slug":"框架","permalink":"https://guchunli.github.io/tags/框架/"}]},{"title":"Swift3.0学习笔记","date":"2017-07-14T09:13:04.000Z","path":"2017/07/14/Swift3.0学习笔记/","text":"基础知识常量和变量let，var分别声明常量，变量代码中有不需要改变的值，使用 let 关键字将它声明为常量 使用 let 修饰 view 并且赋值，表示该常量的内存地址不允许修改，但是可以修改其内部的属性 类型标注很少需要标注，swift会进行类型推断，根据右边的代码，推导出变量的准确类型 Option + Click 可以查看变量的类型1let a:Float = 3.0 注释多行注释可嵌套 分号swift语句，最后分号可写可不写 类型转换值永远不会被隐式转换为其他类型，如果要对不同类型的数据进行计算，必须要显式的转换123let a = &quot;abc&quot;let b = 9let ab = a + String(b) 类型别名1typealias Example = Int 元组 元组可通过变量名或下标访问 可在定义元组的时候给元素命名 不需要访问的元素可用_代替 元组可作为函数返回值返回多个值 可选类型可以是任何类型值的缺失显示类型转换结果是可选类型 nilnil是一个确定的值，表示值缺失，任何类型的可选状态都可以被设置为nil不可用于非可选的常量和变量可选常量或变量不赋值，自动设值为nil if 语句以及强制解析if语句中的条件必须是一个布尔表达式当一个可选常量或变量确定包含值时，可用!强制解析 () 可以省略，但是 {} 不能省略 当 if 的嵌套层次很深，可用where1if let u = url where u.host == &quot;www.baidu.com&quot; &#123;&#125; 解包：(1)!强行解包,如果 变量 为空，运行时会崩溃(2)判断是否为空123if str != nil &#123;print(str!)&#125; (3)if let可选绑定 可选绑定可以用在if或while语句中可以判断多个可选项是否为空，用,隔开 if let 不能与使用 &amp;、| 等条件判断,可以使用 where 子句123if let constantName = someOptional &#123;//constantName&#125; 隐式解析可选类型可选类型被第一次赋值之后就可以确定之后一直有值，这种类型的可选状态被定义为隐式解析可选类型，可使用!直接声明，之后不需要使用!取值。隐式解析可选类型就是可以自动解析的可选类型。仍然可以可选绑定。 错误处理抛出错误：123func canThrowAnError() throws &#123;// 这个函数有可能抛出错误&#125; 捕获错误：123456do &#123;try canThrowAnError()// 没有错误消息抛出&#125; catch &#123;// 有一个错误消息抛出&#125; 断言当前面表达式的结果为false时显示后面的消息，应用终止。后面的断言消息也可省略。release配置时，断言被禁用。1assert() 基本运算符空合运算符??可对可选类型a进行空判断，如果包含值就解封，否则返回默认值b，此默认值b也为可选类型12let let c = a ?? b 区间运算符 闭区间：… 半开区间：..&lt; 字符与字符串初始化空字符串12let s1 = &quot;&quot;let s2 = String() 字符串是值类型字符str.characters12let chars:[Character] = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]let str = String[chars] 字符串可变性变量可变，常量不可变 连接字符串和字符 + append 插入和删除以下方法也可使用在Array,Dictionary,Set中。 str.characters.indices所有索引 在某个索引值之前插入字符：insert(_:at:) 插入字符串：insert(contentsOf:at:) 12var hello = &quot;hello&quot;;hello.insert(contentsOf:&quot; world!&quot;.characters, at: hello(before: welcome.endIndex)) 删除字符：remove(at:) 删除字符串removeSubrange(_:)123var hello = &quot;hello world!&quot;let range = hello.index(hello.endIndex, offsetBy: -7)..&lt;hello.endIndexhello.removeSubrange(range) 计算字符数量str.characters.count 字符串索引 startIndex,endIndex,index(before:),index(after:),index(_:offsetBy:),也可以使用在Array,Dictionary,Set中 str.characters.indices所有索引 比较字符串 字符串相等：== 前缀相等：hasPrefix(_:) 后缀相等：hasSuffix(_:) 插值值转换成字符串：() 如果变量是可选项，拼接的结果中会有 Optional，?? 操作符用于检测可选项是否为 nil， 如果不是 nil，使用当前值，如果是 nil，使用后面的值替代 格式化字符串 在实际开发中，如果需要指定字符串格式，可以使用 String(format:...) 的方式12345let h = 8let m = 23let s = 9//后面的参数需要放在一个数组中let timeString = String(format: \"%02d:%02d:%02d\", arguments: [h, m, s]) 集合类型集合的可变性变量可变，常量不可变 数组 数组的类型 如果初始化时，所有内容类型一致，择数组中保存的是该类型的内容 如果初始化时，所有内容类型不一致，择数组中保存的是 NSObject 数字可以直接添加到集合，不需要再转换成 NSNumber 如果将结构体对象添加到集合，仍然需要转换成 NSValue123var array2 = [&quot;zhangsan&quot;, 18]array2.append(100)array2.append(NSValue(CGPoint: CGPoint(x: 10, y: 10))) 最后一个元素后面允许有个逗号 创建空数组 12var arr1 = [Int]()//var arr1 = [] 错误 给数组赋空值 1arr1 = [] 判断是否是空数组：isEmpty 不可以用下标访问的形式为数组添加新项 遍历数组可以使用元组返回索引和元素 1for (index, value) in arr.enumerated() &#123;&#125; 必须是相同类型的数组才能够合并 集合 存储在集合中的数据必须是可哈希化的。可哈希化必须满足三个条件： a == a(自反性) a == b意味着b == a(对称性) a == b &amp;&amp; b == c意味着a == c(传递性) 创建空集合 1var set1 = Set&lt;String&gt;() 字典 updateValue(_:forKey:):设置或更新值，但是返回更新值之前的原值 1let oldValue = dic.updateValue(&quot;lisi&quot;, forKey: &quot;name&quot;) dic[&quot;akey&quot;] = nil:移除键值对 dic.kets,dic.values 1let keysArr = [String](dic.keys) 遍历字典时候需要明确指明数组中的数据类型for dict in dictArray as! [[String:String]]{} 控制流For-In 循环 index 可直接使用，无序声明，不需要的时候可用_忽略 省略下标 _ 能够匹配任意类型 _ 表示忽略对应位置的值1for index in 1...5 &#123;&#125; while repeat-whileswitch switch支持任意类型的数据比较 switch不会隐式贯穿，匹配到后会退出switch语句，所以不用在每个子句结尾写break 每一个 case 分支都必须包含至少一条语句,没有可用break 必须有default语句,要保证处理所有可能的情况，不然编译器直接报错 每一个 case 中定义的变量仅在当前 case 中有效 复合匹配，可以用逗号隔开匹配多个值 区间匹配 元组匹配 值匹配 where添加额外条件 控制转移语句 continue break可用于switch语句或循环体中 fallthrough：贯穿到下一个case中的代码 return throw guard:提前退出，后面必须有一个else语句，else中必须包含控制转移语句 检测API可用性*是必须的，用于指定在所有其它平台中，如果版本号高于你的设备指定的最低版本，if语句的代码块将会运行。12345if #available(iOS 10, macOS 10.12, *) &#123;// 在 iOS 使用 iOS 10 的 API, 在 macOS 使用 macOS 10.12 的 API&#125; else &#123;// 使用先前版本的 iOS 和 macOS 的 API&#125; 函数函数定义与调用12345func hello(name:String) -&gt; String&#123; let str = &quot;Hello,&quot;+name+&quot;!&quot;; return str;&#125;hello(name:&quot;Anna&quot;); 指定参数标签1func someFunction(argumentLabel parameterName: Int) &#123;&#125; 忽略参数标签如果一个参数有一个标签，那么在调用的额是很好必须使用标签来标记这个参数，如果不希望为某个参数添加标签，可以使用_来代替一个明确的参数标签。1234func hello(name:String) -&gt; String&#123;&#125;//调用 hello(name:&quot;Anna&quot;);func hello(_ name:String) -&gt; String&#123;&#125;//调用 hello(&quot;Anna&quot;); 默认参数值1234func someFunction(parameterWithoutDefault: Int, parameterWithDefault: Int = 12) &#123;// 如果你在调用时候不传第二个参数，parameterWithDefault 会值为 12 传入到函数体中。&#125;someFunction(parameterWithoutDefault: 4) // parameterWithDefault = 12 可变参数1func getMiddle(_ numbers: Double...) -&gt; Double&#123;&#125; 输入输出参数 函数参数默认是常量。试图在函数体中更改参数值将会导致编译错误 输入输出参数：可以在函数中修改的参数，并且这些修改在参数调用的时候仍然存在只能传递变量给输入输出参数，不能传入常量或者字面量，并且在传入的时候在参数名前添加&amp;。12345678func swapTwoInts(_ a: inout Int, _ b: inout Int) &#123;let temporaryA = aa = bb = temporaryA&#125;var someInt = 3var anotherInt = 107swapTwoInts(&amp;someInt, &amp;anotherInt) 函数类型 可作为参数类型或返回值类型 闭包闭包的三种形式： 全局函数是一个有名字但不会捕获任何值的闭包 嵌套函数是一个有名字并可以捕获其封闭函数域内值的闭包 闭包表达式是一个利用轻量级语法所写的可以捕获其上下文中变量或常量值的匿名闭包闭包表达式123&#123; (parameters) -&gt; returnType instatements&#125; 排序闭包：1reversedNames = names.sorted(by: &#123; (s1: String, s2: String) -&gt; Bool in return s1 &gt; s2 &#125; ) 排序闭包函数类型需为(String, String) -&gt; Bool 所有的参数和返回值类型都可以被正确推断，则返回箭头（-&gt;）和围绕在参数周围的括号也可以被省略1reversedNames = names.sorted(by: &#123; s1, s2 in return s1 &gt; s2 &#125; ) 单表达式闭包隐式返回,可以省略 return 关键字，把语句的值作为结果返回 1reversedNames = names.sorted(by: &#123; s1, s2 in s1 &gt; s2 &#125; ) 可以通过参数位置引用参数，通过 $0，$1来顺序调用闭包的参数 1reversedNames = names.sorted(by: &#123; $0 &gt; $1 &#125; ) 运算符方法 1reversedNames = names.sorted(by: &gt;) 尾随闭包 当一个闭包作为最后一个参数传给函数的时候，闭包可以直接跟在括号后面，不用写出参数标签 如果闭包是函数的唯一参数，则当使用尾随闭包时，可以把()省略掉1reversedNames = names.sorted &#123; $0 &gt; $1 &#125; 值捕获 闭包可以在其被定义的上下文中捕获常量或变量。即使定义这些常量和变量的原作用域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。 Swift 中，可以捕获值的闭包的最简单形式是嵌套函数 如果一个值不会被闭包改变，或者在闭包创建后不会改变，Swift 可能会改为捕获并保存一份对值的拷贝。 如果你将闭包赋值给一个类实例的属性，并且该闭包通过访问该实例或其成员而捕获了该实例，你将在闭包和该实例间创建一个循环强引用。Swift 使用捕获列表来打破这种循环强引用 函数和闭包都是引用类型逃逸闭包 @escaping 逃逸闭包：当一个闭包作为参数传到一个函数中，但是这个闭包在函数返回之后才被执行 如何逃逸：将闭包保存在一个函数外部定义的变量中，因为闭包需要在函数返回之后被调用 将一个闭包标记为 @escaping 意味着必须在闭包中显式地引用 self，非逃逸闭包可以隐式引用 self 自动闭包 @ autoclosure 自动闭包让你能够延迟求值，因为直到你调用这个闭包，代码段才会被执行 枚举枚举语法12345678enum CompassPoint &#123; case north case south case east case west&#125;var directionToHead = CompassPoint.west//var directionToHead = .west 使用 Switch 语句匹配枚举值原始值 rawValue当使用整数作为原始值时，如果第一个枚举成员没有设置原始值，其原始值将为0,隐式赋值的值依次递增1 类和结构体类和结构体对比相同点： 定义属性用于存储值 定义方法用于提供功能 定义下标操作使得可以通过下标语法来访问实例所包含的值 定义构造器用于生成初始化值 通过扩展以增加默认实现的功能 实现协议以提供某种标准功能类的不同点： 继承允许一个类继承另一个类的特征 类型转换允许在运行时检查和解释一个类实例的类型 析构器允许一个类实例释放任何其所被分配的资源 引用计数允许对一个类的多次引用 定义 123456class SomeClass &#123;// 在这里定义类&#125;struct SomeStructure &#123;// 在这里定义结构体&#125; 结构体类型的成员逐一构造器，类实例没有 结构体和枚举是值类型 值类型：被赋予给一个变量、常量或者被传递给一个函数的时候，其值会被拷贝。在 Swift 中，Integer、floating-point、Boolean、string、array、dictionary 都是值类型，并且在底层都是以结构体的形式所实现。结构体和枚举类型都是值类型。这意味着它们的实例，以及实例中所包含的任何值类型属性，在代码中传递的时候都会被复制。两者相互独立，是不同的。 类是引用类型 引用类型在被赋予到一个变量、常量或者被传递到一个函数时，其值不会被拷贝。因此，引用的是已存在的实例本身而不是其拷贝。实际是同一个。 恒等运算符===/!==：判定两个常量或者变量是否引用同一个类实例 类和结构体的选择大部分使用类，以下情形考虑构建结构体： 目的是用来封装少量相关简单数据值。 实例在被赋值或传递时，封装的数据将会被拷贝而不是被引用。 储存的值类型属性，也应该被拷贝，而不是被引用。 不需要去继承另一个既有类型的属性或者行为。 属性存储属性 定义：存储在特定类或结构体实例里的一个常量或变量 常量结构体的存储属性：如果创建了一个结构体的实例并将其赋值给一个常量，则无法修改该实例的任何属性，即使有属性被声明为变量也不行(由于结构体（struct）属于值类型。当值类型的实例被声明为常量的时候，它的所有属性也就成了常量；属于引用类型的类（class）则不一样。把一个引用类型的实例赋给一个常量后，仍然可以修改该实例的变量属性。) 延迟存储属性定义：在第一次被访问的时候创建 必须将延迟存储属性声明成变量（使用 var 关键字），而常量属性在构造过程完成之前必须要有初始值，因此无法声明成延迟属性 计算属性 定义：计算属性不直接存储值，而是提供一个 getter 和一个可选的 setter，来间接获取和设置其他属性或变量的值。 计算属性可以用于类、结构体和枚举，存储属性只能用于类和结构体。 新值的参数名默认为newValue 必须使用var定义计算属性，包括只读计算属性 只读计算属性的声明可以去掉get关键字和花括号，直接return 属性观察器 属性被设置值的时候会调用属性观察器（即使新值与当前值相同） 可添加观察器的情况： 定义的存储属性（除延迟存储属性之外） 从父类继承的存储属性或计算属性（通过重写属性的方式） willSet：传入新属性值，默认为newValue，常量参数 didSet：传入旧属性值，默认为oldValue 继承： 父类属性在子类的构造器中赋值，会先调用父类观察器，再调用子类观察器。 在父类初始化方法调用之前，子类给属性赋值时，不会调用观察器方法。 全局变量和局部变量 都属于存储型变量，跟存储属性类似。 都可以定义计算型变量和为存储型变量定义观察器，与计算属性类似。 全局变量或常量都是延迟计算的嗯，与延迟存储属性相似，不需要声明lazy。 局部变量或常量从不延迟计算。 类型属性 存储型类型属性可以是变量或常量，计算型类型属性跟实例的计算型属性一样只能定义成变量属性。 在为类定义计算型类型属性时，可以改用关键字 class 来支持子类对父类的实现进行重写。 方法 类、结构体、枚举都可以定义实例方法，也可以定义类型方法。 self 在一个方法中使用一个已知的属性或者方法名称，可省略self。 实例方法的某个参数名称与实例的某个属性名称相同的时候，参数名称享有优先权，可以使用self属性来区分参数名称和属性名称。 mutating 不能在结构体类型的常量上调用可变方法，因为其属性不能被改变，即使属性是变量属性 赋给隐含属性self一个全新的实例 类型方法：类型方法的方法体中，self指向这个类型本身，而不是类型的某个实例 下标12345678subscript(index: Int) -&gt; Int &#123; get &#123; // 返回一个适当的 Int 类型的值 &#125; set(newValue) &#123; // 执行适当的赋值操作 &#125;&#125; 可设定为读写或只读 newValue的类型和下标的返回类型相同，默认newValue 继承基类 如果你不为你定义的类指定一个超类的话，这个类就自动成为基类。 重写override 可以重写继承来的实例方法、类方法、实例属性、类型属性，自定义getter和setter或添加属性观察器 重写属性的getter或setter 可以为任意继承来的属性（存储属性或计算属性）自定义getter或setter 可以将继承来的只读属性重写为读写属性，但是不能将继承来的读写属性重写为只读属性。 如果在重写属性中提供了 setter，那么一定要提供 getter，如果不修改可以调用super方法 重写属性观察器 不可以为继承来的常量存储属性或只读计算属性添加属性观察器，因为这些属性的值是不可以修改的 不可以同时重写setter和属性观察器，因为在setter中就可以观察到任何值的变化 防止重写 final final var,final func,final class fun,final subscript final class 声明的类不能被继承 构造过程 没有返回值 用于类、结构体或枚举123init() &#123;// 在此处执行构造过程&#125; 默认属性值 如果一个属性总是使用相同的初始值，为其设置默认值比每次在构造器中赋值要好。 存储属性的初始赋值 需要为存储属性在定义时设置默认值或者在构造器中赋值，不会触发属性观察器。 可以使用下划线(_)来显式描述它的外部名 可以在构造过程中的任意时间点给常量属性指定一个值 如果结构体或类的所有属性都有默认值，同时没有自定义的构造器，swift会自动提供默认构造器 结构体自动获得一个逐一成员构造器 类的继承和构造过程 类里面的所有存储型属性——包括所有继承自父类的属性——都必须在构造过程中设置初始值，可以通过指定构造器或便利构造器实现。指定构造器 每一个类都必须拥有至少一个指定构造器123init(parameters) &#123;statements&#125; 便利构造器 便利构造器可以调用同一个类中的指定构造器，并为其参数提供默认值。123convenience init(parameters) &#123;statements&#125; 类的构造器代理规则 指定构造器必须调用其直接父类的指定构造器 便利构造器必须调用其同类定义的其他构造器 便利构造器必须最终导致一个指定构造器被调用 指定构造器向上代理，便利构造器横向代理 两段式构造过程 安全检查1指定构造器必须保证它所在类引入的所有属性都必须先初始化完成，之后才能将其它构造任务向上代理给父类中的构造器。 安全检查2指定构造器必须先向上代理调用父类构造器，然后再为继承的属性设置新值。 安全检查3便利构造器必须先代理调用同一类中的其它构造器，然后再为任意属性赋新值。 安全检查4构造器在第一阶段构造完成之前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用self作为一个值。 构造器的继承和重写可失败构造器必要构造器通过闭包或函数设置属性的默认值 析构过程123deinit &#123;// 执行析构过程&#125; 自动引用计数 引用计数仅仅应用于类的实例。结构体和枚举类型是值类型。 类实例之间的循环强引用解决实例之间的循环强引用:弱引用（weak reference）和无主引用（unowned reference） 弱引用 weak当其他的实例有更短的生命周期时，使用弱引用(当其他实例析构在先) 当 ARC 设置弱引用为nil时，属性观察不会被触发无主引用 unowned当其他实例有相同的或者更长生命周期时，请使用无主引用 使用无主引用，必须确保引用始终指向一个未销毁的实例闭包引起的循环强引用解决闭包引起的循环强引用:闭包捕获列表1234lazy var someClosure: (Int, String) -&gt; String = &#123;[unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -&gt; String in// 这里是闭包的函数体&#125; 可选链 可以应用于任意类型，并且能检查调用是否成功。 使用可选链式调用代替强制展开为可选链式调用定义模型类通过可选链式调用访问属性通过可选链式调用调用方法通过可选链式调用访问下标连接多层可选链式调用在方法的可选返回值上进行可选链式调用 处理变量的可选值时，可以在操作之前加?，如果？之前的值是nil,?后面的操作会被忽略，整个表达式返回nil，否则运行?后面的操作，这两种情况，整个表达式的值也是可选值 错误处理处理错误的四种方式： 把函数抛出的错误传递给调用此函数的代码 do-catch语句 将错误作为可选类型处理 断言此错误根本不会发生 throw：抛出错误 try(try?,try!)：识别错误 do-catch：处理错误 throwing函数 throws写在函数声明的参数列表后,-&gt;前。 throwing函数可在其内部抛出错误，将错误传递到函数被调用时的作用域，非throwing函数内部抛出的错误只能在函数内部处理。 将错误转换成可选值 try?12345678let y = try? someThrowingFunction()等价于let y: Int?do &#123; y = try someThrowingFunction()&#125; catch &#123; y = nil&#125; 禁用错误传递 try!会把调用包装在一个不会有错误抛出的运行时断言中，如果真的抛出，则会发生运行时错误。 指定清理操作 defer语句在即将离开当前代码块时（throw,return,break等）执行一系列语句。将代码的执行延迟到当前作用域退出之前，延时执行的操作会按照被指定时的顺序的相反顺序执行，即第一条defer语句中的代码会在第二条defer语句中的代码被执行之后才执行，以此类推。 类型转换检查类型 is 用类型检查操作符（is）来检查一个实例是否属于特定子类型。向下转型 as 某类型的一个常量或变量可能在幕后实际上属于一个子类，用as向下转到它的子类型。 转换没有真的改变实例或它的值 当不确定向下转型是否成功，使用as?，当确定一定会成功，使用as! Any 和 AnyObject 的类型转换 Any 可以表示任何类型，包括函数类型。 AnyObject 可以表示任何类型的实例。 Any类型可以表示所有类型的值，包括可选类型。Swift 会在你用Any类型来表示一个可选值的时候，给你一个警告。如果你确实想使用Any类型来承载可选值，你可以使用as操作符显式转换为Any。 嵌套类型 类、枚举、结构体之间可相互嵌套 扩展 Extensions 与OC中的分类类似，但是swift中的扩展没有名字 可用于已有的类、结构体、枚举或协议 可以为一个类添加新功能，但是不能重写已有的功能 可以实现的功能： 添加计算型属性和计算型类型属性 定义实例方法和类型方法 提供新的构造器 定义下标 定义和使用新的嵌套类型 使一个已有类型符合某个协议扩展语法extension SomeType {// 为 SomeType 添加的新功能写到这里} 通过为一个已有类型添加新功能，则新功能对该类型的所有实例都有效，即使它们实在扩展定义之前创建的 计算型属性 扩展可以添加新的计算属性，但是不可以添加存储型属性，也不可以为已有属性添加属性观察器。构造器 扩展可以为类添加新的便利构造器，不可以添加新的指定构造器或析构器。指定构造器和析构器必须由原始类提供。方法通过扩展添加的实例方法可以修改该实例本身，结构体和枚举类型中修改self或器属性的方法必须将该实例方法标注为mutating 协议类、枚举、结构体都可以实现协议 协议语法定义协议：123protocol SomeProtocol &#123;// 这里是协议的定义部分&#125; 遵循协议：123struct SomeStructure: FirstProtocol, AnotherProtocol &#123;// 这里是结构体的定义部分&#125; 属性要求 协议可以要求遵循协议的类型提供的实例属性或类型属性的名称和类型，还可指定读写性。 用var声明变量属性，用{set get}声明属性是可读可写的。 方法要求 方法不需要大括号和方法体 不支持为协议中的方法的参数提供默认值Mutating 方法要求 实现协议中的mutating方法时，若是类类型，则不用写mutating，对于结构体和枚举必须写。 构造器要求 必须为构造器实现标上required修饰符，可以确保所有子类也必须提供此构造器实现。 12345class SomeClass: SomeProtocol &#123;required init(someParameter: Int) &#123;// 这里是构造器的实现部分&#125;&#125; 如果一个子类重写了父类的指定构造器，并且该构造器满足了某个协议的要求，则构造器的实现需要标上mutating和override。 1234567891011121314151617protocol SomeProtocol &#123;init()&#125;class SomeSuperClass &#123;init() &#123;// 这里是构造器的实现部分&#125;&#125;class SomeSubClass: SomeSuperClass, SomeProtocol &#123;// 因为遵循协议，需要加上 required// 因为继承自父类，需要加上 overriderequired override init() &#123;// 这里是构造器的实现部分&#125;&#125; 可是白构造器要求非可失败构造器（init）可失败构造器（init?）隐式解包可失败构造器（init!） 协议作为类型 作为函数、方法或构造器中的参数类型或返回值类型 作为常量、变量或属性的类型 作为数组、字典或其他容器中的元素类型 委托（代理）模式通过扩展添加协议一致性通过扩展遵循协议协议类型的集合协议的继承类类型专属协议协议合成检查协议一致性可选的协议要求协议扩展 泛型访问控制高级运算符参考资料：(The Swift Programming Language中文版)[http://wiki.jikexueyuan.com/project/swift]","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"待补充","slug":"待补充","permalink":"https://guchunli.github.io/tags/待补充/"},{"name":"Swift3.0","slug":"Swift3-0","permalink":"https://guchunli.github.io/tags/Swift3-0/"}]},{"title":"podspec学习笔记","date":"2017-07-11T05:56:12.000Z","path":"2017/07/11/podspec学习笔记/","text":"1.创建spec文件：1pod spec create spec文件名 2.创建工程(1)将组件代码放到Classes中(2)1pod lib create 组件代码名称 需要重新pod install 3.验证spec文件123pod lib lintpod lib lint --allow-warnings //屏蔽警告pod lib lint --verbose //获取错误的更多提示信息 出现XXX passed validation.信息则成功，否则按照提示进行修改。 4.指定tag12$ git tag -m &quot;podspec description&quot; &quot;0.0.1&quot;$ git push --tags 5.推送到cocoapods官方库1234//注册pod trunk register EMAIL [NAME]//推送pod trunk push spec文件名 6.搜索1pod search spec文件名 7.安装1pod &apos;spec文件名&apos;，&apos;~&gt;0.0.1&apos;","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"podspec","slug":"podspec","permalink":"https://guchunli.github.io/tags/podspec/"}]},{"title":"Babel学习笔记","date":"2017-07-11T02:24:51.000Z","path":"2017/07/11/Babel学习笔记/","text":"安装12npm install babel@5 --save //安装ES5npm install babel-core --save //安装ES6 安装插件：1npm install babel-preset-es2015 创建.babelrc文件：123&#123;&quot;presets&quot;: [&quot;es2015&quot;]&#125; ##待补充","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"https://guchunli.github.io/tags/ReactNative/"},{"name":"Babel","slug":"Babel","permalink":"https://guchunli.github.io/tags/Babel/"}]},{"title":"ES6学习笔记","date":"2017-07-11T01:13:09.000Z","path":"2017/07/11/ES6学习笔记/","text":"letES5只有全局作用域和函数作用域，没有块级作用域，而let声明的变量，只在let命令所在的代码块内有效ES5产生的问题：1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123;a[i] = function () &#123;console.log(i);&#125;;&#125;a[6](); // 10 (1)let解决：1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123;a[i] = function () &#123;console.log(i);&#125;;&#125;a[6](); // 6 (2)闭包解决：1234567891011var a = [];function iteratorFactory(i)&#123; var onclick = function(e)&#123; console.log(i) &#125; return onclick;&#125;for (var i = 0; i &lt; 10; i++)&#123; a[i] = iteratorFactory(i)&#125;a[6](); // 6 const引用第三方库时声明的变量用const修饰可以避免重命名导致错误 class用于定义类：class Person{} extends继承类，constructor内定义的方法和属性是实例对象自己的，外的是所有实力对象共享的 super必须先调用父类super(),才能修改子类的this arrow function12function(i)&#123;return i+1;&#125;(i) =&gt; i+1 解决函数内this指向全局变量问题：(1)使用self指代this(2)bind(this)(3)=&gt; 使用箭头函数 template string` ` 表示起始，${}引用变量，保留所有空格和缩进 destructuring解构按照一定模式从数组和对象中提取值，对变量进行赋值 default默认值ES5: type = type || ‘value’ES6: 参数列表中指定(type = &#39;value&#39;) rest传递多个参数时：ES5: argumentsES6: 参数列表可写成...types JS中的作用域函数作用域Javascript没有块级作用域，而是函数作用域1234567var scope=&quot;global&quot;; function t()&#123; console.log(scope); //undefinedvar scope=&quot;local&quot; console.log(scope); //local&#125; t(); 123456var name=&quot;global&quot;; if(true)&#123; var name=&quot;local&quot;; console.log(name) //local&#125; console.log(name); //local 12345678910function t(flag)&#123; if(flag)&#123; var s=&quot;ifscope&quot;; for(var i=0;i&lt;2;i++) ; &#125; console.log(i); //2console.log(s); //ifscope&#125; t(true); 变量作用域JS中没有用var声明的变量都是全局变量，而且是顶层对象的属性。使用var声明一个变量时，创建的这个属性是不可配置的，也就是说无法通过delete运算符删除。 作用域链1234567891011121314name=&quot;lwy&quot;; function t()&#123; var name=&quot;tlwy&quot;; function s()&#123; var name=&quot;slwy&quot;; console.log(name); &#125; function ss()&#123; console.log(name); &#125; s(); //slwyss(); //tlwy&#125; t(); 1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123;a[i] = function () &#123;console.log(i);&#125;;&#125;a[6](); // 10 with语句with语句主要用来临时扩展作用域链，将语句中的对象添加到当前作用域的头部。with语句结束后，作用域链恢复正常。1234person=&#123;name:&quot;yhb&quot;,age:22,height:175,wife:&#123;name:&quot;lwy&quot;,age:21&#125;&#125;; with(person.wife)&#123; console.log(name); //lwy&#125; this1.全局代码区域：所有函数之外的区域，指全局对象window（node.js中是global）2.function代码区域：某个函数内的代码，但不包括它所嵌套的函数内的代码函数中的this的含义在函数声明时无法确定，要到运行期才能确定，而且与调用函数的方式有关内部函数可以引用外部函数的局部变量，但是不能直接应用外部函数的this(1)直接调用时，在严格模式下，this会被设为undefined，非严格模式下，this会被设为全局对象window(2)作为方法调用时，this指方法所属的对象 ES6基础知识BabelES6转码器 配置文件.babelrc：用于配置转码规则和插件1234&#123;&quot;presets&quot;: [&quot;latest&quot;,&quot;react&quot;,&quot;stage-2&quot;],&quot;plugins&quot;: []&#125; 123456# 最新转码规则$ npm install --save-dev babel-preset-latest# react 转码规则$ npm install --save-dev babel-preset-react# 不同阶段语法提案的转码规则（0-3)$ npm install --save-dev babel-preset-stage-2 命令行转码babel-cli1$ npm install --global babel-cli 将babel-cli安装在项目中1$ npm install --save-dev babel-cli 改写package.json123456789&#123;// ...&quot;devDependencies&quot;: &#123;&quot;babel-cli&quot;: &quot;^6.0.0&quot;&#125;,&quot;scripts&quot;: &#123;&quot;build&quot;: &quot;babel src -d lib&quot;&#125;,&#125; 执行命令：1$ npm run build 变量###let let：类似于var,声明的变量只在let命令所在的代码块中有效 for语句设置循环变量部分与循环体是两个作用域 不存在变量提升：var声明的变量在声明前使用已经存在，但没有值；let声明的变量在声明前是不存在的 暂时性死区：let声明的变量在块级作用域内被绑定，不受外部影响 let在同一作用域中不可重复声明变量 块级作用域{} var声明的变量存在的问题：1.变量升级 2.for语句中的循环变量为全局变量 块级作用域中可以声明函数，在浏览器中行为类似于var(会提升)，其他环境类似于let do使块级作用域变为表达式，可以用变量接收do{}的返回值 const 声明只读常量，只声明不赋值会报错 同let相同的块级作用域内有效，不提升，窜仔暂时性死区，不可重复声明 ES6声明变量的六中方法var,function,let,const,import,class 顶层对象浏览器环境，顶层对象指window，Node指glocal。var,function声明的全局变量是顶层对象属性，let,const,class声明的不属于。 globalsystem.global可以在所有环境拿到global。 解构赋值1.数组的解构赋值 模式匹配，解构不成功，变量值为undefined； 设置默认值，当成员等于undefined时默认值生效 2.对象的解构赋值 允许取别名 3.字符串的解构赋值 可对length进行解构赋值 4.使用 交换变量值 函数返回多个值 提取json数据 for…of遍历Map结构 加载模块 字符串 includes(),startsWith(\u0010),endsWith(),repeat(),padStart().padEnd() 模板字符串：\\’\\’ &amp;{变量/表达式、函数} 函数数组对象MapPromiseIterator for…ofayncClassModule待补充 参考文章：(30分钟掌握ES6/ES2015核心内容)[http://www.jianshu.com/p/ebfeb687eb70]ECMAScript 6 入门","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"https://guchunli.github.io/tags/ReactNative/"},{"name":"ES6","slug":"ES6","permalink":"https://guchunli.github.io/tags/ES6/"}]},{"title":"ReactNative基础知识学习笔记","date":"2017-07-06T03:30:28.000Z","path":"2017/07/06/ReactNative基础知识学习笔记/","text":"JSX Browser.js:作用是将 JSX 语法转为 JavaScript 语法 JSX 中不能使用 if else 语句，但可以使用 conditional (三元运算) 表达式来替代 注释需要写在花括号中:{/*注释...*/} JSX 允许在模板中插入数组，数组会自动展开所有成员 要渲染 HTML 标签，只需在 JSX 里使用小写字母的标签名,要渲染 React 组件，只需创建一个大写字母开头的本地变量 class-&gt;className for-&gt;htmlFor 使用{}的情况：表达式，变量，对象，字典 {{}}:第一重大括号表示这是 JavaScript 语法，第二重大括号表示样式对象 1&lt;View style=&#123;&#123;flex:1&#125;&#125;&gt;&lt;/View&gt; 使用()的情况：返回组件123456render()&#123;return (&lt;View&gt;&lt;/View&gt;)&#125; CSSposition absolute:绝对定位，相对父组件 使用：当想把一个已经设置了宽度的控件快速的放在左下角，右下角的时候 relative: 相对定位，相对自己的原始位置 使用：当想相对自己做出一些改变的时候，采用相对定位,比如相对自己，往下移动一点 FlexBox1.flexDirection:row|row-reverse|column|column-reverse2.flexWrap:wrap|no-wrap3.justifyContent:flex-start|flex-end|center|space-between|space-around4.alignItems:flex-start|flex-end|center|stretch5.alignSelf:auto|flex-start|flex-end|center|stretch6.flex:子控件在主轴中占据几等分 props,state props:在父组件中指定，而且一经指定，在整个组件的生命周期中都不再改变。this.props.children表示组件的所有子节点 state:constructor中声明(ES6)，在setState中修改数据 this.props 表示那些一旦定义，就不再改变的特性，而 this.state 是会随着用户互动而产生变化的特性。通过state 来更新和修改数据，而子组件只能通过 props 来传递数据定义state: 123this.state = &#123;num:1,&#125;; 修改state:123this.setState(&#123;num : number&#125;) 或者123this.setState(&#123;name: e.target.value&#125;, function()&#123;console.log(this.state.name);&#125;) 状态更新可能是异步的 状态更新合并 父子组件传值1.父传子(1)props:this.props.name(2)ref:this.refs.son.receiveMsg(“msg”)2.子传父(1)方法回调父组件：定义一个处理接收到值的方法，把这个方法传递给子组件，并且绑定this子组件：通过this.props拿到这个方法调用3.无关联组件间传值(1)通知:组件1传值给组件2组件1：123&lt;Text onPress=&#123;()=&gt;&#123;DeviceEventEmitter.emit(&apos;NotificationName&apos;,123);&#125;&#125;&gt;&lt;/Text&gt; 组件2：12345this.lister = DeviceEventEmitter.addListener(&apos;NotificationName&apos;,(value)=&gt;&#123;this.setState(&#123;value:value&#125;);&#125;) 组件生命周期实例化0.defaultProps:给props设置默认值1.constructor:初始化state（只调用一次）2.componentWillMount:即将加载组件调用，render前（只调用一次）3.render:渲染组件4.componentDidMount:组件加载完成调用，render后（只调用一次）运行5.componentWillReceiveProps:props改变调用6.shouldComponentUpdate:props/state改变调用，可控制是否刷新界面7.componentWillUpdate:组件即将更新调用（调用this.setState会循环）8.render9.componentDidUpdate:组件更新完成（调用this.setState会循环）销毁10.componentWillUnmount:组件即将销毁，可移除观察者，清空数据等 propTypes必须要用static修饰，否则无效static：用来定义类方法或者类属性，定义类的方法和属性，生成的对象就自动有这样的属性了。1.类型检查：当传入错误的属性值，会报警告，但是不会报错1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253propTypes: &#123;// 可以声明 prop 为指定的 JS 基本数据类型，默认情况，这些数据是可选的optionalArray: React.PropTypes.array,optionalBool: React.PropTypes.bool,optionalFunc: React.PropTypes.func,optionalNumber: React.PropTypes.number,optionalObject: React.PropTypes.object,optionalString: React.PropTypes.string,// 可以被渲染的对象 numbers, strings, elements 或 arrayoptionalNode: React.PropTypes.node,// React 元素optionalElement: React.PropTypes.element,// 用 JS 的 instanceof 操作符声明 prop 为类的实例。optionalMessage: React.PropTypes.instanceOf(Message),// 用 enum 来限制 prop 只接受指定的值。optionalEnum: React.PropTypes.oneOf([&apos;News&apos;, &apos;Photos&apos;]),// 可以是多个对象类型中的一个optionalUnion: React.PropTypes.oneOfType([React.PropTypes.string,React.PropTypes.number,React.PropTypes.instanceOf(Message)]),// 指定类型组成的数组optionalArrayOf: React.PropTypes.arrayOf(React.PropTypes.number),// 指定类型的属性构成的对象optionalObjectOf: React.PropTypes.objectOf(React.PropTypes.number),// 特定 shape 参数的对象optionalObjectWithShape: React.PropTypes.shape(&#123;color: React.PropTypes.string,fontSize: React.PropTypes.number&#125;),// 任意类型加上 `isRequired` 来使 prop 不可空。requiredFunc: React.PropTypes.func.isRequired,// 不可空的任意类型requiredAny: React.PropTypes.any.isRequired,// 自定义验证器。如果验证失败需要返回一个 Error 对象。不要直接使用 `console.warn` 或抛异常，因为这样 `oneOfType` 会失效。customProp: function(props, propName, componentName) &#123;if (!/matchme/.test(props[propName])) &#123;return new Error(&apos;Validation failed!&apos;);&#125;&#125;&#125;, 12345// 定义属性static propTypes = &#123;name:PropTypes.string,age:PropTypes.number&#125; 2.设置初始化值1234static defaultProps = &#123;name:&apos;xiaoming&apos;,age:20&#125; 基本组件1.View2.TouchableOpacity默认点击区域是所有子控件的区域,因为默认一个组件的尺寸由子控件决定 activeOpacity:0-1 1-不透明 点击事件：onPress|onLongPress|onPressIn|onPressOut disabled:true|false3.Text numberOfLines selectable:true|false 是否允许长按选择文本 suppressHighlighting:true|false 是否允许按下时有灰色阴影 onPress:文字点击事件 onPress={()=&gt;{}} color/fontSize/fontWeight/lineHeight/textAlign4.Button 不可设置样式，一般用text自定义 color/disabled/onPress/title5.TextInput 默认无边框 autoFocus/blurOnSubmit/editable/maxLength/multiline/placeholder keyboardType/returnKeyType/clearButtonMode clearTextOnFocus/enablesReturnKeyAutomatically clear() 事件：onBlur/onFocus/onChange/onChangeText/onEndEditing/onKeyPress/onSubmitEditing6.ImageiOS中的2x,3x图片同样适用，如果存在a@2x.png与a@3x.png，写a.png即可。同时兼容iOS和安卓平台的图片，如果存在a.ios.png与a.android.png，同样写a.png即可。 source/defaultSource本地图片放在与index.ios.js同目录下的Img文件夹 1234&lt;Image source=&#123;require(&apos;./Img/chaolan.jpeg&apos;)&#125; style=&#123;styles.imageSytle&#125;/&gt;//Xcode的asset类目中，或是放置在Android的drawable目录&lt;Image source=&#123;&#123;uri:&apos;wukong&apos;&#125;&#125; style=&#123;styles.imageSytle&#125;/&gt;&lt;Image source=&#123;&#123;uri:&apos;http://img01.youxiaoshuo.com/portal/201703/21/083647y43dl1j14s8s3g99.jpg&apos;, cache: &apos;only-if-cached&apos;&#125;&#125; style=&#123;styles.imageSytle&#125;/&gt; 通过URI加载网络图片，必须设置图片尺寸，否则不显示 通过URI加载网络图片，iOS端可以添加缓存策略(default/reload/force-cache/only-if-cached) blurRadius resizeMode:cover|contain|stretch|repeat|center 事件:onLoad/onLoadStart/onLoadEnd/onProgress/onError7.ScrollView horizontal/showsHorizontalScrollIndicator/showsVerticalScrollIndicator/alwaysBounceHorizontal/alwaysBounceVertical automaticallyAdjustContentInsets bounces/bouncesZoom/contentInset scrollEventThrottle/stickyHeaderIndices(与horizontal={true}冲突) 事件：onScrollBeginDrag/End/onMomentumScrollBegin/End/onScrollAnimationEnd/onScroll/scrollEventThrottle 自定义类1.自定义类1export default class Person&#123;&#125; 2.继承extends1class HomeView extends Component 3.使用：var p = new Person(); ListView1.创建数据源，给数据源设置数据使用state保存数据源 不分组使用：cloneWithRows 分组使用：cloneWithRowsAndSections1234var dataSource = new ListView.DataSource(&#123;rowHasChanged: (r1, r2) =&gt; r1 !== r2&#125;);this.state = &#123;ds: dataSource.cloneWithRows([&apos;row 1&apos;, &apos;row 2&apos;]),&#125;; 12345678var dataSource = new ListView.DataSource(&#123;rowHasChanged:(r1,r2)=&gt;r1 !== r2,sectionHeaderHasChanged:(s1,s2)=&gt;s1 !== s2&#125;);var sectionData = &#123;&#125;;this.state = &#123;ds : dataSource.cloneWithRowsAndSections(sectionData)&#125;; 2.实现数据源方法123456789101112131415161718192021&lt;ListView dataSource=&#123;this.state.ds&#125;renderRow=&#123;this._renderRow.bind(this)&#125;renderSectionHeader=&#123;this._renderSectionHeader.bind(this)&#125;//renderSeparator=&#123;this._renderSeparator.bind(this)&#125;/&gt;_renderRow(rowData, sectionID, rowID, highlightRow) &#123;return (&lt;View&gt;&lt;Text&gt;&#123;rowData&#125;&lt;/Text&gt;&lt;/View&gt;);&#125;//如果是组视图，设置组数据_renderSectionHeader(sectionData, sectionID) &#123;return (&lt;View&gt;&lt;Text&gt;&#123;sectionID&#125;&lt;/Text&gt;&lt;/View&gt;)&#125; 导航Navigator如果找不到Navigator，安装Navigator所在的库：12npm install react-native-deprecated-custom-components --save//yarn add react-native-deprecated-custom-components 项目导入：1import &#123;Navigator&#125; from &apos;react-native-deprecated-custom-components&apos; TabbarTabBarIOS 只可用于iOS平台 badge可设置未读消息数1234567891011121314151617&lt;TabBarIOS style=&#123;&#123;flex:1,alignItems:&apos;flex-end&apos;&#125;&#125;&gt;&lt;TabBarIOS.Item title=&apos;消息&apos;icon=&#123;require(&apos;./Img/home.png&apos;)&#125;badge=&#123;3&#125;onPress=&#123;()=&gt;&#123;this.setState(&#123;selectIndex:0&#125;)&#125;&#125;selected=&#123;0==this.state.selectIndex&#125;&gt;&lt;View&gt;&lt;Text&gt;首页&lt;/Text&gt;&lt;/View&gt;&lt;/TabBarIOS.Item&gt;&lt;/TabBarIOS&gt; TabNavigator 可用于iOS和安卓1.安装1npm install react-native-tab-navigator --save 2.导入1import TabNavigator from &apos;react-native-tab-navigator&apos;; 3.使用 TabBarIOS: icon={require(&#39;./Img/home.png&#39;)} TabNavigator: renderIcon是传入一个函数，这个函数返回一个Image组件,如果是通过url加载，一定要记得设置尺寸，否则不显示1renderIcon=&#123;() =&gt; &lt;Image source=&#123;require(&apos;./Img/indexicon_hone_after@3x.png&apos;)&#125; style=&#123;styles.iconStyle&#125;/&gt;&#125; 12345678910111213141516&lt;TabNavigator&#125;&gt;&lt;TabNavigator.Item title=&apos;消息&apos;renderIcon=&#123;() =&gt; &lt;Image source=&#123;require(&apos;./Img/indexicon_hone_after@3x.png&apos;)&#125; style=&#123;styles.iconStyle&#125;/&gt;&#125;// renderBadge=&#123;3&#125;onPress=&#123;()=&gt;&#123;this.setState(&#123;selectIndex:0&#125;)&#125;&#125;selected=&#123;0==this.state.selectIndex&#125;&gt;&lt;View style=&#123;&#123;flex:1,justifyContent:&apos;center&apos;,alignItems:&apos;center&apos;&#125;&#125;&gt;&lt;Text&gt;首页&lt;/Text&gt;&lt;/View&gt;&lt;/TabNavigator.Item&gt;&lt;/TabNavigator&gt; 主流架构搭建react navigation 网络请求 fetch: 发送请求 then: 回调函数 response: 请求到的json数据 catch: 捕获异常发送GET请求：12345678fetch(&apos;http://192.168.1.143:8080&apos;) // 发送GET请求.then((response)=&gt;response.json()) // 请求成功，把请求数据转换为 JSON.then((json)=&gt;&#123; // 获取JSON数据做事情console.log(json)&#125;).catch((error)=&gt;&#123; // 请求失败或者处理JSON数据失败，调用console.log(error)&#125;) 发送POST请求有三种方式： application/x-www-form-urlencoded: 参数是普通的参数拼接 application/json: 参数是json格式 application/form-data: 文件上传 request模块本地存储 AsyncStorage 异步的 只能存储字符串 把数据保存到沙盒中的Documents中,并生成manifest.json文件 save/read/delete123AsyncStorage.setItem(&apos;object&apos;,JSON.stringify(object),(error)=&gt;&#123;&#125;);AsyncStorage.getItem(&apos;object&apos;,(error,result)=&gt;&#123;&#125;);AsyncStorage.removeItem(&apos;object&apos;,(error)=&gt;&#123;&#125;); 引导页1.第一次进入界面，写个属性，记录下第一次加载。2.每次启动，获取之前是否保存过第一次加载的属性，如果加载过，就显示主页，没加载过，就显示引导页 模块导出 自定义组件：继承自Component，必须使用class定义类 自定义类：可以不使用class定义 自定义组件导出1.ES6/5 ES6:一般使用默认组件，支持import导出 ES5:一般使用非默认组件，支持require导出2.默认组件/非默认组件 默认组件 1234//定义export default class XXX extends Component//外部使用import XXX from &apos;../Custom/XXX&apos; 非默认组件非默认组件：需要加入{} 1234//定义export class XXX extends Component//外部使用import &#123;XXX&#125; from &apos;../Custom/XXX&apos; 自定义类1.没有对象属性的自定义类 定义：class 导出：export default2.有对象属性的自定义类 定义：function 导出：module.exports(也可以export default) 3.class/function class定义类：在类中声明任何属性和方法，都会自动生成对象的属性和方法 1export default class XXX &#123;&#125; function定义类：要想定义属性和方法，属性和方法前面必须添加this 1234function XXX(data) &#123;this.data = data;this.func = function () &#123;&#125;&#125; 4.导出自定义类的两种方式 module.exports 12function XXX(data) &#123;&#125;module.exports = XXX; export default 1export default function XXX(sectionID,rowData) &#123;&#125; 5.外部引用1import XXX from &apos;../Custom/XXX&apos; 自定义类的继承–call方法call方法1.交换方法调用1func1.call(func2); //调用func1 2.交换方法调用者1c1.log.call(c2); //c2调用c1的log方法 3.通过function自定义类没有继承功能，需要通过call方法自己实现本质：交换方法调用者 项目中经常遇到的问题文件导入路径问题（已废弃）@providesModule放到第一行注释1234/*** @providesModule Common*/export default class Common &#123;&#125; 外部引用：1import Common from &apos;Common&apos; 主头文件问题1.创建主头文件123456789import Common from &apos;../Common/GroupListView&apos;...// 这句话的意思：把当前文件作为一个模块导出，模块里面有这些子组件// 以后导入这个模块的时候，就能获取了这个模块里面的东西.module.exports = &#123;GroupListView,...&#125;; 2.使用头文件123import Common from &apos;Common&apos;// 创建行模型var item0 = new Common.GroupListView(); 动画AnimatedAnimated封装了四个可以动画化的组件：View、Text、Image和ScrollView。 配置动画 组合动画parallelsequencestaggerdelay 联动多个动画值 插值：interpolate({inputRange:[0,1],outputRange:[0,100],}) 跟踪动态值:leader,follower,ValueXY 输入事件：Animated.event 使用原生动画驱动：useNativeDriver:true LayoutAnimation12LayoutAnimation.spring();this.setState(&#123;w: this.state.w + 15, h: this.state.h + 15&#125;) 定时器 setTimeout,clearTimeout setInterval,clearInterval setImmediate,clearImmediate requestAnimationFrame,cancelAnimationFrame requestAnimationFrame():用来执行在一段时间内控制视图动画的代码setTimeout/setInterval/setImmediate:稍后执行代码，可能会延迟当前正在进行的动画runAfterInteractions():稍后执行代码，不会延迟当前进行的动画123InteractionManager.runAfterInteractions(() =&gt; &#123;// ...需要长时间同步执行的任务...&#125;); * 注意：在unmount方法中清除定时器 setNativeProps调试iOS模拟器上，cmd+D为摇晃手势启动模拟器：1react-native run-ios --simulator &quot;iPhone 7&quot; Reload:刷新JS文件 Debug JS Remotely：在Chrome中调试JS代码会自动打开http://localhost:8081/debugger-ui，打开开发者工具可以查看console输出，以及打断点调试JS脚本。 Enable Live Reload：自动刷新，实时加载，应用更新时需要刷新当前页面，可以看到明显的全局刷新效果。 Enable Hot Reloading：热加载，基本上看不出刷新的效果，类似于局部刷新。 Start Systrace Show Inspector Show Pert Monitor 必须重新编译应用才能生效： 增加了新的资源，如图片 更改了原生代码 console.error()可触发红屏报错 屏蔽指定警告：ignoreWarnings([‘Warning:’]); 访问控制台日志： 12react-native log-iosreact-native log-android 还可以通过Debug-&gt;Open System Log查看日志 React Developer Tools 12npm install -g react-devtools //安装react-devtools //启动 真机调试(1)退出所有终端打开的页面(2)手机与电脑连到同一无线网下(3)将AppDelegate中jsCodeLocation的URL地址中的localhost改成电脑的IP地址，然后打开Debug JS Remotely(4)解决https问题(5)更新node,npm版本到最新(6)关闭防火墙 自动化测试12345$ cd react-native$ npm test$ npm run flow$ ./scripts/objc-test-ios.sh$ ./scripts/test-manual-e2e.sh 性能只在开发环境时打印日志123456789if (!__DEV__) &#123; global.console = &#123; info: () =&gt; &#123;&#125;, log: () =&gt; &#123;&#125;, warn: () =&gt; &#123;&#125;, debug: () =&gt; &#123;&#125;, error: () =&gt; &#123;&#125;, &#125;;&#125; 发布应用1.edit scheme-&gt;Run-&gt;release release版本会自动禁用开发者菜单，同事讲JS文件和静态图片打包压缩后放到包中2.热更新：pushy 袁峥讲ReactNative-系列React学习资源汇总React Native开发错误警告处理总结（已解决 ！持续更新","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"https://guchunli.github.io/tags/ReactNative/"},{"name":"基础","slug":"基础","permalink":"https://guchunli.github.io/tags/基础/"}]},{"title":"iOS使定时器NSTimer在程序进入后台仍然运行的方法","date":"2017-07-05T08:16:46.000Z","path":"2017/07/05/iOS使定时器NSTimer在程序进入后台仍然运行的方法/","text":"如何使定时器NSTimer在程序进入后台仍然运行1.Info.plist中，Required background modes添加App plays audio or streams audio/video using AirPlay2.- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions中添加以下代码：12345678910NSError *setCategoryErr = nil;NSError *activationErr = nil;[[AVAudioSession sharedInstance]setCategory: AVAudioSessionCategoryPlaybackerror: &amp;setCategoryErr];[[AVAudioSession sharedInstance]setActive: YESerror: &amp;activationErr];self.window.backgroundColor = [UIColor whiteColor];[self.window makeKeyAndVisible]; 3.程序进入后台进行以下操作12345678910111213141516171819202122232425262728- (void)applicationDidEnterBackground:(UIApplication *)application &#123; UIApplication* app = [UIApplication sharedApplication]; __block UIBackgroundTaskIdentifier bgTask; /*注册一个后台任务，告诉系统我们需要向系统借一些事件*/ bgTask = [app beginBackgroundTaskWithExpirationHandler:^&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; if (bgTask != UIBackgroundTaskInvalid) &#123; /*销毁后台任务标识符*/ /*不管有没有完成，结束background_task任务*/ bgTask = UIBackgroundTaskInvalid; &#125; &#125;); &#125;]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; if (bgTask != UIBackgroundTaskInvalid) &#123; /*销毁后台任务标识符*/ /*不管有没有完成，结束background_task任务*/ bgTask = UIBackgroundTaskInvalid; &#125; &#125;); &#125;);&#125; 获取APP进入后台的时间1.AppDelegate 发送通知12345678910111213// APP进入后台- (void)applicationDidEnterBackground:(UIApplication *)application&#123; NSLog(@&quot;APP进入后台&quot;); [[NSNotificationCenter defaultCenter]postNotificationName:UIApplicationDidEnterBackgroundNotification object:nil];&#125;// APP将要从后台返回- (void)applicationWillEnterForeground:(UIApplication *)application&#123; NSLog(@&quot;APP进入前台&quot;); [[NSNotificationCenter defaultCenter]postNotificationName:UIApplicationWillEnterForegroundNotification object:nil];&#125; 2.创建一个管理类：EnterBackgroundManager，添加观察者，接受通知1234567891011121314151617181920212223242526272829303132333435@property(nonatomic,strong) id observer_enterBack;@property(nonatomic,strong) id observer_enterFore;//添加两个观察者- (void)addObserverUsingBlock:(TGHandlerEnterBackgroundBlock)block &#123; __block CFAbsoluteTime enterBackgroundTime; self.observer_enterBack = [[NSNotificationCenter defaultCenter]addObserverForName:UIApplicationDidEnterBackgroundNotification object:nil queue:nil usingBlock:^(NSNotification * _Nonnull note) &#123; if (![note.object isKindOfClass:[UIApplication class]]) &#123; enterBackgroundTime = CFAbsoluteTimeGetCurrent(); &#125; &#125;]; __block CFAbsoluteTime enterForegroundTime; self.observer_enterFore = [[NSNotificationCenter defaultCenter]addObserverForName:UIApplicationWillEnterForegroundNotification object:nil queue:nil usingBlock:^(NSNotification * _Nonnull note) &#123; if (![note.object isKindOfClass:[UIApplication class]]) &#123; enterForegroundTime = CFAbsoluteTimeGetCurrent(); CFAbsoluteTime timeInterval = enterForegroundTime-enterBackgroundTime; NSLog(@&quot;APP在后台持续 time = %lf s&quot;,timeInterval); block? block(note, timeInterval): nil; &#125; &#125;]; NSLog(@&quot;通知中心添加监听者：进入前后台&quot;)&#125;//移除通知-(void)removeNotificationObserver&#123; [[NSNotificationCenter defaultCenter] removeObserver:self.observer_enterBack]; [[NSNotificationCenter defaultCenter] removeObserver:self.observer_enterFore]; self.observer_enterBack = nil; self.observer_enterFore = nil; NSLog(@&quot;通知中心释放监听者：进入前后台&quot;)&#125; 3.获取停留后台时间：123456789- (void)viewDidLoad &#123; [super viewDidLoad]; //监听APP在后台的时间 WS(weakSelf); self.backgroundManager = [[EnterBackgroundManager alloc]init]; [self.backgroundManager addObserverUsingBlock:^(NSNotification * _Nonnull note, NSTimeInterval stayBackgroundTime) &#123; weakSelf.timeStr = weakSelf.timeStr - stayBackgroundTime; &#125;];&#125;","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"NSTimer","slug":"NSTimer","permalink":"https://guchunli.github.io/tags/NSTimer/"},{"name":"后台","slug":"后台","permalink":"https://guchunli.github.io/tags/后台/"}]},{"title":"iOS的UIView动画学习笔记","date":"2017-07-05T07:15:27.000Z","path":"2017/07/05/iOS的UIView动画学习笔记/","text":"1.begin-commit1234567891011[UIView beginAnimations:nil context:nil];[UIView setAnimationDuration:2.0];[UIView setAnimationDelay:.5];[UIView setAnimationRepeatCount:5];//设置代理[UIView setAnimationDelegate:self];//设置动画结束后调用的代理方法[UIView setAnimationDidStopSelector:@selector(animationDidStop:finished:context:)];//动画效果代码view1.alpha = 0;[UIView commitAnimations]; 2.animate1234567[UIView animateWithDuration:2.0 animations:^&#123; view1.alpha = 0;&#125; completion:^(BOOL finished) &#123; if (finished) &#123; view1.alpha = 1; &#125;&#125;]; 3.transition过渡动画，主要用于UIView进入或者离开视图12345[UIView transitionWithView:self.view duration:2.f options:UIViewAnimationOptionTransitionFlipFromLeft animations:^&#123; //动画效果代码&#125; completion:^(BOOL finished) &#123; //动画完成代码&#125;];","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"动画","slug":"动画","permalink":"https://guchunli.github.io/tags/动画/"}]},{"title":"OC与JS交互的几种方法","date":"2017-07-04T03:59:35.000Z","path":"2017/07/04/OC与JS交互的几种方法/","text":"OC与JS交互的几种方法1.JavaScriptCore2.WebViewJavascriptBridge3.WKWebview JavaScriptCore通过JSContext实现OC与JS的交互1.在webViewDidFinishLoad方法中创建JSContext对象,获取该UIWebview的javascript执行环境1234567891011- (void)webViewDidFinishLoad:(UIWebView *)webView &#123; //通过当前webView的键获取到jscontext self.jsContext = [webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;]; //以后JS就可以通过 OCModel 调用OC方法 self.jsContext[@&quot;OCModel&quot;] = self; self.jsContext.exceptionHandler = ^(JSContext *context, JSValue *exceptionValue) &#123; context.exception = exceptionValue; NSLog(@&quot;异常信息：%@&quot;, exceptionValue); &#125;;&#125;; 2.OC调用JS方法并传递一个参数JS方法：123function getImg(path)&#123; //document.getElementById(&quot;test&quot;).src=path;&#125; OC通过evaluateScript调用JS方法：12NSString *alertJS=[NSString stringWithFormat:@&quot;getImg(&apos;%@&apos;)&quot;,@&quot;abc&quot;]; //准备执行的js代码[self.jsContext evaluateScript:alertJS]; 3.JS调用OC方法并传递一个参数OC方法：123- (void)getImg:(NSString *)source&#123; NSLog(@&quot;%@&quot;,source);&#125; JS通过OCModel调用OC方法：123function getGalleryImg()&#123; OCModel.getImg(&apos;gallery&apos;);&#125; 通过request的URL实现交互JS代码:1234567891011&lt;script&gt;//触发该方法，调用OC中webview的`shouldStartLoadWithRequest`方法实现与OC交互function goCamera()&#123; window.location.href=&quot;js-call://camera/cameraCallback&quot;;&#125;//OC回调的JS方法function cameraCallback(data) &#123; //获取到OC传递过来的参数 alert(data);&#125;&lt;/script&gt; OC代码:123456789101112131415161718192021222324- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType&#123; NSString *requestString = [[request URL] absoluteString]; //jS协议头 NSString *protocol = @&quot;js-call://&quot;; //请求的字符串符合协议头 if ([requestString hasPrefix:protocol]) &#123; //从协议头后的位置截取字符串到最后 NSString *requestContent = [requestString substringFromIndex:[protocol length]]; //将/分隔的字符串转换成数组 NSArray *vals = [requestContent componentsSeparatedByString:@&quot;/&quot;]; if ([[vals objectAtIndex:0] isEqualToString:@&quot;camera&quot;]) &#123; //获取到回调方法：cameraCallback callback = [vals objectAtIndex:1]; //OC回调JS方法，并传递一个参数 [_webView stringByEvaluatingJavaScriptFromString:[NSString stringWithFormat:@&quot;%@(&apos;%@&apos;);&quot;, callback, @&quot;abc&quot;]]; &#125; else &#123; [webView stringByEvaluatingJavaScriptFromString:@&quot;alert(&apos;未定义&apos;);&quot;]; &#125; return NO; &#125; return YES;&#125; WebViewJavascriptBridge1.通过cocoapods或手动导入WebViewJavascriptBridge框架2.OC端:创建webview,与bridge对象建立联系123456// 开启日志[WebViewJavascriptBridge enableLogging];// 指定webview，建立JS与OjbC的沟通桥梁self.bridge = [WebViewJavascriptBridge bridgeForWebView:webView];[self.bridge setWebViewDelegate:self]; 3.JS端：创建setupWebViewJavascriptBridge1234567891011121314151617181920212223242526272829303132333435&lt;script&gt;window.onerror = function(err) &#123;log(&apos;window.onerror: &apos; + err)&#125;/*这段代码是固定的，必须要放到js中*/function setupWebViewJavascriptBridge(callback) &#123;if (window.WebViewJavascriptBridge) &#123; return callback(WebViewJavascriptBridge); &#125;if (window.WVJBCallbacks) &#123; return window.WVJBCallbacks.push(callback); &#125;window.WVJBCallbacks = [callback];var WVJBIframe = document.createElement(&apos;iframe&apos;);WVJBIframe.style.display = &apos;none&apos;;WVJBIframe.src = &apos;wvjbscheme://__BRIDGE_LOADED__&apos;;document.documentElement.appendChild(WVJBIframe);setTimeout(function() &#123; document.documentElement.removeChild(WVJBIframe) &#125;, 0)&#125;/*与OC交互的所有JS方法都要放在此处注册，才能调用通过JS调用OC方法或者让OC调用这里的JS方法*/setupWebViewJavascriptBridge(function(bridge) &#123; //在这注册OC调用JS的方法，可以接收OC传过来的参数 data ，还可以通过 responseCallback 回调OC /* bridge.registerHandler(&apos;JSFunction&apos;, function(data, responseCallback) &#123; responseCallback(&#123;&apos;&apos;: &apos;&apos;&#125;) &#125; */ //这里可以调用OC方法，OC端在处理完成后，反馈给JS，这样写是在载入页面完成时就先调用 document.getElementById(&apos;btn&apos;).onclick = function (e) &#123; bridge.callHandler(&apos;OCFunction&apos;, &#123;&apos;js&apos;: &apos;abc&apos;&#125;, function(response) &#123; alert(response) &#125;)&#125;&lt;/script&gt; 4.JS调用OC方法bridge通过registerHandler注册提供给JS调用的方法OC端通过responseCallback回调JS，JS就可以得到所需要的数据OC方法：1234567[self.bridge registerHandler:@&quot;JSCallOC&quot; handler:^(id data, WVJBResponseCallback responseCallback) &#123; NSLog(@&quot;%@&quot;, data); //js-oc,abc if (responseCallback) &#123; // 回调给JS responseCallback(@&#123;@&quot;oc-js&quot;: @&quot;123&quot;&#125;); &#125;&#125;]; JS调用OC方法：123bridge.callHandler(&apos;JSCallOC&apos;, &#123;&apos;js-oc&apos;: &apos;abc&apos;&#125;, function(responseData) &#123; alert(responseData) //oc-js,123&#125;) 5.OC调用JS方法JS方法：12345/*JS给ObjC提供公开的API，在ObjC端可以手动调用JS的这个API。接收ObjC传过来的参数，且可以回调ObjC*/bridge.registerHandler(&apos;OCCallJS&apos;, function(data, responseCallback) &#123; alert(data) //oc-js,123 responseCallback(&#123;&apos;a&apos;: &apos;1&apos;, &apos;b&apos;: &apos;2&apos;&#125;)&#125;) OC调用JS方法：123[self.bridge callHandler:@&quot;OCCallJS&quot; data:@&#123;@&quot;oc-js&quot;: @&quot;123&quot;&#125; responseCallback:^(id responseData) &#123; NSLog(@&quot;%@&quot;, responseData); //&apos;a&apos;: &apos;1&apos;, &apos;b&apos;: &apos;2&apos;&#125;]; WKWebview1.添加JS交互方法12345678//添加JS交互方法-(void)setupJSmethod&#123;// 注入JS对象名称AppModel，当JS通过AppModel来调用时，// 我们可以在WKScriptMessageHandler代理中接收到[self.userContentController addScriptMessageHandler:self name:@&quot;AppModel&quot;];[self.userContentController addScriptMessageHandler:self name:@&quot;userLogin&quot;];&#125; 2.创建WKWebview1234567891011121314151617181920212223WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init];/*NSString *js = @&quot;I am JS Code&quot;;//初始化WKUserScript对象//根据生成的WKUserScript对象，初始化WKWebViewConfiguration//WKUserScriptInjectionTimeAtDocumentEnd为网页加载完成时注入WKUserScript *script = [[WKUserScript alloc] initWithSource:js injectionTime:WKUserScriptInjectionTimeAtDocumentEnd forMainFrameOnly:YES];[config.userContentController addUserScript:script];*/// 注入JS对象名称AppModel，当JS通过AppModel来调用时，// 我们可以在WKScriptMessageHandler代理中接收到[config.userContentController addScriptMessageHandler:self name:@&quot;AppModel&quot;];self.webView = [[WKWebView alloc] initWithFrame:self.view.bounds configuration:config];// 导航代理self.webView.navigationDelegate = self;// 与webview UI交互代理self.webView.UIDelegate = self;[self.view addSubview:self.webView];NSURL *path = [[NSBundle mainBundle] URLForResource:@&quot;demo&quot; withExtension:@&quot;html&quot;];[self.webView loadRequest:[NSURLRequest requestWithURL:path]]; 3.添加WKWebView属性的监听1234567891011121314151617181920212223242526272829303132333435363738394041424344// 添加KVO监听[self.webView addObserver:selfforKeyPath:@&quot;loading&quot;options:NSKeyValueObservingOptionNewcontext:nil];[self.webView addObserver:selfforKeyPath:@&quot;title&quot;options:NSKeyValueObservingOptionNewcontext:nil];[self.webView addObserver:selfforKeyPath:@&quot;estimatedProgress&quot;options:NSKeyValueObservingOptionNewcontext:nil];#pragma mark - KVO- (void)observeValueForKeyPath:(NSString *)keyPathofObject:(id)objectchange:(NSDictionary&lt;NSString *,id&gt; *)changecontext:(void *)context &#123;if ([keyPath isEqualToString:@&quot;loading&quot;]) &#123;NSLog(@&quot;loading&quot;);&#125; else if ([keyPath isEqualToString:@&quot;title&quot;]) &#123;self.title = self.webView.title;&#125; else if ([keyPath isEqualToString:@&quot;estimatedProgress&quot;]) &#123;NSLog(@&quot;progress: %f&quot;, self.webView.estimatedProgress);// self.progressView.progress = self.webView.estimatedProgress;&#125;// 加载完成// if (!self.webView.loading) &#123;// // 手动调用JS代码// // 每次页面完成都弹出来，大家可以在测试时再打开// NSString *js = @&quot;callJsAlert()&quot;;// [self.webView evaluateJavaScript:js completionHandler:^(id _Nullable response, NSError * _Nullable error) &#123;// NSLog(@&quot;response: %@ error: %@&quot;, response, error);// NSLog(@&quot;call js alert by native&quot;);// &#125;];//// [UIView animateWithDuration:0.5 animations:^&#123;// self.progressView.alpha = 0;// &#125;];// &#125;&#125; 4.WKScriptMessageHandler12345678910111213141516171819#pragma mark - WKScriptMessageHandler//JS调用iOS- (void)userContentController:(WKUserContentController *)userContentControllerdidReceiveScriptMessage:(WKScriptMessage *)message &#123;if ([message.name isEqualToString:@&quot;AppModel&quot;]) &#123;// 打印所传过来的参数，只支持NSNumber, NSString, NSDate, NSArray,// NSDictionary, and NSNull类型NSLog(@&quot;%@&quot;, message.body);&#125;else if ([message.name isEqualToString:@&quot;userLogin&quot;])&#123;NSLog(@&quot;%@&quot;, message.body);// 每次页面完成都弹出来，大家可以在测试时再打开NSString *js = [NSString stringWithFormat:@&quot;callJsUserName(&apos;%@&apos;)&quot;,message.body[@&quot;body&quot;]];[self.webView evaluateJavaScript:js completionHandler:^(id _Nullable response, NSError * _Nullable error) &#123;NSLog(@&quot;response: %@ error: %@&quot;, response, error);NSLog(@&quot;call js username by native&quot;);&#125;];&#125;&#125; 5.WKUIDelegatemark - WKUIDelegate12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455- (void)webViewDidClose:(WKWebView *)webView &#123;NSLog(@&quot;%s&quot;, __FUNCTION__);&#125;// 在JS端调用alert函数时，会触发此代理方法。// JS端调用alert时所传的数据可以通过message拿到// 在原生得到结果后，需要回调JS，是通过completionHandler回调- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler &#123;NSLog(@&quot;%s&quot;, __FUNCTION__);UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;alert&quot; message:@&quot;JS调用alert&quot; preferredStyle:UIAlertControllerStyleAlert];[alert addAction:[UIAlertAction actionWithTitle:@&quot;确定&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123;completionHandler();&#125;]];[self presentViewController:alert animated:YES completion:NULL];NSLog(@&quot;%@&quot;, message);&#125;// JS端调用confirm函数时，会触发此方法// 通过message可以拿到JS端所传的数据// 在iOS端显示原生alert得到YES/NO后// 通过completionHandler回调给JS端- (void)webView:(WKWebView *)webView runJavaScriptConfirmPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(BOOL result))completionHandler &#123;NSLog(@&quot;%s&quot;, __FUNCTION__);UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;confirm&quot; message:@&quot;JS调用confirm&quot; preferredStyle:UIAlertControllerStyleAlert];[alert addAction:[UIAlertAction actionWithTitle:@&quot;确定&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123;completionHandler(YES);&#125;]];[alert addAction:[UIAlertAction actionWithTitle:@&quot;取消&quot; style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) &#123;completionHandler(NO);&#125;]];[self presentViewController:alert animated:YES completion:NULL];NSLog(@&quot;%@&quot;, message);&#125;// JS端调用prompt函数时，会触发此方法// 要求输入一段文本// 在原生输入得到文本内容后，通过completionHandler回调给JS- (void)webView:(WKWebView *)webView runJavaScriptTextInputPanelWithPrompt:(NSString *)prompt defaultText:(nullable NSString *)defaultText initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(NSString * __nullable result))completionHandler &#123;NSLog(@&quot;%s&quot;, __FUNCTION__);NSLog(@&quot;%@&quot;, prompt);UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;textinput&quot; message:@&quot;JS调用输入框&quot; preferredStyle:UIAlertControllerStyleAlert];[alert addTextFieldWithConfigurationHandler:^(UITextField * _Nonnull textField) &#123;textField.textColor = [UIColor redColor];&#125;];[alert addAction:[UIAlertAction actionWithTitle:@&quot;确定&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123;completionHandler([[alert.textFields lastObject] text]);&#125;]];[self presentViewController:alert animated:YES completion:NULL];&#125; 6.WKNavigationDelegate123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#pragma mark - WKNavigationDelegate// 请求开始前，会先调用此代理方法// 与UIWebView的// - (BOOL)webView:(UIWebView *)webView// shouldStartLoadWithRequest:(NSURLRequest *)request// navigationType:(UIWebViewNavigationType)navigationType;// 类型，在请求先判断能不能跳转（请求）- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler &#123;NSString *hostname = navigationAction.request.URL.host.lowercaseString;if (navigationAction.navigationType == WKNavigationTypeLinkActivated&amp;&amp; ![hostname containsString:@&quot;.baidu.com&quot;]) &#123;// 对于跨域，需要手动跳转[[UIApplication sharedApplication] openURL:navigationAction.request.URL];// 不允许web内跳转decisionHandler(WKNavigationActionPolicyCancel);&#125; else &#123;self.progressView.alpha = 1.0;decisionHandler(WKNavigationActionPolicyAllow);&#125;NSLog(@&quot;%s&quot;, __FUNCTION__);&#125;// 在响应完成时，会回调此方法// 如果设置为不允许响应，web内容就不会传过来- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler &#123;decisionHandler(WKNavigationResponsePolicyAllow);NSLog(@&quot;%s&quot;, __FUNCTION__);&#125;// 开始导航跳转时会回调- (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(null_unspecified WKNavigation *)navigation &#123;NSLog(@&quot;%s&quot;, __FUNCTION__);&#125;// 接收到重定向时会回调- (void)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(null_unspecified WKNavigation *)navigation &#123;NSLog(@&quot;%s&quot;, __FUNCTION__);&#125;// 导航失败时会回调- (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(null_unspecified WKNavigation *)navigation withError:(NSError *)error &#123;NSLog(@&quot;%s&quot;, __FUNCTION__);&#125;// 页面内容到达main frame时回调- (void)webView:(WKWebView *)webView didCommitNavigation:(null_unspecified WKNavigation *)navigation &#123;NSLog(@&quot;%s&quot;, __FUNCTION__);&#125;// 导航完成时，会回调（也就是页面载入完成了）- (void)webView:(WKWebView *)webView didFinishNavigation:(null_unspecified WKNavigation *)navigation &#123;NSLog(@&quot;%s&quot;, __FUNCTION__);&#125;// 导航失败时会回调- (void)webView:(WKWebView *)webView didFailNavigation:(null_unspecified WKNavigation *)navigation withError:(NSError *)error &#123;&#125;// 对于HTTPS的都会触发此代理，如果不要求验证，传默认就行// 如果需要证书验证，与使用AFN进行HTTPS证书验证是一样的- (void)webView:(WKWebView *)webView didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *__nullable credential))completionHandler &#123;NSLog(@&quot;%s&quot;, __FUNCTION__);completionHandler(NSURLSessionAuthChallengePerformDefaultHandling, nil);&#125;// 9.0才能使用，web内容处理中断时会触发- (void)webViewWebContentProcessDidTerminate:(WKWebView *)webView &#123;NSLog(@&quot;%s&quot;, __FUNCTION__);&#125; 7.dealloc123- (void)dealloc &#123;[[_webView configuration].userContentController removeScriptMessageHandlerForName:@&quot;方法名&quot;];&#125; 8.JS端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;iOS and Js&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;* &#123;font-size: 40px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div style=&quot;margin-top: 100px&quot;&gt;&lt;h1&gt;Test how to use objective-c call js&lt;/h1&gt;&lt;br/&gt;&lt;div&gt;&lt;input type=&quot;button&quot; value=&quot;userLogin&quot; onclick=&quot;callJsUserLogin()&quot;&gt;&lt;/div&gt;&lt;br/&gt;&lt;div&gt;&lt;input type=&quot;button&quot; value=&quot;call js alert&quot; onclick=&quot;callJsAlert()&quot;&gt;&lt;/div&gt;&lt;br/&gt;&lt;div&gt;&lt;input type=&quot;button&quot; value=&quot;Call js confirm&quot; onclick=&quot;callJsConfirm()&quot;&gt;&lt;/div&gt;&lt;br/&gt;&lt;/div&gt;&lt;br/&gt;&lt;div&gt;&lt;div&gt;&lt;input type=&quot;button&quot; value=&quot;Call Js prompt &quot; onclick=&quot;callJsInput()&quot;&gt;&lt;/div&gt;&lt;br/&gt;&lt;div&gt;Click me here: &lt;a href=&quot;https://www.baidu.com&quot;&gt;Jump to Baidu&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;br/&gt;&lt;div id=&quot;SwiftDiv&quot;&gt;&lt;span id=&quot;jsParamFuncSpan&quot; style=&quot;color: red; font-size: 50px;&quot;&gt;&lt;/span&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;function callJsAlert() &#123;alert(&apos;Objective-C call js to show alert&apos;);window.webkit.messageHandlers.AppModel.postMessage(&#123;body: &apos;call js alert in js&apos;&#125;);&#125;function callJsConfirm() &#123;if (confirm(&apos;confirm&apos;, &apos;Objective-C call js to show confirm&apos;)) &#123;document.getElementById(&apos;jsParamFuncSpan&apos;).innerHTML= &apos;true&apos;;&#125; else &#123;document.getElementById(&apos;jsParamFuncSpan&apos;).innerHTML= &apos;false&apos;;&#125;// AppModel是我们所注入的对象window.webkit.messageHandlers.AppModel.postMessage(&#123;body: &apos;call js confirm in js&apos;&#125;);&#125;function callJsInput() &#123;var response = prompt(&apos;Hello&apos;, &apos;Please input your name:&apos;);document.getElementById(&apos;jsParamFuncSpan&apos;).innerHTML = response;// AppModel是我们所注入的对象window.webkit.messageHandlers.AppModel.postMessage(&#123;body: response&#125;);&#125;function callJsUserLogin()&#123;window.webkit.messageHandlers.userLogin.postMessage(&#123;body: &apos;xiaoming&apos;&#125;);&#125;function callJsUserName(username)&#123;document.getElementById(&apos;jsParamFuncSpan&apos;).innerHTML= username;&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 9.总结 JS调用OC方法：JS端：1window.webkit.messageHandlers.userLogin.postMessage(&#123;body: &apos;xiaoming&apos;&#125;); OC端：1234567- (void)userContentController:(WKUserContentController *)userContentControllerdidReceiveScriptMessage:(WKScriptMessage *)message &#123; if ([message.name isEqualToString:@&quot;userLogin&quot;])&#123; NSLog(@&quot;%@&quot;, message.body); &#125; //else if ...&#125; OC调用JS方法：OC端：123456NSString *username = @&quot;xiaoming&quot;;NSString *js = [NSString stringWithFormat:@&quot;callJsUserName(&apos;%@&apos;)&quot;,username];[self.webView evaluateJavaScript:js completionHandler:^(id _Nullable response, NSError * _Nullable error) &#123;NSLog(@&quot;response: %@ error: %@&quot;, response, error);NSLog(@&quot;call js username by native&quot;);&#125;]; JS端：1234function callJsUserName(username)&#123;document.getElementById(&apos;jsParamFuncSpan&apos;).innerHTML= username;&#125; 参考文章：WKWebView与Js实战(OC版)","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"OC","slug":"OC","permalink":"https://guchunli.github.io/tags/OC/"},{"name":"JS","slug":"JS","permalink":"https://guchunli.github.io/tags/JS/"}]},{"title":"OpenGL学习笔记","date":"2017-07-03T10:23:19.000Z","path":"2017/07/03/OpenGL学习笔记/","text":"1.GPUImage底层使用的是OPENGL,操控GPU来实现屏幕展示 01-自定义图层类型02-初始化CAEAGLLayer图层属性03-创建EAGLContext04-创建渲染缓冲区05-创建帧缓冲区06-创建着色器07-创建着色器程序08-创建纹理对象09-YUV转RGB绘制纹理10-渲染缓冲区到屏幕11-清理内存","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"OpenGL","slug":"OpenGL","permalink":"https://guchunli.github.io/tags/OpenGL/"},{"name":"待补充","slug":"待补充","permalink":"https://guchunli.github.io/tags/待补充/"}]},{"title":"iBeacon学习笔记","date":"2017-07-03T03:05:55.000Z","path":"2017/07/03/iBeacon学习笔记/","text":"待补充","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"待补充","slug":"待补充","permalink":"https://guchunli.github.io/tags/待补充/"},{"name":"iBeacon","slug":"iBeacon","permalink":"https://guchunli.github.io/tags/iBeacon/"}]},{"title":"OC中的block","date":"2017-07-01T06:59:03.000Z","path":"2017/07/01/OC中的block/","text":"block的定义 用作本地变量1returnType (^blockName)(parameterTypes) = ^returnType(parameters) &#123;...&#125;; 用作属性 12@property (nonatomic, copy, nullability) returnType (^blockName)(parameterTypes);As a method parameter: 用作方法参数 1- (void)someMethodThatTakesABlock:(returnType (^nullability)(parameterTypes))blockName; 调用参数为block的方法 1[someObject someMethodThatTakesABlock:^returnType (parameters) &#123;...&#125;]; 用作类型 12typedef returnType (^TypeName)(parameterTypes);TypeName blockName = ^returnType(parameters) &#123;...&#125;; block的使用block用copy修饰，delegate用weak修饰，枚举用assign修饰MRC环境下：(1)block引用局部变量局部变量a:block代码块中使用局部变量,会自动拷贝一份到常量区,所以不可改变量如果要修改局部变量，需要加__block修饰变量12345__block int number = 10;void (^myBlock)(void) = ^(void) &#123;number = 20; //不用__block，则不能修改NSLog(@&quot;%d&quot;,number);;&#125;; (2)block中引用一个局部OC对象该对象会被retain，如果局部变量使用__block修饰，则不会retain12345__block NSObject *obj = [[NSObject alloc]init];void (^myBlock)(void) = ^(void) &#123;NSLog(@&quot;%ld&quot;,obj.retainCount); //不用__block，则为2&#125;;myBlock(); (3)block中引用一个全局变量在block代码块中使用全局变量或方法时,会将这个变量或方法所在的对象self引用计数加1,引起循环引用解决方法:使用__block修饰self1__block SecondViewController *weakSelf =self; ARC环境下：(1)在block中引用局部变量，同MRC需要block修饰(2)在block中引用局部对象，不用加block(3)在block中引用全局变量，1234567891011121314151617_index = 1;__weak SecondViewController *weakThis = self;[btn addTapAction:^(UIButton *btn) &#123;//可修改值,但控制器不销毁,发生了循环引用// _index = 2;// NSLog(@&quot;index:%ld&quot;,_index);//属性__strong SecondViewController *strongThis = weakThis;strongThis-&gt;_index = 2;NSLog(@&quot;index:%ld&quot;,strongThis-&gt;_index);//方法//[weakThis test];[strongThis test];&#125;]; weak与block区别MRC，block 修饰，可以避免循环引用；ARC，block 修饰，同样会引起循环引用问题；block不管是ARC还是MRC模式下都可以使用，可以修饰对象，还可以修饰基本数据类型； weak只能在ARC模式下使用，也只能修饰对象，不能修饰基本数据类型；(1)block下循环引用的问题block本身并不能避免循环引用，避免循环引用需要在block内部把block修饰的obj置为nilweak可以避免循环引用，但是其会导致外部对象释放了之后，block 内部也访问不到这个对象的问题，我们可以通过在 block 内部声明一个 strong的变量来指向 weakObj，使外部对象既能在 block 内部保持住，又能避免循环引用的问题(2)block与weak功能上的区别。block会持有该对象，即使超出了该对象的作用域，该对象还是会存在的，直到block对象从堆上销毁；而weak仅仅是将该对象赋值给weak对象，当该对象销毁时，weak对象将指向nil；block可以让block修改局部变量，而weak不能。另外，MRC中block是不会引起retain；但在ARC中block则会引起retain。所以ARC中应该使用__weak。 参考：How Do I Declare A Block in Objective-C?","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"OC","slug":"OC","permalink":"https://guchunli.github.io/tags/OC/"},{"name":"block","slug":"block","permalink":"https://guchunli.github.io/tags/block/"}]},{"title":"iOS多线程学习笔记","date":"2017-06-30T08:45:27.000Z","path":"2017/06/30/iOS多线程学习笔记/","text":"多线程的三种使用方式：NSThread，NSOperationQueue和NSOperation，GCD。 NSThread创建线程的三种方式（1）创建、启动线程123NSThread* myThread = [[NSThread alloc] initWithTarget:self selector:@selector(doSomething:) object:nil]; //设置线程优先级、线程名称等信息[myThread start]; （2）创建线程后自动启动线程1[NSThread detachNewThreadSelector:@selector(doSomething:) toTarget:self withObject:nil]; （3）隐式创建并启动线程1[self performSelectorInBackground:@selector(doSomething) withObject:nil]; 注意：三种创建方式都只能传一个参数，如果需要传递多参数，可以封装一个对象将多个参数保存起来。 回到主线程performSelectorOnMainThread：该方法主要用来在主线程上修改页面UI的状态waitUntilDone参数： YES:当前线程要被阻塞，直到主线程将我们制定的代码块执行完，即优先执行updateUI方法 NO:当前线程不阻塞，会直接向下运行代码，不会立即进入updateUI方法， 当前线程为主线程的时候，waitUntilDone:YES参数无效，那么updateUI方法会马上执行1[self performSelectorOnMainThread:@selector(updateUI:) withObject:image waitUntilDone:YES]; 获取主线程、多线程：[NSThread mainThread] [NSThread isMultiThreaded] 线程间通讯 通知主线程更新UI界面 1- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait; 通知其他线程： 1- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait; 延迟执行（1）调用NSObject的方法:1[self performSelector:@selector(run) withObject:nil afterDelay:2.0]; （2）12[NSThread sleepForTimeInterval:2.0];[NSThread sleepUntilDate:(NSDate*)date] 死亡：+ (void)exit()NSOperationQueue和NSOperation创建NSOperation是个抽象类，使用它必须用它的子类。NSOperation的两个子类：NSInvocationOperation 和 NSBlockOperation。（1）NSInvocationOperation1234567891011/*创建一个调用操作object:调用方法参数*/NSInvocationOperation *invocationOperation=[[NSInvocationOperation alloc]initWithTarget:self selector:@selector(loadImage) object:nil];//创建完NSInvocationOperation对象并不会调用，它由一个start方法启动操作，但是注意如果直接调用start方法，则此操作会在主线程中调用，一般不会这么操作,而是添加到NSOperationQueue中// [invocationOperation start];//创建操作队列NSOperationQueue *operationQueue=[[NSOperationQueue alloc]init];//注意添加到操作队后，队列会开启一个线程执行此操作[operationQueue addOperation:invocationOperation]; （2）NSBlockOperation：相比NSInvocationOperation 更简单，推荐123456789101112//方法1：创建操作块添加到队列//创建多线程操作NSBlockOperation *blockOperation=[NSBlockOperation blockOperationWithBlock:^&#123; [self loadImage:[NSNumber numberWithInt:i]];&#125;];//创建操作队列[operationQueue addOperation:blockOperation];//方法2：直接使用操队列添加操作[operationQueue addOperationWithBlock:^&#123;[self loadImage:[NSNumber numberWithInt:i]];&#125;]; （3）继承NSOperation在.m文件中实现main方法，main方法编写要执行的代码。 并发数、优先级 设置队列并发数默认情况下是-1，-1表示没有限制，这样会同时运行队列中的全部的操作。 1[queue setMaxConcurrentOperationCount:5]; 设置线程优先级 单独设置线程在队列中的优先级不起作用,必须先将队列挂起(还得设置并发誓),等线程都加进去,再开启 1234queue.suspended = YES;operation.queuePriority = NSOperationQueuePriorityHigh;[queue addOperation:operation];[queue setSuspended:NO]; 依赖关系每个NSOperation可以设置依赖线程。假设操作A依赖于操作B，线程操作队列在启动线程时就会首先执行B操作，然后执行A。以下代码实现了优先加载最后一张图片：12//会优先执行operation2[operation1 addDependency:operation2]; GCDdispatch queue（1）serial同时只执行一个任务。通常用于同步访问特定的资源或数据。（2）concurrent可以并发地执行多个任务，但是执行完成的顺序是随机的。（3）main主队列，它是全局可用的serial queue。在主线程上执行任务。（4）global系统给每一个应用程序提供了三个concurrent dispatch queues。这三个并发调度队列是全局的，它们只有优先级的不同。因为是全局的，我们不需要去创建。我们只需要通过使用函数dispath_get_global_queue去得到队列。 dispatch_group_async可以实现监听一组任务是否完成，完成后得到通知执行其他的操作1234567891011121314151617dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_group_t group = dispatch_group_create(); dispatch_group_async(group, queue, ^&#123; [NSThread sleepForTimeInterval:1]; NSLog(@&quot;group1&quot;); &#125;); dispatch_group_async(group, queue, ^&#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;group2&quot;); &#125;); dispatch_group_async(group, queue, ^&#123; [NSThread sleepForTimeInterval:3]; NSLog(@&quot;group3&quot;); &#125;); dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; NSLog(@&quot;updateUI&quot;); &#125;); dispatch_barrier_async在前面的任务执行结束后它才执行，而且等它执行完成之后后面的任务才会执行。123456789101112131415161718dispatch_queue_t queue = dispatch_queue_create(&quot;barrier&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^&#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;dispatch_async1&quot;); &#125;); dispatch_async(queue, ^&#123; [NSThread sleepForTimeInterval:4]; NSLog(@&quot;dispatch_async2&quot;); &#125;); dispatch_barrier_async(queue, ^&#123; NSLog(@&quot;dispatch_barrier_async&quot;); [NSThread sleepForTimeInterval:4]; &#125;); dispatch_async(queue, ^&#123; [NSThread sleepForTimeInterval:1]; NSLog(@&quot;dispatch_async3&quot;); &#125;); dispatch_apply执行某个代码片段N次。注意：这个方法没有办法异步执行（为了不阻塞线程可以使用dispatch_async()包装一下再执行）123dispatch_apply(5, queue, ^(size_t index) &#123;// 执行5次&#125;); dispatch_time()： 延迟一定的时间后执行。1234dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 3*NSEC_PER_SEC);dispatch_after(time, dispatch_get_main_queue(), ^&#123; NSLog(@&quot;3秒后执行&quot;);&#125;); 单例123456static SingleClass *instance;static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123; instance = [[SingleClass alloc]init];&#125;);return instance; dispatch_suspend(myQueue)： 挂起队列dispatch_resume(myQueue)：恢复队列线程同步加锁的几种方式： NSLock注意：lock和unlock之间的”加锁代码“应该是抢占资源的读取和修改代码，不要将过多的其他操作代码放到里面，否则一个线程执行的时候另一个线程就一直在等待，就无法发挥多线程的作用了。1234theLock = [[NSLock alloc] init]; [theLock lock]; //dosomething[theLock unlock]; NSCondition123456789101112ticketsCondition = [[NSCondition alloc] init]; [ticketsCondition lock]; if (_imageNames.count&gt;0) &#123; [_condition wait];&#125;else&#123; [_imageNames addObject:[NSString stringWithFormat:@&quot;http://images.cnblogs.com/cnblogs_com/kenshincui/613474/o_%i.jpg&quot;,_currentIndex++]]; //创建完图片则发出信号唤醒其他等待线程 [_condition signal];&#125;[ticketsCondition unlock]; // [ticketsCondition signal]：发送信号的方式// [ticketsCondition wait]：在一个线程唤醒另外一个线程的等待 @synchronized：更简单，推荐1234@synchronized(anObj)&#123;//dosomething&#125; GCD123456789101112/*初始化信号量参数是信号量初始值*/_semaphore=dispatch_semaphore_create(1);/*信号等待第二个参数：等待时间*/dispatch_semaphore_wait(_semaphore, DISPATCH_TIME_FOREVER); //dosomething&#125;//信号通知dispatch_semaphore_signal(_semaphore); iOS中的其他类型锁NSRecursiveLock ：递归锁，有时候“加锁代码”中存在递归调用，递归开始前加锁，递归调用开始后会重复执行此方法以至于反复执行加锁代码最终造成死锁，这个时候可以使用递归锁来解决。使用递归锁可以在一个线程中反复获取锁而不造成死锁，这个过程中会记录获取锁和释放锁的次数，只有最后两者平衡锁才被最终释放。NSDistributedLock：分布锁，它本身是一个互斥锁，基于文件方式实现锁机制，可以跨进程访问。pthread_mutex_t：同步锁，基于C语言的同步锁机制，使用方法与其他同步锁机制类似。 注意：调用dispatch_suspend会增加队列挂起的引用计数，而调用dispatch_resume则会减少引用计数，当引用计数大于0时，队列会保持挂起状态。因此，这队列的挂起和恢复中，我们需要小心使用以避免引用计数计算错误的出现。 参考链接：荣芳志专栏中的文章 iOS开发系列–并行开发其实很容易","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"多线程","slug":"多线程","permalink":"https://guchunli.github.io/tags/多线程/"}]},{"title":"iOS面试知识点总结","date":"2017-06-30T06:31:59.000Z","path":"2017/06/30/iOS面试知识点总结/","text":"1.category与extension的区别 category可以不用继承系统类，直接给系统类添加方法，最大程度的体现了Objective-C的动态语言特性。可以用来定义私有方法。 extension为一个类增加私有方法,属性或成员变量,并且新添加的方法一定要予以实现。Extension都是放在.m文件中@implementation的上方。区别：Extension可以添加属性。另外Extension添加的方法是必须要实现的。 2.OC中的私有变量用@private修饰，私有方法用category3.NSInteger是基本数据类型Int或者Long的别名(NSInteger的定义typedef long NSInteger)，它的区别在于，NSInteger会根据系统是32位还是64位来决定是本身是int还是Long。 4.block 5.Objective-C的内存管理(1)主要有三种方式ARC(自动内存计数)、手动内存计数、内存池内存管理机制；当使用new,alloc和copy方法创建一个对象时,该对象的保留计数器值为1.当不再使用该对象时,要负责向该对象发送一条release或autorelease消息.这样,该对象将在使用寿命结束时被销毁.(2)堆与栈 栈:是由编译器自动管理，无需我们手工控制； 堆:释放工作由程序员控制，容易产生memory leak。6.属性关键字(1)atomic/nonatomic atomic提供多线程安全。是防止在未写完的时候被另外一个线程读取，造成数据错误 non-atomic:在自己管理内存的环境中，解析的访问器保留并自动释放返回的值，如果指定了 nonatomic ，那么访问器只是简单地返回这个值(2)assign/weak 用assign声明的变量在栈中可能不会自动赋值为nil，就会造成野指针错误 用weak声明的变量在栈中会自动清空，赋值为nilassigin 可以用非OC对象,而weak必须用于OC对象在ARC中,在有可能出现循环引用的时候,往往要通过让其中一端使用weak来解决,比如:delegate代理属性(3)浅复制和深复制的区别? 浅层复制：只复制指向对象的指针，而不复制引用对象本身。 深层复制：复制引用对象本身。(4)copy/mutableCopy copy是指针复制（浅拷贝） mutableCopy就是对象复制（深拷贝） 7.多态：不同对象以自己的方式响应相同的消息的能力叫做多态。子类指针可以赋值给父类对象。主要是将数据类型的确定由编译时，推迟到了运行时。(1)对于语句NSString*obj = [[NSData alloc] init]; obj在编译时和运行时分别时什么类型的对象?答：编译时是NSString的类型;运行时是NSData类型的对象。(2)id声明的对象具有运行时的特性，即可以指向任意类型的objcetive-c的对象.8.NSObject方法类方法：alloc,class,description实例方法：init,dealloc,performSelector 9.通知与协议 协议有控制链(has-a)的关系，通知没有。 通知：一对多。代理/block：一对一。 OC中的多继承用委托代理实现 10.事件的传递与响应传递：application-&gt;window-&gt;controller-&gt;view响应：view-&gt;controller-&gt;window-&gt;application重写hitTest:withEvent:方法 11.延迟加载：用到的时候才去初始化。延迟加载可以避免内存过高，异步加载可以避免线程堵塞。 多线程(1)Object C中创建线程的方法是什么?如果在主线程中执行代码，方法是什么?如果想延时执行代码、方法又是什么?答：线程创建有三种方法 使用NSThread创建 使用GCD的dispatch 使用子类化的NSOperation,然后将其加入NSOperationQueue;(2)在主线程执行代码，方法是performSelectorOnMainThread如果想延时执行代码可以用performSelector:onThread:withObject:waitUntilDone:(3)进程与线程进程有独立的地址空间线程有自己的堆栈和局部变量(4)队列：串行、并行、全局、主队列 13.持久化存储机制：存到文件，存到NSUserDeaults(plist文件)，sqlite数据库NSUserDeaults数据存储在沙盒library下的Preferences文件夹。沙盒目录：documents、library(chches,preferences),tmpSDWebImage原理：内存中找-&gt;沙盒中找，缓存到内存-&gt;网络上获取，缓存到内存，缓存到沙盒 14.网络(1)发起网络请求的对象：AFHTTPSessionManager、ASIHTTPRequest与NSURLConnection(2)http与socket http:短连接，请求方式为客户端主动发起请求，服务器才能给响应，一次请求完毕后则断开连接，以节省资源。服务器不能主动给客户端响应（除非采取http长连接 技术） socket:长连接，客户端和服务器可以保持连接通道，双方 都可以主动发送数据 15.fmmpeg框架答：音视频编解码框架，内部使用UDP协议针对流媒体开发，内部开辟了六个端口来接受流媒体数据，完成快速接受之目的。16.Cocoa Touch中一小部分可用的框架： 音频和视频：Core Audio ，OpenAL ，Media Library ，AV Foundation 数据管理 ：Core Data ，SQLite 图形和动画 ：Core Animation ，OpenGL ES ，Quartz 2D 网络：Bonjour ，WebKit ，BSD Sockets 用户应用：Address Book ，Core Location ，Map Kit ，Store Kit 17.isMemberOfClass 与 isKindOfClassisKindOfClass 不仅用来确定一个对象是否是一个类的成员,也可以用来确定一个对象是否派生自该类的类的成员,而isMemberOfClass 只能做到第一点 18.UIViewController的生命周期-[ViewController initWithNibName:bundle:]；-[ViewController init]；-[ViewController loadView]；-[ViewController viewDidLoad]；-[ViewController viewWillDisappear:]；-[ViewController viewWillAppear:]；-[ViewController viewDidAppear:]；-[ViewController viewDidDisappear:]； Received simulated memory warning.-[ViewController viewVillUnload]-[ViewController viewDidUnload] (1)创建Controller： 通过storyBoard: [UIStoryboard storyboardWithName:@”” bundle:nil]instantiateInitialViewController`此处bundle:nil 等价于 [NSBundle mainBundle] 通过XIB 加载与控制器同名的XIB文件:使用init或initWithNibName加载 加载与控制器不同名的XIB Controller文件,通过loadNibNamed加载控制器（不同名需要修改file owner） 1SecondViewController *secondVc = [[[NSBundle mainBundle]loadNibNamed:@&quot;SecondVC&quot; owner:nil options:nil] lastObject] 加载与控制器不同名的XIB View文件,通过loadNibNamed加载控制器的view（不同名需要修改file owner） 12SecondViewController *secondVc = [[SecondViewController alloc]init];secondVc.view = [[[NSBundle mainBundle]loadNibNamed:@&quot;SecondViewController&quot; owner:nil options:nil] lastObject]; 在创建控制器的时候直接指定要加载xib作为控制器的view,名称不相干 需要修改xib文件的fileOwner进行关联需要将fileOwner里面的view指向xib里面的view(2)创建View: 通过XIB：[[NSBundle alloc]loadNibNamed:@”” owner:self options:nil]; 19.OC单例12345678910+(instancetype)shareNetworkTools&#123; static id instance; static dispatch_once_t onceToken; //onceToken默认等于0，如果是0就执行block，如果不是就不执行 NSLog(@&quot;%ld&quot;,onceToken); dispatch_once(&amp;onceToken, ^&#123; instance = [[self alloc] init]; &#125;); return instance;&#125; swift单例123456789101112131415161718192021222324/*//在swift中，类方法中不允许定义静态变量static var once_t: dispatch_once_t = 0static var instance: NetworkTools?//用于获取单例对象的类方法class func shareNetworkTools() -&gt; NetworkTools&#123; print(once_t) dispatch_once(&amp;once_t) &#123; () -&gt; Void in instance = NetworkTools() &#125; return instance!&#125;*///swift中的let是线程安全的static let instance: NetworkTools = NetworkTools()class func shareNetworkTools() -&gt; NetworkTools&#123; return instance&#125;//init方法在需要的时候才创建override init()&#123;super.init()print(&quot;----------&quot;)&#125;","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"面试","slug":"面试","permalink":"https://guchunli.github.io/tags/面试/"}]},{"title":"iOS直播学习笔记","date":"2017-06-29T09:14:34.000Z","path":"2017/06/29/iOS直播学习笔记/","text":"推流//LFLiveKit,librtmp 1.安装Homebrew查看是否已经安装了Homebrew1man brew 安装Homebrew1ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 2.安装nginx12345678//从github下载Nginx到本地,增加home-brew对nginx的扩展brew tap homebrew/nginx//安装Nginx服务器和rtmp模块brew install nginx-full --with-rtmp-module查看是否安装成功nginx 在浏览器地址栏输入：http://localhost:8080如果出现Welcome to nginx!，则表示安装成功 3.配置rtmp查看nginx配置文件安装在哪brew info nginx-full 前往/usr/local/etc/nginx/nginx.conf，在最后添加以下代码：123456789rtmp &#123; server &#123; listen 1990; application liveApp &#123; live on; record off; &#125; &#125;&#125; 重新加载nginx的配置文件nginx -s reload 4.安装ffmpeg进行推流brew install ffmpeg 5.使用ffmepg推流测试12ffmpeg -re -i (视频全路径) -vcodec copy -f flv (rtmp路径)ffmpeg -re -i /Users/xxx/Downloads/4.mp4 -vcodec copy -f flv rtmp://localhost:1990/liveApp/room 出现错误：1234[tcp @ 0x7ffd66e08440] Connection to tcp://localhost:1990 failed (Connection refused), trying next address[flv @ 0x7ffd68005400] FLV does not support sample rate 48000, choose from (44100, 22050, 11025)[flv @ 0x7ffd68005400] Audio codec mp3 not compatible with flvCould not write header for output file #0 (incorrect codec parameters ?): Function not implemented 原因：flv格式不支持音频码率为48000的，只支持44100，22050，11025的，你得找一个音频码率为这三个中的其中一个的视频或者利用ffmpeg修改音频的码率 6.使用VLC播放rtmp推流VLC 7.用ffmpeg抓取桌面以及摄像头推流进行直播1234//查看ffmpeg是否支持对应的设备ffmpeg -f avfoundation -list_devices true -i &quot;&quot;//抓取桌面和摄像头进行推流ffmpeg -f avfoundation -framerate 30 -i &quot;1:0&quot; -f avfoundation -framerate 30 -video_size 640x480 -i &quot;0&quot; -c:v libx264 -preset slow -filter_complex &apos;overlay=main_w-overlay_w-10:main_h-overlay_h-10&apos; -acodec libmp3lame -ar 44100 -ac 1 -f flv rtmp://localhost:1990/liveApp/room 搭建WEB服务器1.安装node.js,NPM2.利用NPM下载第三方模块（Express和Socket.IO）创建package.json:1234&quot;dependencies&quot;: &#123;&quot;express&quot;: &quot;^4.14.0&quot;,&quot;socket.io&quot;: &quot;^1.4.8&quot;&#125; 执行npm install 3.http服务器搭建创建xxx.js文件，然后执行node xxx.js即可`// require// 加载http模块var http = require(‘http’); // 创建http服务器var server = http.createServer(function(request,response){// response.write(‘Hello world’);// response.end();}); // 监听服务器server.listen(8080,’192.168.0.101’); console.log(‘监听8080’);` 4.express框架Express框架建立在node.js内置的http模块上，可以快速地搭建一个Web服务器123456789101112131415161718// 引入express模块var express = require(&apos;express&apos;);// 创建express服务器，创建服务器没有对访问服务器进行处理var app = express();// 监听get请求，请求根目录，输出Hello worldapp.get(&apos;/&apos;,function(request,response)&#123;response.send(&apos;Hello world&apos;);&#125;);app.post(&apos;/&apos;,function(request,response)&#123;response.send(&apos;Hello world&apos;);&#125;);app.listen(8080,&quot;192.168.0.101&quot;);console.log(&quot;监听8080&quot;); 5.上传下载服务器搭建 搭建socket即时通讯服务器1.WebSocketWebSocket：服务器和 客户端 都能主动的向对方发送或接收数据websocket协议头:wsSocket.IO:是一个完全由JavaScript实现、基于Node.js、支持WebSocket的协议用于实时通信、跨平台的开源框架。2.导入Socket.IO3.创建socket （1）面向express框架开发，加载express框架，方便处理get,post请求 （2）因为socket依赖http,创建http服务器，使用http模块. （3）可以通过express创建http服务器http.server(express) （4）通过http服务器创建socket （5）监听http服务器4.建立socket连接12345// 监听socket连接// function参数必填socketsocket.on(&apos;connection&apos;,function(clientSocket)&#123;console.log(&apos;建立连接&apos;,clientSocket);&#125;); 5.SocketIO发送事件","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"待补充","slug":"待补充","permalink":"https://guchunli.github.io/tags/待补充/"},{"name":"直播","slug":"直播","permalink":"https://guchunli.github.io/tags/直播/"}]},{"title":"ReactNative使用学习笔记","date":"2017-06-21T03:39:45.000Z","path":"2017/06/21/ReactNative使用学习笔记/","text":"直接通过ReactNative方式创建项目安装必须安装：Xcode，Homebrew，node,npmnpm其实是Node.js的包管理工具,已经在Node.js安装的时候顺带装好了。可选：React Native的命令行工具,IDE(Atom/Nuclide/Webstorm/Sublime),watchman,Flow1234567891011//brewruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;brew -v//nodebrew install node//React Native的命令行工具npm install -g react-native-cli//watchmanbrew install watchman//flowbrew install flow 创建项目1$ react-native init RNDemo 运行项目:使用命令行或Xcode12345678$ react-native run-ios$ react-native run-android......React packager ready.Loading dependency graph, done.` 运行项目时如果遇到&lt;React/RCTBundleURLProvider.h&gt;” file not found问题，可按如下方法试着解决： 把项目里面的 node_modules 文件夹删除掉 npm install react-native upgrade clean,run RN与原生项目先创建iOS项目，再集成React Native到原生项目(1) 先通过Xcode创建项目(2) 将iOS原生项目代码放到ios文件夹中，ios文件夹与package.json、index.ios.js放在根目录下。在根目录创建一个package.json文件，用于初始化react-native.package.json内容如下：123456789101112&#123;&quot;name&quot;: &quot;RNDemo&quot;,&quot;version&quot;: &quot;0.0.1&quot;,&quot;private&quot;: true,&quot;scripts&quot;: &#123;&quot;start&quot;: &quot;node node_modules/react-native/local-cli/cli.js start&quot;&#125;,&quot;dependencies&quot;: &#123;&quot;react&quot;: &quot;15.4.1&quot;,&quot;react-native&quot;: &quot;0.39.2&quot;&#125;&#125; dependencies中的react和react-native的版本取决于你的具体需求。一般来说我们推荐使用最新版本。你可以使用npm info react和npm info react-native来查看当前的最新版本。另外，react-native对react的版本有严格要求，高于或低于某个范围都不可以。可以先尝试执行npm install，然后注意观察安装过程中的报错信息，例如require react@某.某.某版本, but none was installed，然后根据这样的提示，执行npm i -S react@某.某.某版本。 (3) 安装依赖包1$ npm install 或者安装指定版本的react/react-native12$ npm install --save react-native@0.45.1$ npm install --save react@15.6.1 (4)集成cocoaPods1pod init Podfile文件内容：1234567891011121314151617platform :ios, &quot;8.0&quot;target &quot;HelloRN&quot; douse_frameworks! # &apos;node_modules&apos;目录一般位于根目录中，但是如果你的结构不同，那你就要根据实际路径修改下面的`:path`pod &apos;React&apos;, :path =&gt; &apos;../node_modules/react-native&apos;, :subspecs =&gt;[&apos;Core&apos;,&apos;DevSupport&apos;, # 如果RN版本 &gt;= 0.43，则需要加入此行才能开启开发者菜单&apos;RCTText&apos;,&apos;RCTNetwork&apos;,&apos;RCTWebSocket&apos;, # 这个模块是用于调试功能的# 在这里继续添加需要的模块]# 如果你的RN版本 &gt;= 0.42.0，请加入下面这行pod &quot;Yoga&quot;, :path =&gt; &quot;../node_modules/react-native/ReactCommon/yoga&quot;end 修改完Podfile文件内容执行pod install (4) 创建index.ios.js文件注意当前项目名称为RNDemo，修改为实际项目名称。123456789101112131415161718192021222324252627282930&apos;use strict&apos;;import React from &apos;react&apos;;import &#123;AppRegistry,StyleSheet,Text,View&#125; from &apos;react-native&apos;;class RNDemo extends React.Component &#123; render() &#123;return (&lt;View style=&#123;styles.container&#125;&gt;&lt;Text&gt;This is a simple application.&lt;/Text&gt;&lt;/View&gt;)&#125;&#125;const styles = StyleSheet.create(&#123;container: &#123;flex: 1,justifyContent: &apos;center&apos;,alignItems: &apos;center&apos;,backgroundColor: &apos;#FFFFFF&apos;,&#125;,&#125;);React.AppRegistry.registerComponent(&apos;RNDemo&apos;, () =&gt; RNDemo); (5) Cocoapods集成react-native在工程目录下创建Podfile文件，内容如下：123456789101112# 请将:path后面的内容为node_modules文件夹路径。plateform :ios, &apos;8.0&apos;target &quot;RNDemo&quot; dopod &apos;React&apos;, :path =&gt; &apos;../node_modules/react-native&apos;, :subspecs =&gt; [&apos;Core&apos;,&apos;RCTImage&apos;,&apos;RCTNetwork&apos;,&apos;RCTText&apos;,&apos;RCTWebSocket&apos;,# 添加其他你想在工程中使用的依赖。]end 执行pod install即可如果出现如下问题：1The dependency `React/Core (from `./node_modules/react-native`)` is not used in any concrete target. 在项目首尾请添加上target即可12target &quot;RNDemo&quot; do end (6)添加react native应用创建一个ReactView视图文件1234567891011121314151617- (instancetype)initWithFrame:(CGRect)frame&#123;if (self = [super initWithFrame:frame]) &#123;NSString * strUrl = @&quot;http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true&quot;;NSURL * jsCodeLocation = [NSURL URLWithString:strUrl];RCTRootView * rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocationmoduleName:@&quot;SimpleApp&quot;initialProperties:nillaunchOptions:nil];[self addSubview:rootView];rootView.frame = self.bounds;&#125;return self;&#125; ReactView.m 中通过 http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true 加载bundle文件 在ViewController中加载这个视图12ReactView * reactView = [[ReactView alloc] initWithFrame:CGRectMake(0, 40, CGRectGetWidth(self.view.bounds), 100)];[self.view addSubview:reactView]; (7)启动开发服务器1$ react-native start (8)Info.list中修改NSAppTransportSecurity配置(9)在Xcode中运行项目，完成 升级Xcode8后遇到的错误Q1:’React/RCTBundleURLProvider.h’ file not foundA1:将node_modules文件夹删除，执行12$ npm install$ react-native upgrade clean，重新运行 Q2:RCTSCrollView.m 中_refreshControl找不到A2:在@implementation RCTCustomScrollView下添加如下代码：1234@implementation RCTCustomScrollView&#123;RCTRefreshControl *_refreshControl;&#125; Q3:’React/JavaScriptCore.h’ file not foundA3:cocoapods升级到1.2.0 Q4:控制台不断输出[] nw_connection_get_connected_socket_block_invoke 710 Connection has no connected handlerA4:edit scheme-&gt;arguments-&gt;Environment Variables-&gt;添加Name: “OS_ACTIVITY_MODE”, Value:”disable” JavaScript基础(1){}表示定义一个对象(2)var,let,function,弱类型,typeof(),isNaN()数据类型：Boolean,null,undefined,Number,String,Symbol,Objectfalse:false,undefined,NaN,null,””,0显式类型转换：parseInt()隐式类型转换：==,-,*,/数组：var a = [“1”,”2”,”3”] var a = new Array(“1”,”2”,”3”) var a = Array(“1”,”2”,”3”)字典：{} JS:基于原型(所有对象均为实例,通过构造器函数来定义和创建一组对象)OC：基于类(3)Promises(ES6)JS本身是单线程的语言，它要实现异步都是通过回调函数来实现的，JS中引入了Promises来处理异步和延迟操作。 promise有以下几种状态： * pending，最初的状态 * fulfilled，执行成功 * rejected，执行出错 * settled，执行结束了，失败(rejected)或者成功(fulfilled) (4)箭头函数(ES6)1(s) =&gt; s.length 等同于 function(s)&#123; return s.length &#125; 普通函数.bind(this) 来把内部函数中的this绑定到了外部函数去。箭头函数里的this还是原来的this，不需要额外绑定。(5)模板字符串(ES6)1234567var html = `公司名：$&#123;name&#125; 简介：$&#123;desc&#125;`;等同于var tpl = &apos;公司名：&apos; + name + &apos;\\n&apos;+&apos;简介：&apos;+ desc; React基础组件（component）是React类的基类，进行视图展示。 组件的属性(prop)：组件之前通过标签的属性来传递数据，由父组件传递给子组件(单向的属性传递) 组件的状态(state) 每次调用setState时都会更新组件的状态，触发render函数进行渲染更新界面（render方法是被异步调用的，这可以保证同步的多个setState方法只会触发一次render） 组件自己不可以自己修改props（即：props可认为是只读的），只可由其他组件调用它时在外部修改 createClass：创建一个component render()：返回的的 JSX 模板需要一个根元素包裹起来返回一个根的视图，用来渲染实际的Component可视部分 getInitialState()：只能在用React.createClass创建的时候使用在Component被加载之前调用一次，这个方法的返回值会被设置为this.state getDefaultProps()：在Class 创建的时候，调用一次，这个方法在调用的时候，任何实例还没有被创建返回的任何Object 对象，在各个实例中是共享的 组件的生命周期 (1)创建：getDefaultProps(ES6:defaultProps)-&gt;(2)实例化：getInitialState(ES6:constructor)-&gt;componentWillMount-&gt;render-&gt;componentDidMount-&gt;(3)运行更新阶段： + 运行中-&gt;props改变-&gt;componentWillReceiveProps-&gt; + 运行中-&gt;state改变-&gt; shouldComponentUpdate-&gt; + false-&gt;运行中 + true-&gt;componentWillUpdate-&gt;render-&gt;componentDidUpdate-&gt;运行中 (4)销毁阶段：Unmount(卸载)-&gt;componentWillUnmount 生命周期 调用次数 能否使用 setSate() defaultProps / getDefaultProps 1(全局调用一次) 否 constructor / getInitialState 1 否 componentWillMount 1 是 render &gt;=1 否 componentDidMount 1 是 componentWillReceiveProps &gt;=0 是 shouldComponentUpdate &gt;=0 否 componentWillUpdate &gt;=0 否 componentDidUpdate &gt;=0 否 componentWillUnmount 1 否 (1)getDefaultProps(ES6:defaultProps):初始化一些默认的属性，一个控件可以利用this.props获取并初始化它的属性 + ES5:getDefaultProps:function(){},propTypes:{}, + ES6:static defaultProps={};static propTypes={}; (2)constructor(props) / getInitialState():状态初始化 + ES5:getInitialState: function(){} + ES6:constructor(props){} (3)componentWillMount():准备加载组件，业务初始化操作，也可以设置组件状态(4)render():渲染界面，返回JSX或其它组件来构成DOM，只能返回一个顶级元素(5)componentDidMount():组件加载成功并被成功渲染，一般会做一些网络请求等加载数据的操作 (6)componentWillReceiveProps():组件接收到新的props会触发，可以调用setState()来完成对state的修改，nextProps 是即将被设置的属性，旧的属性还是可以通过 this.props 来获取(7)shouldComponentUpdate():返回布尔值（决定是否需要更新组件）(8)componentWillUpdate():shouldComponentUpdate返回true或者调用forceUpdate之后触发此方法，会把 nextProps 和 nextState 分别设置到 this.props 和 this.state 中，开始准备更新组件。不能使用 this.setState 来修改状态。(9)render()：再确定需要更新组件时，调用render，根据diff算法，渲染界面，生成需要更新的虚拟DOM数据。(10)componentDidUpdate():可以在这个方法中做DOM操作，首次render之后调用componentDidMount，其它render结束之后都是调用componentDidUpdate。(11)componentWillUnmount():组件从DOM中移除，可以做一些组件相关的清理工作，例如取消计时器、网络请求。1注意：绝对不要在componentWillUpdate和componentDidUpdate中调用this.setState方法，否则将导致无限循环调用。 组件更新的四种方式(1)首次Initial Render，即首次加载组件(2)调用this.setState(3)父组件发生更新(4)调用this.forceUpdate强制更新 statics定义Components可以调用的静态方法 原生和React Native之间的通信方式主要包括三部分： 属性 原生模块 原生UI组件封装 属性原生给JS传数据，主要依靠属性。(1)原生-&gt;React Native 传递属性initialProperties：必须是NSDictionary的一个实例。这一字典参数会在内部被转化为一个可供JS组件调用的JSON对象。 更新属性appProperties：可以通过componentWillMount访问新的属性值。 更新必须在主线程中进行，读取则可以在任何线程中进行。 更新属性时并不能做到只更新一部分属性。建议自己封装一个函数来构造属性。(2)React Native-&gt;原生宏RCT_CUSTOM_VIEW_PROPERTY 原生模块原生模块是JS中也可以使用的Objective-C类。一个“原生模块”就是一个实现了“RCTBridgeModule”协议的Objective-C类。 原生UI组件封装参考链接：React Native开发React Native 简介与入门reactnative集成到原生ios项目","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"ReactNative","slug":"ReactNative","permalink":"https://guchunli.github.io/tags/ReactNative/"}]},{"title":"JSP学习笔记","date":"2017-06-12T01:22:10.000Z","path":"2017/06/12/JSP学习笔记/","text":"cookies 存储在浏览器。而会话存储在服务器端待补充","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://guchunli.github.io/tags/Java/"},{"name":"JSP","slug":"JSP","permalink":"https://guchunli.github.io/tags/JSP/"}]},{"title":"几种常见算法","date":"2017-06-09T03:02:24.000Z","path":"2017/06/09/几种常见算法/","text":"排序1、插入排序在要排序的一组数中，假设前面(n-1) [n&gt;=2] 个数已经是排好顺序的，现在要把第n个数插到前面的有序数中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。12345678910111213141516if(arr == null || arr.length &lt; 2)&#123; return arr;&#125;for(int i=1;i&lt;arr.length;i++)&#123; for(intj=i;j&gt;0;j--)&#123; if(arr[j]&lt;arr[j-1])&#123; int temp=arr[j]; arr[j]=arr[j-1]; arr[j-1]=temp; &#125;else&#123; //接下来是无用功 break; &#125; &#125;&#125;return arr; 2、冒泡排序在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。12345678910111213int temp = 0;for (int i = a.length - 1; i &gt; 0; --i)&#123; for (int j = 0; j &lt; i; ++j) &#123; if (a[j + 1] &lt; a[j]) &#123; temp = a[j]; a[j] = a[j + 1]; a[j + 1] = temp; &#125; &#125;&#125; 3、快速排序快速排序是对冒泡排序的一种本质改进。它的基本思想是通过一趟扫描后，使得排序序列的长度能大幅度地减少。在冒泡排序中，一次扫描只能确保最大数值的数移到正确位置，而待排序序列的长度可能只减少1。快速排序通过一趟扫描，就能确保以某个数为基准点的左边各数都比它小，右边各数都比它大。然后又用同样的方法处理它左右两边的数，直到基准点的左右只有一个元素为止。1234567891011121314151617181920212223242526272829303132333435363738main()&#123; if(left &gt;= right)/*如果左边索引大于或者等于右边的索引就代表已经整理完成一个组了*/ &#123; return ; &#125; int i = left; int j = right; int key = a[left]; while(i &lt; j) /*控制在当组内寻找一遍*/ &#123; while(i &lt; j &amp;&amp; key &lt;= a[j]) /*而寻找结束的条件就是，1，找到一个小于或者大于key的数（大于或小于取决于你想升 序还是降序）2，没有符合条件1的，并且i与j的大小没有反转*/ &#123; j--;/*向前寻找*/ &#125; a[i] = a[j]; /*找到一个这样的数后就把它赋给前面的被拿走的i的值（如果第一次循环且key是 a[left]，那么就是给key）*/ while(i &lt; j &amp;&amp; key &gt;= a[i]) /*这是i在当组内向前寻找，同上，不过注意与key的大小关系停止循环和上面相反， 因为排序思想是把数往两边扔，所以左右两边的数大小与key的关系相反*/ &#123; i++; &#125; a[j] = a[i]; &#125; a[i] = key;/*当在当组内找完一遍以后就把中间数key回归*/ sort(a, left, i - 1);/*最后用同样的方式对分出来的左边的小组进行同上的做法*/ sort(a, i + 1, right);/*用同样的方式对分出来的右边的小组进行同上的做法*/ /*当然最后可能会出现很多分左右，直到每一组的i = j 为止*/&#125; 4、选择排序在要排序的一组数中，选出最小的一个数与第一个位置的数交换；然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。123456789101112131415161718main()&#123;int i,j,min,t;for(i=0;i&lt;n-1;i++)&#123; min=i;//查找最小值 for(j=i+1;j&lt;n;j++) if(a[min]&gt;a[j]) min=j;//交换 if(min!=i) &#123; t=a[min]; a[min]=a[i]; a[i]=t; &#125; &#125;&#125; 二分法二分法查找只适用与已排序的数列。思路：首先将值 x 与数组 v 的中间元素比较，如果 x 小于中间的元素，则将 end 值设为 中间元素-1，同理，若 x 大于中间元素，则将中间元素 + 1作为 start，再在 start 与 end 之间进行查找。123456789101112int start = 0;int end = data.length-1;int mid = (start+end)/2;//awhile(data[mid]!=aim&amp;&amp;end&gt;start)&#123; if(data[mid]&gt;aim)&#123; end = mid-1; &#125;else if(data[mid]&lt;aim)&#123; start = mid+1; &#125; mid = (start+end)/2;&#125;return (data[mid]!=aim)?-1:mid; 斐波那契数列数列：1,1,2,3,5,8,13,21… 求第n项的值1234567891011int f1,f2,f,i,n; f1=f2=1;if(n&lt;=2) printf(&quot;%d&quot;,1); else &#123; //加上括号 for(i=3;i&lt;=n;i++) &#123; f=f1+f2; f1=f2; f2=f;","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://guchunli.github.io/tags/排序/"},{"name":"算法","slug":"算法","permalink":"https://guchunli.github.io/tags/算法/"}]},{"title":"Java语言学习笔记","date":"2017-06-09T01:59:09.000Z","path":"2017/06/09/Java语言学习笔记/","text":"##JAVA基础 1.public类 一个源文件中只能有一个public类 一个源文件可以有多个非public类 2.package/import编译java包： $ javac -d directory javafilename 1234E:\\sources&gt; javac -d c:\\classes Simple.java//运行e:\\sources&gt; set classpath=c:\\classes;.;e:\\sources&gt; java mypack.Simple OR1e:\\sources&gt; java -classpath c:\\classes mypack.Simple 加载类文件或jar文件的方式: 加载临时类文件 通过在命令提示符中设置类路径 通过 -classpath 开关选项 永久加载类文件 通过在环境变量中设置类路径 通过创建jar文件，其中包含所有类文件，并将jar文件复制到JDK安装目录的jre/lib/ext文件夹中。 3.引用类型对象、数组都是引用数据类型。所有引用类型的默认值都是null。 4.JAVA常量在 Java 中使用 final 关键字来修饰常量，通常使用大写字母表示常量 5. 基本数据类型 不能对boolean类型进行类型转换。 在把容量大的类型转换为容量小的类型时必须使用强制类型转换 double-&gt;float 6.自动类型转换转换前的数据类型的位数要低于转换后的数据类型。Float-&gt;double Java语言支持的变量类型类变量：独立于方法之外的变量，用 static 修饰。 在类中以static关键字声明，但必须在方法构造方法和语句块之外 静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。 静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。 为了对类的使用者可见，大多数静态变量声明为public类型 默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。 类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。 静态块在类加载时main之前执行实例变量：独立于方法之外的变量，不过没有 static 修饰。 当一个对象被实例化之后，每个实例变量的值就跟着确定； 实例变量可以声明在使用前或者使用后； 一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见； 实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定； 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名局部变量：类的方法中的变量。 访问修饰符不能用于局部变量； 局部变量是在栈上分配的。 局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。 实例初始化块主要有三个规则。 它们如下： 在创建类的实例时创建实例初始化程序块。 在父类构造函数被调用之后(即在super()构造函数调用之后)调用实例初始化块。 实例初始化程序块按它们显示的顺序排列。 8．修饰符：访问修饰符、非访问修饰符 修饰符用来定义类、方法或者变量，通常放在语句的最前端，默认default访问修饰符（1） public/protected/default/private（2） private: 只能通过类中公共的 getter 方法被外部类访问（3） protected: 同一个包中的任何其他类访问，也能够被不同包中的子类访问 public: 如果几个相互访问的 public 类分布在不同的包中，则需要导入相应 public 类所在的包 注意：父类中声明为 public 的方法在子类中也必须为 public。 父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。 父类中声明为 private 的方法，不能够被继承。 非访问修饰符static,abstract,final,synchronized,volatile（1）final：用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。 final 变量：能被显式地初始化并且只能初始化一次。被声明为 final 的对象的引用不能指向不同的对象。但是 final 对象里的数据可以被改变。也就是说 final 对象的引用不能改变，但是里面的值可以改变。final 修饰符通常和 static 修饰符一起使用来创建类常量。 final 方法：类中的 final 方法可以被子类继承，但是不能被子类修改。 final 类：final 类不能被继承，没有类能够继承 final 类的任何特性。 被声明为 final 类的方法自动地声明为 final，但是实例变量并不是 final 在声明时未初始化的静态final变量称为静态空白final变量。 它只能在静态块中初始化。（2）abstract: 抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充一个类不能同时被 abstract 和 final 修饰。抽象方法:是一种没有任何实现的方法，该方法的的具体实现由子类提供。 抽象方法不能被声明成 final 和 static。 任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。 如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。抽象类可以包含抽象方法和非抽象方法。 抽象方法的声明以分号结尾，例如：public abstract sample()。在java中有两种实现抽象的方法，它们分别是： 抽象类(部分) 接口 (完全)抽象类实现了部分抽象(0到100％)，而接口实现了完全抽象(100％)。 9.instanceof: name instanceof String增强for循环：for(声明语句 : 表达式)switch支持字符串，直到break退出 10.装箱/拆箱装箱：int-&gt;number 拆箱：number-&gt;intintValue() valueOf() compareo() equals() parseInt()(string-&gt;int) ceil() floor() random() 11.Character char的包装类isLetter() isDigit() isUpperCase() isWhitespace() toUpperCase() toString() 12.Stringlength() s1.concat(s2) s = format(”—%f %d %s”,floatVar,.,.) charAt(index) int compareo()(对象，字符串)boolean contentEquals(StringBuffer) endsWith() equals() indexOf(ch) split substring 13. StringBuffer/StringBuilder当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。StringBuffer(线程安全) StringBuilder(速度优势,不是线程安全的,不能同步访问) 多数情况下建议使用 StringBuilder 类StringBuffer：append(s) reverse dekete(start,end) replace(start,end,str) capacity() charAt() indexOf() toString substring 14.Arrays数组double[] list = new double[10]; 参数：(int[] array) 返回值：int[]fill sort equals binarySearch 15.Datedate.toString() getime() after before equals compareo format parseSimpleDateFormat(E yyyy-MM-dd HH:mm:ss a zzz) PMSleep(1000*3) Calender.getInstance() 16.正则表达式Pattern Matcher\\s+ 多个空格 ^$ 以什么开始 \\d+多个数字 ()? 0/1 可选 * 0/n +1\\n {n} (n,) &gt;=n . 除\\n\\r之外的任何单个字符[xyz] [^xyz] [a-z] \\b字符边界 17.function重载：方法名相同，参数列表不同构造方法：方法名与类名相同，没有返回值，自定义则默认构造方法失效可变参数：一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明（double… numbers）protected void finalize() 18.BufferReaderread() write() scanner() print() println() 19.I/OFileInputStream FileOutputStream File FileReader FileWrite mkdir mkdirs isDirectory delete() 20.Scanner(System.in)next nextLine 21.Exceptionjava.lang.Exception Error ThrowableIOException RuntimeException 22.面向对象继承extends final修饰的类不能被集成，方法不能被重写 单继承 重写与重载Override(返回值和形参都不能改变) Overload(方法名字相同，而参数不同。返回类型可以相同也可以不同)构造方法不能被重写最常用的地方就是构造器的重载 多态父类指向子类对象 Animal a = new Cat() 实现方式：重写，接口，抽象类和抽象方法 变量不能被重写 抽象类抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。 封装修改属性的可见性来限制对属性的访问（一般限制为private）对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问 接口是抽象方法的集合。有静态、final变量和抽象方法（JAVA8还可以有默认方法，静态方法），接口字段默认是public，static和final，方法默认是public和abstract类描述对象的属性和方法。接口则包含类要实现的方法。除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。接口中的方法会被隐式的指定为 public abstract，接口中的变量会被隐式的指定为 public static final类的多重继承是不合法，但接口允许多重继承 包小写开头使用类全名描述 或 import(import 声明必须在包声明之后，类声明之前) java高级1.一些概念理解JVM(Java虚拟机)一个抽象机器。它是一个提供可以执行Java字节码的运行时环境的规范。JVM执行以下主要任务： 加载代码 验证代码 执行代码 提供运行时环境JRE（Java Runtime Environment）用于提供Java运行时环境。它是JVM的实现。它是实际存在的。它包含一组库和JVM在运行时使用的其他文件。JDK（Java Development Kit）它是实际上存在的。它包含JRE+开发工具。 JDK(JRE(JVM+LIB+OTHER)+IDE)","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://guchunli.github.io/tags/Java/"},{"name":"语法","slug":"语法","permalink":"https://guchunli.github.io/tags/语法/"}]},{"title":"MyEclipse快捷键","date":"2017-06-09T01:33:03.000Z","path":"2017/06/09/MyEclipse快捷键/","text":"1.补全：alt+/2.修复：ctrl+13.删除当前行：ctrl+d4.复制当前行到上一行/下一行：ctrl+alt+上/下方向键5.互换位置：alt+上/下方向键6.上/下一个编辑的页面：alt+左/右方向键7.显示工程文件目录：alt+enter8.当前行插入空行：shift+enter(+ctrl 下一行插入)9.格式化：ctrl+shift+f10.重命名：alt+shift+r11.抽取方法：alt+shift+m12.组织导入（自动加入引用）：ctrl+shift+o13.添加导入：Ctrl+Shift+M14.单步返回 F715.单步跳过 F616.单步跳入 F517.单步跳入选择 Ctrl+F518.调试上次启动 F1119.继续 F8","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://guchunli.github.io/tags/Java/"},{"name":"快捷键","slug":"快捷键","permalink":"https://guchunli.github.io/tags/快捷键/"}]},{"title":"mysql学习笔记","date":"2017-06-08T05:41:17.000Z","path":"2017/06/08/mysql学习笔记/","text":"数据库创建数据库1create database db; 删除数据库1drop database db; 查看数据库1show databases; 使用数据库1use db; 表创建表1234CREATE TABLE db.tb (`id` INT NOT NULL AUTO_INCREMENT,`name` VARCHAR(45) NOT NULL,PRIMARY KEY (`cid`)); 删除表1drop table tb 修改表名12RENAME TABLE tb TO new_tbname;ALTER TABLE tb RENAME TO new_tbname; 初始化表(清空)1TRUNCATE TABLE tb 复制表：1CREATE TABLE tb_name2 SELECT * FROM tb_name; 或者部分复制：1CREATE TABLE tb_name2 SELECT id,name FROM tb_name; 查看数据库中可用的表：1SHOW TABLES; 查看表的结构：12DESCRIBE tb_name;SHOW COLUMNS in tb_name; //from也可以 列/约束ALTER TABLE tb ADD[CHANGE,RENAME,DROP] 增加列/约束1alter table tb add column name VARCHAR(45) not null after id,add primary key(id); 删除列/约束1alter table tb drop col2 drop primary key(id); 修改列/约束ALTER TABLE tb MODIFY col2 int NOT NULL DEFAULT 100 add col1 int identity(1,1);ALTER TABLE tb ALTER col2 SET DEFAULT 1000;ALTER TABLE tb ALTER col2 DROP DEFAULT; 约束primary key,not null,unique,asc/desc/default 0/AUTO_INCREMENT/zerofill 单表操作插入1insert into tb(col1,col2) values(value1,value2) 删除1delete from tb [WHERE Clause] 更新1update tb set col1=value1 [WHERE Clause] 使用MySQL执行update的时候报错：1Error Code: 1175. You are using safe update mode and you tried to update a table without a WHERE that uses a KEY column To disable safe mode, toggle the option in Preferences -&gt; SQL Queries and reconnect. 解决方法：执行命令 SET SQL_SAFE_UPDATES = 0; //修改下数据库模式如果想要提高数据库安全等级，可以在恢复回原有的设置，执行命令：SET SQL_SAFE_UPDATES = 1; 查找1select * from tb [WHERE Clause] where =、&gt;、&lt;、&lt;&gt; and/not and or is null/is not null 分组查询：order by/group by/having 1select * from tb order by col1,col2 asc/desc like 123SELECT field1, field2,...fieldN FROM tbWHERE field1 LIKE condition1 [AND [OR]] filed2 = &apos;somevalue&apos; in/not in 1select * from tb1 where a [not] in (value1,value2,value3) between/not between exists/not exists 全选/全不选where 1=1 表示选择全部where 1=2 表示全部不选， 分页 1234declare @start int,@end int@sql nvarchar(600)set @sql=’select top’+str(@end-@start+1)+’+from T where rid not in(select top’+str(@str-1)+’Rid from T where Rid&gt;-1)’exec sp_executesql @sql 删除重复记录 12341),delete from tablename where id not in (select max(id) from tablename group by col1,col2,...)2),select distinct * into temp from tablenamedelete from tablenameinsert into tablename select * from temp 列出数据库里所有的表名 1select name from sysobjects where type=&apos;U&apos; // U代表用户 列出表里的所有的列名 123select name from syscolumns where id=object_id(&apos;TableName&apos;)select column_name,data_type from information_schema.columnswhere table_name = &apos;表名&apos; //查询某一个表的字段和数据类型 获取当前数据库中的所有用户表 1select Name from sysobjects where xtype=&apos;u&apos; and status&gt;=0 多表操作union通过组合其他两个结果表（例如 TABLE1 和 TABLE2）并消去表中任何重复行而派生出一个结果表。当 ALL 随 UNION 一起使用时（即 UNION ALL），不消除重复行。两种情况下，派生表的每一行不是来自 TABLE1 就是来自 TABLE2。12345678910SELECT expression1, expression2, ... expression_nFROM tb1[WHERE conditions]UNION [ALL | DISTINCT]SELECT expression1, expression2, ... expression_nFROM tb2[WHERE conditions];DISTINCT: 可选，删除结果集中重复的数据。默认情况下 UNION 操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没啥影响。ALL: 可选，返回所有结果集，包含重复数据。 EXCEPT通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个结果表。当 ALL 随 EXCEPT 一起使用时 (EXCEPT ALL)，不消除重复行。 INTERSECT通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表。当 ALL 随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。 注：使用运算词的几个查询结果行必须是一致的。 分组：group bycount,sum,max,min,avg 连接：join INNER JOIN（内连接,或等值连接）：获取两个表中字段匹配关系的记录。 12345SELECT a.col1, a.col2, b.col3 FROM tb1 a INNER JOIN tb2 bON a.col1 = b.col1;等价于SELECT a.col1, a.col2, b.col3 FROM tb1 a, tb2 b WHERE a.col1 = b.col1; LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。 12SELECT a.col1, a.col2, b.col3 FROM tb1 a LEFT JOIN tb2 b ON a.col1 = b.col1; RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。 12SELECT a.col1, a.col2, b.col3 FROM tb1 a RIGHT JOIN tb2 b ON a.col1 = b.col1; 高级用法索引临时表视图","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://guchunli.github.io/tags/Java/"},{"name":"mysql","slug":"mysql","permalink":"https://guchunli.github.io/tags/mysql/"}]},{"title":"Java搭建springMVC项目笔记","date":"2017-06-08T01:44:19.000Z","path":"2017/06/08/Java搭建springMVC项目笔记/","text":"MyEclipse搭建项目 创建命名空间namespace 新建项目 new -&gt; project 添加tomcat,jdk 运行 访问：http://localhost:8080/project_name/ 12345...nested exception is org.springframework.core.NestedIOException: ASM ClassReader failed to parse class file - probably due to a new Java class file version that isn&apos;t supported yet...nested exception is java.lang.IllegalArgumentException... 解决方法：在项目上右键–properties–java Compile–compiler compliance level 在工程目录下添加config文件夹，下面添加文件：jdbc.properties,spring-mvc.xml,spring-mybatis.xml jdbc.properties：mysql配置 spring-mvc.xml context -&gt; base-package: 包的跟路径 bean -&gt; prefix: /WEB-INF/page/下放.jsp文件 mvc -&gt; bean: utl 的根路径 spring-mybatis.xml: context -&gt; base-package: 包的根路径 bean -&gt; base-package: dao的根路径 aop -&gt; expression: service的根路径","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://guchunli.github.io/tags/Java/"},{"name":"springMVC","slug":"springMVC","permalink":"https://guchunli.github.io/tags/springMVC/"},{"name":"项目","slug":"项目","permalink":"https://guchunli.github.io/tags/项目/"}]},{"title":"java开发环境配置","date":"2017-06-06T03:27:51.000Z","path":"2017/06/06/java开发环境配置/","text":"Java开发需要：1.JDK (Java Deverlopment Kit)Java开发工具包(JDK)是一个用于开发Java应用程序和小程序的软件开发环境。它包括Java运行时环境(JRE)，编译器/加载程序(JAVA)，编译器(javac)，归档器(jar)，文档生成(Javadoc)以及 Java 开发的其他工具。2.IDE (Integrated Development Environment)集成开发环境：MyEclipse,IDEA tomcat1.下载：http://tomcat.apache.org2.修改权限，否则会提示permission denny错误：1sudo chmod 755 xxx/bin/*.sh (xxx表示你tomcat放至的路径) 3.将Tomcat写入系统的环境变量PATH中。1$ pico .bash_profile 在打开的页面中，输入以下：12export PATH=$PATH:tomcat_dir/bin; export PATH=$PATH:tomcat_dir/logs; 其中tomcat_dir为tomcat根目录接着按下 control+x，再按 y 表示确定修改，最后回车。 验证是否成功 $ echo $PATH显示如下:$ -bash: /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Users/fuhua/Documents/Tomcat/apache-tomcat-8.0.30/bin: No such file or directory需要重新启动计算机，以便完成系统环境变量的配置。 4.启动Tomcat. 如果你完成将Tomcat写入系统的环境变量PATH中，你可以直接在终端输入 startup.sh ； 如果你没有完成，那么就要定位到Tomcat的bin目录中，如在终端输入 123$ cd tomcat_dir/bin$ startup.shTomcat started. 在浏览器中输入http://localhost:8080/如果出现Apache Tomcat界面，代表 tomcat 启动成功。 MySQL安装MySQL 下载：MySQL官网 安装完成时记得保存弹出框中的密码，这是mysql root账号和密码 系统偏好设置中，点击MySQL开启MySQL Server服务修改root账户密码 关闭MySQL Server服务 终端输入12345678910111213141516171819202122232425262728// 苹果系统下 mysql server 的安装地址$ cd /usr/local/mysql/bin/// 登录管理员权限$ sudo su// 禁止 mysql 验证功能sh-3.2# ./mysqld_safe --skip-grant-tables &amp;//终端输出[1] 2487sh-3.2# Logging to &apos;/usr/local/mysql-5.7.18-macos10.12-x86_64/data/192.168.1.143.err&apos;.2017-06-06T06:35:36.6NZ mysqld_safe Starting mysqld daemon with databases from /usr/local/mysql-5.7.18-macos10.12-x86_64/datash-3.2# ./mysqlWelcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 3Server version: 5.7.18 MySQL Community Server (GPL)Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\\h&apos; for help. Type &apos;\\c&apos; to clear the current input statement.mysql&gt; FLUSH PRIVILEGES;Query OK, 0 rows affected (0.00 sec)mysql&gt; SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos; = PASSWORD(&apos;123456&apos;);Query OK, 0 rows affected, 1 warning (0.00 sec) 安装MySQL Workbenchhttps://dev.mysql.com/downloads/workbench/MySQL connections + ：输入connection name创建新链接 加入系统环境变量12345678910111213141516171819$ cd /usr/local/mysql/bin$ ls//查看目录中是否有mysql$ vim ~/.bash_profile//在该文件中添加 PATH=$PATH:/usr/local/mysql/bin$ source ~/.bash_profile$ mysql -uroot -p //登录mysql//输入密码后，登录成功会显示：Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 22Server version: 5.7.18 MySQL Community Server (GPL)Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\\h&apos; for help. Type &apos;\\c&apos; to clear the current input statement. 可以通过以下名录修改密码： $ $ SET PASSWORD FOR ‘root’@’localhost’ = PASSWORD(‘newpass’); JDK安装JDK下载：JDK官网安装 mac自带jdk，安装目录：/System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home 自己安装目录：/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home配置jdk环境变量\u0010\u0010（1）只针对当前用户12$ touch ~/.bash_profile $ vim ~/.bash_profile 在编辑器中添加如下内容：123456JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/HomeCLASSPAHT=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarPATH=$JAVA_HOME/bin:$PATH:export JAVA_HOMEexport CLASSPATHexport PATH 使系统变量生效，使用以下命令或重启电脑：1$ source .bash_profile 查看java版本：1$ java -version 检查系统变量是否生效：1$ echo $JAVA_HOME （2）针对所有用户12$ cd /etc$ sudo vi profile 在编辑器最下面添加如下内容：123JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/HomeCLASSPAHT=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarPATH=$JAVA_HOME/bin:$PATH: 接下来同上：123$ source .bash_profile$ java -version$ echo $JAVA_HOME","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://guchunli.github.io/tags/Java/"},{"name":"web","slug":"web","permalink":"https://guchunli.github.io/tags/web/"}]},{"title":"iOS调试与性能优化学习笔记","date":"2017-06-05T10:31:25.000Z","path":"2017/06/05/iOS调试与性能优化学习笔记/","text":"Analyze 静态内存分析：指在程序未运行时，通过工具对代码直接进行分析，根据代码的上下文语法结构，让编译器分析内存情况，检查是否有内存泄露。Analyze主要分析四种问题 1.逻辑错误：访问空指针或未初始化的变量等，建议在声明变量时，同时进行初始化。（len is a garbage value。） 2.内存管理错误：如内存泄露等（Potential leak of an object stored into ‘XXX’。） 3.声明错误：创建了对象但未使用（Unused、Never read….） 4.API调用错误：未包含使用的库或框架 Instruments1.Time Profile1.1 在底部的Call Tree中勾选： Seperate by state： Separate by Thread（建议选择）：按照线程分类查看结果 Invert Call Tree（不建议选择）：反向输出调用树，把调用层级最深的方法显示在最上面，如果想要查看哪个方法调用为最深时使用。 Hide system Libraries（建议选择）：隐藏系统函数，选上后只会展示与应用有关的符号信息。 Flatten Recursion（一般不选）：拼合递归，把同一递归函数产生的多条堆栈合并为一条 Top Functions（可选）：选上后会将最耗时的函数降序排列，比如A调用了B，A的耗时时间是会包含B的耗时。 1.2 配置项目scheme-&gt;profile-&gt;Build Configuration：Debugproject-&gt;debug information format-&gt;debug：DWARF with dSYM File 1.3 运行项目在time profiler中，选择对应的device和process，点击红色按钮运行APP。 可以拖动时间轴查看其中一段时间的CPU使用情况 可以点击weight，按照时间消耗进行排序选择真机运行APP，模拟器使用的是电脑的CPU 2.内存泄露 Leaks3.僵尸对象 Zoombies4.被遗弃的内存 Generational Analysis5.Allocations6.Energy Log断点Exception Breakpoint1.异常断点：项目crash时，添加异常断点运行，会定位到出错的代码行 2.条件断点 condational 3.符号断点 symbolic -[NSObject(NSObject) doesNotRecognizeSelector:]4.NSLog5.僵尸对象6.lldb LLVM GCC:p po expr callimage lookup –address 0x0000000100004af87.instruments-profile:analyze：发现release问题，以及继承过程中的父类方法缺失等leaks:自动加载Allocations，监控程序运行过程中的内存变化《How to Use Instruments in Xcode》： https://www.raywenderlich.com/97886/instruments-tutorial-with-swift-getting-started《与调试器共舞 - LLDB 的华尔兹》：https://objccn.io/issue-19-2/《LLDB调试命令初探》：http://www.starfelix.com/blog/2014/03/17/lldbdiao-shi-ming-ling-chu-tan/《The LLDB Debugger》：http://lldb.llvm.org/tutorial.html《About LLDB and Xcode》：https://developer.apple.com/library/mac/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/Introduction.htmlhttp://www.cnblogs.com/daiweilai/p/4234336.html8.Debug View Hierarchy9.预编译指令123456789101112//swift#if DEBUGfunc dlog&lt;T&gt;(object: T) &#123;println(object)&#125;#elsefunc dlog&lt;T&gt;(object: T) &#123;&#125;#endif#warning#error#pragma message","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"待补充","slug":"待补充","permalink":"https://guchunli.github.io/tags/待补充/"},{"name":"优化","slug":"优化","permalink":"https://guchunli.github.io/tags/优化/"}]},{"title":"798艺术区","date":"2017-06-04T07:30:49.000Z","path":"2017/06/04/798艺术区/","text":"2017-06-04 北京798艺术区抽象画各种小陶瓷 猫咪，卡哇伊 brain red people 未名 孤独的小孩 恋人","comments":true,"categories":[{"name":"随笔","slug":"other","permalink":"https://guchunli.github.io/categories/other/"}],"tags":[{"name":"798","slug":"798","permalink":"https://guchunli.github.io/tags/798/"}]},{"title":"MVVM学习笔记","date":"2017-05-20T03:38:51.000Z","path":"2017/05/20/MVVM学习笔记/","text":"MVVM的四个组件： view ：由 MVC 中的 view 和 controller 组成，负责 UI 的展示，绑定 viewModel 中的属性，触发 viewModel 中的命令； viewModel ：从 MVC 的 controller 中抽取出来的展示逻辑，负责从 model 中获取 view 所需的数据，转换成 view 可以展示的数据，并暴露公开的属性和命令供 view 进行绑定； model ：与 MVC 中的 model 一致，包括数据模型、访问数据库的操作和网络请求等； binder ：在 MVVM 中，声明式的数据和命令绑定是一个隐含的约定，它可以让开发者非常方便地实现 view 和 viewModel 的同步，避免编写大量繁杂的样板化代码。在微软的 MVVM 实现中，使用的是一种被称为 XAML 的标记语言。总结：在 iOS 的 MVVM 实现中，我们可以使用 RAC 来在 view 和 viewModel 之间充当 binder 的角色，优雅地实现两者之间的同步。此外，我们还可以把 RAC 用在 model 层，使用 Signal 来代表异步的数据获取操作，比如读取文件、访问数据库和网络请求等。 实现MVC到MVVM的转变 将 MVC 中的 controller 中的展示逻辑抽取出来，放置到 viewModel 中，然后通过一定的技术手段，比如 RAC 来同步 view 和 viewModel。 MVVM相较于MVM的优势 由于展示逻辑被抽取到了 viewModel 中，所以 view 中的代码将会变得非常轻量级； 由于 viewModel 中的代码是与 UI 无关的，所以它具有良好的可测试性； 对于一个封装了大量业务逻辑的 model 来说，改变它可能会比较困难，并且存在一定的风险。在这种场景下，viewModel 可以作为 model 的适配器使用，从而避免对 model 进行较大的改动。 参考链接：MVVM With ReactiveCocoa","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"MVVM","slug":"MVVM","permalink":"https://guchunli.github.io/tags/MVVM/"}]},{"title":"ReactiveCocoa学习笔记","date":"2017-05-20T02:31:47.000Z","path":"2017/05/20/ReactiveCocoa学习笔记/","text":"ReactiveCocoa(RAC):是函数响应式编程(Functional Reactive Programming:FRP)框架，高聚合、低耦合思想。使用cocoapods导入时加上use_frameworks! ReactiveCocoa常见类RACSiganl:信号类(核心)一般表示将来有数据传递，只要有数据改变，信号内部接收到数据，就会马上发出数据。 注意： 信号类(RACSiganl)，只是表示当数据改变时，信号内部会发出数据，它本身不具备发送信号的能力，而是交给内部一个订阅者去发出。 默认一个信号都是冷信号，也就是值改变了，也不会触发，只有订阅了这个信号，这个信号才会变为热信号，值改变了才会触发。 如何订阅信号：调用信号RACSignal的subscribeNext就能订阅。 RACSiganl简单使用 1.创建信号 1$ + (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe 2.订阅信号,才会激活信号. 1$ - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock 3.发送信号 1$ - (void)sendNext:(id)value RACSignal底层实现 1.创建信号，首先把didSubscribe保存到信号中，还不会触发。 2.当信号被订阅，也就是调用signal的subscribeNext:nextBlock 2.1 subscribeNext内部会创建订阅者subscriber，并且把nextBlock保存到subscriber中。 2.2 subscribeNext内部会调用signal的didSubscribe 3.siganl的didSubscribe中调用[subscriber sendNext:@1]; 3.1 sendNext底层其实就是执行subscriber的nextBlock1234567891011121314151617181920// 1.创建信号RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; // block调用时刻：每当有订阅者订阅信号，就会调用block。 // 2.发送信号 [subscriber sendNext:@1]; // 如果不在发送数据，最好发送信号完成，内部会自动调用[RACDisposable disposable]取消订阅信号。 [subscriber sendCompleted]; return [RACDisposable disposableWithBlock:^&#123; // block调用时刻：当信号发送完成或者发送错误，就会自动执行这个block,取消订阅信号。 // 执行完Block后，当前信号就不在被订阅了。 NSLog(@&quot;信号被销毁&quot;); &#125;];&#125;];// 3.订阅信号,才会激活信号.[siganl subscribeNext:^(id x) &#123; // block调用时刻：每当有信号发出数据，就会调用block. NSLog(@&quot;接收到数据:%@&quot;,x);&#125;]; RACSubscriber表示订阅者的意思，用于发送信号，这是一个协议，不是一个类，只要遵守这个协议，并且实现方法才能成为订阅者。通过create创建的信号，都有一个订阅者，帮助他发送数据。 RACDisposable 用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。 使用场景:不想监听某个信号时，可以通过它主动取消订阅信号。 RACSubject 信号提供者，自己可以充当信号，又能发送信号。 使用场景:通常用来代替代理，有了它，就不必要定义代理了。 RACSubject:底层实现和RACSignal不一样。 1.调用subscribeNext订阅信号，只是把订阅者保存起来，并且订阅者的nextBlock已经赋值了。 2.调用sendNext发送信号，遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。 RACSubject使用步骤: 1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。 2.订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock 3.发送信号 sendNext:(id)value123456789101112131415// 1.创建信号RACSubject *subject = [RACSubject subject];// 2.订阅信号[subject subscribeNext:^(id x) &#123;// block调用时刻：当信号发出新值，就会调用.NSLog(@&quot;第一个订阅者%@&quot;,x);&#125;];[subject subscribeNext:^(id x) &#123;// block调用时刻：当信号发出新值，就会调用.NSLog(@&quot;第二个订阅者%@&quot;,x);&#125;];// 3.发送信号[subject sendNext:@&quot;1&quot;]; RACSubject替换代理需求:1.给当前控制器添加一个按钮，modal到另一个控制器界面2.另一个控制器view中有个按钮，点击按钮，通知当前控制器 步骤一：在第二个控制器.h，添加一个RACSubject代替代理。 123@interface TwoViewController : UIViewController@property (nonatomic, strong) RACSubject *delegateSignal;@end 步骤二：监听第二个控制器按钮点击 123456789101112@implementation TwoViewController- (IBAction)notice:(id)sender &#123;// 通知第一个控制器，告诉它，按钮被点了// 通知代理// 判断代理信号是否有值if (self.delegateSignal) &#123; // 有值，才需要通知 [self.delegateSignal sendNext:nil]; &#125;&#125;@end 步骤三：在第一个控制器中，监听跳转按钮，给第二个控制器的代理信号赋值，并且监听. 1234567891011121314@implementation OneViewController - (IBAction)btnClick:(id)sender &#123; // 创建第二个控制器 TwoViewController *twoVc = [[TwoViewController alloc] init]; // 设置代理信号 twoVc.delegateSignal = [RACSubject subject]; // 订阅代理信号 [twoVc.delegateSignal subscribeNext:^(id x) &#123; NSLog(@&quot;点击了通知按钮&quot;); &#125;]; // 跳转到第二个控制器 [self presentViewController:twoVc animated:YES completion:nil];&#125;@end RACReplaySubject重复提供信号类，是RACSubject的子类。RACReplaySubject与RACSubject区别: RACReplaySubject可以先发送信号，在订阅信号，RACSubject就不可以。 使用场景一:如果一个信号每被订阅一次，就需要把之前的值重复发送一遍，使用重复提供信号类。 使用场景二:可以设置capacity数量来限制缓存的value的数量,即只缓充最新的几个值。RACReplaySubject:底层实现和RACSubject不一样。 1.调用sendNext发送信号，把值保存起来，然后遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。 2.调用subscribeNext订阅信号，遍历保存的所有值，一个一个调用订阅者的nextBlock注意：如果想当一个信号被订阅，就重复播放之前所有值，需要先发送信号，在订阅信号。也就是先保存值，在订阅值。RACReplaySubject使用步骤: 1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。 2.可以先订阅信号，也可以先发送信号。 2.1 订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock 2.2 发送信号 sendNext:(id)value12345678910111213141516// 1.创建信号RACReplaySubject *replaySubject = [RACReplaySubject subject];// 2.发送信号[replaySubject sendNext:@1];[replaySubject sendNext:@2];// 3.订阅信号[replaySubject subscribeNext:^(id x) &#123; NSLog(@&quot;第一个订阅者接收到的数据%@&quot;,x);&#125;];// 订阅信号[replaySubject subscribeNext:^(id x) &#123; NSLog(@&quot;第二个订阅者接收到的数据%@&quot;,x);&#125;]; RACTuple元组类,类似NSArray,用来包装值. RACSequenceRAC中的集合类，用于代替NSArray,NSDictionary,可以使用它来快速遍历数组和字典。使用场景：字典转模型RACSequence和RACTuple简单使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 1.遍历数组NSArray *numbers = @[@1,@2,@3,@4];// 第一步: 把数组转换成集合RACSequence numbers.rac_sequence// 第二步: 把集合RACSequence转换RACSignal信号类,numbers.rac_sequence.signal// 第三步: 订阅信号，激活信号，会自动把集合中的所有值，遍历出来。[numbers.rac_sequence.signal subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x);&#125;];// 2.遍历字典,遍历出来的键值对会包装成RACTuple(元组对象)NSDictionary *dict = @&#123;@&quot;name&quot;:@&quot;zs&quot;,@&quot;age&quot;:@18&#125;;[dict.rac_sequence.signal subscribeNext:^(RACTuple *x) &#123;// 解包元组，会把元组的值，按顺序给参数里面的变量赋值RACTupleUnpack(NSString *key,NSString *value) = x; // 相当于以下写法 // NSString *key = x[0]; // NSString *value = x[1]; NSLog(@&quot;%@ %@&quot;,key,value);&#125;];// 3.字典转模型// 3.1 OC写法NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;flags.plist&quot; ofType:nil];NSArray *dictArr = [NSArray arrayWithContentsOfFile:filePath];NSMutableArray *items = [NSMutableArray array];for (NSDictionary *dict in dictArr) &#123; FlagItem *item = [FlagItem flagWithDict:dict]; [items addObject:item];&#125;// 3.2 RAC写法NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;flags.plist&quot; ofType:nil];NSArray *dictArr = [NSArray arrayWithContentsOfFile:filePath];NSMutableArray *flags = [NSMutableArray array];_flags = flags;// rac_sequence注意点：调用subscribeNext，并不会马上执行nextBlock，而是会等一会。[dictArr.rac_sequence.signal subscribeNext:^(id x) &#123; // 运用RAC遍历字典，x：字典 FlagItem *item = [FlagItem flagWithDict:x]; [flags addObject:item];&#125;];NSLog(@&quot;%@&quot;, NSStringFromCGRect([UIScreen mainScreen].bounds));// 3.3 RAC高级写法:NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;flags.plist&quot; ofType:nil];NSArray *dictArr = [NSArray arrayWithContentsOfFile:filePath];// map:映射的意思，目的：把原始值value映射成一个新值// array: 把集合转换成数组// 底层实现：当信号被订阅，会遍历集合中的原始值，映射成新值，并且保存到新的数组里。NSArray *flags = [[dictArr.rac_sequence map:^id(id value) &#123; return [FlagItem flagWithDict:value];&#125;] array]; RACCommandRAC中用于处理事件的类，可以把事件如何处理,事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。使用场景:监听按钮点击，网络请求 RACCommand使用步骤: 1.创建命令 initWithSignalBlock:(RACSignal * (^)(id input))signalBlock 2.在signalBlock中，创建RACSignal，并且作为signalBlock的返回值 3.执行命令 - (RACSignal *)execute:(id)input RACCommand使用注意 1.signalBlock必须要返回一个信号，不能传nil. 2.如果不想要传递信号，直接创建空的信号[RACSignal empty]; 3.RACCommand中信号如果数据传递完，必须调用[subscriber sendCompleted]，这时命令才会执行完毕，否则永远处于执行中。 4.RACCommand需要被强引用，否则接收不到RACCommand中的信号，因此RACCommand中的信号是延迟发送的。 RACCommand设计思想：内部signalBlock为什么要返回一个信号，这个信号有什么用。 1.在RAC开发中，通常会把网络请求封装到RACCommand，直接执行某个RACCommand就能发送请求。 2.当RACCommand内部请求到数据的时候，需要把请求的数据传递给外界，这时候就需要通过signalBlock返回的信号传递了。 如何拿到RACCommand中返回信号发出的数据。 1.RACCommand有个执行信号源executionSignals，这个是signal of signals(信号的信号),意思是信号发出的数据是信号，不是普通的类型。 2.订阅executionSignals就能拿到RACCommand中返回的信号，然后订阅signalBlock返回的信号，就能获取发出的值。 五、监听当前命令是否正在执行executing 六、使用场景,监听按钮点击，网络请求 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 1.创建命令RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) &#123; NSLog(@&quot;执行命令&quot;); // 创建空信号,必须返回信号 // return [RACSignal empty]; // 2.创建信号,用来传递数据 return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;请求数据&quot;]; // 注意：数据传递完，最好调用sendCompleted，这时命令才执行完毕。 [subscriber sendCompleted]; return nil; &#125;];&#125;];// 强引用命令，不要被销毁，否则接收不到数据_conmmand = command;// 3.订阅RACCommand中的信号[command.executionSignals subscribeNext:^(id x) &#123; [x subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x); &#125;];&#125;];// RAC高级用法// switchToLatest:用于signal of signals，获取signal of signals发出的最新信号,也就是可以直接拿到RACCommand中的信号[command.executionSignals.switchToLatest subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x);&#125;];// 4.监听命令是否执行完毕,默认会来一次，可以直接跳过，skip表示跳过第一次信号。[[command.executing skip:1] subscribeNext:^(id x) &#123; if ([x boolValue] == YES) &#123; // 正在执行 NSLog(@&quot;正在执行&quot;); &#125;else&#123; // 执行完成 NSLog(@&quot;执行完成&quot;); &#125;&#125;];// 5.执行命令[self.conmmand execute:@1]; RACMulticastConnection用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。注意:RACMulticastConnection通过RACSignal的-publish或者-muticast:方法创建. RACMulticastConnection使用步骤: 1.创建信号 + (RACSignal )createSignal:(RACDisposable (^)(id subscriber))didSubscribe 2.创建连接 RACMulticastConnection *connect = [signal publish]; 3.订阅信号,注意：订阅的不在是之前的信号，而是连接的信号。 [connect.signal subscribeNext:nextBlock] 4.连接 [connect connect] RACMulticastConnection底层原理: 1.创建connect，connect.sourceSignal -&gt; RACSignal(原始信号) connect.signal -&gt; RACSubject 2.订阅connect.signal，会调用RACSubject的subscribeNext，创建订阅者，而且把订阅者保存起来，不会执行block。 3.[connect connect]内部会订阅RACSignal(原始信号)，并且订阅者是RACSubject 3.1.订阅原始信号，就会调用原始信号中的didSubscribe 3.2 didSubscribe，拿到订阅者调用sendNext，其实是调用RACSubject的sendNext 4.RACSubject的sendNext,会遍历RACSubject所有订阅者发送信号。 4.1 因为刚刚第二步，都是在订阅RACSubject，因此会拿到第二步所有的订阅者，调用他们的nextBlock 需求：假设在一个信号中发送请求，每次订阅一次都会发送请求，这样就会导致多次请求。解决：使用RACMulticastConnection就能解决. 123456789101112131415// 1.创建请求信号RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@&quot;发送请求&quot;); return nil;&#125;];// 2.订阅信号[signal subscribeNext:^(id x) &#123; NSLog(@&quot;接收数据&quot;);&#125;];// 2.订阅信号[signal subscribeNext:^(id x) &#123; NSLog(@&quot;接收数据&quot;);&#125;];// 3.运行结果，会执行两遍发送请求，也就是每次订阅都会发送一次请求 RACMulticastConnection:解决重复请求问题 12345678910111213141516171819202122// 1.创建信号RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@&quot;发送请求&quot;); [subscriber sendNext:@1]; return nil;&#125;];// 2.创建连接RACMulticastConnection *connect = [signal publish];// 3.订阅信号，// 注意：订阅信号，也不能激活信号，只是保存订阅者到数组，必须通过连接,当调用连接，就会一次性调用所有订阅者的sendNext:[connect.signal subscribeNext:^(id x) &#123; NSLog(@&quot;订阅者一信号&quot;);&#125;];[connect.signal subscribeNext:^(id x) &#123; NSLog(@&quot;订阅者二信号&quot;);&#125;];// 4.连接,激活信号[connect connect]; RACSchedulerRAC中的队列，用GCD封装的。 RACUnit表⽰stream不包含有意义的值,也就是看到这个，可以直接理解为nil. RACEvent把数据包装成信号事件(signal event)。它主要通过RACSignal的-materialize来使用，然并卵。 ReactiveCocoa开发中常见用法。代替代理rac_signalForSelector：用于替代代理。 代替KVOrac_valuesAndChangesForKeyPath：用于监听某个对象的属性改变。 监听事件rac_signalForControlEvents：用于监听某个事件。 代替通知rac_addObserverForName:用于监听某个通知。 监听文本框文字改变rac_textSignal:只要文本框发出改变就会发出这个信号。 处理当界面有多次请求时，需要都获取到数据时，才能展示界面rac_liftSelector:withSignalsFromArray:Signals:当传入的Signals(信号数组)，每一个signal都至少sendNext过一次，就会去触发第一个selector参数的方法。使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据。代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 1.代替代理// 需求：自定义redView,监听红色view中按钮点击// 之前都是需要通过代理监听，给红色View添加一个代理属性，点击按钮的时候，通知代理做事情// rac_signalForSelector:把调用某个对象的方法的信息转换成信号，就要调用这个方法，就会发送信号。// 这里表示只要redV调用btnClick:,就会发出信号，订阅就好了。[[redV rac_signalForSelector:@selector(btnClick:)] subscribeNext:^(id x) &#123; NSLog(@&quot;点击红色按钮&quot;);&#125;];// 2.KVO// 把监听redV的center属性改变转换成信号，只要值改变就会发送信号// observer:可以传入nil[[redV rac_valuesAndChangesForKeyPath:@&quot;center&quot; options:NSKeyValueObservingOptionNew observer:nil] subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x);&#125;];// 3.监听事件// 把按钮点击事件转换为信号，点击按钮，就会发送信号[[self.btn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) &#123; NSLog(@&quot;按钮被点击了&quot;);&#125;];// 4.代替通知// 把监听到的通知转换信号[[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIKeyboardWillShowNotification object:nil] subscribeNext:^(id x) &#123; NSLog(@&quot;键盘弹出&quot;);&#125;];// 5.监听文本框的文字改变[_textField.rac_textSignal subscribeNext:^(id x) &#123; NSLog(@&quot;文字改变了%@&quot;,x);&#125;];// 6.处理多个请求，都返回结果的时候，统一做处理.RACSignal *request1 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;// 发送请求1[subscriber sendNext:@&quot;发送请求1&quot;]; return nil;&#125;];RACSignal *request2 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; // 发送请求2 [subscriber sendNext:@&quot;发送请求2&quot;]; return nil;&#125;];// 使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据。[self rac_liftSelector:@selector(updateUIWithR1:r2:) withSignalsFromArray:@[request1,request2]];&#125;// 更新UI- (void)updateUIWithR1:(id)data r2:(id)data1&#123; NSLog(@&quot;更新UI%@ %@&quot;,data,data1);&#125; ReactiveCocoa常见宏RAC(TARGET, [KEYPATH, [NIL_VALUE]])用于给某个对象的某个属性绑定。12// 只要文本框文字改变，就会修改label的文字RAC(self.labelView,text) = _textField.rac_textSignal; RACObserve(self, name)监听某个对象的某个属性,返回的是信号。123[RACObserve(self.view, center) subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x);&#125;]; @weakify(Obj)和@strongify(Obj)一般两个都是配套使用,在主头文件(ReactiveCocoa.h)中并没有导入，需要自己手动导入，RACEXTScope.h才可以使用。但是每次导入都非常麻烦，只需要在主头文件自己导入就好了。 RACTuplePack把数据包装成RACTuple（元组类）12// 把参数中的数据包装成元组RACTuple *tuple = RACTuplePack(@10,@20); RACTupleUnpack：把RACTuple（元组类）解包成对应的数据。123456// 把参数中的数据包装成元组RACTuple *tuple = RACTuplePack(@&quot;abc&quot;,@20);// 解包元组，会把元组的值，按顺序给参数里面的变量赋值// name = @&quot;abc&quot; age = @20RACTupleUnpack(NSString *name,NSNumber *age) = tuple; 原文链接：最快让你上手ReactiveCocoa之基础篇","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"RAC","slug":"RAC","permalink":"https://guchunli.github.io/tags/RAC/"}]},{"title":"iOS多媒体学习笔记","date":"2017-05-06T03:41:05.000Z","path":"2017/05/06/iOS多媒体学习笔记/","text":"音频音效 AudioToolbox.framework限制： 音频播放时间不能超过30s 数据必须是PCM或者IMA4格式 音频文件必须打包成.caf、.aif、.wav中的一种（注意这是官方文档的说法，实际测试发现一些.mp3也可以播放） 音乐 AVAudioPlayerAVFoundation.framework中的AVAudioPlayerAVAudioPlayer可以看成一个播放器，它支持多种音频格式，而且能够进行进度、音量、播放速度等控制。AVAudioPlayer使用： 初始化AVAudioPlayer对象，此时通常指定本地文件路径。 设置播放器属性，例如重复次数、音量大小等。 调用play方法播放。 MPMusicPlayerController音频会话 AVAudioSession支持后台播放： 1.设置后台运行模式：在plist文件中添加Required background modes，并且设置item 0=App plays audio or streams audio/video using AirPlay（其实可以直接通过Xcode在Project Targets-Capabilities-Background Modes中设置） 2.设置AVAudioSession的类型为AVAudioSessionCategoryPlayback并且调用setActive::方法启动会话。 123AVAudioSession *audioSession=[AVAudioSession sharedInstance];[audioSession setCategory:AVAudioSessionCategoryPlayback error:nil];[audioSession setActive:YES error:nil]; 3.为了能够让应用退到后台之后支持耳机控制，建议添加远程控制事件（这一步不是后台播放必须的）在iOS中每个应用都有一个音频会话，这个会话就通过AVAudioSession来表示。AVAudioSession同样存在于AVFoundation框架中，它是单例模式设计，通过sharedInstance进行访问。在使用Apple设备时大家会发现有些应用只要打开其他音频播放就会终止，而有些应用却可以和其他应用同时播放，在多种音频环境中如何去控制播放的方式就是通过音频会话来完成的。 音频队列服务（Audio Queue Services） AVAudioPlayer只能播放本地文件，并且是一次性加载所以音频数据，初始化AVAudioPlayer时指定的URL也只能是File URL而不能是HTTP URL。 AudioToolbox框架中的音频队列服务Audio Queue Services，支持网络流媒体播放。 FSAudioStream录音AVAudioRecorderAVFoundation框架中的AVAudioRecorder类info.plist 添加 NSMicrophoneUsageDescription 音频队列服务（Audio Queue Services）视频播放MPMoviePlayerControllerMediaPlayer.framework种的MPMoviePlayerController类，它支持本地视频和网络视频播放，如果要在UI中展示视频需要将view属性添加到界面中。 MPMoviePlayerViewController默认全屏播放，开发者在开发的时候直接使用这个视图控制器。注意：由于MPMoviePlayerViewController的初始化方法做了大量工作（例如设置URL、自动播放、添加点击Done完成的监控等），所以当再次点击播放弹出新的模态窗口的时如果不销毁之前的MPMoviePlayerViewController，那么新的对象就无法完成初始化，这样也就不能再次进行播放。 AVPlayerAVPlayer存在于AVFoundation中，它更加接近于底层，所以灵活性也更强。AVPlayer本身并不能显示视频，而且它也不像MPMoviePlayerController有一个view属性。如果AVPlayer要显示必须创建一个播放器层AVPlayerLayer用于展示，播放器层继承于CALayer，有了AVPlayerLayer之添加到控制器视图的layer中即可。几个相关类： AVAsset：主要用于获取多媒体信息，是一个抽象类，不能直接使用。 AVURLAsset：AVAsset的子类，可以根据一个URL路径创建一个包含媒体信息的AVURLAsset对象。 AVPlayerItem：一个媒体资源管理对象，管理者视频的一些基本信息和状态，一个AVPlayerItem对应着一个视频资源。 视频截图MPMoviePlayerControllerAVAssetImageGeneratorAVFundation框架中的AVAssetImageGenerator123456789101112131415161718192021222324252627282930/*** 截取指定时间的视频缩略图** @param timeBySecond 时间点*/-(void)thumbnailImageRequest:(CGFloat )timeBySecond&#123; //创建URL NSURL *url=[self getNetworkUrl]; //根据url创建AVURLAsset AVURLAsset *urlAsset=[AVURLAsset assetWithURL:url]; //根据AVURLAsset创建AVAssetImageGenerator AVAssetImageGenerator *imageGenerator=[AVAssetImageGenerator assetImageGeneratorWithAsset:urlAsset]; /*截图 * requestTime:缩略图创建时间 * actualTime:缩略图实际生成的时间 */ NSError *error=nil; CMTime time=CMTimeMakeWithSeconds(timeBySecond, 10);//CMTime是表示电影时间信息的结构体，第一个参数表示是视频第几秒，第二个参数表示每秒帧数.(如果要活的某一秒的第几帧可以使用CMTimeMake方法) CMTime actualTime; CGImageRef cgImage= [imageGenerator copyCGImageAtTime:time actualTime:&amp;actualTime error:&amp;error]; if(error)&#123; NSLog(@&quot;截取视频缩略图时发生错误，错误信息：%@&quot;,error.localizedDescription); return; &#125; CMTimeShow(actualTime); UIImage *image=[UIImage imageWithCGImage:cgImage];//转化为UIImage //保存到相册 UIImageWriteToSavedPhotosAlbum(image,nil, nil, nil); CGImageRelease(cgImage);&#125; 第三方iOS上常用的视频编码、解码框架有：VLC、ffmpeg 摄像头（拍照和视频录制）UIImagePickerControllerUIImagePickerController继承于UINavigationController AVFoundation（AVCaptureSession/AVCaptureDevice）灵活性强。 参考原文：iOS开发系列–音频播放、录音、视频播放、拍照、视频录制","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"音频","slug":"音频","permalink":"https://guchunli.github.io/tags/音频/"},{"name":"视频","slug":"视频","permalink":"https://guchunli.github.io/tags/视频/"},{"name":"播放","slug":"播放","permalink":"https://guchunli.github.io/tags/播放/"},{"name":"录制","slug":"录制","permalink":"https://guchunli.github.io/tags/录制/"}]},{"title":"RAC与Target-Action、通知、代理、KVO","date":"2017-04-23T03:30:03.000Z","path":"2017/04/23/RAC与Target-Action、通知、代理、KVO/","text":"ReactiveCocoa作用1.target-action:rac_signalForControlEventsrac_textSignal rac_gestureSignal2.代理 rac_signalForSelector:@selector() fromProtocol:()3.通知 rac_addObserverForName4.KVO RACObserve(object, value) 代码示例：1.target-action123456789101112131415161718//1.1 监听textfield文字更改[[self.textfiled rac_signalForControlEvents:UIControlEventEditingChanged] subscribeNext:^(id x)&#123; NSLog(@&quot;change&quot;);&#125;];//简写[[self.textfiled rac_textSignal] subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x);&#125;];//1.2UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] init]; [[tap rac_gestureSignal] subscribeNext:^(id x) &#123; NSLog(@&quot;tap&quot;);&#125;];//注意：如果给label添加手势，需要打开userInteractionEnabledself.lab.userInteractionEnabled = YES;[self.lab addGestureRecognizer:tap]; 2.代理：rac_signalForSelector:@selector() fromProtocol:()* 注意：只能实现返回值为void的代理方法12345678910111213UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@&quot;title&quot; message:@&quot;rac test&quot; delegate:self cancelButtonTitle:@&quot;no&quot; otherButtonTitles:@&quot;yes&quot;, nil]; [[self rac_signalForSelector:@selector(alertView:clickedButtonAtIndex:) fromProtocol:@protocol(UIAlertViewDelegate)] subscribeNext:^(RACTuple *tuple) &#123; //tuple为点击按钮的各个参数 NSLog(@&quot;%ld&quot;,tuple.count); //参数个数 2 NSLog(@&quot;%@&quot;,tuple.first); //alertView NSLog(@&quot;%@&quot;,tuple.second); //buttonIndex NSLog(@&quot;%@&quot;,tuple.third); //null &#125;];//简写[[alertView rac_buttonClickedSignal] subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x); //buttonIndex&#125;];[alertView show]; 3.通知 rac_addObserverForName点击一个页面可以更新另一个页面数据123456[[[NSNotificationCenter defaultCenter] rac_addObserverForName:@&quot;postData&quot; object:nil] subscribeNext:^(NSNotification *notification) &#123; NSLog(@&quot;%@&quot;, notification.name); NSLog(@&quot;%@&quot;, notification.object);&#125;];[self presentViewController:[[SecondViewController alloc]init] animated:YES completion:nil]; SecondViewController代码：123NSMutableArray *dataArray = [[NSMutableArray alloc] initWithObjects:@&quot;1&quot;, @&quot;2&quot;, @&quot;3&quot;, nil];[[NSNotificationCenter defaultCenter] postNotificationName:@&quot;postData&quot; object:dataArray];[self dismissViewControllerAnimated:YES completion:nil]; 4.KVO RACObserve(object, value)1234567UIScrollView *scrolView = [[UIScrollView alloc] initWithFrame:CGRectMake(0, 300, 200, 400)];scrolView.contentSize = CGSizeMake(200, 800);scrolView.backgroundColor = [UIColor greenColor];[self.view addSubview:scrolView];[RACObserve(scrolView, contentOffset) subscribeNext:^(id x) &#123; NSLog(@&quot;success&quot;);&#125;]; 原文链接：学习RAC小记-适合给新手看的RAC用法总结","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"RAC","slug":"RAC","permalink":"https://guchunli.github.io/tags/RAC/"}]},{"title":"iOS IM学习笔记","date":"2017-04-22T03:19:11.000Z","path":"2017/04/22/iOS-IM学习笔记/","text":"客户端需要做如下4件事： 1.客户端调用 socket(…) 创建socket； 2.客户端调用 connect(…) 向服务器发起连接请求以建立连接； 3.客户端与服务器建立连接之后，就可以通过send(…)/receive(…)向客户端发送或从客户端接收数据； 4.客户端调用 close 关闭 socket； 服务端需要做如下5件事： 1.服务器调用 socket(…) 创建socket； 2.服务器调用 listen(…) 设置缓冲区； 3.服务器通过 accept(…)接受客户端请求建立连接； 4.服务器与客户端建立连接之后，就可以通过 send(…)/receive(…)向客户端发送或从客户端接收数据； 5.服务器调用 close 关闭 socket； 可以通过以下几种方式实现： 1.系统socket 2.基于Scoket原生：代表框架 CocoaAsyncSocket 3.基于WebScoket：代表框架 SocketRocket。(npm install ws) 4.MQTTKit：MQTTClient(npm install mosca) 5.XMPP 6.私有协议：基于WebScoket或者Scoket原生进行封装（高效，省流量，安全性高）其中MQTT和XMPP为聊天协议，它们是最上层的协议，而WebScoket是传输通讯协议。 XMPP常用对象：XMPPStream：xmpp基础服务类XMPPRoster：好友列表类XMPPRosterCoreDataStorage：好友列表（用户账号）在core data中的操作类XMPPvCardCoreDataStorage：好友名片（昵称，签名，性别，年龄等信息）在core data中的操作类XMPPvCardTemp：好友名片实体类，从数据库里取出来的都是它xmppvCardAvatarModule：好友头像XMPPReconnect：如果失去连接,自动重连XMPPRoom：提供多用户聊天支持XMPPPubSub：发布订阅 代码传送门：IMWithSocket 参考原文：iOS即时通讯，从入门到“放弃”？iOS - XMPP 的使用","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"IM","slug":"IM","permalink":"https://guchunli.github.io/tags/IM/"},{"name":"socket","slug":"socket","permalink":"https://guchunli.github.io/tags/socket/"}]},{"title":"北京十渡","date":"2017-04-16T06:49:48.000Z","path":"2017/04/16/北京十渡/","text":"2017-04-16 北京十渡飞拉达、蹦极 今天真是玩嗨了 早上六点起床，准备好之后早早出了门，乘地铁赶往公主坟与大家集合。到了集合地，坐着租的面包车开始前往目的地————十渡。 十渡景区位于北京房山，到了景区之后，带队的队长确定参加飞拉达的人数开始买票。之前了解了一下飞拉达就是攀岩（岩壁探险或铁道式攀登），因为之前从来没参与过类似冒险运动，心里有点小紧张。因为人还比较多，所以一块请了一位教练。刚开始教练教授装备的穿戴，之后带领我们来到了攀岩的山脚下，教练说这座山大概有70多米，之后告诉了我们扣锁的使用，然后开始攀爬演示，小伙伴们也开始一个个紧随其后开始了攀爬之路。 飞拉达历经大约三个小时，穿越了ABCD区，终于到达了终点。教练帮我们把所有锁扣都挂到绳索上，下面是湖水，随着绳索划过去才算再次到达了地面。 之后和大家一起腐败吃午餐，吃午餐的餐厅对面正好就是蹦极的跳台，时不时看着一个个挑战者坠落、弹起，再坠落… 由于某些原因（吃的有点多了，惭愧…），本来打算不参加蹦极了，但是一想如果不参加，回去之后一定会捶胸顿足，后悔不跌，而且同行的小伙伴们除了一对情侣之外都参加了，狠了狠心还是买了票。 来到蹦极门口，工作人员给每个人测量了身高和体重，并把数据写到了手背上。由于蹦极的人很多，等了大约有两三个小时，期间目睹一个一个从跳台自由落体，还有情侣相拥跳下，他们调侃这肯定是他们这辈子抱得最紧的一次了吧~~轮到我们的时候，不知怎么安排的被调到了最后一个，轮到我的时候，工作人员开始给我腿上绑绳，把眼镜粘到了胳膊上，为了避免女生走光把上衣和裤子的连接处也用胶带粘上了，说实话，自从买了票心有一直还挺紧张的，但真到了马上就要跳下去的时候，心里反而没有那么紧张了，还算比较平静。起跳之前冲着镜头挥挥手，然后只要张开双臂就可以了，看着50米下宽阔的湖水，心里还真是怂了，嗯，怂了（幸亏自己还是近视眼，并且还没戴眼镜）…接着工作人员扶着胳膊向前推去，从未有过的自由落体的失重感觉瞬间侵占了大脑，一片空白，只得紧闭双眼，只感觉到达最低点之后又弹跳到了下降高度的三分之二，然后又开始降落，才敢睁开眼睛环顾四周，之后又弹了大概两三次，高度就不是很高了，才开始享受蹦极的乐趣，然后就被放了下来，湖面上有专业人员把我接了下去，整个过程也就是一两分钟的样子，算是真切的感受了一次蹦极的刺激！ 今天认识了一个很说的来的朋友，我俩基本上叽叽喳喳聊了一天，感觉很是投缘，遇到很聊得来的人总是感觉心情很舒畅！同行的小伙伴中了有一个四川的男生，还在上大学，曾经自己骑行去过云南，还有一个广州的女孩（就是下图中的女孩），刚辞了工作专门出来游玩的，很佩服这种勇气！ 最后用鹿晗的《某时某刻 Catch me when I fall》结个尾~~~","comments":true,"categories":[{"name":"随笔","slug":"other","permalink":"https://guchunli.github.io/categories/other/"}],"tags":[{"name":"十渡","slug":"十渡","permalink":"https://guchunli.github.io/tags/十渡/"},{"name":"蹦极","slug":"蹦极","permalink":"https://guchunli.github.io/tags/蹦极/"}]},{"title":"iOS打包提交APP Store注意事项","date":"2017-04-13T04:20:22.000Z","path":"2017/04/13/iOS打包提交APP-Store注意事项/","text":"1.改为正式环境 接口改成线上服务器 极光推送环境改为生产环境等 2.版本号target -&gt; general：Version和Build版本号 3.签名target -&gt; general -&gt; signing 4.删除断点，log 5.本地化，语言包 6.Capabilities -&gt; background modes如果后台使用了位置，提交信息中应用描述添加免责声明 温馨提示：GPS在后台持续运行，会大大降低电池的寿命。 7.设备选择Generic iOS Device，注意不要选择真机或模拟器。 8.edit scheme: run,archive -&gt; debug 改为 release 9.打包ad-hoc，进行内测：clean -&gt; build -&gt; archive 最后，打正式包，提交APP Store。","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"app store","slug":"app-store","permalink":"https://guchunli.github.io/tags/app-store/"}]},{"title":"iOS单元测试学习笔记","date":"2017-04-09T06:16:58.000Z","path":"2017/04/09/iOS单元测试学习笔记/","text":"1.新建项目时注意勾选Unit Tests,UI Tests如果忘记勾选，File–&gt;new–&gt;target–&gt;iOS–&gt;Cocoa Unit Testing Bundle/Cocoa UI Testing Bundle 添加2.setUp是每个测试方法调用前执行，tearDown是每个测试方法调用后执行3.测试方法必须testXXX的格式，且不能有参数4.测试方法的执行顺序是字典序排序,cmd + U进行单元测试，这个快捷键是全部测试，在代码左侧就是平常打断点的地方，有个菱形按钮是单独测试这个方法5.iOS9的http安全问题：现在进行异步请求的网络测试，由于测试方法主线程执行完就会结束，所以需要设置一下，否则没法查看异步返回结果。在方法结束前设置等待，调回回来的时候再让它继续执行。12345678//waitForExpectationsWithTimeout是等待时间，超过了就不再等待往下执行。#define WAIT do &#123;\\[self expectationForNotification:@&quot;RSBaseTest&quot; object:nil handler:nil];\\[self waitForExpectationsWithTimeout:30 handler:nil];\\&#125; while (0);#define NOTIFY \\[[NSNotificationCenter defaultCenter]postNotificationName:@&quot;RSBaseTest&quot; object:nil]; 常用的断言测试函数XCTFail(format…) //生成一个失败的测试；XCTAssertNil(a1, format…) //为空判断，a1为空时通过，反之不通过；XCTAssertNotNil(a1, format…) //不为空判断，a1不为空时通过，反之不通过；XCTAssert(expression, format…) //当expression求值为TRUE时通过；XCTAssertTrue(expression, format…) //当expression求值为TRUE时通过；XCTAssertFalse(expression, format…) //当expression求值为False时通过；XCTAssertEqualObjects(a1, a2, format…) //判断相等，[a1 isEqual:a2]值为TRUE时通过，其中一个不为空时，不通过；XCTAssertNotEqualObjects(a1, a2, format…) //判断不等，[a1 isEqual:a2]值为False时通过；XCTAssertEqual(a1, a2, format…) //判断相等（当a1和a2是 C语言标量、结构体或联合体时使用,实际测试发现NSString也可以）；XCTAssertNotEqual(a1, a2, format…) //判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；XCTAssertEqualWithAccuracy(a1, a2, accuracy, format…) //判断相等，（double或float类型）提供一个误差范围，当在误差范围（+/-accuracy）以内相等时通过测试；XCTAssertNotEqualWithAccuracy(a1, a2, accuracy, format…) //判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试；XCTAssertThrows(expression, format…) //异常测试，当expression发生异常时通过；反之不通过；XCTAssertThrowsSpecific(expression, specificException, format…) //异常测试，当expression发生specificException异常时通过；反之发生其他异常或不发生异常均不通过；XCTAssertThrowsSpecificNamed(expression, specificException, exception_name, format…) //异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过；XCTAssertNoThrow(expression, format…) //异常测试，当expression没有发生异常时通过测试；XCTAssertNoThrowSpecific(expression, specificException, format…) //异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过；XCTAssertNoThrowSpecificNamed(expression, specificException, exception_name, format…) //异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过 示例代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// XCTFail(format…) //生成一个失败的测试；// XCTFail(@&quot;Fail&quot;);// XCTAssertNil(a1, format...) 为空判断， a1 为空时通过，反之不通过；// XCTAssertNil(@&quot;not nil string&quot;, @&quot;string must be nil&quot;);// XCTAssertNotNil(a1, format…) 不为空判断，a1不为空时通过，反之不通过；XCTAssertNotNil(@&quot;not nil string&quot;, @&quot;string can not be nil&quot;);// XCTAssert(expression, format...) 当expression求值为TRUE时通过；// XCTAssert((2 &gt; 2), @&quot;expression must be true&quot;);// XCTAssertTrue(expression, format...) 当expression求值为TRUE时通过；XCTAssertTrue(1, @&quot;Can not be zero&quot;);// XCTAssertFalse(expression, format...) 当expression求值为False时通过；XCTAssertFalse((2 &lt; 2), @&quot;expression must be false&quot;);// XCTAssertEqualObjects(a1, a2, format...) 判断相等， [a1 isEqual:a2] 值为TRUE时通过，其中一个不为空时，不通过；// XCTAssertEqualObjects(@&quot;1&quot;, @&quot;1&quot;, @&quot;[a1 isEqual:a2] should return YES&quot;);// XCTAssertEqualObjects(@&quot;1&quot;, @&quot;2&quot;, @&quot;[a1 isEqual:a2] should return YES&quot;);// XCTAssertNotEqualObjects(a1, a2, format...) 判断不等， [a1 isEqual:a2] 值为False时通过，// XCTAssertNotEqualObjects(@&quot;1&quot;, @&quot;1&quot;, @&quot;[a1 isEqual:a2] should return NO&quot;);// XCTAssertNotEqualObjects(@&quot;1&quot;, @&quot;2&quot;, @&quot;[a1 isEqual:a2] should return NO&quot;);// XCTAssertEqual(a1, a2, format...) 判断相等（当a1和a2是 C语言标量、结构体或联合体时使用,实际测试发现NSString也可以）；// 1.比较基本数据类型变量// XCTAssertEqual(1, 2, @&quot;a1 = a2 shoud be true&quot;); // 无法通过测试// XCTAssertEqual(1, 1, @&quot;a1 = a2 shoud be true&quot;); // 通过测试// 2.比较NSString对象// NSString *str1 = @&quot;1&quot;;// NSString *str2 = @&quot;1&quot;;// NSString *str3 = str1;// XCTAssertEqual(str1, str2, @&quot;a1 and a2 should point to the same object&quot;); // 通过测试// XCTAssertEqual(str1, str3, @&quot;a1 and a2 should point to the same object&quot;); // 通过测试// 3.比较NSArray对象// NSArray *array1 = @[@1];// NSArray *array2 = @[@1];// NSArray *array3 = array1;// XCTAssertEqual(array1, array2, @&quot;a1 and a2 should point to the same object&quot;); // 无法通过测试// XCTAssertEqual(array1, array3, @&quot;a1 and a2 should point to the same object&quot;); // 通过测试// XCTAssertNotEqual(a1, a2, format...) 判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；// XCTAssertEqualWithAccuracy(a1, a2, accuracy, format...) 判断相等，（double或float类型）提供一个误差范围，当在误差范围（+/- accuracy ）以内相等时通过测试；// XCTAssertEqualWithAccuracy(1.0f, 1.5f, 0.25f, @&quot;a1 = a2 in accuracy should return YES&quot;);// XCTAssertNotEqualWithAccuracy(a1, a2, accuracy, format...) 判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试；// XCTAssertNotEqualWithAccuracy(1.0f, 1.5f, 0.25f, @&quot;a1 = a2 in accuracy should return NO&quot;);// XCTAssertThrows(expression, format...) 异常测试，当expression发生异常时通过；反之不通过；（很变态）// XCTAssertThrowsSpecific(expression, specificException, format...) 异常测试，当expression发生 specificException 异常时通过；反之发生其他异常或不发生异常均不通过；// XCTAssertThrowsSpecificNamed(expression, specificException, exception_name, format...) 异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过；// XCTAssertNoThrow(expression, format…) 异常测试，当expression没有发生异常时通过测试；// XCTAssertNoThrowSpecific(expression, specificException, format...)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过；// XCTAssertNoThrowSpecificNamed(expression, specificException, exception_name, format...) 异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过 转自：iOS单元测试(作用及入门提升)(http://www.jianshu.com/p/009844a0b9ed)","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"test","slug":"test","permalink":"https://guchunli.github.io/tags/test/"}]},{"title":"2017玉渊潭樱花节","date":"2017-04-08T11:54:47.000Z","path":"2017/04/08/2017玉渊潭樱花节/","text":"2017-04-08 玉渊潭樱花节 去年就打算去玉渊潭看花的忘了是什么原因错过了花期，没能去成心里总觉得遗憾今年决定不能再错过一定要去看看的虽然今天天气不太好，但是花开尤盛，自以为很是不错也算是了了一个小小心愿最重要的是去了，并且看到了不是么~~","comments":true,"categories":[{"name":"随笔","slug":"other","permalink":"https://guchunli.github.io/categories/other/"}],"tags":[{"name":"玉渊潭","slug":"玉渊潭","permalink":"https://guchunli.github.io/tags/玉渊潭/"},{"name":"樱花节","slug":"樱花节","permalink":"https://guchunli.github.io/tags/樱花节/"}]},{"title":"iOS runtime学习笔记","date":"2017-03-22T03:39:18.000Z","path":"2017/03/22/iOS-runtime学习笔记/","text":"Objective-C 是一门动态语言，它把很多静态语言在编译和链接时做的事情放到了运行时去处理，它在运行时实现了对类、方法、成员变量、属性等信息的管理机制。 运行时的类与对象类与对象相关的函数12345678910111213141516171819202122232425262728293031const char *class_getName(Class cls)，获取指定类的类名。BOOL class_isMetaClass(Class cls)，判断指定类是否是一个元类。Class class_getSuperclass(Class cls)，获取指定类的父类。Class class_setSuperclass(Class cls, Class newSuper)，设定指定类的父类。int class_getVersion(Class cls)，获取指定类的版本信息。void class_setVersion(Class cls, int version)，设定指定类的版本信息。size_t class_getInstanceSize(Class cls)，获取实例大小。Ivar class_getInstanceVariable(Class cls, const char *name)，获取指定名字的实例变量。Ivar class_getClassVariable(Class cls, const char *name)，获取指定名字的类变量。Ivar *class_copyIvarList(Class cls, unsigned int *outCount)，获取类的成员变量列表的拷贝。调用后需要自己 free()。Method class_getInstanceMethod(Class cls, SEL name)，获取指定名字的实例方法。Method class_getClassMethod(Class cls, SEL name)，获取指定名字的类方法。IMP class_getMethodImplementation(Class cls, SEL name)，获取指定名字的方法实现。BOOL class_respondsToSelector(Class cls, SEL sel)，类是否响应指定的方法。Method *class_copyMethodList(Class cls, unsigned int *outCount)，获取方法列表的拷贝。调用后需要自己 free()。BOOL class_conformsToProtocol(Class cls, Protocol *protocol)，类是否遵循指定的协议。Protocol * __unsafe_unretained *class_copyProtocolList(Class cls, unsigned int *outCount)，获取协议列表的拷贝。调用后需要自己 free()。objc_property_t class_getProperty(Class cls, const char *name)，获取指定名字的属性。objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)，获取类的属性列表。调用后需要自己 free()。BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)，为类添加方法。IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types)，替代类的方法。BOOL class_addIvar(Class cls, const char *name, size_t size, uint8_t alignment, const char *types)，给指定的类添加成员变量。这个函数只能在 objc_allocateClassPair() 和 objc_registerClassPair() 之间调用，并且不能为一个已经存在的类添加成员变量。BOOL class_addProtocol(Class cls, Protocol *protocol)，为类添加协议。BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)，为类添加属性。void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)，替代类的属性。id class_createInstance(Class cls, size_t extraBytes)，创建指定类的实例。id objc_constructInstance(Class cls, void *bytes)，在指定的位置创建类的实例。void *objc_destructInstance(id obj)，销毁实例。Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)，创建类和元类。void objc_registerClassPair(Class cls)，注册类到 Runtime。void objc_disposeClassPair(Class cls)，销毁类和对应的元类。 类是元类的实例。 isa，在大多面向对象的语言中，都有类和对象的概念，其中，对象是类的实例，是通过类定义的结构生成出来的。而在 Objective-C 中，类本身也是一个对象，类作为对象时的 isa 指针指向的是元类(Meta Class)。 object_getClass() 可以获得当前对象 isa #pragma clang diagnostic...代码，可用于忽略编译器对于未声明的 @selector 的 warning。因为我们的代码中我们需要动态的为一个类创建方法，所以必然不会事先声明。 1234#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wundeclared-selector&quot;//调用未声明的 @selector#pragma clang diagnostic pop 使用 objc_registerClassPair() 函数需要注意，不能注册已经注册过的类。 使用 objc_disposeClassPair() 函数需要注意，如果一个类的实例和子类还存在时，不要去销毁一个类。 运行时的成员变量与属性 我们不能用 class_addIvar() 函数为一个已经存在的类添加 Ivar。并且 class_addIvar() 只能在 objc_allocateClassPair() 和 objc_registerClassPair() 之间调用。 添加一个属性及对应的成员变量后，我们还能通过 [obj valueForKey:@”propertyName”]; 获得属性值。 关联对象可用于在类别中添加属性，创建一个category，然后添加property，并且实现setter,gertter。1234567- (void)setName:(NSString *)name&#123;objc_setAssociatedObject(self, &quot;name&quot;, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (NSString *)name&#123;return objc_getAssociatedObject(self, &quot;name&quot;);&#125; 相关方法：123void objc_setAssociatedObject(id object, const void *key, id value, objc _AssociationPolicy policy)id objc_getAssociatedObject(id object, const void *key)void objc_removeAssociatedObjects(id object) 方法与消息 IMP 其实就是 implementation 的缩写，表示方法实现的代码块地址 IMP定义：id (*IMP)(id, SEL,...) 2.SEL用于唯一标识一个方法名,因此一个类中是不能存在两个同名的方法的，即使参数类型不同也不行。获取SEL的三种方法：(1)sel_registerName函数(2)Objective-C编译器提供的@selector()(3)NSSelectorFromString()方法 3.Method将[receiver message]转化为一个消息函数的调用 定义：objc_msgSend(receiver, selector, arg1, arg2,...) 消息机制 注意：使用objc_msgSend，需要#import &lt;objc/runtime.h&gt;1234567891011121314// 通过类名获取类Class catClass = objc_getClass(&quot;Cat&quot;); //注意Class实际上也是对象，所以同样能够接受消息，向Class发送alloc消息Cat *cat = objc_msgSend(catClass, @selector(alloc)); //发送init消息给Cat实例catcat = objc_msgSend(cat, @selector(init)); //发送eat消息给cat，即调用eat方法objc_msgSend(cat, @selector(eat));//汇总消息传递过程objc_msgSend(objc_msgSend(objc_msgSend(objc_getClass(&quot;Cat&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;)), sel_registerName(&quot;eat&quot;)); objc_msgSend()报错Too many arguments to function call ,expected 0,have3 Build Setting–&gt; Apple LLVM 6.0 - Preprocessing–&gt; Enable Strict Checking of objc_msgSend Calls 改为 NO 方法交换12345+ (void)load&#123;Method eatMethod = class_getInstanceMethod(self, @selector(eat));Method playMethod = class_getInstanceMethod(self, @selector(play));method_exchangeImplementations(eatMethod, playMethod);&#125; 动态加载方法12345678910111213void run(id self, SEL _cmd, NSNumber *number)&#123;NSLog(@&quot;%@&quot;, number);&#125;//收到run:消息时候，为该类添加一个方法实现+ (BOOL)resolveInstanceMethod:(SEL)sel&#123;if(sel == NSSelectorFromString(@&quot;run:&quot;))&#123;class_addMethod(self, @selector(run:), run, &quot;v@:@&quot;);return YES;&#125;return [super resolveInstanceMethod:sel];&#125;//另外针对类方法的为 resolveClassMethod 消息转发消息转发机制基本上分为三个步骤：第一步：动态方法解析。第二步：备用接收者。第三步：完整转发。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 第一步，消息接收者没有找到对应的方法时候，会先调用此方法，可在此方法实现中动态添加新的方法// 返回YES表示相应selector的实现已经被找到，或者添加新方法到了类中，否则返回NO+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;return YES;&#125;// 第二步， 如果第一步的返回NO或者直接返回了YES而没有添加方法，该方法被调用// 在这个方法中，我们可以指定一个可以返回一个可以响应该方法的对象， 注意如果返回self就会死循环- (id)forwardingTargetForSelector:(SEL)aSelector &#123;// if ([NSStringFromSelector(aSelector) isEqualToString:@&quot;run:&quot;]) &#123;// return [[RuntimeMethodHelper alloc] init];// &#125;// return [super forwardingTargetForSelector:aSelector];return nil;&#125;// 第三步， 如果forwardingTargetForSelector:返回了nil，则该方法会被调用，系统会询问我们要一个合法的『类型编码(Type Encoding)』// 函数的最后一个参数 types 是描述方法返回值和参数列表的字符串，我们的代码中的用到的 i@:@ 四个字符分别对应着：返回值 int32_t、参数 id self、参数 SEL _cmd、参数 NSDictionary *dic,即类型编码。// 若返回 nil，则不会进入下一步，而是无法处理消息- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123; NSMethodSignature *signature = [super methodSignatureForSelector:aSelector]; if (!signature) &#123; if ([NSStringFromSelector(aSelector) isEqualToString:@&quot;run:&quot;])&#123; return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;]; &#125; return [super methodSignatureForSelector: aSelector]; &#125; return signature;&#125;// 当实现了此方法后，-doesNotRecognizeSelector: 将不会被调用// 在这里进行消息转发- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;if ([RuntimeMethodHelper instancesRespondToSelector:anInvocation.selector]) &#123;[anInvocation invokeWithTarget:[[RuntimeMethodHelper alloc] init]];&#125;// // 在这里可以改变方法选择器// [anInvocation setSelector:@selector(run:)];// // 改变方法选择器后，需要指定消息的接收者// [anInvocation invokeWithTarget:self];&#125;//- (void)run:(NSNumber *)num &#123;// NSLog(@&quot;---%@&quot;, num); // Print: &lt;RuntimeMethodHelper: 0x7f814b498ee0&gt;, 0x102d79929//&#125;// 如果没有实现消息转发 forwardInvocation 则调用此方法- (void)doesNotRecognizeSelector:(SEL)aSelector &#123;NSLog(@&quot;unresolved method ：%@&quot;, NSStringFromSelector(aSelector));&#125; 字典转模型应用12345678910111213141516171819+ (instancetype)modelWithDict:(NSDictionary *)dict&#123; id model = [[self alloc] init]; unsigned int count = 0; Ivar *ivars = class_copyIvarList(self, &amp;count); for (int i = 0 ; i &lt; count; i++) &#123; Ivar ivar = ivars[i]; NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(ivar)]; //这里注意，拿到的成员变量名为_cid,_age ivarName = [ivarName substringFromIndex:1]; id value = dict[ivarName]; [model setValue:value forKeyPath:ivarName]; &#125; return model;&#125; demo 参考：Objective-C 的 RuntimeiOS Runtime 几种基本用法简记iOS运行时(Runtime)详解+Demo","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"runtime","slug":"runtime","permalink":"https://guchunli.github.io/tags/runtime/"}]},{"title":"mac显示隐藏文件","date":"2017-03-21T10:37:39.000Z","path":"2017/03/21/mac显示隐藏文件/","text":"1.显示隐藏文件1defaults write com.apple.finder AppleShowAllFiles Yes &amp;&amp; killall Finder 2.不显示隐藏文件1defaults write com.apple.finder AppleShowAllFiles No &amp;&amp; killall Finder 3.删除文件夹下的所有 .git 文件1find . -name &quot;.git&quot; | xargs rm -Rf","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"https://guchunli.github.io/tags/技巧/"},{"name":"隐藏文件","slug":"隐藏文件","permalink":"https://guchunli.github.io/tags/隐藏文件/"}]},{"title":"Apple Pay学习笔记","date":"2017-03-15T08:37:17.000Z","path":"2017/03/15/Apple-Pay学习笔记/","text":"概述1.支付方式：Touch ID/ Passcode2.设备要求：iPhone6以上（iphone:线上/线下 ipad:线上 watch:线下）3.系统要求：iOS8.0以上，银联（中国）：9.2 4.基于NFC5.2014年10月20日在美国正式上线，2016年2月18日凌晨5：00， Apple Pay 业务在中国上线。6.与微信支付以及支付宝等第三方支付平台的区别： 硬件方面 Apple Pay：必须是iOS设备， 而且是按照线上支付和线下支付区分不同的真机设备（具体参考表1） 微信、支付宝： 基本跟硬件设备无关， 支持大多数的只能手机 网络环境要求 Apple Pay：线上支付需要联网， 线下支付无需联网就可以支付 微信、支付宝： 无论是线上还是线下支付， 都需要联网使用 使用技术 Apple Pay：线下支付使用的是 基于NFC的近场通讯技术 微信、支付宝： 线下支付使用的是 扫码支付（条形码、二维码） 主要功能 Apple Pay：线上支付、线下支付、部分升级后的ATM机可以取款 微信、支付宝： 线上支付、线下支付、转账、理财等 安全性能 Apple Pay：不保留银行卡信息，并且不会暴漏给外界、不分流银行存款（不需要从银行卡转钱到另外一个平台）、不能充值 安全性较高 微信、支付宝： 密码保护，身份验证等手段保护账户 安全性相对稍差 支付时长 Apple Pay：无论是线上支付，还是线下支付， 只需要验证指纹即可支付。非常迅速 微信、支付宝： 需要扫码支付， 流程相对繁琐，所以时长较长 各自弊端 Apple Pay：只适用于苹果设备， 支付场景单一，无转账理财等业务 微信、支付宝： 安全性较差， 必须联网操作，需要充值到对应平台 注册并配置一个商业标示符1.添加一个App ID2.配置Merchant ID3.为Merchant ID 配置证书, 并下载证书安装到钥匙串4.检查安装到钥匙串中的证书是否有效5.绑定Merchant ID 到 APP ID 证书失效，请到以下地址下载重新安装：https://www.apple.com/certificateauthority/ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239//一.判断当前设备是否支持支付if (![PKPaymentAuthorizationViewController canMakePayments]) &#123;NSLog(@&quot;该设备不支持ApplePay&quot;);return;//二.判断Wallet有没有添加该支付网络的储蓄卡/信用卡&#125;else if ([PKPaymentAuthorizationViewController canMakePaymentsUsingNetworks:@[PKPaymentNetworkChinaUnionPay,PKPaymentNetworkVisa]])&#123;NSLog(@&quot;Wallet没有添加该支付网络的储蓄卡/信用卡&quot;);//创建一个添加卡的按钮PKPaymentButton *btn = [PKPaymentButton buttonWithType:PKPaymentButtonTypeSetUp style:PKPaymentButtonStyleBlack];[btn addTarget:self action:@selector(jumpToSetup) forControlEvents:UIControlEventTouchUpInside];[self.payView addSubview:btn]; &#125;else&#123;//创建一个支付按钮PKPaymentButton *btn = [PKPaymentButton buttonWithType:PKPaymentButtonTypeBuy style:PKPaymentButtonStyleWhiteOutline];[btn addTarget:self action:@selector(jumpToPay) forControlEvents:UIControlEventTouchUpInside];[self.payView addSubview:btn];&#125;- (void)jumpToSetup&#123;NSLog(@&quot;跳转到添加银行卡页面&quot;);PKPassLibrary * pk = [[PKPassLibrary alloc]init];[pk openPaymentSetup];&#125;- (void)jumpToPay&#123;//三.创建支付请求并配置各项信息//1.创建支付请求PKPaymentRequest *request = [[PKPaymentRequest alloc]init];//2.配置参数//2.1 商店标识request.merchantIdentifier = @&quot;&quot;;//2.2 国家代码request.countryCode = @&quot;CN&quot;;//2.3 货币代码request.currencyCode = @&quot;CNY&quot;;//2.4 支持的支付网络request.supportedNetworks = @[PKPaymentNetworkChinaUnionPay,PKPaymentNetworkVisa];//2.5 支付请求包含一个支付摘要项目的列表NSDecimalNumber *price1 = [NSDecimalNumber decimalNumberWithString:@&quot;10.0&quot;];PKPaymentSummaryItem *item1 = [PKPaymentSummaryItem summaryItemWithLabel:@&quot;iPhone&quot; amount:price1];NSDecimalNumber *price2 = [NSDecimalNumber decimalNumberWithString:@&quot;20.0&quot;];PKPaymentSummaryItem *item2 = [PKPaymentSummaryItem summaryItemWithLabel:@&quot;iPad&quot; amount:price2 type:PKPaymentSummaryItemTypePending];NSDecimalNumber *totalPrice = [NSDecimalNumber zero];totalPrice = [totalPrice decimalNumberByAdding:price1];totalPrice = [totalPrice decimalNumberByAdding:price2];PKPaymentSummaryItem *total = [PKPaymentSummaryItem summaryItemWithLabel:@&quot;财务中心&quot; amount:totalPrice type:PKPaymentSummaryItemTypePending];//注意：数组最后一个是总价格request.paymentSummaryItems = @[item1,item2,total];//2.6运输方式NSDecimalNumber *shippingPrice = [NSDecimalNumber decimalNumberWithString:@&quot;18.0&quot;];PKShippingMethod *method = [PKShippingMethod summaryItemWithLabel:@&quot;顺风快递&quot; amount:shippingPrice];method.identifier = @&quot;shunfeng&quot;;method.detail = @&quot;24小时内送到&quot;;request.shippingMethods = @[method];request.shippingType = PKShippingTypeServicePickup;//2.7通过指定merchantCapabilities属性来指定你支持的支付处理标准，3DS支付方式是必须支持的，EMV方式是可选的request.merchantCapabilities = PKMerchantCapability3DS | PKMerchantCapabilityEMV | PKMerchantCapabilityCredit | PKMerchantCapabilityDebit;//2.8需要的配送信息和账单信息request.requiredBillingAddressFields = PKAddressFieldAll;request.requiredShippingAddressFields = PKAddressFieldAll;//2.9 存储额外信息request.applicationData = [@&quot;购物车ID：123456&quot; dataUsingEncoding:NSUTF8StringEncoding];//四.弹出授权控制器，让用户给支付授权//开始支付PKPaymentAuthorizationViewController *pkCtrl = [[PKPaymentAuthorizationViewController alloc]initWithPaymentRequest:request];if (pkCtrl == nil) &#123;NSLog(@&quot;授权控制器创建失败&quot;);return;&#125;pkCtrl.delegate = self;[self presentViewController:pkCtrl animated:YES completion:nil];&#125;#pragma mark - PKPaymentAuthorizationViewControllerDelegate//五.处理支付凭证//授权成功- (void)paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)controllerdidAuthorizePayment:(PKPayment *)paymentcompletion:(void (^)(PKPaymentAuthorizationStatus status))completion&#123;/*服务器接收到token后的一般处理流程:1.验证支付数据的哈希表和签名2.为加密过的支付数据解码3.向支付处理系统提交支付数据4.向订单追踪系统提交订单*/NSLog(@&quot;验证授权---%@&quot;,payment.token);/*处理支付请求时，你有两个选择:1.你既可以利用支付平台处理支付请求，2.也可以自己实现支付请求处理流程。一个常用的支付平台可以完成上述大部分操作。*/NSLog(@&quot;验证通过后，需要开发中继续完成交易&quot;);BOOL isSuccess = YES;if (isSuccess) &#123;completion(PKPaymentAuthorizationStatusSuccess);&#125;else&#123;completion(PKPaymentAuthorizationStatusFailure);&#125;&#125;//六.关闭授权控制器//授权成功或者取消授权之后会调用此方法- (void)paymentAuthorizationViewControllerDidFinish:(PKPaymentAuthorizationViewController *)controller&#123;NSLog(@&quot;取消或者交易完成&quot;);[self dismissViewControllerAnimated:YES completion:nil];&#125; 转自：Apple Pay–iOS开发","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"Apple Pay","slug":"Apple-Pay","permalink":"https://guchunli.github.io/tags/Apple-Pay/"}]},{"title":"将.c文件打包成库文件","date":"2017-03-06T10:43:09.000Z","path":"2017/03/06/将-c文件打包成库文件/","text":"打包.a1.Cocoa Touch Static Library2.添加要打包的文件:.c，.h3.将头文件添加到Build Phases -&gt; Copy Files中去4.需要修改Build Settings中的 Build Active Architecture Only 以满足运行不同CPU环境的模拟器。 将此设置为NO。 选择Edit Scheme–&gt; Buid Configuration设置为release5.分别选择模拟器和真机编译，生成.a文件，在不同编译环境下编译会生成四种静态库，debug模拟器，debug真机，release模拟器，release真机6.查看静态库所支持的CPU环境：lipo -info 静态库文件7.合并静态库：lipo -create 静态库1 静态库2 -output 新静态库名称.a 注意：1.如果直接拖拽的是一个项目，并将项目当做一个静态库引用需要这样处理：在 Build Phases 中的 Target Dependencies 和 Link Binary With Libraries 中分别添加项目。如果仅仅是一个静态库的话，那么Link Binary WithLibraries 是必须添加的。2.如果编译的静态库中有分类的话必须在 Build Settings –&gt; Other Linker Flags 中加 -Objc 如果还崩溃，还得加上 -all_load 打包.so1.编译1gcc -c -fPIC -o myfile.o myfile.c 2.生成.so文件1gcc -shared -o libname.so myfile.o","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":".c","slug":"c","permalink":"https://guchunli.github.io/tags/c/"},{"name":".a","slug":"a","permalink":"https://guchunli.github.io/tags/a/"},{"name":".so","slug":"so","permalink":"https://guchunli.github.io/tags/so/"}]},{"title":"github上使用SSH和gitignore","date":"2017-03-03T08:52:02.000Z","path":"2017/03/03/github上使用SSH和gitignore/","text":"使用SSH来到以下路径1$ cd ~/.ssh //如果.ssh文件夹不存在，执行mkdir ~/.ssh 进行创建 生成RSA密钥对1$ ssh-keygen -t rsa -C &quot;your email address&quot; 查看公钥内容复制粘贴公钥，注意：公钥内容以ssh-rsa开头，你的邮箱结尾：1$ cat ~/.ssh/id_rsa.pub 测试连接123$ ssh -T git@github.com （github） $ ssh -T git@git.oschina.net (oschina)$ Welcome to Git@OSC, nickname! gitignore123456cd /Users/apple/Desktop/codegit clone git地址cp gitignore路径 .gitignoregit add .git commit -m &quot;添加 gitignore&quot;git push 注意：”cp gitignore路径 .gitignore”一定要加”.gitignore”。","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"github","slug":"github","permalink":"https://guchunli.github.io/tags/github/"},{"name":"SSH","slug":"SSH","permalink":"https://guchunli.github.io/tags/SSH/"},{"name":"gitignore","slug":"gitignore","permalink":"https://guchunli.github.io/tags/gitignore/"}]},{"title":"git学习笔记","date":"2017-03-03T02:49:42.000Z","path":"2017/03/03/git学习笔记/","text":"初始化仓库 $ git init 提交代码 $ git add .$ git commit -m “” 查看状态 $ git status 查看修改 $ git diff12-change something+change $ git diff &gt; 1.diff将diff修改写到1.diff文件中 查看提交历史 $ git log 1234567891011121314151617commit acbcfcfa48c89deb725aae9e03a68a2f5abaa1d4Author: gcl &lt;155@163.com&gt;Date: Tue Feb 7 14:30:11 2017 +0800change 2commit 99f733644454644d90b8ee39c6737dc283c78cecAuthor: gcl &lt;155@163.com&gt;Date: Tue Feb 7 14:27:55 2017 +0800change readme.txtcommit 58110376e350d36c8df095b17ff2ecb44906eae2Author: gcl &lt;155@163.com&gt;Date: Tue Feb 7 14:25:17 2017 +0800add readme.txt 简化版本信息 $ git log –pretty=oneline123acbcfcfa48c89deb725aae9e03a68a2f5abaa1d4 change 299f733644454644d90b8ee39c6737dc283c78cec change readme.txt58110376e350d36c8df095b17ff2ecb44906eae2 add readme.txt 查看命令历史 $ git reflog12345acbcfcf HEAD@&#123;0&#125;: reset: moving to acbcfcfa499f7336 HEAD@&#123;1&#125;: reset: moving to HEAD^acbcfcf HEAD@&#123;2&#125;: commit: change 299f7336 HEAD@&#123;3&#125;: commit: change readme.txt5811037 HEAD@&#123;4&#125;: commit (initial): add readme.txt 回退版本HEAD指向当前版本，HEAD^是上一版本，HEAD^^是上上版本，HEAD~100是上100个版本--hard是强制抹除修改，未提交的修改会丢失。git reset –hard 慎重使用--mixed是保存修改，相当于重新提交。 回到上一版本 $ git reset –hard HEAD^ 回到某一历史 $ git reset –hard commitid 工作区与暂存区 respository文件夹：工作区 .git：版本库，包含了stage（暂存区），分支master，指针HEAD git add是把文件修改放到了暂存区，git commit把暂存区的内容提交到了分支，没有提交到暂存区的修改是不会被提交到分支的提交的事件线：工作区-&gt;git add-&gt;暂存区-&gt;git commit-&gt;分支 撤销修改git管理的是修改，而不是文件 清空工作区的修改，回到最近一次git commit或git add时的状态（用版本库的版本替换工作区的版本）：git checkout – readme.txt （注意：git checkout 是切换分支命令） 撤销add后，commit前在暂存区的修改，将暂存区的修改放回工作区：git reset HEAD readme.txt（注意：reset可以回退版本，还可以撤销add到暂存区的内容，回退到工作区，如果要撤销在工作区的修改，可以再次checkout – file） 撤销commit之后，push之前：版本回退，git reset git push：无法撤销 删除文件确定删除 git rm filenamegit commit 撤销删除，找回文件 git checkout – filename注意：git checkout是使用版本库中的最新版本替换工作区的版本，即撤销git add/rm之前的修改 远程仓库 本地库master与远程库origin关联，origin为远程库的默认叫法 $ git remote add origin git@github.com:XXX/learngit.git（XXX为你的github账户名） 将本地库中的所有内容推送到远程库中，加上-u将本地master分支和远程origin分支关联起来，以后推送就可以直接使用git push简化命令 $ git push -u origin master 以后推送使用以下命令 $ git push origin master 把远程库克隆到本地,使用https速度慢，而且每次都要输入口令 $ git clone ssh或https push与pull push：本地 –&gt; 远程，如果本地超前远程，需要push pull：本地 &lt;– 远程，如果本地落后远程，需要pull 分支管理HEAD指向当前分支--master分支，master指向最新提交 创建分支 创建分支将当前分支中的所有文件拷贝到新分支 $ git branch second 切换到分支 $ git checkout second 创建+切换到分支 $ git checkout -b second 查看当前分支 $ git branch 合并分支 合并指定分支到当前分支(主分支) $ git branch master$ git merge second 撤销合并操作 $ git reset 合并模式 ”fast forward”模式：合并分支默认使用”fast forward”模式，删除分支会丢掉分支信息，合并后看不出做过合并 普通模式：禁用”fast forward” 使用普通模式，合并后的历史可以看出曾经做过合并，在merge时生成一个新的commit。禁用”fast forward”并且加上了commit描述： $ git merge –no-ff -m “merge with no-ff” second 如果出现冲突:git status-&gt;修改冲突-&gt;git add-&gt;git commit git rebase origin master如果出现冲突:git status-&gt;修改冲突-&gt;git add-&gt;git rebase --continue 查看分支 $ git log 查看分支合并图$ git log –graph$ git log –graph –pretty=oneline –abbrev-commit 删除分支 $ git branch -d second$ git branch -D second：强行删除一个没有合并过的分支$ git push origin –delete second 删除远程分支 分支管理策略本地分支：master，dev，bug，feature远程分支：origin，dev 解决冲突 查看冲突 $ git status 查看分支合并图 git log –graph $ git log –graph –pretty=oneline –abbrev-commit 解决冲突合并分支发生冲突后，解决冲突步骤：查看冲突-&gt;修改-&gt;提交-&gt;合并完成 bug分支将当前无法提交到现场先保存起来，使工作区恢复clean状态，修复bug后，再将保存的东西解开 将工作现场先保存起来：git stash 查看保存现场记录：git stash list 恢复工作线程 git stash apply ：stash内容不删除，需要使用git stash drop手动删除 git stash pop：恢复的同时将stash的内容删除 git stash apply stash@{0}：有多个stah时，指定恢复到某个stash feature分支新添加功能时创建feature分支，开发完成合并到主分支，最好在开发新功能时为每一个新功能创建一个分支 多人协作查看远程库 查看远程库的信息 $ git remote 查看远程分支详细信息 $ git remote -v 推送分支将本地某个分支中的所有提交推送到远程库 $ git push origin master一般只推送master和dev分支，其他可以在本地放着 抓取分支创建本地dev分支： $ git checkout -b dev origin/dev git pull提示“no tracking information”,设置dev和origin/dev的链接：$ git branch –set-upstream dev origin/dev$ git pull$ git add/commit/push 注意：如果git pull时提示“no tracking information”，则需要指定本地master/dev分支与远程origin/dev分支的链接后，才能pull $ git branch –set-upstream dev origin/dev 已弃用$ git branch –set-upstream-to=origin/dev dev 最新用法 多⼈人协作的⼯工作模式:（1）git push origin branch-name（2）如果推送失败,则因为远程分⽀支⽐比你的本地更新,需要先⽤用git pull试图合并;（3）如果合并有冲突,则解决冲突,并在本地提交;（4）没有冲突或者解决掉冲突后,再⽤用git push origin branch-name推送就能成功! 标签添加标签 添加标签 $ git tag v1.0 补加标签 $ git log –pretty=oneline –abbrev-commit$ git tag v0.9 commitid 添加说明用-a指定标签名，-m指定说明文字： $ git tag -a v0.1 -m “version 0.1 released” 3628164 私钥签名标签 $ git tag -s v0.2 -m “signed version 0.2 released” fec145a 查看标签 查看所有标签 $ git tag 查看标签信息 $ git show v0.9注意，标签不是按时间顺序列出，而是按字母排序的。 推送标签 推送某一标签 $ git push origin v1.0 推送本地所有未推送标签 $ git push origin –tags 删除标签 删除本地标签 $ git tag -d v1.0 删除远程标签 需要先删除本地标签： $ git tag -d v1.0 推送到远程： $ git push origin :refs/tags/v1.0 github使用SSH123456789$ ssh-keygen -t rsa -C &quot;xxxxx@xxxxx.com&quot;# Creates a new ssh key using the provided email# Generating public/private rsa key pair...$ cat ~/.ssh/id_rsa.pub# ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC6eNtGpNGwstc.... 将public key添加$ ssh -T git@github.com （github）ssh -T git@git.oschina.net (oschina)Welcome to Git@OSC, yourname! 为开源仓库贡献代码fork在GitHub上，可以任意Fork开源仓库 提交修改自己拥有Fork后的仓库的读写权限，从自己帐号克隆仓库，然后提交到自己的仓库 pull request请求官方接受修改 自定义git配置用户名和email如果遇到以下问题：1234567891011*** Please tell me who you are.Rungit config --global user.email &quot;you@example.com&quot;git config --global user.name &quot;Your Name&quot;to set your account&apos;s default identity.Omit --global to set the identity only in this repository.&gt;&gt;&gt;fatal: unable to auto-detect email address (got &apos;xxx@xxx.(none)&apos;) 需要配置用户名和邮箱： $ git config –global user.name “Your Name”$ git config –global user.email “email@example.com” 给git命令添加颜色 $ git config –global color.ui true 忽略特殊文件 忽略文件的原则 忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件； 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。 强制添加被忽略的文件 $ git add -f App.class 查看想添加的文件被.gitignore中的哪条规则忽略了 $ git check-ignore -v App.class 注意：.gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理 配置别名 $ git config –global alias.st status$ git config –global alias.co checkout$ git config –global alias.ci commit$ git config –global alias.br branch$ git config –global alias.unstage ‘reset HEAD’$ git config –global alias.last ‘log -1’$ git config –global alias.lg “log –color –graph – 注意：--global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用 配置文件每个仓库的Git配置文件都放在.git/config文件中，查看配置文件 $ cat .git/config1234567891011121314[core]repositoryformatversion = 0filemode = falsebare = falselogallrefupdates = truesymlinks = falseignorecase = truehideDotFiles = dotGitOnly[remote &quot;origin&quot;]url = git@xxxfetch = +refs/heads/*:refs/remotes/origin/*[branch &quot;master&quot;]remote = originmerge = refs/heads/master $ cat ~/gitconfig1234567891011[user]email = xxxname = xxx[color]ui = true[alias]st = statusco = checkoutbr = branch[gui]encoding = gbk 要删除别名，直接把对应的行删掉即可改错了，可以删掉文件重新通过命令配置 自己搭建git服务器（1）安装gitsudo apt-get install git（2）创建一个git用户，用来运行git服务sudo adduser git（3）创建证书登录收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个（4）初始化Git仓库sudo chown -R git:git sample.git（5）禁用shell登录出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：git:x:1001:1001:,,,:/home/git:/bin/bash改为： git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。（6）克隆远程仓库git clone git@server:/srv/sample.git（7）要方便管理公钥，用Gitosis； 要像SVN那样变态地控制权限，用Gitolite。 安装可视化工具gitkgitk是需要tcl/tk支持的，所以安装gitk之前必须安装tcl/tk。tcl/tk下载：http://www.tcl.tk/software/tcltk/download.html git命令汇总git init git addgit commitgit rmgit status git diffgit log (–pretty=oneling)git reflog git checkout – filenamegit reset HEAD filenamegit reset –hard HEAD^(commitid) git add remote origin git/httpsgit push/pull/clone git branch secondgit checkout secondgit checkout -b secondgit branchgit branch -d secondgit log –graph –pretty=oneline –abbrev-commit git stashgit stash listgit stash applygit stash dropgit stash popgit stash apply stash@{0} git remote -vgit checkout -b dev origin/devgit branch –set-upstream-to=origin/dev devgit pull git tag namegit tag tagname commitidgit tag -a tagname -m “description”git taggit show tagnamegit push origin tagnamegit push origin –tagsgit tag -d tagnamegit push origin :refs/tags/tagname ssh-keygen -t rsa -C “xxxxx@xxxxx.com”cat ~/.ssh/id_rsa.pubssh -T git@github.com （github） git add -f App.class git config user.name “username”git config user.email “email”git config –global alias.st status 附Unix命令（1）创建文件夹：mkdir（2）跳到指定路径：cd（3）查看当前完整路径：pwd（4）查看当前路径下的所有文件及文件夹：ls（5）cat：可以显示文件内容，但是不能编辑（6）touch：如果文件存在，使用touch指令可更改这个文件或目录的日期时间，包括存取时间和更改时间；如果文件不存在，touch指令会在当前目录下新建一个空白文件（7）vi/vim：打开文件后可以编辑（8）echo：输出（9）删除文件夹，如果文件夹为空，使用rmdir dir即可，如果文件夹不为空，使用rm -rf dir删除该目录以及该目录下的所有文件 ，-r–是删除目录，-f意思是–强制删除，不提示。(-f:force -r:recursive) man -k rmdir查看rmdir命令作用，info rmdir查看rmdir命令详细信息 Git的官方网站 本文为阅读廖雪峰的官方网站中的git教程的学习笔记，仅为自己的一点学习记录，原文写的非常好，作者很厉害，有兴趣的朋友可以阅读原文：廖雪峰的官方网站的git教程","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://guchunli.github.io/tags/Git/"}]},{"title":"Markdown学习笔记","date":"2017-02-19T01:48:39.000Z","path":"2017/02/19/Markdown学习笔记/","text":"基本语法1.换行符： 一行结束时输入两个空格 line1line2 2.段落： 段落之间空一行 p1 p2p3 3.标题： （1）Setext形式：= 大标题 - 中标题 （2）atx形式：# 大标题中标题 一级标题二级标题三级标题四级标题五级标题六级标题 4.区块引用：> 区块1 区块2 区块3 5.列表：*/+/- 前后加空格，tab键或四个空格可分级 列表1 列表2 列表3 6.斜体、粗体、删除线斜体：*斜体* 斜体粗体：**斜体** 粗体粗斜体：***斜体*** 粗斜体删除线：~~删除线~~ 删除线 7.内嵌代码：` 内嵌代码 ` 内嵌代码8.水平线：—— 9.链接： [文字]（url title） ![]（图片 title） 百度一下-你就知道 10.注意：反斜杠\\实现转义效果11.表格 第一行为表头，第二行分割表头和主体，第三行开始每一行代表一个表格行 列与列之间用管道符号 “|” 隔开 居中对齐，-两边加: ； 居右对齐，-右侧加: 注意：如果表格不显示，表格的第一行与上面的内容之间要隔开，换行试试。 12345| title1 | title2 | title3 ||--------|:------:|----------:|| a | aa | aaa || b | bb | bbb || c | cc | ccc | title1 title2 title3 a aa aaa b bb bbb c cc ccc","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://guchunli.github.io/tags/markdown/"}]},{"title":"hexo创建个人博客记录","date":"2017-02-18T08:43:01.000Z","path":"2017/02/18/hexo创建个人博客记录/","text":"常见命令1.安装hexo1$ sudo npm install -g hexo 2.初始化1$ hexo init 3.生成静态页面1$ hexo generate（hexo g也可以） 4.启动本地服务，进行文章预览调试,浏览器输入http://localhost:4000即可1$ hexo server（hexo s也可以） 5.发布配置1$ hexo deploy（hexo d也可以） deploy之前进行build，可以对博客进行优化，提高网站访问速度。1$ gulp build //压缩js、css、img文件 每次部署的步骤，可按以下三步来进行: hexo clean，hexo generate，hexo deploy，或者 hexo d -g 6.新建文章1$ hexo new &quot;postName&quot; 7.新建页面1$ hexo new page &quot;pageName&quot; 8.添加统计数据在themes/yilia/layout/_partial/footer.ejs文件&lt;style&gt;上添加以下代码：1&lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt; &lt;style&gt;下添加以下代码：123本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次本文总阅读量&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次 hexo填坑历程(1)坑一：hexo命令找不到12ERROR Local hexo not found in E:\\blogERROR Try running: &apos;npm install hexo --save&apos; 解决：按照提示输入npm install hexo --save，如果不可以，可能是：因为安装包中有些内容在墙外，所以可以换淘宝源，或者用 $ npm install -g hexo-cli –no-optional(很重要)有时候只写npm install --no-optional也不行，只能以上命令 如果还是不可以，可能是由于：.gitignore文件里面忽略了node_modules文件夹，所以这个文件夹没有更新上去。所以用npm重新安装即可，输入以下命令：123cd ...\\blognpm installhexo server (2)坑二：ERROR Deployer not found: git $ npm install hexo-deployer-git –save然后重新 deploy 即可 (3)坑三：hexo deploy成功，但是页面不显示解决：到仓库下的settings下修改GitHub Pages，source选择master分支，显示 Your site is published at https://XXX.github.io/即可 (4)坑四：123fatal: Not a git repository (or any of the parent directories): .gitFATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: fatal: Not a git repository (or any of the parent directories): .git 解决：检查_config.yml文件deploy的配置如下：12type: gitrepo: https://github.com/XXX/XXX.github.io.git 如果还是不可以，请看下一解决方案。 (5)坑五：Permission to XXX.github.io.git denied解决：12$ git config --global user.name &quot;yourname&quot;$ git config --global user.email &quot;youremail&quot; 如果以上做完还是出不来，删掉根目录下的文件夹：.deploy_git，重新deploy就可以了。 添加动态背景效果代码：12&lt;script type=&quot;text/javascript&quot;color=&quot;0,0,255&quot; opacity=&apos;0.7&apos; zIndex=&quot;-2&quot; count=&quot;99&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://guchunli.github.io/tags/hexo/"},{"name":"个人博客","slug":"个人博客","permalink":"https://guchunli.github.io/tags/个人博客/"}]},{"title":"iOS国际化学习笔记","date":"2016-12-19T02:30:38.000Z","path":"2016/12/19/iOS国际化学习笔记/","text":"配置需要国际化的语言project-&gt;Info-&gt;Localizations 添加本地化语言包 App名称本地化(1)创建InfoPlist.string文件，Xcode的File inspection中Localize选择需要本地化的语言(2)在不同语言InfoPlist.strings对应文件中添加应用名称 InfoPlist.strings(English) 12//App在英语环境下显示的名称CFBundleDisplayName = &quot;AppName&quot;; InfoPlist.strings(Chinese)CFBundleDisplayName = “应用名称”; (3)info.plist添加Application has localized display name，值为YES 代码中字符串本地化(1)创建Localizable.strings文件，Xcode的File inspection中Localize选择需要本地化的语言(2)以KeyValue的形式，为代码中每一个需要本地化的字符串赋值 Localizable.strings(English) 1&quot;hello&quot; = &quot;Hello!&quot;; Localizable.strings(Chinese) 1&quot;hello&quot; = &quot;你好&quot;; (3)使用Foundation框架自带的NSLocalizedString(key, comment)这个宏根据Key获取对应字符串NSlocalizeString 第一个参数key是内容,根据key去对应语言的文件中获取对应的字符串，如果没有找到，那么就会以key作为value返回，第二个参数将会转化为字符串文件里的注释。 #define NSLocalizedString(key, comment) [[NSBundle mainBundle] localizedStringForKey:(key) value:@”” table:nil] 多人开发情况下的字符串本地化不在系统默认的本地化文件Localizable.strings中定义字符串，自定义strings文件储存本地化字符串，然后通过NSLocalizedStringFromTable(\\&lt;#key#\\&gt;, &lt;#tbl#&gt;, &lt;#comment#&gt;)获取。 tbl：自定义strings文件的名称图片本地化（两种方式两种方式）第一张方式：同获取本地化字符串方式获取图片名称进行加载第二种方式：将图片本地化，选中图片，在Xcode的File inspection中Localize选择需要本地化的语言，项目目录中显示service(English)和service(Chinese)两张图片，分别替换为不同语言的两张图片，实际是存储在en.lproj和zh-Hans.lproj中同为service.png名称的两张图片。两种方式同获取本地化字符串相同获取图片名称：1NSString *imgName = NSLocalizedString(@&quot;service&quot;, nil); 查看/切换本地语言查看本地语言环境：从NSUserDefaults中获取key为AppleLanguages的value即为当前语言环境。12NSArray *languages = [[NSUserDefaults standardUserDefaults] valueForKey:@&quot;AppleLanguages&quot;];NSString *currentLanguage = languages.firstObject; 切换当前语言环境：12NSArray *lans = @[@&quot;zh-Hans&quot;];[[NSUserDefaults standardUserDefaults] setObject:lans forKey:@&quot;AppleLanguages&quot;]; 也可通过Edit Scheme-&gt;Run-&gt;Arguments Passed On Launch -&gt;-AppleLanguages (语言)改变语言环境 原文链接：3分钟实现iOS语言本地化/国际化（图文详解）","comments":true,"categories":[{"name":"学习","slug":"study","permalink":"https://guchunli.github.io/categories/study/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"国际化","slug":"国际化","permalink":"https://guchunli.github.io/tags/国际化/"}]}]