[{"title":"iOS单元测试","date":"2017-06-13T06:16:58.000Z","path":"2017/06/13/iOS单元测试/","text":"1.新建项目时注意勾选Unit Tests,UI Tests如果忘记勾选，File–&gt;new–&gt;target–&gt;iOS–&gt;Cocoa Unit Testing Bundle/Cocoa UI Testing Bundle 添加2.setUp是每个测试方法调用前执行，tearDown是每个测试方法调用后执行3.测试方法必须testXXX的格式，且不能有参数4.测试方法的执行顺序是字典序排序,cmd + U进行单元测试，这个快捷键是全部测试，在代码左侧就是平常打断点的地方，有个菱形按钮是单独测试这个方法5.iOS9的http安全问题：现在进行异步请求的网络测试，由于测试方法主线程执行完就会结束，所以需要设置一下，否则没法查看异步返回结果。在方法结束前设置等待，调回回来的时候再让它继续执行。12345678//waitForExpectationsWithTimeout是等待时间，超过了就不再等待往下执行。#define WAIT do &#123;\\[self expectationForNotification:@&quot;RSBaseTest&quot; object:nil handler:nil];\\[self waitForExpectationsWithTimeout:30 handler:nil];\\&#125; while (0);#define NOTIFY \\[[NSNotificationCenter defaultCenter]postNotificationName:@&quot;RSBaseTest&quot; object:nil]; 常用的断言测试函数XCTFail(format…) //生成一个失败的测试；XCTAssertNil(a1, format…) //为空判断，a1为空时通过，反之不通过；XCTAssertNotNil(a1, format…) //不为空判断，a1不为空时通过，反之不通过；XCTAssert(expression, format…) //当expression求值为TRUE时通过；XCTAssertTrue(expression, format…) //当expression求值为TRUE时通过；XCTAssertFalse(expression, format…) //当expression求值为False时通过；XCTAssertEqualObjects(a1, a2, format…) //判断相等，[a1 isEqual:a2]值为TRUE时通过，其中一个不为空时，不通过；XCTAssertNotEqualObjects(a1, a2, format…) //判断不等，[a1 isEqual:a2]值为False时通过；XCTAssertEqual(a1, a2, format…) //判断相等（当a1和a2是 C语言标量、结构体或联合体时使用,实际测试发现NSString也可以）；XCTAssertNotEqual(a1, a2, format…) //判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；XCTAssertEqualWithAccuracy(a1, a2, accuracy, format…) //判断相等，（double或float类型）提供一个误差范围，当在误差范围（+/-accuracy）以内相等时通过测试；XCTAssertNotEqualWithAccuracy(a1, a2, accuracy, format…) //判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试；XCTAssertThrows(expression, format…) //异常测试，当expression发生异常时通过；反之不通过；XCTAssertThrowsSpecific(expression, specificException, format…) //异常测试，当expression发生specificException异常时通过；反之发生其他异常或不发生异常均不通过；XCTAssertThrowsSpecificNamed(expression, specificException, exception_name, format…) //异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过；XCTAssertNoThrow(expression, format…) //异常测试，当expression没有发生异常时通过测试；XCTAssertNoThrowSpecific(expression, specificException, format…) //异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过；XCTAssertNoThrowSpecificNamed(expression, specificException, exception_name, format…) //异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过 示例代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// XCTFail(format…) //生成一个失败的测试；// XCTFail(@&quot;Fail&quot;);// XCTAssertNil(a1, format...) 为空判断， a1 为空时通过，反之不通过；// XCTAssertNil(@&quot;not nil string&quot;, @&quot;string must be nil&quot;);// XCTAssertNotNil(a1, format…) 不为空判断，a1不为空时通过，反之不通过；XCTAssertNotNil(@&quot;not nil string&quot;, @&quot;string can not be nil&quot;);// XCTAssert(expression, format...) 当expression求值为TRUE时通过；// XCTAssert((2 &gt; 2), @&quot;expression must be true&quot;);// XCTAssertTrue(expression, format...) 当expression求值为TRUE时通过；XCTAssertTrue(1, @&quot;Can not be zero&quot;);// XCTAssertFalse(expression, format...) 当expression求值为False时通过；XCTAssertFalse((2 &lt; 2), @&quot;expression must be false&quot;);// XCTAssertEqualObjects(a1, a2, format...) 判断相等， [a1 isEqual:a2] 值为TRUE时通过，其中一个不为空时，不通过；// XCTAssertEqualObjects(@&quot;1&quot;, @&quot;1&quot;, @&quot;[a1 isEqual:a2] should return YES&quot;);// XCTAssertEqualObjects(@&quot;1&quot;, @&quot;2&quot;, @&quot;[a1 isEqual:a2] should return YES&quot;);// XCTAssertNotEqualObjects(a1, a2, format...) 判断不等， [a1 isEqual:a2] 值为False时通过，// XCTAssertNotEqualObjects(@&quot;1&quot;, @&quot;1&quot;, @&quot;[a1 isEqual:a2] should return NO&quot;);// XCTAssertNotEqualObjects(@&quot;1&quot;, @&quot;2&quot;, @&quot;[a1 isEqual:a2] should return NO&quot;);// XCTAssertEqual(a1, a2, format...) 判断相等（当a1和a2是 C语言标量、结构体或联合体时使用,实际测试发现NSString也可以）；// 1.比较基本数据类型变量// XCTAssertEqual(1, 2, @&quot;a1 = a2 shoud be true&quot;); // 无法通过测试// XCTAssertEqual(1, 1, @&quot;a1 = a2 shoud be true&quot;); // 通过测试// 2.比较NSString对象// NSString *str1 = @&quot;1&quot;;// NSString *str2 = @&quot;1&quot;;// NSString *str3 = str1;// XCTAssertEqual(str1, str2, @&quot;a1 and a2 should point to the same object&quot;); // 通过测试// XCTAssertEqual(str1, str3, @&quot;a1 and a2 should point to the same object&quot;); // 通过测试// 3.比较NSArray对象// NSArray *array1 = @[@1];// NSArray *array2 = @[@1];// NSArray *array3 = array1;// XCTAssertEqual(array1, array2, @&quot;a1 and a2 should point to the same object&quot;); // 无法通过测试// XCTAssertEqual(array1, array3, @&quot;a1 and a2 should point to the same object&quot;); // 通过测试// XCTAssertNotEqual(a1, a2, format...) 判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；// XCTAssertEqualWithAccuracy(a1, a2, accuracy, format...) 判断相等，（double或float类型）提供一个误差范围，当在误差范围（+/- accuracy ）以内相等时通过测试；// XCTAssertEqualWithAccuracy(1.0f, 1.5f, 0.25f, @&quot;a1 = a2 in accuracy should return YES&quot;);// XCTAssertNotEqualWithAccuracy(a1, a2, accuracy, format...) 判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试；// XCTAssertNotEqualWithAccuracy(1.0f, 1.5f, 0.25f, @&quot;a1 = a2 in accuracy should return NO&quot;);// XCTAssertThrows(expression, format...) 异常测试，当expression发生异常时通过；反之不通过；（很变态）// XCTAssertThrowsSpecific(expression, specificException, format...) 异常测试，当expression发生 specificException 异常时通过；反之发生其他异常或不发生异常均不通过；// XCTAssertThrowsSpecificNamed(expression, specificException, exception_name, format...) 异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过；// XCTAssertNoThrow(expression, format…) 异常测试，当expression没有发生异常时通过测试；// XCTAssertNoThrowSpecific(expression, specificException, format...)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过；// XCTAssertNoThrowSpecificNamed(expression, specificException, exception_name, format...) 异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过 转自：iOS单元测试(作用及入门提升)(http://www.jianshu.com/p/009844a0b9ed)","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"test","slug":"test","permalink":"https://guchunli.github.io/tags/test/"}]},{"title":"iOS图片处理的几种方式","date":"2017-06-13T03:41:31.000Z","path":"2017/06/13/iOS图片处理的几种方式/","text":"","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"图片","slug":"图片","permalink":"https://guchunli.github.io/tags/图片/"},{"name":"美图","slug":"美图","permalink":"https://guchunli.github.io/tags/美图/"}]},{"title":"iOS实现音频/视频的播放/录制的几种方式","date":"2017-06-13T03:41:05.000Z","path":"2017/06/13/iOS实现音频-视频的播放-录制的几种方式/","text":"","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"音频","slug":"音频","permalink":"https://guchunli.github.io/tags/音频/"},{"name":"视频","slug":"视频","permalink":"https://guchunli.github.io/tags/视频/"},{"name":"播放","slug":"播放","permalink":"https://guchunli.github.io/tags/播放/"},{"name":"录制","slug":"录制","permalink":"https://guchunli.github.io/tags/录制/"}]},{"title":"ReactiveNative使用","date":"2017-06-13T03:39:45.000Z","path":"2017/06/13/ReactiveNative使用/","text":"","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"ReactiveNative","slug":"ReactiveNative","permalink":"https://guchunli.github.io/tags/ReactiveNative/"}]},{"title":"iOS runtime的理解","date":"2017-06-13T03:39:18.000Z","path":"2017/06/13/iOS-runtime的理解/","text":"Objective-C 是一门动态语言，它把很多静态语言在编译和链接时做的事情放到了运行时去处理，它在运行时实现了对类、方法、成员变量、属性等信息的管理机制。 运行时的类与对象 类与对象相关的函数12345678910111213141516171819202122232425262728293031const char *class_getName(Class cls)，获取指定类的类名。BOOL class_isMetaClass(Class cls)，判断指定类是否是一个元类。Class class_getSuperclass(Class cls)，获取指定类的父类。Class class_setSuperclass(Class cls, Class newSuper)，设定指定类的父类。int class_getVersion(Class cls)，获取指定类的版本信息。void class_setVersion(Class cls, int version)，设定指定类的版本信息。size_t class_getInstanceSize(Class cls)，获取实例大小。Ivar class_getInstanceVariable(Class cls, const char *name)，获取指定名字的实例变量。Ivar class_getClassVariable(Class cls, const char *name)，获取指定名字的类变量。Ivar *class_copyIvarList(Class cls, unsigned int *outCount)，获取类的成员变量列表的拷贝。调用后需要自己 free()。Method class_getInstanceMethod(Class cls, SEL name)，获取指定名字的实例方法。Method class_getClassMethod(Class cls, SEL name)，获取指定名字的类方法。IMP class_getMethodImplementation(Class cls, SEL name)，获取指定名字的方法实现。BOOL class_respondsToSelector(Class cls, SEL sel)，类是否响应指定的方法。Method *class_copyMethodList(Class cls, unsigned int *outCount)，获取方法列表的拷贝。调用后需要自己 free()。BOOL class_conformsToProtocol(Class cls, Protocol *protocol)，类是否遵循指定的协议。Protocol * __unsafe_unretained *class_copyProtocolList(Class cls, unsigned int *outCount)，获取协议列表的拷贝。调用后需要自己 free()。objc_property_t class_getProperty(Class cls, const char *name)，获取指定名字的属性。objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)，获取类的属性列表。调用后需要自己 free()。BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)，为类添加方法。IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types)，替代类的方法。BOOL class_addIvar(Class cls, const char *name, size_t size, uint8_t alignment, const char *types)，给指定的类添加成员变量。这个函数只能在 objc_allocateClassPair() 和 objc_registerClassPair() 之间调用，并且不能为一个已经存在的类添加成员变量。BOOL class_addProtocol(Class cls, Protocol *protocol)，为类添加协议。BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)，为类添加属性。void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)，替代类的属性。id class_createInstance(Class cls, size_t extraBytes)，创建指定类的实例。id objc_constructInstance(Class cls, void *bytes)，在指定的位置创建类的实例。void *objc_destructInstance(id obj)，销毁实例。Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)，创建类和元类。void objc_registerClassPair(Class cls)，注册类到 Runtime。void objc_disposeClassPair(Class cls)，销毁类和对应的元类。 类是元类的实例。 isa，在大多面向对象的语言中，都有类和对象的概念，其中，对象是类的实例，是通过类定义的结构生成出来的。而在 Objective-C 中，类本身也是一个对象，类作为对象时的 isa 指针指向的是元类(Meta Class)。 object_getClass() 可以获得当前对象 isa #pragma clang diagnostic...代码，这是用于忽略编译器对于未声明的 @selector 的 warning。因为我们的代码中我们需要动态的为一个类创建方法，所以必然不会事先声明。 class_addMethod() 函数的最后一个参数 types 是描述方法返回值和参数列表的字符串，我们的代码中的用到的 i@:@ 四个字符分别对应着：返回值 int32_t、参数 id self、参数 SEL _cmd、参数 NSDictionary *dic。这个其实就是类型编码(Type Encoding)的概念。在 Objective-C 中，为了协助 Runtime 系统，编译器会将每个方法的返回值和参数列表编码为一个字符串，这个字符串会与方法对应的 selector 关联。更详细的知识可以查阅 Type Encodings。 使用 objc_registerClassPair() 函数需要注意，你不能注册已经注册过的类。 使用 objc_disposeClassPair() 函数需要注意，如果一个类的实例和子类还存在时，不要去销毁一个类。 运行时的成员变量与属性成员变量和属性相关的函数123456789101112131415161718Ivar class_getClassVariable(Class cls, const char *name)，返回指定类的指定名字的成员变量。Ivar *class_copyIvarList(Class cls, unsigned int *outCount)，返回指定类的成员变量列表。调用后需要自己 free()。BOOL class_addIvar(Class cls, const char *name, size_t size, uint8_t alignment, const char *types)，给指定的类添加成员变量。这个函数只能在 objc_allocateClassPair() 和 objc_registerClassPair() 之间调用，并且不能为一个已经存在的类添加成员变量。id object_getIvar(id obj, Ivar ivar)，获得对象的指定成员变量的值。速度比 object_getInstanceVariable() 快。void object_setIvar(id obj, Ivar ivar, id value)，设置对象指定成员变量的值。速度比 object_setInstanceVariable() 快。Ivar object_getInstanceVariable(id obj, const char *name, void **outValue)，获取指定名字的成员变量的值。Ivar object_setInstanceVariable(id obj, const char *name, void *value)，设置指定名字成员变量的值。const char *ivar_getName(Ivar v)，获取成员变量名。const char *ivar_getTypeEncoding(Ivar v)，获取成员变量的类型编码。ptrdiff_t ivar_getOffset(Ivar v)，获取成员变量的偏移量。objc_property_t class_getProperty(Class cls, const char *name), 获取指定类指定名字的属性。objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount), 获取指定类的属性列表。调用后需要自己 free()。BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)， 给指定的类添加属性。void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)，替代指定类的属性。const char *property_getName(objc_property_t property)，获取属性名。const char *property_getAttributes(objc_property_t property)，获取属性特性描述。objc_property_attribute_t *property_copyAttributeList(objc_property_t property, unsigned int *outCount)，获取属性特性列表。调用后需要自己 free()。char *property_copyAttributeValue(objc_property_t property, const char *attributeName)，获取属性特性值。调用后需要自己 free()。 IMP 其实就是 implementation 的缩写，表示方法实现的代码块地址 我们不能用 class_addIvar() 函数为一个已经存在的类添加 Ivar。并且 class_addIvar() 只能在 objc_allocateClassPair() 和 objc_registerClassPair() 之间调用。 添加一个属性及对应的成员变量后，我们还能通过 [obj valueForKey:@”propertyName”]; 获得属性值。 运行时的消息分发objc_msgSend(id self, SEL op, ...)，消息分发。(objc/message.h)1234567891011121314151617id method_invoke(id receiver, Method m, ...);，调用指定方法的实现。void method_invoke_stret(id receiver, Method m, ...);，调用返回一个数据结构的方法的实现。SEL method_getName(Method m);，获取方法名。IMP method_getImplementation(Method m);，返回方法的实现。const char * method_getTypeEncoding(Method m);，获取描述方法参数和返回值类型的字符串。char * method_copyReturnType(Method m);，获取方法的返回值类型的字符串。char * method_copyArgumentType(Method m, unsigned int index);，获取方法的指定位置参数的类型字符串。void method_getReturnType(Method m, char *dst, size_t dst_len);，通过引用返回方法的返回值类型字符串。unsigned int method_getNumberOfArguments(Method m);，返回方法的参数的个数。void method_getArgumentType(Method m, unsigned int index, char *dst, size_t dst_len);，通过引用返回方法指定位置参数的类型字符串。struct objc_method_description * method_getDescription(Method m);，返回指定方法的方法描述结构体。IMP method_setImplementation(Method m, IMP imp);，设置方法的实现。注意该函数返回值是方法之前的实现。void method_exchangeImplementations(Method m1, Method m2);，交换两个方法的实现。const char * sel_getName(SEL sel);，返回给定选择器指定的方法的名称。SEL sel_registerName(const char *str);，在Objective-C Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器。SEL sel_getUid(const char *str);，在Objective-C Runtime系统中注册一个方法。BOOL sel_isEqual(SEL lhs, SEL rhs);，比较两个选择器。 消息转发机制基本上分为三个步骤：第一步：动态方法解析。未知的方法被截获，程序不会崩溃123456789101112131415#import &lt;objc/runtime.h&gt;- (void)viewDidLoad &#123;[super viewDidLoad];[self performSelector:@selector(unknownMethod)];&#125;void dealWithExceptionForUnknownMethod(id self, SEL _cmd) &#123;NSLog(@&quot;%@, %p&quot;, self, _cmd); // Print: &lt;ViewController: 0x7ff96be33e60&gt;, 0x1078259fc&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;NSString *selectorString = NSStringFromSelector(sel);if ([selectorString isEqualToString:@&quot;unknownMethod&quot;]) &#123;class_addMethod(self.class, @selector(unknownMethod), (IMP) dealWithExceptionForUnknownMethod, &quot;v@:&quot;);&#125;return [super resolveInstanceMethod:sel];&#125; 第二步：备用接收者。如果在第一步还是无法处理消息，则 Runtime 会继续调以下方法：1- (id)forwardingTargetForSelector:(SEL)aSelector 这一步适用于当我们只想将消息转发到另一个能处理该消息的对象上的情况，它无法进一步对消息进行处理，比如：操作消息的参数和返回值。 第三步：完整转发。如果第二步：备用接收者还是未能处理好消息，那么接下来只有启用完整的消息转发机制了，这时候会调用以下方法：1- (void)forwardInvocation:(NSInvocation *)anInvocation 运行时系统会在这一步给消息接收者最后一次机会将消息转发给其它对象。另外还有一个重要的问题是我们必须重写下面方法：1- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector 如果不在以上所述的三个步骤中处理未知消息，到了 NSObject 那则会引发一个异常。 代码：RuntimeDemo 转自：Objective-C 的 Runtime","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"runtime","slug":"runtime","permalink":"https://guchunli.github.io/tags/runtime/"}]},{"title":"MVVM学习","date":"2017-06-13T03:38:51.000Z","path":"2017/06/13/MVVM学习/","text":"","comments":true,"categories":[],"tags":[]},{"title":"RAC使用入门","date":"2017-06-13T03:30:03.000Z","path":"2017/06/13/RAC使用入门/","text":"ReactiveCocoa作用1.target-action:rac_signalForControlEventsrac_textSignal rac_gestureSignal2.代理 rac_signalForSelector:@selector() fromProtocol:()3.通知 rac_addObserverForName4.KVO RACObserve(object, value) 代码示例：1.target-action123456789101112131415161718//1.1 监听textfield文字更改// [[self.textfiled rac_signalForControlEvents:UIControlEventEditingChanged] subscribeNext:^(id x)&#123;// NSLog(@&quot;change&quot;);// &#125;];//简写[[self.textfiled rac_textSignal] subscribeNext:^(id x) &#123;NSLog(@&quot;%@&quot;,x);&#125;];//1.2UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] init];[[tap rac_gestureSignal] subscribeNext:^(id x) &#123;NSLog(@&quot;tap&quot;);&#125;];//注意：如果给label添加手势，需要打开userInteractionEnabledself.lab.userInteractionEnabled = YES;[self.lab addGestureRecognizer:tap]; 2.代理：rac_signalForSelector:@selector() fromProtocol:()* 注意：只能实现返回值为void的代理方法12345678910111213UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@&quot;title&quot; message:@&quot;rac test&quot; delegate:self cancelButtonTitle:@&quot;no&quot; otherButtonTitles:@&quot;yes&quot;, nil];// [[self rac_signalForSelector:@selector(alertView:clickedButtonAtIndex:) fromProtocol:@protocol(UIAlertViewDelegate)] subscribeNext:^(RACTuple *tuple) &#123;// //tuple为点击按钮的各个参数// NSLog(@&quot;%ld&quot;,tuple.count);// NSLog(@&quot;%@&quot;,tuple.first);// NSLog(@&quot;%@&quot;,tuple.second);// NSLog(@&quot;%@&quot;,tuple.third);// &#125;];//简写[[alertView rac_buttonClickedSignal] subscribeNext:^(id x) &#123;NSLog(@&quot;%@&quot;,x);&#125;];[alertView show]; 3.通知 rac_addObserverForName123456[[[NSNotificationCenter defaultCenter] rac_addObserverForName:@&quot;postData&quot; object:nil] subscribeNext:^(NSNotification *notification) &#123;NSLog(@&quot;%@&quot;, notification.name);NSLog(@&quot;%@&quot;, notification.object);&#125;];[self presentViewController:[[SecondViewController alloc]init] animated:YES completion:nil]; SecondViewController代码：123NSMutableArray *dataArray = [[NSMutableArray alloc] initWithObjects:@&quot;1&quot;, @&quot;2&quot;, @&quot;3&quot;, nil];[[NSNotificationCenter defaultCenter] postNotificationName:@&quot;postData&quot; object:dataArray];[self dismissViewControllerAnimated:YES completion:nil]; 4.KVO RACObserve(object, value)1234567UIScrollView *scrolView = [[UIScrollView alloc] initWithFrame:CGRectMake(0, 300, 200, 400)];scrolView.contentSize = CGSizeMake(200, 800);scrolView.backgroundColor = [UIColor greenColor];[self.view addSubview:scrolView];[RACObserve(scrolView, contentOffset) subscribeNext:^(id x) &#123; NSLog(@&quot;success&quot;);&#125;]; 原文链接：学习RAC小记-适合给新手看的RAC用法总结","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"RAC","slug":"RAC","permalink":"https://guchunli.github.io/tags/RAC/"}]},{"title":"iOS IM的几种实现方式","date":"2017-06-13T03:19:11.000Z","path":"2017/06/13/iOS-IM的几种实现方式/","text":"客户端需要做如下4件事： 1.客户端调用 socket(…) 创建socket； 2.客户端调用 connect(…) 向服务器发起连接请求以建立连接； 3.客户端与服务器建立连接之后，就可以通过send(…)/receive(…)向客户端发送或从客户端接收数据； 4.客户端调用 close 关闭 socket； 服务端需要做如下5件事： 1.服务器调用 socket(…) 创建socket； 2.服务器调用 listen(…) 设置缓冲区； 3.服务器通过 accept(…)接受客户端请求建立连接； 4.服务器与客户端建立连接之后，就可以通过 send(…)/receive(…)向客户端发送或从客户端接收数据； 5.服务器调用 close 关闭 socket； 可以通过以下几种方式实现： 1.系统socket 2.基于Scoket原生：代表框架 CocoaAsyncSocket 3.基于WebScoket：代表框架 SocketRocket。(npm install ws) 4.MQTTKit：MQTTClient(npm install mosca) 5.XMPP 6.私有协议：基于WebScoket或者Scoket原生进行封装（高效，省流量，安全性高）其中MQTT和XMPP为聊天协议，它们是最上层的协议，而WebScoket是传输通讯协议。 XMPP常用对象：XMPPStream：xmpp基础服务类XMPPRoster：好友列表类XMPPRosterCoreDataStorage：好友列表（用户账号）在core data中的操作类XMPPvCardCoreDataStorage：好友名片（昵称，签名，性别，年龄等信息）在core data中的操作类XMPPvCardTemp：好友名片实体类，从数据库里取出来的都是它xmppvCardAvatarModule：好友头像XMPPReconnect：如果失去连接,自动重连XMPPRoom：提供多用户聊天支持XMPPPubSub：发布订阅 代码传送门：IMWithSocket 参考原文：iOS即时通讯，从入门到“放弃”？iOS - XMPP 的使用","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"IM","slug":"IM","permalink":"https://guchunli.github.io/tags/IM/"},{"name":"socket","slug":"socket","permalink":"https://guchunli.github.io/tags/socket/"}]},{"title":"RAC使用进阶","date":"2017-06-13T02:31:47.000Z","path":"2017/06/13/RAC使用进阶/","text":"ReactiveCocoa(RAC):函数响应式编程（FRP）框架 ReactiveCocoa常见类RACSiganl:信号类一般表示将来有数据传递，只要有数据改变，信号内部接收到数据，就会马上发出数据。 注意： 信号类(RACSiganl)，只是表示当数据改变时，信号内部会发出数据，它本身不具备发送信号的能力，而是交给内部一个订阅者去发出。 默认一个信号都是冷信号，也就是值改变了，也不会触发，只有订阅了这个信号，这个信号才会变为热信号，值改变了才会触发。 如何订阅信号：调用信号RACSignal的subscribeNext就能订阅。 RACSiganl简单使用 1.创建信号 1$ + (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe 2.订阅信号,才会激活信号. 1$ - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock 3.发送信号 1$ - (void)sendNext:(id)value RACSignal底层实现 1.创建信号，首先把didSubscribe保存到信号中，还不会触发。 2.当信号被订阅，也就是调用signal的subscribeNext:nextBlock 2.1 subscribeNext内部会创建订阅者subscriber，并且把nextBlock保存到subscriber中。 2.2 subscribeNext内部会调用siganl的didSubscribe 3.siganl的didSubscribe中调用[subscriber sendNext:@1]; 3.1 sendNext底层其实就是执行subscriber的nextBlock1234567891011121314151617181920// 1.创建信号RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; // block调用时刻：每当有订阅者订阅信号，就会调用block。 // 2.发送信号 [subscriber sendNext:@1]; // 如果不在发送数据，最好发送信号完成，内部会自动调用[RACDisposable disposable]取消订阅信号。 [subscriber sendCompleted]; return [RACDisposable disposableWithBlock:^&#123; // block调用时刻：当信号发送完成或者发送错误，就会自动执行这个block,取消订阅信号。 // 执行完Block后，当前信号就不在被订阅了。 NSLog(@&quot;信号被销毁&quot;); &#125;];&#125;];// 3.订阅信号,才会激活信号.[siganl subscribeNext:^(id x) &#123; // block调用时刻：每当有信号发出数据，就会调用block. NSLog(@&quot;接收到数据:%@&quot;,x);&#125;]; RACSubscriber表示订阅者的意思，用于发送信号，这是一个协议，不是一个类，只要遵守这个协议，并且实现方法才能成为订阅者。通过create创建的信号，都有一个订阅者，帮助他发送数据。 RACDisposable 用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。 使用场景:不想监听某个信号时，可以通过它主动取消订阅信号。 RACSubject 信号提供者，自己可以充当信号，又能发送信号。 使用场景:通常用来代替代理，有了它，就不必要定义代理了。 RACSubject:底层实现和RACSignal不一样。 1.调用subscribeNext订阅信号，只是把订阅者保存起来，并且订阅者的nextBlock已经赋值了。 2.调用sendNext发送信号，遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。 RACSubject使用步骤: 1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。 2.订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock 3.发送信号 sendNext:(id)value123456789101112131415// 1.创建信号RACSubject *subject = [RACSubject subject];// 2.订阅信号[subject subscribeNext:^(id x) &#123;// block调用时刻：当信号发出新值，就会调用.NSLog(@&quot;第一个订阅者%@&quot;,x);&#125;];[subject subscribeNext:^(id x) &#123;// block调用时刻：当信号发出新值，就会调用.NSLog(@&quot;第二个订阅者%@&quot;,x);&#125;];// 3.发送信号[subject sendNext:@&quot;1&quot;]; RACSubject替换代理需求:1.给当前控制器添加一个按钮，modal到另一个控制器界面2.另一个控制器view中有个按钮，点击按钮，通知当前控制器 步骤一：在第二个控制器.h，添加一个RACSubject代替代理。 123@interface TwoViewController : UIViewController@property (nonatomic, strong) RACSubject *delegateSignal;@end 步骤二：监听第二个控制器按钮点击 123456789101112@implementation TwoViewController- (IBAction)notice:(id)sender &#123;// 通知第一个控制器，告诉它，按钮被点了// 通知代理// 判断代理信号是否有值if (self.delegateSignal) &#123; // 有值，才需要通知 [self.delegateSignal sendNext:nil]; &#125;&#125;@end 步骤三：在第一个控制器中，监听跳转按钮，给第二个控制器的代理信号赋值，并且监听. 1234567891011121314@implementation OneViewController - (IBAction)btnClick:(id)sender &#123; // 创建第二个控制器 TwoViewController *twoVc = [[TwoViewController alloc] init]; // 设置代理信号 twoVc.delegateSignal = [RACSubject subject]; // 订阅代理信号 [twoVc.delegateSignal subscribeNext:^(id x) &#123; NSLog(@&quot;点击了通知按钮&quot;); &#125;]; // 跳转到第二个控制器 [self presentViewController:twoVc animated:YES completion:nil];&#125;@end RACReplaySubject重复提供信号类，是RACSubject的子类。RACReplaySubject与RACSubject区别: RACReplaySubject可以先发送信号，在订阅信号，RACSubject就不可以。 使用场景一:如果一个信号每被订阅一次，就需要把之前的值重复发送一遍，使用重复提供信号类。 使用场景二:可以设置capacity数量来限制缓存的value的数量,即只缓充最新的几个值。RACReplaySubject:底层实现和RACSubject不一样。 1.调用sendNext发送信号，把值保存起来，然后遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。 2.调用subscribeNext订阅信号，遍历保存的所有值，一个一个调用订阅者的nextBlock注意：如果想当一个信号被订阅，就重复播放之前所有值，需要先发送信号，在订阅信号。也就是先保存值，在订阅值。RACReplaySubject使用步骤: 1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。 2.可以先订阅信号，也可以先发送信号。 2.1 订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock 2.2 发送信号 sendNext:(id)value12345678910111213141516// 1.创建信号RACReplaySubject *replaySubject = [RACReplaySubject subject];// 2.发送信号[replaySubject sendNext:@1];[replaySubject sendNext:@2];// 3.订阅信号[replaySubject subscribeNext:^(id x) &#123; NSLog(@&quot;第一个订阅者接收到的数据%@&quot;,x);&#125;];// 订阅信号[replaySubject subscribeNext:^(id x) &#123; NSLog(@&quot;第二个订阅者接收到的数据%@&quot;,x);&#125;]; RACTuple元组类,类似NSArray,用来包装值. RACSequenceRAC中的集合类，用于代替NSArray,NSDictionary,可以使用它来快速遍历数组和字典。使用场景：字典转模型RACSequence和RACTuple简单使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 1.遍历数组NSArray *numbers = @[@1,@2,@3,@4];// 第一步: 把数组转换成集合RACSequence numbers.rac_sequence// 第二步: 把集合RACSequence转换RACSignal信号类,numbers.rac_sequence.signal// 第三步: 订阅信号，激活信号，会自动把集合中的所有值，遍历出来。[numbers.rac_sequence.signal subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x);&#125;];// 2.遍历字典,遍历出来的键值对会包装成RACTuple(元组对象)NSDictionary *dict = @&#123;@&quot;name&quot;:@&quot;zs&quot;,@&quot;age&quot;:@18&#125;;[dict.rac_sequence.signal subscribeNext:^(RACTuple *x) &#123;// 解包元组，会把元组的值，按顺序给参数里面的变量赋值RACTupleUnpack(NSString *key,NSString *value) = x; // 相当于以下写法 // NSString *key = x[0]; // NSString *value = x[1]; NSLog(@&quot;%@ %@&quot;,key,value);&#125;];// 3.字典转模型// 3.1 OC写法NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;flags.plist&quot; ofType:nil];NSArray *dictArr = [NSArray arrayWithContentsOfFile:filePath];NSMutableArray *items = [NSMutableArray array];for (NSDictionary *dict in dictArr) &#123; FlagItem *item = [FlagItem flagWithDict:dict]; [items addObject:item];&#125;// 3.2 RAC写法NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;flags.plist&quot; ofType:nil];NSArray *dictArr = [NSArray arrayWithContentsOfFile:filePath];NSMutableArray *flags = [NSMutableArray array];_flags = flags;// rac_sequence注意点：调用subscribeNext，并不会马上执行nextBlock，而是会等一会。[dictArr.rac_sequence.signal subscribeNext:^(id x) &#123; // 运用RAC遍历字典，x：字典 FlagItem *item = [FlagItem flagWithDict:x]; [flags addObject:item];&#125;];NSLog(@&quot;%@&quot;, NSStringFromCGRect([UIScreen mainScreen].bounds));// 3.3 RAC高级写法:NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;flags.plist&quot; ofType:nil];NSArray *dictArr = [NSArray arrayWithContentsOfFile:filePath];// map:映射的意思，目的：把原始值value映射成一个新值// array: 把集合转换成数组// 底层实现：当信号被订阅，会遍历集合中的原始值，映射成新值，并且保存到新的数组里。NSArray *flags = [[dictArr.rac_sequence map:^id(id value) &#123; return [FlagItem flagWithDict:value];&#125;] array]; RACCommandRAC中用于处理事件的类，可以把事件如何处理,事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。使用场景:监听按钮点击，网络请求 RACCommand使用步骤: 1.创建命令 initWithSignalBlock:(RACSignal * (^)(id input))signalBlock 2.在signalBlock中，创建RACSignal，并且作为signalBlock的返回值 3.执行命令 - (RACSignal *)execute:(id)input RACCommand使用注意 1.signalBlock必须要返回一个信号，不能传nil. 2.如果不想要传递信号，直接创建空的信号[RACSignal empty]; 3.RACCommand中信号如果数据传递完，必须调用[subscriber sendCompleted]，这时命令才会执行完毕，否则永远处于执行中。 4.RACCommand需要被强引用，否则接收不到RACCommand中的信号，因此RACCommand中的信号是延迟发送的。 RACCommand设计思想：内部signalBlock为什么要返回一个信号，这个信号有什么用。 1.在RAC开发中，通常会把网络请求封装到RACCommand，直接执行某个RACCommand就能发送请求。 2.当RACCommand内部请求到数据的时候，需要把请求的数据传递给外界，这时候就需要通过signalBlock返回的信号传递了。 如何拿到RACCommand中返回信号发出的数据。 1.RACCommand有个执行信号源executionSignals，这个是signal of signals(信号的信号),意思是信号发出的数据是信号，不是普通的类型。 2.订阅executionSignals就能拿到RACCommand中返回的信号，然后订阅signalBlock返回的信号，就能获取发出的值。 五、监听当前命令是否正在执行executing 六、使用场景,监听按钮点击，网络请求 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 1.创建命令RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) &#123; NSLog(@&quot;执行命令&quot;); // 创建空信号,必须返回信号 // return [RACSignal empty]; // 2.创建信号,用来传递数据 return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;请求数据&quot;]; // 注意：数据传递完，最好调用sendCompleted，这时命令才执行完毕。 [subscriber sendCompleted]; return nil; &#125;];&#125;];// 强引用命令，不要被销毁，否则接收不到数据_conmmand = command;// 3.订阅RACCommand中的信号[command.executionSignals subscribeNext:^(id x) &#123; [x subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x); &#125;];&#125;];// RAC高级用法// switchToLatest:用于signal of signals，获取signal of signals发出的最新信号,也就是可以直接拿到RACCommand中的信号[command.executionSignals.switchToLatest subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x);&#125;];// 4.监听命令是否执行完毕,默认会来一次，可以直接跳过，skip表示跳过第一次信号。[[command.executing skip:1] subscribeNext:^(id x) &#123; if ([x boolValue] == YES) &#123; // 正在执行 NSLog(@&quot;正在执行&quot;); &#125;else&#123; // 执行完成 NSLog(@&quot;执行完成&quot;); &#125;&#125;];// 5.执行命令[self.conmmand execute:@1]; RACMulticastConnection用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。注意:RACMulticastConnection通过RACSignal的-publish或者-muticast:方法创建. RACMulticastConnection使用步骤: 1.创建信号 + (RACSignal )createSignal:(RACDisposable (^)(id subscriber))didSubscribe 2.创建连接 RACMulticastConnection *connect = [signal publish]; 3.订阅信号,注意：订阅的不在是之前的信号，而是连接的信号。 [connect.signal subscribeNext:nextBlock] 4.连接 [connect connect] RACMulticastConnection底层原理: 1.创建connect，connect.sourceSignal -&gt; RACSignal(原始信号) connect.signal -&gt; RACSubject 2.订阅connect.signal，会调用RACSubject的subscribeNext，创建订阅者，而且把订阅者保存起来，不会执行block。 3.[connect connect]内部会订阅RACSignal(原始信号)，并且订阅者是RACSubject 3.1.订阅原始信号，就会调用原始信号中的didSubscribe 3.2 didSubscribe，拿到订阅者调用sendNext，其实是调用RACSubject的sendNext 4.RACSubject的sendNext,会遍历RACSubject所有订阅者发送信号。 4.1 因为刚刚第二步，都是在订阅RACSubject，因此会拿到第二步所有的订阅者，调用他们的nextBlock 需求：假设在一个信号中发送请求，每次订阅一次都会发送请求，这样就会导致多次请求。解决：使用RACMulticastConnection就能解决. 123456789101112131415// 1.创建请求信号RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@&quot;发送请求&quot;); return nil;&#125;];// 2.订阅信号[signal subscribeNext:^(id x) &#123; NSLog(@&quot;接收数据&quot;);&#125;];// 2.订阅信号[signal subscribeNext:^(id x) &#123; NSLog(@&quot;接收数据&quot;);&#125;];// 3.运行结果，会执行两遍发送请求，也就是每次订阅都会发送一次请求 RACMulticastConnection:解决重复请求问题 12345678910111213141516171819202122// 1.创建信号RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@&quot;发送请求&quot;); [subscriber sendNext:@1]; return nil;&#125;];// 2.创建连接RACMulticastConnection *connect = [signal publish];// 3.订阅信号，// 注意：订阅信号，也不能激活信号，只是保存订阅者到数组，必须通过连接,当调用连接，就会一次性调用所有订阅者的sendNext:[connect.signal subscribeNext:^(id x) &#123; NSLog(@&quot;订阅者一信号&quot;);&#125;];[connect.signal subscribeNext:^(id x) &#123; NSLog(@&quot;订阅者二信号&quot;);&#125;];// 4.连接,激活信号[connect connect]; RACSchedulerRAC中的队列，用GCD封装的。 RACUnit表⽰stream不包含有意义的值,也就是看到这个，可以直接理解为nil. RACEvent把数据包装成信号事件(signal event)。它主要通过RACSignal的-materialize来使用，然并卵。 ReactiveCocoa开发中常见用法。代替代理rac_signalForSelector：用于替代代理。 代替KVOrac_valuesAndChangesForKeyPath：用于监听某个对象的属性改变。 监听事件rac_signalForControlEvents：用于监听某个事件。 代替通知rac_addObserverForName:用于监听某个通知。 监听文本框文字改变rac_textSignal:只要文本框发出改变就会发出这个信号。 处理当界面有多次请求时，需要都获取到数据时，才能展示界面rac_liftSelector:withSignalsFromArray:Signals:当传入的Signals(信号数组)，每一个signal都至少sendNext过一次，就会去触发第一个selector参数的方法。使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据。代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 1.代替代理// 需求：自定义redView,监听红色view中按钮点击// 之前都是需要通过代理监听，给红色View添加一个代理属性，点击按钮的时候，通知代理做事情// rac_signalForSelector:把调用某个对象的方法的信息转换成信号，就要调用这个方法，就会发送信号。// 这里表示只要redV调用btnClick:,就会发出信号，订阅就好了。[[redV rac_signalForSelector:@selector(btnClick:)] subscribeNext:^(id x) &#123; NSLog(@&quot;点击红色按钮&quot;);&#125;];// 2.KVO// 把监听redV的center属性改变转换成信号，只要值改变就会发送信号// observer:可以传入nil[[redV rac_valuesAndChangesForKeyPath:@&quot;center&quot; options:NSKeyValueObservingOptionNew observer:nil] subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x);&#125;];// 3.监听事件// 把按钮点击事件转换为信号，点击按钮，就会发送信号[[self.btn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) &#123; NSLog(@&quot;按钮被点击了&quot;);&#125;];// 4.代替通知// 把监听到的通知转换信号[[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIKeyboardWillShowNotification object:nil] subscribeNext:^(id x) &#123; NSLog(@&quot;键盘弹出&quot;);&#125;];// 5.监听文本框的文字改变[_textField.rac_textSignal subscribeNext:^(id x) &#123; NSLog(@&quot;文字改变了%@&quot;,x);&#125;];// 6.处理多个请求，都返回结果的时候，统一做处理.RACSignal *request1 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;// 发送请求1[subscriber sendNext:@&quot;发送请求1&quot;]; return nil;&#125;];RACSignal *request2 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; // 发送请求2 [subscriber sendNext:@&quot;发送请求2&quot;]; return nil;&#125;];// 使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据。[self rac_liftSelector:@selector(updateUIWithR1:r2:) withSignalsFromArray:@[request1,request2]];&#125;// 更新UI- (void)updateUIWithR1:(id)data r2:(id)data1&#123; NSLog(@&quot;更新UI%@ %@&quot;,data,data1);&#125; ReactiveCocoa常见宏RAC(TARGET, [KEYPATH, [NIL_VALUE]])用于给某个对象的某个属性绑定。12// 只要文本框文字改变，就会修改label的文字RAC(self.labelView,text) = _textField.rac_textSignal; RACObserve(self, name)监听某个对象的某个属性,返回的是信号。123[RACObserve(self.view, center) subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x);&#125;]; @weakify(Obj)和@strongify(Obj)一般两个都是配套使用,在主头文件(ReactiveCocoa.h)中并没有导入，需要自己手动导入，RACEXTScope.h才可以使用。但是每次导入都非常麻烦，只需要在主头文件自己导入就好了。 RACTuplePack把数据包装成RACTuple（元组类）12// 把参数中的数据包装成元组RACTuple *tuple = RACTuplePack(@10,@20); RACTupleUnpack：把RACTuple（元组类）解包成对应的数据。123456// 把参数中的数据包装成元组RACTuple *tuple = RACTuplePack(@&quot;xmg&quot;,@20);// 解包元组，会把元组的值，按顺序给参数里面的变量赋值// name = @&quot;xmg&quot; age = @20RACTupleUnpack(NSString *name,NSNumber *age) = tuple; 原文链接：最快让你上手ReactiveCocoa之基础篇","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"RAC","slug":"RAC","permalink":"https://guchunli.github.io/tags/RAC/"}]},{"title":"JSP","date":"2017-06-12T01:22:10.000Z","path":"2017/06/12/JSP/","text":"cookies 存储在浏览器。而会话存储在服务器端","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://guchunli.github.io/tags/Java/"},{"name":"JSP","slug":"JSP","permalink":"https://guchunli.github.io/tags/JSP/"}]},{"title":"798艺术区","date":"2017-06-04T07:30:49.000Z","path":"2017/06/04/798艺术区/","text":"2017-06-04 北京798艺术区 抽象画 各种小陶瓷 猫咪，卡哇伊 brain red people 未名 孤独的小孩 恋人","comments":true,"categories":[{"name":"随笔","slug":"other","permalink":"https://guchunli.github.io/categories/other/"}],"tags":[{"name":"798","slug":"798","permalink":"https://guchunli.github.io/tags/798/"}]},{"title":"几种排序算法","date":"2017-05-09T03:02:24.000Z","path":"2017/05/09/排序算法/","text":"1.冒泡排序123456789101112int n = arr.length;int temp = 0;for (int i = 0; i &lt; n; i++) &#123; for (int j = 1; j &lt; (n - i); j++) &#123; if (arr[j - 1] &gt; arr[j]) &#123; // swap elements temp = arr[j - 1]; arr[j - 1] = arr[j]; arr[j] = temp; &#125; &#125;&#125; 2.选择排序1234567891011for (int i = 0; i &lt; arr.length - 1; i++) &#123; int index = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[index]) &#123; index = j;// searching for lowest index &#125; &#125; int smallerNumber = arr[index]; arr[index] = arr[i]; arr[i] = smallerNumber;&#125; 3.插入排序12345678910int n = array.length;for (int j = 1; j &lt; n; j++) &#123; int key = array[j]; int i = j - 1; while ((i &gt; -1) &amp;&amp; (array[i] &gt; key)) &#123; array[i + 1] = array[i]; i--; &#125; array[i + 1] = key;&#125;","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://guchunli.github.io/tags/排序/"},{"name":"算法","slug":"算法","permalink":"https://guchunli.github.io/tags/算法/"}]},{"title":"Java语言学习笔记","date":"2017-05-09T01:59:09.000Z","path":"2017/05/09/Java语言学习笔记/","text":"##JAVA基础 1.public类 一个源文件中只能有一个public类 一个源文件可以有多个非public类 2.package/import编译java包： $ javac -d directory javafilename1234E:\\sources&gt; javac -d c:\\classes Simple.java//运行e:\\sources&gt; set classpath=c:\\classes;.;e:\\sources&gt; java mypack.Simple OR1e:\\sources&gt; java -classpath c:\\classes mypack.Simple 加载类文件或jar文件的方式: 加载临时类文件 通过在命令提示符中设置类路径 通过 -classpath 开关选项 永久加载类文件 通过在环境变量中设置类路径 通过创建jar文件，其中包含所有类文件，并将jar文件复制到JDK安装目录的jre/lib/ext文件夹中。 3.引用类型对象、数组都是引用数据类型。所有引用类型的默认值都是null。 4.JAVA常量在 Java 中使用 final 关键字来修饰常量，通常使用大写字母表示常量 5. 基本数据类型 不能对boolean类型进行类型转换。 在把容量大的类型转换为容量小的类型时必须使用强制类型转换 double-&gt;float 6.自动类型转换转换前的数据类型的位数要低于转换后的数据类型。Float-&gt;double Java语言支持的变量类型类变量：独立于方法之外的变量，用 static 修饰。 在类中以static关键字声明，但必须在方法构造方法和语句块之外 静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。 静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。 为了对类的使用者可见，大多数静态变量声明为public类型 默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。 类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。 静态块在类加载时main之前执行实例变量：独立于方法之外的变量，不过没有 static 修饰。 当一个对象被实例化之后，每个实例变量的值就跟着确定； 实例变量可以声明在使用前或者使用后； 一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见； 实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定； 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名局部变量：类的方法中的变量。 访问修饰符不能用于局部变量； 局部变量是在栈上分配的。 局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。 实例初始化块主要有三个规则。 它们如下： 在创建类的实例时创建实例初始化程序块。 在父类构造函数被调用之后(即在super()构造函数调用之后)调用实例初始化块。 实例初始化程序块按它们显示的顺序排列。 8．修饰符：访问修饰符、非访问修饰符 修饰符用来定义类、方法或者变量，通常放在语句的最前端，默认default访问修饰符（1） public/protected/default/private（2） private: 只能通过类中公共的 getter 方法被外部类访问（3） protected: 同一个包中的任何其他类访问，也能够被不同包中的子类访问 public: 如果几个相互访问的 public 类分布在不同的包中，则需要导入相应 public 类所在的包 注意：父类中声明为 public 的方法在子类中也必须为 public。 父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。 父类中声明为 private 的方法，不能够被继承。 非访问修饰符static,abstract,final,synchronized,volatile（1）final：用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。 final 变量：能被显式地初始化并且只能初始化一次。被声明为 final 的对象的引用不能指向不同的对象。但是 final 对象里的数据可以被改变。也就是说 final 对象的引用不能改变，但是里面的值可以改变。final 修饰符通常和 static 修饰符一起使用来创建类常量。 final 方法：类中的 final 方法可以被子类继承，但是不能被子类修改。 final 类：final 类不能被继承，没有类能够继承 final 类的任何特性。 被声明为 final 类的方法自动地声明为 final，但是实例变量并不是 final 在声明时未初始化的静态final变量称为静态空白final变量。 它只能在静态块中初始化。（2）abstract: 抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充一个类不能同时被 abstract 和 final 修饰。抽象方法:是一种没有任何实现的方法，该方法的的具体实现由子类提供。 抽象方法不能被声明成 final 和 static。 任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。 如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。抽象类可以包含抽象方法和非抽象方法。 抽象方法的声明以分号结尾，例如：public abstract sample()。在java中有两种实现抽象的方法，它们分别是： 抽象类(部分) 接口 (完全)抽象类实现了部分抽象(0到100％)，而接口实现了完全抽象(100％)。 9.instanceof: name instanceof String增强for循环：for(声明语句 : 表达式)switch支持字符串，直到break退出 10.装箱/拆箱装箱：int-&gt;number 拆箱：number-&gt;intintValue() valueOf() compareo() equals() parseInt()(string-&gt;int) ceil() floor() random() 11.Character char的包装类isLetter() isDigit() isUpperCase() isWhitespace() toUpperCase() toString() 12.Stringlength() s1.concat(s2) s = format(”—%f %d %s”,floatVar,.,.) charAt(index) int compareo()(对象，字符串)boolean contentEquals(StringBuffer) endsWith() equals() indexOf(ch) split substring 13. StringBuffer/StringBuilder当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。StringBuffer(线程安全) StringBuilder(速度优势,不是线程安全的,不能同步访问) 多数情况下建议使用 StringBuilder 类StringBuffer：append(s) reverse dekete(start,end) replace(start,end,str) capacity() charAt() indexOf() toString substring 14.Arrays数组double[] list = new double[10]; 参数：(int[] array) 返回值：int[]fill sort equals binarySearch 15.Datedate.toString() getime() after before equals compareo format parseSimpleDateFormat(E yyyy-MM-dd HH:mm:ss a zzz) PMSleep(1000*3) Calender.getInstance() 16.正则表达式Pattern Matcher\\s+ 多个空格 ^$ 以什么开始 \\d+多个数字 ()? 0/1 可选 * 0/n +1\\n {n} (n,) &gt;=n . 除\\n\\r之外的任何单个字符[xyz] [^xyz] [a-z] \\b字符边界 17.function重载：方法名相同，参数列表不同构造方法：方法名与类名相同，没有返回值，自定义则默认构造方法失效可变参数：一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明（double… numbers）protected void finalize() 18.BufferReaderread() write() scanner() print() println() 19.I/OFileInputStream FileOutputStream File FileReader FileWrite mkdir mkdirs isDirectory delete() 20.Scanner(System.in)next nextLine 21.Exceptionjava.lang.Exception Error ThrowableIOException RuntimeException 22.面向对象继承extends final修饰的类不能被集成，方法不能被重写 单继承 重写与重载Override(返回值和形参都不能改变) Overload(方法名字相同，而参数不同。返回类型可以相同也可以不同)构造方法不能被重写最常用的地方就是构造器的重载 多态父类指向子类对象 Animal a = new Cat() 实现方式：重写，接口，抽象类和抽象方法 变量不能被重写 抽象类抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。 封装修改属性的可见性来限制对属性的访问（一般限制为private）对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问 接口是抽象方法的集合。有静态、final变量和抽象方法（JAVA8还可以有默认方法，静态方法），接口字段默认是public，static和final，方法默认是public和abstract类描述对象的属性和方法。接口则包含类要实现的方法。除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。接口中的方法会被隐式的指定为 public abstract，接口中的变量会被隐式的指定为 public static final类的多重继承是不合法，但接口允许多重继承 包小写开头使用类全名描述 或 import(import 声明必须在包声明之后，类声明之前) java高级1.一些概念理解JVM(Java虚拟机)一个抽象机器。它是一个提供可以执行Java字节码的运行时环境的规范。JVM执行以下主要任务： 加载代码 验证代码 执行代码 提供运行时环境JRE（Java Runtime Environment）用于提供Java运行时环境。它是JVM的实现。它是实际存在的。它包含一组库和JVM在运行时使用的其他文件。JDK（Java Development Kit）它是实际上存在的。它包含JRE+开发工具。 JDK(JRE(JVM+LIB+OTHER)+IDE)","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://guchunli.github.io/tags/Java/"},{"name":"语法","slug":"语法","permalink":"https://guchunli.github.io/tags/语法/"}]},{"title":"MyEclipse快捷键","date":"2017-05-09T01:33:03.000Z","path":"2017/05/09/MyEclipse快捷键/","text":"1.补全：alt+/2.修复：ctrl+13.删除当前行：ctrl+d4.复制当前行到上一行/下一行：ctrl+alt+上/下方向键5.互换位置：alt+上/下方向键6.上/下一个编辑的页面：alt+左/右方向键7.显示工程文件目录：alt+enter8.当前行插入空行：shift+enter(+ctrl 下一行插入)9.格式化：ctrl+shift+f10.重命名：alt+shift+r11.抽取方法：alt+shift+m12.组织导入（自动加入引用）：ctrl+shift+o13.添加导入：Ctrl+Shift+M14.单步返回 F715.单步跳过 F616.单步跳入 F517.单步跳入选择 Ctrl+F518.调试上次启动 F1119.继续 F8","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://guchunli.github.io/tags/Java/"},{"name":"快捷键","slug":"快捷键","permalink":"https://guchunli.github.io/tags/快捷键/"}]},{"title":"mysql语句","date":"2017-05-08T05:41:17.000Z","path":"2017/05/08/mysql语句/","text":"数据库创建数据库1create database db; 删除数据库1drop database db; 查看数据库 1show databases; 使用数据库1use db; 表创建表1234CREATE TABLE db.tb (`id` INT NOT NULL AUTO_INCREMENT,`name` VARCHAR(45) NOT NULL,PRIMARY KEY (`cid`)); 删除表1drop table tb 修改表名12RENAME TABLE tb TO new_tbname;ALTER TABLE tb RENAME TO new_tbname; 初始化表(清空)1TRUNCATE TABLE tb 复制表：1CREATE TABLE tb_name2 SELECT * FROM tb_name; 或者部分复制：1CREATE TABLE tb_name2 SELECT id,name FROM tb_name; 查看数据库中可用的表：1SHOW TABLES; 查看表的结构：12DESCRIBE tb_name;SHOW COLUMNS in tb_name; //from也可以 列/约束ALTER TABLE tb ADD[CHANGE,RENAME,DROP] 增加列/约束1alter table tb add column name VARCHAR(45) not null after id,add primary key(id); 删除列/约束1alter table tb drop col2 drop primary key(id); 修改列/约束ALTER TABLE tb MODIFY col2 int NOT NULL DEFAULT 100 add col1 int identity(1,1);ALTER TABLE tb ALTER col2 SET DEFAULT 1000;ALTER TABLE tb ALTER col2 DROP DEFAULT; 约束primary key,not null,unique,asc/desc/default 0/AUTO_INCREMENT/zerofill 单表操作插入1insert into tb(col1,col2) values(value1,value2) 删除1delete from tb [WHERE Clause] 更新1update tb set col1=value1 [WHERE Clause] 使用MySQL执行update的时候报错：1Error Code: 1175. You are using safe update mode and you tried to update a table without a WHERE that uses a KEY column To disable safe mode, toggle the option in Preferences -&gt; SQL Queries and reconnect. 解决方法：执行命令 SET SQL_SAFE_UPDATES = 0; //修改下数据库模式如果想要提高数据库安全等级，可以在恢复回原有的设置，执行命令：SET SQL_SAFE_UPDATES = 1; 查找1select * from tb [WHERE Clause] where =、&gt;、&lt;、&lt;&gt; and/not and or is null/is not null 分组查询：order by/group by/having 1select * from tb order by col1,col2 asc/desc like 123SELECT field1, field2,...fieldN FROM tbWHERE field1 LIKE condition1 [AND [OR]] filed2 = &apos;somevalue&apos; in/not in 1select * from tb1 where a [not] in (value1,value2,value3) between/not between exists/not exists 全选/全不选where 1=1 表示选择全部where 1=2 表示全部不选， 分页 1234declare @start int,@end int@sql nvarchar(600)set @sql=’select top’+str(@end-@start+1)+’+from T where rid not in(select top’+str(@str-1)+’Rid from T where Rid&gt;-1)’exec sp_executesql @sql 删除重复记录 12341),delete from tablename where id not in (select max(id) from tablename group by col1,col2,...)2),select distinct * into temp from tablenamedelete from tablenameinsert into tablename select * from temp 列出数据库里所有的表名 1select name from sysobjects where type=&apos;U&apos; // U代表用户 列出表里的所有的列名 123select name from syscolumns where id=object_id(&apos;TableName&apos;)select column_name,data_type from information_schema.columnswhere table_name = &apos;表名&apos; //查询某一个表的字段和数据类型 获取当前数据库中的所有用户表 1select Name from sysobjects where xtype=&apos;u&apos; and status&gt;=0 多表操作union通过组合其他两个结果表（例如 TABLE1 和 TABLE2）并消去表中任何重复行而派生出一个结果表。当 ALL 随 UNION 一起使用时（即 UNION ALL），不消除重复行。两种情况下，派生表的每一行不是来自 TABLE1 就是来自 TABLE2。12345678910SELECT expression1, expression2, ... expression_nFROM tb1[WHERE conditions]UNION [ALL | DISTINCT]SELECT expression1, expression2, ... expression_nFROM tb2[WHERE conditions];DISTINCT: 可选，删除结果集中重复的数据。默认情况下 UNION 操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没啥影响。ALL: 可选，返回所有结果集，包含重复数据。 EXCEPT通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个结果表。当 ALL 随 EXCEPT 一起使用时 (EXCEPT ALL)，不消除重复行。 INTERSECT通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表。当 ALL 随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。 注：使用运算词的几个查询结果行必须是一致的。 分组：group bycount,sum,max,min,avg 连接：join INNER JOIN（内连接,或等值连接）：获取两个表中字段匹配关系的记录。 12345SELECT a.col1, a.col2, b.col3 FROM tb1 a INNER JOIN tb2 bON a.col1 = b.col1;等价于SELECT a.col1, a.col2, b.col3 FROM tb1 a, tb2 b WHERE a.col1 = b.col1; LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。 12SELECT a.col1, a.col2, b.col3 FROM tb1 a LEFT JOIN tb2 b ON a.col1 = b.col1; RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。 12SELECT a.col1, a.col2, b.col3 FROM tb1 a RIGHT JOIN tb2 b ON a.col1 = b.col1; 高级用法索引临时表视图","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://guchunli.github.io/tags/Java/"},{"name":"mysql","slug":"mysql","permalink":"https://guchunli.github.io/tags/mysql/"}]},{"title":"Java搭建springMVC项目","date":"2017-05-08T01:44:19.000Z","path":"2017/05/08/Java搭建springMVC项目/","text":"MyEclipse搭建项目 创建命名空间namespace 新建项目 new -&gt; project 添加tomcat,jdk 运行 访问：http://localhost:8080/project_name/ 12345...nested exception is org.springframework.core.NestedIOException: ASM ClassReader failed to parse class file - probably due to a new Java class file version that isn&apos;t supported yet...nested exception is java.lang.IllegalArgumentException... 解决方法：在项目上右键–properties–java Compile–compiler compliance level 在工程目录下添加config文件夹，下面添加文件：jdbc.properties,spring-mvc.xml,spring-mybatis.xml jdbc.properties：mysql配置 spring-mvc.xml context -&gt; base-package: 包的跟路径 bean -&gt; prefix: /WEB-INF/page/下放.jsp文件 mvc -&gt; bean: utl 的根路径 spring-mybatis.xml: context -&gt; base-package: 包的根路径 bean -&gt; base-package: dao的根路径 aop -&gt; expression: service的根路径","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://guchunli.github.io/tags/Java/"},{"name":"springMVC","slug":"springMVC","permalink":"https://guchunli.github.io/tags/springMVC/"},{"name":"项目","slug":"项目","permalink":"https://guchunli.github.io/tags/项目/"}]},{"title":"java开发环境配置","date":"2017-05-06T03:27:51.000Z","path":"2017/05/06/java开发环境配置/","text":"Java开发需要：1.JDK (Java Deverlopment Kit)Java开发工具包(JDK)是一个用于开发Java应用程序和小程序的软件开发环境。它包括Java运行时环境(JRE)，编译器/加载程序(JAVA)，编译器(javac)，归档器(jar)，文档生成(Javadoc)以及 Java 开发的其他工具。2.IDE (Integrated Development Environment)集成开发环境：MyEclipse,IDEA tomcat1.下载：http://tomcat.apache.org2.修改权限，否则会提示permission denny错误：1sudo chmod 755 xxx/bin/*.sh (xxx表示你tomcat放至的路径) 3.将Tomcat写入系统的环境变量PATH中。 1$ pico .bash_profile 在打开的页面中，输入以下：12export PATH=$PATH:tomcat_dir/bin; export PATH=$PATH:tomcat_dir/logs; 其中tomcat_dir为tomcat根目录接着按下 control+x，再按 y 表示确定修改，最后回车。 验证是否成功 $ echo $PATH显示如下:$ -bash: /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Users/fuhua/Documents/Tomcat/apache-tomcat-8.0.30/bin: No such file or directory需要重新启动计算机，以便完成系统环境变量的配置。 4.启动Tomcat. 如果你完成将Tomcat写入系统的环境变量PATH中，你可以直接在终端输入 startup.sh ； 如果你没有完成，那么就要定位到Tomcat的bin目录中，如在终端输入 123$ cd tomcat_dir/bin$ startup.shTomcat started. 在浏览器中输入http://localhost:8080/如果出现Apache Tomcat界面，代表 tomcat 启动成功。 MySQL安装MySQL 下载：MySQL官网 安装完成时记得保存弹出框中的密码，这是mysql root账号和密码 系统偏好设置中，点击MySQL开启MySQL Server服务修改root账户密码 关闭MySQL Server服务 终端输入12345678910111213141516171819202122232425262728// 苹果系统下 mysql server 的安装地址$ cd /usr/local/mysql/bin/// 登录管理员权限$ sudo su// 禁止 mysql 验证功能sh-3.2# ./mysqld_safe --skip-grant-tables &amp;//终端输出[1] 2487sh-3.2# Logging to &apos;/usr/local/mysql-5.7.18-macos10.12-x86_64/data/192.168.1.143.err&apos;.2017-06-06T06:35:36.6NZ mysqld_safe Starting mysqld daemon with databases from /usr/local/mysql-5.7.18-macos10.12-x86_64/datash-3.2# ./mysqlWelcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 3Server version: 5.7.18 MySQL Community Server (GPL)Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\\h&apos; for help. Type &apos;\\c&apos; to clear the current input statement.mysql&gt; FLUSH PRIVILEGES;Query OK, 0 rows affected (0.00 sec)mysql&gt; SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos; = PASSWORD(&apos;123456&apos;);Query OK, 0 rows affected, 1 warning (0.00 sec) 安装MySQL Workbenchhttps://dev.mysql.com/downloads/workbench/MySQL connections + ：输入connection name创建新链接 加入系统环境变量12345678910111213141516171819$ cd /usr/local/mysql/bin$ ls//查看目录中是否有mysql$ vim ~/.bash_profile//在该文件中添加 PATH=$PATH:/usr/local/mysql/bin$ source ~/.bash_profile$ mysql -uroot -p //登录mysql//输入密码后，登录成功会显示：Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 22Server version: 5.7.18 MySQL Community Server (GPL)Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\\h&apos; for help. Type &apos;\\c&apos; to clear the current input statement. 可以通过以下名录修改密码： $ $ SET PASSWORD FOR ‘root’@’localhost’ = PASSWORD(‘newpass’); JDK安装JDK下载：JDK官网安装 mac自带jdk，安装目录：/System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home 自己安装目录：/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home配置jdk环境变量\u0010\u0010（1）只针对当前用户12$ touch ~/.bash_profile $ vim ~/.bash_profile 在编辑器中添加如下内容：123456JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/HomeCLASSPAHT=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarPATH=$JAVA_HOME/bin:$PATH:export JAVA_HOMEexport CLASSPATHexport PATH 使系统变量生效，使用以下命令或重启电脑：1$ source .bash_profile 查看java版本：1$ java -version 检查系统变量是否生效：1$ echo $JAVA_HOME （2）针对所有用户12$ cd /etc$ sudo vi profile 在编辑器最下面添加如下内容：123JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/HomeCLASSPAHT=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarPATH=$JAVA_HOME/bin:$PATH: 接下来同上：123$ source .bash_profile$ java -version$ echo $JAVA_HOME","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://guchunli.github.io/tags/Java/"},{"name":"web","slug":"web","permalink":"https://guchunli.github.io/tags/web/"}]},{"title":"北京十渡","date":"2017-04-19T06:49:48.000Z","path":"2017/04/19/北京十渡/","text":"2017-04-17 北京十渡飞拉达、蹦极 今天真是玩嗨了 早上六点起床，准备好之后早早出了门，乘地铁赶往公主坟与大家集合。到了集合地，坐着租的面包车开始前往目的地————十渡。 十渡景区位于北京房山，到了景区之后，带队的队长确定参加飞拉达的人数开始买票。之前了解了一下飞拉达就是攀岩（岩壁探险或铁道式攀登），因为之前从来没参与过类似冒险运动，心里有点小紧张。因为人还比较多，所以一块请了一位教练。刚开始教练教授装备的穿戴，之后带领我们来到了攀岩的山脚下，教练说这座山大概有70多米，之后告诉了我们扣锁的使用，然后开始攀爬演示，小伙伴们也开始一个个紧随其后开始了攀爬之路。 飞拉达历经大约三个小时，穿越了ABCD区，终于到达了终点。教练帮我们把所有锁扣都挂到绳索上，下面是湖水，随着绳索划过去才算再次到达了地面。 之后和大家一起腐败吃午餐，吃午餐的餐厅对面正好就是蹦极的跳台，是不是看着一个个挑战者坠落、弹跳… 由于某些原因（吃的有点多了，惭愧…），本来打算不参加蹦极了，但是一想如果不参加，回去之后一定会捶胸顿足，后悔不跌，而且同性的小伙伴除了一对情侣之外都参加了，狠了狠心还是买了票。 来到蹦极门口，工作人员给每个人测量了身高和体重，并把数据写到了手背上。由于蹦极的人很多，等了大约有两三个小时，期间目睹一个一个从跳台自由落体，还有情侣相拥跳下，他们调侃这肯定是他们这辈子抱得最紧的一次了吧~~轮到我们的时候，不知怎么安排的被调到了最后一个，轮到我的时候，工作人员开始给我腿上绑绳，把眼镜粘到了胳膊上，为了避免女生走光把上衣和裤子的连接处也用胶带粘上了，说实话，自从买了票心有一直还挺紧张的，但真到了马上就要跳下去的时候，心里反而没有那么紧张了，还算比较平静。起跳之前冲着镜头挥挥手，然后只要张开双臂就可以了，看着50米下宽阔的湖水，心里还真是怂了，嗯，怂了（幸亏自己还是近视眼，并且还没戴眼镜）…接着工作人员扶着胳膊向前推去，从未有过的自由落体的失重感觉瞬间侵占了大脑，一片空白，只得紧闭双眼，只感觉到达最低点之后又弹跳到了下降高度的三分之二，然后又开始降落，才敢睁开眼睛环顾四周，之后又弹了大概两三次，高度就不是很高了，才开始享受蹦极的乐趣，然后就被放了下来，湖面上又专业人员把我接了下去，整个过程也就是一两分钟的样子，算是真切的感受了一次蹦极的刺激！ 今天认识了一个很说的来的朋友，我俩基本上叽叽喳喳聊了一天，感觉很是投缘，遇到很聊得来的人总是感觉心情很舒畅！也认识了一个四川的男生，还在上大学，曾经自己骑行去过云南，还认识了一个广州的女孩（就是下图中的女孩），刚辞了工作专门出来游玩的，很佩服这种勇气！ 最后用鹿晗的《某时某刻 Catch me when I fall》结个尾~~~","comments":true,"categories":[{"name":"随笔","slug":"other","permalink":"https://guchunli.github.io/categories/other/"}],"tags":[{"name":"十渡","slug":"十渡","permalink":"https://guchunli.github.io/tags/十渡/"},{"name":"蹦极","slug":"蹦极","permalink":"https://guchunli.github.io/tags/蹦极/"}]},{"title":"2017玉渊潭樱花节","date":"2017-04-18T11:54:47.000Z","path":"2017/04/18/2017玉渊潭樱花节/","text":"2017-04-18 玉渊潭樱花节 去年就打算去玉渊潭看花的忘了是什么原因错过了花期，没能去成心里总觉得遗憾今年决定不能再错过一定要去看看的虽然今天天气不太好，但是花开尤盛，自以为很是不错也算是了了一个小小心愿 最重要的是去了，并且看到了不是么~~","comments":true,"categories":[{"name":"随笔","slug":"other","permalink":"https://guchunli.github.io/categories/other/"}],"tags":[{"name":"玉渊潭","slug":"玉渊潭","permalink":"https://guchunli.github.io/tags/玉渊潭/"},{"name":"樱花节","slug":"樱花节","permalink":"https://guchunli.github.io/tags/樱花节/"}]},{"title":"iOS打包提交APP Store注意事项","date":"2017-04-13T04:20:22.000Z","path":"2017/04/13/iOS打包提交APP-Store注意事项/","text":"1.改为正式环境 接口改成线上服务器 极光推送环境改为生产环境等 2.版本号target -&gt; general：Version和Build版本号3.签名target -&gt; general -&gt; signing 4.删除断点，log 5.本地化，语言包 6.Capabilities -&gt; background modes如果后台使用了位置，提交信息中应用描述添加免责声明 温馨提示：GPS在后台持续运行，会大大降低电池的寿命。 7.edit scheme: run,archive -&gt; debug 改为 release 8.打包ad-hoc，进行内测：clean -&gt; build -&gt; archive 最后，打正式包，提交APP Store。","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"app store","slug":"app-store","permalink":"https://guchunli.github.io/tags/app-store/"}]},{"title":"mac显示隐藏文件","date":"2017-03-21T10:37:39.000Z","path":"2017/03/21/mac显示隐藏文件/","text":"1.显示隐藏文件1defaults write com.apple.finder AppleShowAllFiles Yes &amp;&amp; killall Finder 2.不显示隐藏文件1defaults write com.apple.finder AppleShowAllFiles No &amp;&amp; killall Finder 3.删除文件夹下的所有 .git 文件1find . -name &quot;.git&quot; | xargs rm -Rf","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"https://guchunli.github.io/tags/技巧/"},{"name":"隐藏文件","slug":"隐藏文件","permalink":"https://guchunli.github.io/tags/隐藏文件/"}]},{"title":"Apple Pay学习","date":"2017-03-15T08:37:17.000Z","path":"2017/03/15/Apple-Pay学习/","text":"概述1.支付方式：Touch ID/ Passcode2.设备要求：iPhone6以上（iphone:线上/线下 ipad:线上 watch:线下）3.系统要求：iOS8.0以上，银联（中国）：9.2 4.基于NFC5.2014年10月20日在美国正式上线，2016年2月18日凌晨5：00， Apple Pay 业务在中国上线。6.与微信支付以及支付宝等第三方支付平台的区别： 硬件方面 Apple Pay：必须是iOS设备， 而且是按照线上支付和线下支付区分不同的真机设备（具体参考表1） 微信、支付宝： 基本跟硬件设备无关， 支持大多数的只能手机 网络环境要求 Apple Pay：线上支付需要联网， 线下支付无需联网就可以支付 微信、支付宝： 无论是线上还是线下支付， 都需要联网使用 使用技术 Apple Pay：线下支付使用的是 基于NFC的近场通讯技术 微信、支付宝： 线下支付使用的是 扫码支付（条形码、二维码） 主要功能 Apple Pay：线上支付、线下支付、部分升级后的ATM机可以取款 微信、支付宝： 线上支付、线下支付、转账、理财等 安全性能 Apple Pay：不保留银行卡信息，并且不会暴漏给外界、不分流银行存款（不需要从银行卡转钱到另外一个平台）、不能充值 安全性较高 微信、支付宝： 密码保护，身份验证等手段保护账户 安全性相对稍差 支付时长 Apple Pay：无论是线上支付，还是线下支付， 只需要验证指纹即可支付。非常迅速 微信、支付宝： 需要扫码支付， 流程相对繁琐，所以时长较长 各自弊端 Apple Pay：只适用于苹果设备， 支付场景单一，无转账理财等业务 微信、支付宝： 安全性较差， 必须联网操作，需要充值到对应平台 注册并配置一个商业标示符1.添加一个App ID2.配置Merchant ID3.为Merchant ID 配置证书, 并下载证书安装到钥匙串4.检查安装到钥匙串中的证书是否有效5.绑定Merchant ID 到 APP ID 证书失效，请到以下地址下载重新安装：https://www.apple.com/certificateauthority/ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239//一.判断当前设备是否支持支付if (![PKPaymentAuthorizationViewController canMakePayments]) &#123;NSLog(@&quot;该设备不支持ApplePay&quot;);return;//二.判断Wallet有没有添加该支付网络的储蓄卡/信用卡&#125;else if ([PKPaymentAuthorizationViewController canMakePaymentsUsingNetworks:@[PKPaymentNetworkChinaUnionPay,PKPaymentNetworkVisa]])&#123;NSLog(@&quot;Wallet没有添加该支付网络的储蓄卡/信用卡&quot;);//创建一个添加卡的按钮PKPaymentButton *btn = [PKPaymentButton buttonWithType:PKPaymentButtonTypeSetUp style:PKPaymentButtonStyleBlack];[btn addTarget:self action:@selector(jumpToSetup) forControlEvents:UIControlEventTouchUpInside];[self.payView addSubview:btn]; &#125;else&#123;//创建一个支付按钮PKPaymentButton *btn = [PKPaymentButton buttonWithType:PKPaymentButtonTypeBuy style:PKPaymentButtonStyleWhiteOutline];[btn addTarget:self action:@selector(jumpToPay) forControlEvents:UIControlEventTouchUpInside];[self.payView addSubview:btn];&#125;- (void)jumpToSetup&#123;NSLog(@&quot;跳转到添加银行卡页面&quot;);PKPassLibrary * pk = [[PKPassLibrary alloc]init];[pk openPaymentSetup];&#125;- (void)jumpToPay&#123;//三.创建支付请求并配置各项信息//1.创建支付请求PKPaymentRequest *request = [[PKPaymentRequest alloc]init];//2.配置参数//2.1 商店标识request.merchantIdentifier = @&quot;&quot;;//2.2 国家代码request.countryCode = @&quot;CN&quot;;//2.3 货币代码request.currencyCode = @&quot;CNY&quot;;//2.4 支持的支付网络request.supportedNetworks = @[PKPaymentNetworkChinaUnionPay,PKPaymentNetworkVisa];//2.5 支付请求包含一个支付摘要项目的列表NSDecimalNumber *price1 = [NSDecimalNumber decimalNumberWithString:@&quot;10.0&quot;];PKPaymentSummaryItem *item1 = [PKPaymentSummaryItem summaryItemWithLabel:@&quot;iPhone&quot; amount:price1];NSDecimalNumber *price2 = [NSDecimalNumber decimalNumberWithString:@&quot;20.0&quot;];PKPaymentSummaryItem *item2 = [PKPaymentSummaryItem summaryItemWithLabel:@&quot;iPad&quot; amount:price2 type:PKPaymentSummaryItemTypePending];NSDecimalNumber *totalPrice = [NSDecimalNumber zero];totalPrice = [totalPrice decimalNumberByAdding:price1];totalPrice = [totalPrice decimalNumberByAdding:price2];PKPaymentSummaryItem *total = [PKPaymentSummaryItem summaryItemWithLabel:@&quot;财务中心&quot; amount:totalPrice type:PKPaymentSummaryItemTypePending];//注意：数组最后一个是总价格request.paymentSummaryItems = @[item1,item2,total];//2.6运输方式NSDecimalNumber *shippingPrice = [NSDecimalNumber decimalNumberWithString:@&quot;18.0&quot;];PKShippingMethod *method = [PKShippingMethod summaryItemWithLabel:@&quot;顺风快递&quot; amount:shippingPrice];method.identifier = @&quot;shunfeng&quot;;method.detail = @&quot;24小时内送到&quot;;request.shippingMethods = @[method];request.shippingType = PKShippingTypeServicePickup;//2.7通过指定merchantCapabilities属性来指定你支持的支付处理标准，3DS支付方式是必须支持的，EMV方式是可选的request.merchantCapabilities = PKMerchantCapability3DS | PKMerchantCapabilityEMV | PKMerchantCapabilityCredit | PKMerchantCapabilityDebit;//2.8需要的配送信息和账单信息request.requiredBillingAddressFields = PKAddressFieldAll;request.requiredShippingAddressFields = PKAddressFieldAll;//2.9 存储额外信息request.applicationData = [@&quot;购物车ID：123456&quot; dataUsingEncoding:NSUTF8StringEncoding];//四.弹出授权控制器，让用户给支付授权//开始支付PKPaymentAuthorizationViewController *pkCtrl = [[PKPaymentAuthorizationViewController alloc]initWithPaymentRequest:request];if (pkCtrl == nil) &#123;NSLog(@&quot;授权控制器创建失败&quot;);return;&#125;pkCtrl.delegate = self;[self presentViewController:pkCtrl animated:YES completion:nil];&#125;#pragma mark - PKPaymentAuthorizationViewControllerDelegate//五.处理支付凭证//授权成功- (void)paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)controllerdidAuthorizePayment:(PKPayment *)paymentcompletion:(void (^)(PKPaymentAuthorizationStatus status))completion&#123;/*服务器接收到token后的一般处理流程:1.验证支付数据的哈希表和签名2.为加密过的支付数据解码3.向支付处理系统提交支付数据4.向订单追踪系统提交订单*/NSLog(@&quot;验证授权---%@&quot;,payment.token);/*处理支付请求时，你有两个选择:1.你既可以利用支付平台处理支付请求，2.也可以自己实现支付请求处理流程。一个常用的支付平台可以完成上述大部分操作。*/NSLog(@&quot;验证通过后，需要开发中继续完成交易&quot;);BOOL isSuccess = YES;if (isSuccess) &#123;completion(PKPaymentAuthorizationStatusSuccess);&#125;else&#123;completion(PKPaymentAuthorizationStatusFailure);&#125;&#125;//六.关闭授权控制器//授权成功或者取消授权之后会调用此方法- (void)paymentAuthorizationViewControllerDidFinish:(PKPaymentAuthorizationViewController *)controller&#123;NSLog(@&quot;取消或者交易完成&quot;);[self dismissViewControllerAnimated:YES completion:nil];&#125; 转自：Apple Pay–iOS开发","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://guchunli.github.io/tags/iOS/"},{"name":"Apple Pay","slug":"Apple-Pay","permalink":"https://guchunli.github.io/tags/Apple-Pay/"}]},{"title":"将.c文件打包成库文件","date":"2017-03-06T10:43:09.000Z","path":"2017/03/06/将-c文件打包成库文件/","text":"打包.a1.Cocoa Touch Static Library2.添加要打包的文件:.c，.h3.将头文件添加到Build Phases -&gt; Copy Files中去4.需要修改Build Settings中的 Build Active Architecture Only 以满足运行不同CPU环境的模拟器。 将此设置为NO。 选择Edit Scheme–&gt; Buid Configuration设置为release5.分别选择模拟器和真机编译，生成.a文件，在不同编译环境下编译会生成四种静态库，debug模拟器，debug真机，release模拟器，release真机6.查看静态库所支持的CPU环境：lipo -info 静态库文件7.合并静态库：lipo -create 静态库1 静态库2 -output 新静态库名称.a 注意：1.如果直接拖拽的是一个项目，并将项目当做一个静态库引用需要这样处理：在 Build Phases 中的 Target Dependencies 和 Link Binary With Libraries 中分别添加项目。如果仅仅是一个静态库的话，那么Link Binary WithLibraries 是必须添加的。2.如果编译的静态库中有分类的话必须在 Build Settings –&gt; Other Linker Flags 中加 -Objc 如果还崩溃，还得加上 -all_load 打包.so1.编译1gcc -c -fPIC -o myfile.o myfile.c 2.生成.so文件1gcc -shared -o libname.so myfile.o","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":".c","slug":"c","permalink":"https://guchunli.github.io/tags/c/"},{"name":".a","slug":"a","permalink":"https://guchunli.github.io/tags/a/"},{"name":".so","slug":"so","permalink":"https://guchunli.github.io/tags/so/"}]},{"title":"github上使用SSH和gitignore","date":"2017-03-03T08:52:02.000Z","path":"2017/03/03/github上使用SSH和gitignore/","text":"1.使用SSH123456$ cd ~/.ssh$ ssh-keygen -t rsa -C &quot;your email address&quot;$ cat ~/.ssh/id_rsa.pub$ ssh -T git@github.com （github） $ ssh -T git@git.oschina.net (oschina)$ Welcome to Git@OSC, nickname! 2.gitignore 123456cd /Users/apple/Desktop/codegit clone git地址cp gitignore路径 .gitignoregit add .git commit -m &quot;添加 gitignore&quot;git push 注意：”cp gitignore路径 .gitignore”一定要加”.gitignore”。","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"github","slug":"github","permalink":"https://guchunli.github.io/tags/github/"},{"name":"SSH","slug":"SSH","permalink":"https://guchunli.github.io/tags/SSH/"},{"name":"gitignore","slug":"gitignore","permalink":"https://guchunli.github.io/tags/gitignore/"}]},{"title":"git使用","date":"2017-03-03T02:49:42.000Z","path":"2017/03/03/git使用/","text":"初始化仓库 $ git init 提交代码 $ git add .$ git commit -m “” 查看状态 $ git status 查看修改 $ git diff12-change something+change 查看提交历史 $ git log 1234567891011121314151617commit acbcfcfa48c89deb725aae9e03a68a2f5abaa1d4Author: gcl &lt;155@163.com&gt;Date: Tue Feb 7 14:30:11 2017 +0800change 2commit 99f733644454644d90b8ee39c6737dc283c78cecAuthor: gcl &lt;155@163.com&gt;Date: Tue Feb 7 14:27:55 2017 +0800change readme.txtcommit 58110376e350d36c8df095b17ff2ecb44906eae2Author: gcl &lt;155@163.com&gt;Date: Tue Feb 7 14:25:17 2017 +0800add readme.txt 简化版本信息 $ git log –pretty=oneline123acbcfcfa48c89deb725aae9e03a68a2f5abaa1d4 change 299f733644454644d90b8ee39c6737dc283c78cec change readme.txt58110376e350d36c8df095b17ff2ecb44906eae2 add readme.txt 查看命令历史 $ git reflog12345acbcfcf HEAD@&#123;0&#125;: reset: moving to acbcfcfa499f7336 HEAD@&#123;1&#125;: reset: moving to HEAD^acbcfcf HEAD@&#123;2&#125;: commit: change 299f7336 HEAD@&#123;3&#125;: commit: change readme.txt5811037 HEAD@&#123;4&#125;: commit (initial): add readme.txt 回退版本HEAD指向当前版本，HEAD^是上一版本，HEAD^^是上上版本，HEAD~100是上100个版本--hard是强制抹除修改，未提交的修改会丢失。git reset –hard 慎重使用--mixed是保存修改，相当于重新提交。 回到上一版本 $ git reset –hard HEAD^ 回到某一历史 $ git reset –hard commitid 工作区与暂存区 respository文件夹：工作区 .git：版本库，包含了stage（暂存区），分支master，指针HEAD git add是把文件修改放到了暂存区，git commit把暂存区的内容提交到了分支，没有提交到暂存区的修改是不会被提交到分支的提交的事件线：工作区-&gt;git add-&gt;暂存区-&gt;git commit-&gt;分支 撤销修改git管理的是修改，而不是文件 清空工作区的修改，回到最近一次git commit或git add时的状态（用版本库的版本替换工作区的版本）：git checkout – readme.txt （注意：git checkout 是切换分支命令） 撤销add后，commit前在暂存区的修改，将暂存区的修改放回工作区：git reset HEAD readme.txt（注意：reset可以回退版本，还可以撤销add到暂存区的内容，回退到工作区，如果要撤销在工作区的修改，可以再次checkout – file） 撤销commit之后，push之前：版本回退，git reset git push：无法撤销 删除文件确定删除 git rm filenamegit commit 撤销删除，找回文件 git checkout – filename注意：git checkout是使用版本库中的最新版本替换工作区的版本，即撤销git add/rm之前的修改 远程仓库 本地库master与远程库origin关联，origin为远程库的默认叫法 $ git remote add origin git@github.com:XXX/learngit.git（XXX为你的github账户名） 将本地库中的所有内容推送到远程库中，加上-u将本地master分支和远程origin分支关联起来，以后推送就可以直接使用git push简化命令 $ git push -u origin master 以后推送使用以下命令 $ git push origin master 把远程库克隆到本地,使用https速度慢，而且每次都要输入口令 $ git clone ssh或https push与pull push：本地 –&gt; 远程，如果本地超前远程，需要push pull：本地 &lt;– 远程，如果本地落后远程，需要pull 分支管理HEAD指向当前分支--master分支，master指向最新提交 创建分支 创建分支将当前分支中的所有文件拷贝到新分支 $ git branch second 切换到分支 $ git checkout second 创建+切换到分支 $ git checkout -b second 查看当前分支 $ git branch 合并分支 合并指定分支到当前分支(主分支) $ git branch master$ git merge second 撤销合并操作 $ git reset 合并模式 ”fast forward”模式：合并分支默认使用”fast forward”模式，删除分支会丢掉分支信息，合并后看不出做过合并 普通模式：禁用”fast forward” 使用普通模式，合并后的历史可以看出曾经做过合并，在merge时生成一个新的commit。禁用”fast forward”并且加上了commit描述： $ git merge –no-ff -m “merge with no-ff” second 查看分支 $ git log 查看分支合并图$ git log –graph$ git log –graph –pretty=oneline –abbrev-commit 删除分支 $ git branch -d second$ git branch -D second：强行删除一个没有合并过的分支$ git push origin –delete second 删除远程分支 分支管理策略本地分支：master，dev，bug，feature远程分支：origin，dev 解决冲突 查看冲突 $ git status 查看分支合并图 git log –graph $ git log –graph –pretty=oneline –abbrev-commit 解决冲突合并分支发生冲突后，解决冲突步骤：查看冲突-&gt;修改-&gt;提交-&gt;合并完成 bug分支将当前无法提交到现场先保存起来，使工作区恢复clean状态，修复bug后，再将保存的东西解开 将工作现场先保存起来：git stash 查看保存现场记录：git stash list 恢复工作线程 git stash apply ：stash内容不删除，需要使用git stash drop手动删除 git stash pop：恢复的同时将stash的内容删除 git stash apply stash@{0}：有多个stah时，指定恢复到某个stash feature分支新添加功能时创建feature分支，开发完成合并到主分支，最好在开发新功能时为每一个新功能创建一个分支 多人协作查看远程库 查看远程库的信息 $ git remote 查看远程分支详细信息 $ git remote -v 推送分支将本地某个分支中的所有提交推送到远程库 $ git push origin master一般只推送master和dev分支，其他可以在本地放着 抓取分支创建本地dev分支： $ git checkout -b dev origin/dev git pull提示“no tracking information”,设置dev和origin/dev的链接：$ git branch –set-upstream dev origin/dev$ git pull$ git add/commit/push 注意：如果git pull时提示“no tracking information”，则需要指定本地master/dev分支与远程origin/dev分支的链接后，才能pull $ git branch –set-upstream dev origin/dev 已弃用$ git branch –set-upstream-to=origin/dev dev 最新用法 多⼈人协作的⼯工作模式:（1）git push origin branch-name（2）如果推送失败,则因为远程分⽀支⽐比你的本地更新,需要先⽤用git pull试图合并;（3）如果合并有冲突,则解决冲突,并在本地提交;（4）没有冲突或者解决掉冲突后,再⽤用git push origin branch-name推送就能成功! 标签添加标签 添加标签 $ git tag v1.0 补加标签 $ git log –pretty=oneline –abbrev-commit$ git tag v0.9 commitid 添加说明用-a指定标签名，-m指定说明文字： $ git tag -a v0.1 -m “version 0.1 released” 3628164 私钥签名标签 $ git tag -s v0.2 -m “signed version 0.2 released” fec145a 查看标签 查看所有标签 $ git tag 查看标签信息 $ git show v0.9注意，标签不是按时间顺序列出，而是按字母排序的。 推送标签 推送某一标签 $ git push origin v1.0 推送本地所有未推送标签 $ git push origin –tags 删除标签 删除本地标签 $ git tag -d v1.0 删除远程标签 需要先删除本地标签： $ git tag -d v1.0 推送到远程： $ git push origin :refs/tags/v1.0 github使用SSH123456789$ ssh-keygen -t rsa -C &quot;xxxxx@xxxxx.com&quot;# Creates a new ssh key using the provided email# Generating public/private rsa key pair...$ cat ~/.ssh/id_rsa.pub# ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC6eNtGpNGwstc.... 将public key添加$ ssh -T git@github.com （github）ssh -T git@git.oschina.net (oschina)Welcome to Git@OSC, yourname! 为开源仓库贡献代码fork在GitHub上，可以任意Fork开源仓库 提交修改自己拥有Fork后的仓库的读写权限，从自己帐号克隆仓库，然后提交到自己的仓库 pull request请求官方接受修改 自定义git配置用户名和email如果遇到以下问题：1234567891011*** Please tell me who you are.Rungit config --global user.email &quot;you@example.com&quot;git config --global user.name &quot;Your Name&quot;to set your account&apos;s default identity.Omit --global to set the identity only in this repository.&gt;&gt;&gt;fatal: unable to auto-detect email address (got &apos;xxx@xxx.(none)&apos;) 需要配置用户名和邮箱： $ git config –global user.name “Your Name”$ git config –global user.email “email@example.com” 给git命令添加颜色 $ git config –global color.ui true 忽略特殊文件 忽略文件的原则 忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件； 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。 强制添加被忽略的文件 $ git add -f App.class 查看想添加的文件被.gitignore中的哪条规则忽略了 $ git check-ignore -v App.class 注意：.gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理 配置别名 $ git config –global alias.st status$ git config –global alias.co checkout$ git config –global alias.ci commit$ git config –global alias.br branch$ git config –global alias.unstage ‘reset HEAD’$ git config –global alias.last ‘log -1’$ git config –global alias.lg “log –color –graph – 注意：--global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用 配置文件每个仓库的Git配置文件都放在.git/config文件中，查看配置文件 $ cat .git/config 要删除别名，直接把对应的行删掉即可改错了，可以删掉文件重新通过命令配置 自己搭建git服务器（1）安装gitsudo apt-get install git（2）创建一个git用户，用来运行git服务sudo adduser git（3）创建证书登录收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个（4）初始化Git仓库sudo chown -R git:git sample.git（5）禁用shell登录出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：git:x:1001:1001:,,,:/home/git:/bin/bash改为： git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。（6）克隆远程仓库git clone git@server:/srv/sample.git（7）要方便管理公钥，用Gitosis； 要像SVN那样变态地控制权限，用Gitolite。 git命令汇总git init git addgit commitgit rmgit status git diffgit log (–pretty=oneling)git reflog git checkout – filenamegit reset HEAD filenamegit reset –hard HEAD^(commitid) git add remote origin git/httpsgit push/pull/clone git branch secondgit checkout secondgit checkout -b secondgit branchgit branch -d secondgit log –graph –pretty=oneline –abbrev-commit git stashgit stash listgit stash applygit stash dropgit stash popgit stash apply stash@{0} git remote -vgit checkout -b dev origin/devgit branch –set-upstream-to=origin/dev devgit pull git tag namegit tag tagname commitidgit tag -a tagname -m “description”git taggit show tagnamegit push origin tagnamegit push origin –tagsgit tag -d tagnamegit push origin :refs/tags/tagname ssh-keygen -t rsa -C “xxxxx@xxxxx.com”cat ~/.ssh/id_rsa.pubssh -T git@github.com （github） git add -f App.class git config user.name “username”git config user.email “email”git config –global alias.st status 附Unix命令（1）创建文件夹：mkdir（2）跳到指定路径：cd（3）查看当前完整路径：pwd（4）查看当前路径下的所有文件及文件夹：ls（5）cat：可以显示文件内容，但是不能编辑（6）touch：如果文件存在，使用touch指令可更改这个文件或目录的日期时间，包括存取时间和更改时间；如果文件不存在，touch指令会在当前目录下新建一个空白文件（7）vi/vim：打开文件后可以编辑（8）echo：输出 Git的官方网站 本文为阅读廖雪峰的官方网站中的git教程的学习笔记，仅为自己的一点学习记录，原文写的非常好，作者很厉害，有兴趣的朋友可以阅读原文：廖雪峰的官方网站的git教程","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://guchunli.github.io/tags/Git/"}]},{"title":"Markdown的使用","date":"2017-02-19T01:48:39.000Z","path":"2017/02/19/Markdown的使用/","text":"基本语法1.换行符： 一行结束时输入两个空格 line1line2 2.段落： 段落之间空一行 p1 p2p3 3.标题： （1）Setext形式：= 大标题 - 中标题 （2）atx形式：# 大标题中标题 一级标题二级标题三级标题四级标题五级标题六级标题 4.区块引用：> 区块1 区块2 区块3 5.列表：*/+/- 前后加空格，tab键或四个空格可分级 列表1 列表2 列表3 6.斜体、粗体、删除线斜体：*斜体* 斜体粗体：**斜体** 粗体粗斜体：***斜体*** 粗斜体删除线：~~删除线~~ 删除线 7.内嵌代码：` 内嵌代码 ` 内嵌代码8.水平线：—— 9.链接： [文字]（url title） ![]（图片 title） 百度一下-你就知道 10.注意：反斜杠\\实现转义效果","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://guchunli.github.io/tags/markdown/"}]},{"title":"hexo创建个人博客","date":"2017-02-18T08:43:01.000Z","path":"2017/02/18/hexo创建个人博客/","text":"常见命令1.安装hexo1$ sudo npm install -g hexo 2.初始化1$ hexo init 3.生成静态页面1$ hexo generate（hexo g也可以） 4.启动本地服务，进行文章预览调试,浏览器输入http://localhost:4000即可1$ hexo server（hexo s也可以） 5.发布配置1$ hexo deploy（hexo d也可以） 每次部署的步骤，可按以下三步来进行: hexo clean，hexo generate，hexo deploy，或者 hexo d -g 6.新建文章1$ hexo new&quot;postName&quot; 7.新建页面1$ hexo new page&quot;pageName&quot; 8.添加统计数据在themes/yilia/layout/_partial/footer.ejs文件上添加以下代码：1&lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt; 下添加以下代码：123本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次本文总阅读量&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次 hexo填坑历程(1)坑一：hexo命令找不到12ERROR Local hexo not found in E:\\blogERROR Try running: &apos;npm install hexo --save&apos; 解决：按照提示输入npm install hexo --save，如果不可以，可能是：因为安装包中有些内容在墙外，所以可以换淘宝源，或者用 $ npm install -g hexo-cli –no-optional(很重要)有时候只写npm install --no-optional也不行，只能以上命令 如果还是不可以，可能是由于：.gitignore文件里面忽略了node_modules文件夹，所以这个文件夹没有更新上去。所以用npm重新安装即可，输入以下命令：123cd ...\\blognpm installhexo server (2)坑二：ERROR Deployer not found: git $ npm install hexo-deployer-git –save然后重新 deploy 即可 (3)坑三：hexo deploy成功，但是页面不显示解决：到仓库下的settings下修改GitHub Pages，source选择master分支，显示 Your site is published at https://XXX.github.io/即可 (4)坑四：123fatal: Not a git repository (or any of the parent directories): .gitFATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: fatal: Not a git repository (or any of the parent directories): .git 解决：检查_config.yml文件deploy的配置如下：12type: gitrepo: https://github.com/XXX/XXX.github.io.git 如果还是不可以，请看下一解决方案。 (5)坑五：Permission to XXX.github.io.git denied解决：12$ git config --global user.name &quot;yourname&quot;$ git config --global user.email &quot;youremail&quot; 如果以上做完还是出不来，删掉根目录下的文件夹：.deploy_git，重新deploy就可以了。","comments":true,"categories":[{"name":"笔记","slug":"note","permalink":"https://guchunli.github.io/categories/note/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://guchunli.github.io/tags/hexo/"},{"name":"个人博客","slug":"个人博客","permalink":"https://guchunli.github.io/tags/个人博客/"}]}]