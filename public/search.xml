<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>OC面试题总结-2019</title>
      <link href="/2019/05/24/OC%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-2019/"/>
      <url>/2019/05/24/OC%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-2019/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> OC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>读书笔记</title>
      <link href="/2019/03/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/03/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><center><img src="/assets/imgs/gufeng.jpg" alt="&quot;&quot;"></center><br><a id="more"></a></p><h1 id="书单"><a href="#书单" class="headerlink" title="书单"></a>书单</h1><h2 id="to-do"><a href="#to-do" class="headerlink" title="to do"></a>to do</h2><ul><li>严歌苓、村上春树</li><li>豆瓣 60</li><li>《平凡的世界》——路遥</li><li>《百年孤独》——马尔克斯</li><li>《我是猫》</li><li>《乌合之众》——古斯塔夫勒庞</li><li>《遇见未知的自己》</li><li>《苏菲的世界》</li><li>《月亮与六便士》</li><li>《少有人走的路4》</li><li>《麦田里的守望者》</li><li>《当下的力量》</li><li>《果壳中的宇宙》</li><li>《枪炮、病菌与钢铁》</li><li>《霍乱时期的爱情》</li><li>《围城》</li><li>《王阳明心学》</li><li>《你是世界写给我的情书》</li><li>《二十几岁，没有十年》</li><li>《追风筝的人》</li><li>《极简力》</li><li>《摆渡人》</li><li>《姥姥语录》</li><li>《我们仨》</li><li>《灵魂有香气的女子》</li><li>《借山而居》</li><li>《爱你时有风》</li><li>《西西弗的神话》</li><li>古希腊罗马神话故事</li><li>《如何让你爱的人爱上你》</li><li>《愿你喜欢被岁月修改的自己》——张西</li><li>《自私的基因》</li><li>《从0到1》<h3 id="《人性的弱点》"><a href="#《人性的弱点》" class="headerlink" title="《人性的弱点》"></a>《人性的弱点》</h3></li><li>世界上最无情的不是人，而是时间，最难听的不是脏话，而是谎言<h3 id="《鬼谷子》"><a href="#《鬼谷子》" class="headerlink" title="《鬼谷子》"></a>《鬼谷子》</h3></li><li>如果你遇到的是猪，你不用跟他谈思想，因为他关心的是饲料<h3 id="《羊皮卷》"><a href="#《羊皮卷》" class="headerlink" title="《羊皮卷》"></a>《羊皮卷》</h3></li><li>爱笑的人运气不会太差，因为运气差的人根本笑不出来<h3 id="《墨菲定律》"><a href="#《墨菲定律》" class="headerlink" title="《墨菲定律》"></a>《墨菲定律》</h3></li><li>教会你不要相信任何人的都是你最信任的人<h3 id="《狼道》"><a href="#《狼道》" class="headerlink" title="《狼道》"></a>《狼道》</h3></li><li>外向是生活所需，孤独才是自我享受</li><li>《剑来》烽火戏诸侯</li><li>《选择》</li><li>《生活需要仪式感》</li><li>《董卿：做一个有才情的女子》</li><li>《别在该动脑子的时候动感情》</li><li>《断舍离》</li><li>《所谓情商高，就是会说话》</li><li>《蔡康永的情商课：为你自己活一次》</li><li>《钝感力》</li><li>《时间的礼物》</li><li>《你要相信改变的力量》</li><li>《好看的皮囊千篇一律，有趣的灵魂万里挑一》</li><li>《天才在左疯子在右》</li><li>《影响力》</li><li>《我喜欢人生快活的样子》</li><li>孤独三部曲：《孤独是人生的修行》 《孤独是生命的礼物》 《百年孤独》</li><li>《吃掉那只青蛙》</li><li>《黄金时代》</li></ul><h3 id="书单1"><a href="#书单1" class="headerlink" title="书单1"></a>书单1</h3><ul><li>《娱乐至死》</li><li>《被讨厌的勇气》</li><li>《拆掉思维里的墙》</li><li>《东京本屋》</li><li>《独居的一年》</li><li>《爸爸爸》——韩少功</li><li>《不能承受的生命之轻》</li><li>《巨河流》——齐邦媛</li><li>《挪威的森林》——村上春树</li><li>《情人》</li><li>《人面桃花》——格非</li><li>《解忧杂货铺》——东野圭吾</li><li>《房思琪的初恋乐园》——林奕含</li></ul><h3 id="卢思浩"><a href="#卢思浩" class="headerlink" title="卢思浩"></a>卢思浩</h3><h4 id="《愿有人陪你颠沛流离》"><a href="#《愿有人陪你颠沛流离》" class="headerlink" title="《愿有人陪你颠沛流离》"></a>《愿有人陪你颠沛流离》</h4><ul><li>今天能做的事不要等到明天，答应自己要去的地方就尽力去抵达。这个世界太危险，时间就该浪费在美好的事物上。——</li><li>所谓的成长，就是越来越能接受自己本来的样子，也能更好的和孤单的自己，失落的自己，挫败的自己相处，并且接受它，然后面对它。</li></ul><h4 id="《你要去相信，没有到不了的明天》"><a href="#《你要去相信，没有到不了的明天》" class="headerlink" title="《你要去相信，没有到不了的明天》"></a>《你要去相信，没有到不了的明天》</h4><h4 id="《离开前请叫醒我》"><a href="#《离开前请叫醒我》" class="headerlink" title="《离开前请叫醒我》"></a>《离开前请叫醒我》</h4><h4 id="《你也走了很远的路吧》"><a href="#《你也走了很远的路吧》" class="headerlink" title="《你也走了很远的路吧》"></a>《你也走了很远的路吧》</h4><h4 id="《想太多》"><a href="#《想太多》" class="headerlink" title="《想太多》"></a>《想太多》</h4><h3 id="孙宇晨"><a href="#孙宇晨" class="headerlink" title="孙宇晨"></a>孙宇晨</h3><h4 id="《这世界既残酷也温柔》"><a href="#《这世界既残酷也温柔》" class="headerlink" title="《这世界既残酷也温柔》"></a>《这世界既残酷也温柔》</h4><h3 id="张皓宸"><a href="#张皓宸" class="headerlink" title="张皓宸"></a>张皓宸</h3><h4 id="《我与世界只差一个你》"><a href="#《我与世界只差一个你》" class="headerlink" title="《我与世界只差一个你》"></a>《我与世界只差一个你》</h4><h4 id="《你是最好的自己》"><a href="#《你是最好的自己》" class="headerlink" title="《你是最好的自己》"></a>《你是最好的自己》</h4><h4 id="《后来时间都与你有关》"><a href="#《后来时间都与你有关》" class="headerlink" title="《后来时间都与你有关》"></a>《后来时间都与你有关》</h4><h4 id="《谢谢自己够勇敢》"><a href="#《谢谢自己够勇敢》" class="headerlink" title="《谢谢自己够勇敢》"></a>《谢谢自己够勇敢》</h4><h2 id="part"><a href="#part" class="headerlink" title="part"></a>part</h2><h3 id="《厚黑学》——李宗吾"><a href="#《厚黑学》——李宗吾" class="headerlink" title="《厚黑学》——李宗吾"></a>《厚黑学》——李宗吾</h3><h3 id="《人生三书》——龙应台"><a href="#《人生三书》——龙应台" class="headerlink" title="《人生三书》——龙应台"></a>《人生三书》——龙应台</h3><h3 id="《活着》——余华"><a href="#《活着》——余华" class="headerlink" title="《活着》——余华"></a>《活着》——余华</h3><ul><li>以笑的方式哭，在死亡的伴随下活着。——《活着》</li><li>人类无法承受太多的真实。——《活着》</li><li>没有什么比时间更有说服力了，因为时间无需通知我们就可以改变一切。——《活着》</li><li>人这一生，一定要明白一些道理，比如活着要开心，要快乐。——《活着》</li><li>活着是自己去感受活着的幸福和辛苦、无聊和平庸；幸存，不过是旁人的评价罢了。——《活着》<h3 id="《人性的弱点》——戴尔·卡耐基"><a href="#《人性的弱点》——戴尔·卡耐基" class="headerlink" title="《人性的弱点》——戴尔·卡耐基"></a>《人性的弱点》——戴尔·卡耐基</h3></li></ul><h2 id="done"><a href="#done" class="headerlink" title="done"></a>done</h2><h3 id="《看见》——柴静"><a href="#《看见》——柴静" class="headerlink" title="《看见》——柴静"></a>《看见》——柴静</h3><h3 id="《我不喜欢这世界，我只喜欢你》"><a href="#《我不喜欢这世界，我只喜欢你》" class="headerlink" title="《我不喜欢这世界，我只喜欢你》"></a>《我不喜欢这世界，我只喜欢你》</h3><h3 id="《每个人都是一座孤岛》——沈三废"><a href="#《每个人都是一座孤岛》——沈三废" class="headerlink" title="《每个人都是一座孤岛》——沈三废"></a>《每个人都是一座孤岛》——沈三废</h3><ul><li>我们遇见很多人，和很多人分开，又和很多人再相遇。大家都一样，没有什么不同，一样的孤单，一样的幸福。</li><li>人生来是寂寞的，赤条条来到这个陌生的世界上，行走一世，最后又孤单地走了，如同幻梦一般。人们说，每个人都是一座孤岛，快乐着自己的快乐，痛苦着自己的痛苦，与这个世界无关。我是这句话的信徒。</li><li>总要经历一段活在自己世界中的时刻，在那里才能明白自己最想要的是什么，没了那些遮盖双眼的迷雾，一切都变得清晰起来。</li><li>喜欢一个人，就会没来由的自卑。从来粗心大意的自己，开始变得小心翼翼。每一天都做心理斗争，每一天都想着放弃，可却每一天都坚持下来。懦弱和勇敢，原来只隔着一层喜欢。</li><li>愿你终有一天，所有压抑的烦恼，说不出的痛楚，难于表达的情感，都能毫不掩盖发泄出来。你会发现，原来生活也能这么美丽，就连那些不堪的东西，都变得越发璀璨起来。</li><li>逆着光前行，总会经历比别人困难的事情。在困难中逆行，才造就了世界上独一无二的你。</li><li>有的时候，我喜欢就这样安静地坐着看一旁忙碌的城市，仿佛自己不是城市中的一员，我只是个看客。看他们行色匆匆，看他们悲伤与狂喜，看他们面无表情的样子。</li><li>记忆被时间绑架，回忆被心软美化，最终只留下了你的好。</li><li>时间就是让你觉得走得好慢，可是不经意间又快到让你无法接受。</li><li>岁月漫长，分离总会再次相遇，误会也会慢慢澄清，孤零零的你也总有一天会得到归宿。命运已把所有都规划好，该会好的总会好。</li><li>于是渐渐明白，能否享受一个人的时光，能否经营好人生这座孤岛，关键看内心。内心从容，便是一个人孤处，那也是最美的时光；内心孤单，便是处于闹市，那也是一群人的寂寞。那种依靠外物的刺激形成的欢愉，眨眼之间便烟消云散，最后都会是一个人品尝寂寞的滋味。</li><li>趁着年轻，多走一走，走到那个只有在梦里才会出现的地方，去看那些想都想不出的艳丽风景。</li><li>你可以用很长的一段时间去爱一个人，同样也可以努力忘掉他，长短与否，都是用心的结果。</li><li>原地停留并不是一件不好的事，那些不被人仔细看过的风景，不被人注意的小美好，都藏在这些需要静下心来才能发现的时间里。</li><li>愿你生活中处处充满笑容，不再有大风大浪的袭击，只有这小小静谧的美好。</li><li>感觉是个骗子，它像是个没有长大的小孩，我行我素，想要离开，想要逃避，想要新鲜的地方和新鲜的面孔，可是最后又会后悔，希望时光倒流。</li><li>肯定是真挚过的，那些说出来的话在那一刻必定是诚意满满的。只是最后，时光亏欠了承诺，你也慢慢离开了我。</li><li>心事随着时间慢慢变冷，不再喜欢复杂轰轰烈烈的感情，能简单干脆表达爱即可，反正都一样，爱能有什么不同。</li><li>很羡慕鸟儿，它们想去哪里拍拍翅膀就能飞去，说走就走。不像我们，人还在，心却走了。</li><li>因为不喜欢说再见，所以逃得快，用所有的行动去避开结局，就以为不会结束。</li><li>刚走到最后再回首，身边已经没有来时伴。丢在人生旅途中的人，不好找，也寻不回。</li><li>他们是过去的人，就该让他们活在回忆里。</li></ul><h3 id="《人间失格》——太宰治"><a href="#《人间失格》——太宰治" class="headerlink" title="《人间失格》——太宰治"></a>《人间失格》——太宰治</h3><ul><li>生而为人，我很抱歉</li><li>严歌苓在《芳华》里说过：一个从来不被善待的人，最能识别善良。</li><li>从上帝视角看不过是一轮又一轮的七情六欲，生老病死的循环往复。</li><li>残缺的灵魂才看得清另一个残缺的灵魂</li><li>如果沉默比争辩更有力量，那我会建议沉默。如果争辩更有助于理清来龙去脉，那我建议争辩。</li><li>不知道在哪里看到，说人不快乐的时候就会思考人生的意义，现在想想，快乐真是一味好药，真是维稳世界最好的致幻剂，清醒本就是最荒唐的。</li><li>真情实感流露出来就变了调，它在心里是真诚而坚定的，表露出来就脱离了你的精神，开始接受世界的质询，你以这质询为尺度，时时刻刻衡量自己。累。</li><li>相同之事也反复发生在明日，只需遵从与昨天同样的惯例，只要避免过度的狂喜，自然不会有悲哀造次，蟾蜍总是会迂回前进，躲开阻挡前方的路石。（若能避开猛烈的欢喜，自然不会有悲痛来袭）</li></ul><h3 id="《皮囊》——蔡崇达"><a href="#《皮囊》——蔡崇达" class="headerlink" title="《皮囊》——蔡崇达"></a>《皮囊》——蔡崇达</h3><h3 id="《时间的礼物》——弗雷德里克-巴克曼"><a href="#《时间的礼物》——弗雷德里克-巴克曼" class="headerlink" title="《时间的礼物》——弗雷德里克 巴克曼"></a>《时间的礼物》——弗雷德里克 巴克曼</h3><h3 id="《运动健身与营养》——史仍飞、袁海平"><a href="#《运动健身与营养》——史仍飞、袁海平" class="headerlink" title="《运动健身与营养》——史仍飞、袁海平"></a>《运动健身与营养》——史仍飞、袁海平</h3>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> list </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>小思</title>
      <link href="/2019/03/13/%E5%B0%8F%E6%80%9D/"/>
      <url>/2019/03/13/%E5%B0%8F%E6%80%9D/</url>
      
        <content type="html"><![CDATA[<p><center><img src="/assets/imgs/shoucang.jpeg" alt="&quot;抽象画&quot;"></center><br><a id="more"></a></p><ul><li>起初笑是心情，后来笑是表情</li><li>不是很贵，但是很对胃</li><li>认清生活的残酷</li><li>有水的地方扎根，有光的地方长叶</li><li>反正我们都是活一天少一天的人了</li><li>在命运面前，如果缴械投降的话，从今往后就只有挨揍的份儿，并且会随着时间的推移越来越糟。但是如果奋起反击、放手一搏的话，没准还能靠自己的能力把局面扳回来。</li><li>时间的残酷，在于它从不管你对过去有多少的留恋，都会用它那让人无法抗拒的力量裹挟着你往前走。<!--当每天上班和上坟一样，感觉是去祭奠我这还没逝去但我深知终将逝去，并且会和昨天、前天一样，和逝去没什么两样的今天，谁还不是过一天少一天的人了呢，生活不止一种活法，任何生活的标准都不该是你生活的标准，你该随着点自己的内心，不应该因为任何其他人的评判标准影响你选择如果过你的一生，都是第一次活，并且就活这一次，人生苦短，何必如此为难自己呢--></li><li>当你心里有比吃东西更重要的东西，就像一个天平，一边是美食，一边是减肥后带来的好处，当对减肥后带来的好处对你诱惑更大，让你更追求的话，就能克制自己对美食的诱惑，就能战胜你对美食带来的直接的快感和安全感的追求。</li><li>遇到困难是好事，想想如果这一生平淡无奇该有多无聊，遇到困难，克服困难，这本来就是人存在的价值</li></ul>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> list </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>收集</title>
      <link href="/2019/03/07/%E6%94%B6%E9%9B%86/"/>
      <url>/2019/03/07/%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p><center><img src="/assets/imgs/xiaosi.png" alt="&quot;抽象画&quot;"></center><br><a id="more"></a></p><h1 id="剧单"><a href="#剧单" class="headerlink" title="剧单"></a>剧单</h1><ul><li>《超体》</li><li>《W两个世界》</li><li>《天空之上三公尺》</li><li>《大小谎言》</li><li>《隐秘而伟大》</li><li>《地球最后的夜晚》</li><li>《迦百农》</li><li>《壁花少年》</li><li>《灵魂摆渡-黄泉》</li><li>《何以为家》</li><li>《sky》</li><li>《大人物》</li><li>《看不见的客人》</li><li>《只有你》</li><li>《最完美的离婚》<h2 id="孤独"><a href="#孤独" class="headerlink" title="孤独"></a>孤独</h2></li><li>《她》</li><li>《绿皮书》</li><li>《超脱》</li><li>《出租车司机》</li><li>《心房客》</li><li>《哑舍》</li></ul><h1 id="歌单"><a href="#歌单" class="headerlink" title="歌单"></a>歌单</h1><ul><li>《We can’t stop》</li><li>《try》</li><li>《right now》</li><li>《Natural》</li><li>《soap》</li><li>《blow me a kiss》</li><li>《staring at you》</li><li>01.《Drip Drip Drip》[低落的星星]</li><li>02.《Dance of Gossamer》[薄纱之舞]</li><li>03.《Floating in the City》[城市漂流]</li><li>04.《Rising of the Deam》[梦起始的地方]</li><li>05.《Dazing》[微醺]</li><li>06.《A New Beginning》[全新的开始]</li><li>07.《Smiling Memories》[回忆微微笑]</li><li>08.《Tender Passion》[柔情]</li><li>09.《Completely Vacant》[净空]</li><li>10.《Infinite Vitality》[生机无限]</li><li>11.《A Fairy In The Woods》[遇见林间精灵]</li><li>12.《Awakening》[唤醒]</li><li>13.《Mermaid》[美人鱼]</li><li>14.《Ocean Blue》[像海一样蓝]</li><li>15.《Diving Deep》[深浅]</li><li>16.《Activation》[纤活]</li><li>17.《You Look Lovely》[你曼妙的身影]</li><li>18.《Have A Feeling In Love》[恋爱的预感]</li><li>19.《Breeze In The Afternoon》[午后微风]</li><li>20.《Intellectual Life》[智慧的生命]</li><li>21.《Floating Space》[无限的想象力]</li><li>22.《Brain》[大脑]</li><li>23.《A Clear Head》[清晰的头脑]</li><li>24.《Intellect》[智慧]</li><li>25.《Knowledge》[知识]</li><li>26.《Intelligence Of Infinity》[无尽的智慧]</li></ul><h1 id="旅游收集"><a href="#旅游收集" class="headerlink" title="旅游收集"></a>旅游收集</h1><ul><li><a href="https://guchunli.github.io/2018/08/11/圣托里尼/">圣托里尼</a></li></ul><h2 id="句子收集"><a href="#句子收集" class="headerlink" title="句子收集"></a>句子收集</h2><p><a href="https://guchunli.github.io/2018/02/02/喜欢的句子/">喜欢的句子</a><br><a href="https://guchunli.github.io/2019/02/22/名言/">名言</a></p><h1 id="英文名收集"><a href="#英文名收集" class="headerlink" title="英文名收集"></a>英文名收集</h1><p>Carol<br>Cassie<br>Charis<br>Claire<br>Colleen<br>Coral<br>Cori<br>Cynthia<br>Corrie<br>Filicia<br>Gillian<br>Iris<br>Josie<br>Jessica<br>Jessie<br>Kate<br>Karol<br>Laura<br>Lucca </p><h1 id="兴趣爱好收集"><a href="#兴趣爱好收集" class="headerlink" title="兴趣爱好收集"></a>兴趣爱好收集</h1><h2 id="坚持，努力，勤奋，热情"><a href="#坚持，努力，勤奋，热情" class="headerlink" title="坚持，努力，勤奋，热情"></a>坚持，努力，勤奋，热情</h2><ul><li>读书，练字（楷书，毛笔字，书法笔，立体字口诀：1.只要下边和右边 2.有连接处要断笔 3.断笔处留好空隙）</li><li>美术：<a href="https://guchunli.github.io/2018/06/12/铅笔画/">铅笔画</a>，禅绕画，简笔画，彩铅，<a href="https://www.zhihu.com/question/31381682" target="_blank" rel="noopener">水彩</a>，油画</li><li>音乐：吉他，古筝，唱歌，跳舞，钢琴，打击垫</li><li>运动：<br>球类：台球，棒球，网球，羽毛球，兵乓球，篮球<br>瑜伽，普拉提，拉丁舞，爵士舞，肚皮舞，尊巴，瘦身操，有氧舞蹈，形体芭蕾<br>跑步，跆拳道，防身术，轮滑，游泳，跳绳，攀岩</li><li>外语：英语，韩语，日语，法语</li><li>other：摄影（微单：索尼ILCE-5100L APS-C 2999），烘焙，手工，棋类，书法，手工，数独，魔方，口哨</li></ul><h2 id="运动-健身"><a href="#运动-健身" class="headerlink" title="运动/健身"></a>运动/健身</h2><p>1.上下比例=5/8（肚脐）64/100<br>2.胸围=身高/2=82 90<br>3.腰围=身高/2-20=62 75<br>4.臀围=胸围+4=86 91<br>5.大腿围=腰围-10=52 54<br>6.小腿围=大腿围-20=32 37<br>7.足颈围=小腿围-10=22 23<br>8.上臂围=大腿围/2=26 25<br>9.颈围=小腿围=32 33<br>10.肩宽=胸围/2-4=37 39</p><ul><li>眼保健操</li><li>去浮肿：口味清淡，躺靠墙，空中自行车，西红柿，芹菜，香蕉</li><li>波比跳，郑多燕，HIIT，tabate，insanity，美丽芭蕾，凯格尔</li></ul><p>蹲起100<br>仰卧起坐50<br>膝肘100<br>自行车100<br>仰开合腿前后左右100<br>仰抬腿50<br>侧抬腿50<br>平板撑<br>摸脚踝<br>高抬腿<br>深蹲开合跳<br>深蹲交替弓步<br>深蹲侧踢<br>后踢腿<br>平躺挺腰<br>燕儿飞<br>抬臀高抬腿跳跃</p><h1 id="自律"><a href="#自律" class="headerlink" title="自律"></a>自律</h1><h2 id="不要"><a href="#不要" class="headerlink" title="不要"></a>不要</h2><ul><li>不熬夜，不超过11点</li><li>不暴饮暴食，节制，自律，（吃东西尝味道，细嚼慢咽）不饿不吃，饿了不吃撑</li></ul><h2 id="要"><a href="#要" class="headerlink" title="要"></a>要</h2><ul><li>早上先喝一杯水</li><li>晚上七点下班回来先刷牙，不吃东西</li><li>多喝水，少吃零食</li><li>间歇性断食：每天吃东西时间控制在8小时之内</li><li>每周至少运动两次</li><li>改善驼背，按摩小腿，眼保健操</li><li>瘦（105），护肤，身材姿态，穿搭</li></ul><h1 id="情商"><a href="#情商" class="headerlink" title="情商"></a>情商</h1><p>为人处世谨记<br>时刻带上脑子，用脑子为人处事，想想自己应该怎么做<br>不说别人坏话，赞美别人<br>不生气，控制住<br>不虚荣，做自己的事<br>记住冲马桶<br>学习拿筷子<br>记住别人姓名<br>吃饭不发声，慢点吃<br>走路挺直腰杆，稍微慢一点<br>提高生活品质，享受生活：学习，健身<br>为人处事圆滑一点，学习卖萌柔和，不要太钢太直<br>时刻注意自己身边的东西，切莫丢三落四<br>去做想做的事，去想去的地方<br>保持善良</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> list </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>随记</title>
      <link href="/2019/03/06/%E9%9A%8F%E8%AE%B0/"/>
      <url>/2019/03/06/%E9%9A%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="常见咖啡组成"><a href="#常见咖啡组成" class="headerlink" title="常见咖啡组成"></a>常见咖啡组成</h3><p>卡布奇诺=1份浓缩咖啡+0.5份热牛奶+1.5份奶泡<br>拿铁=1份浓缩咖啡+1.5份热牛奶+0.5份奶泡<br>摩卡=1份浓缩咖啡+1份热牛奶+0.5份鲜奶油+0.5份巧克力酱<br>玛奇朵=1份浓缩咖啡+0.5份奶泡<br><a id="more"></a></p><h3 id="原花青素含量"><a href="#原花青素含量" class="headerlink" title="原花青素含量"></a>原花青素含量</h3><p>红小豆、蓝莓、巧克力、草莓、白葡萄、富士苹果、紫葡萄</p><h3 id="化妆"><a href="#化妆" class="headerlink" title="化妆"></a>化妆</h3><p>悦诗风吟，爱丽小屋，NARS,MAC,YSL,Dior,ARMANI,CHENEL,GIVENCHY,CPB,TF</p><ul><li>香水：屋顶花园，尼罗河，柏林少女</li><li>面膜：敷尔佳面膜（祛痘）</li></ul><h3 id="值得入手的微单相机"><a href="#值得入手的微单相机" class="headerlink" title="值得入手的微单相机"></a>值得入手的微单相机</h3><ul><li>尼康D5300 （2500）</li><li>索尼A6000（3000）</li></ul><h3 id="别人的结婚清单"><a href="#别人的结婚清单" class="headerlink" title="别人的结婚清单"></a>别人的结婚清单</h3><p>1.彩礼（8万） 回礼（10万）<br>2.新房：80平方以上*7000/平方（首付25万 月贷3000）<br>3.装修：中等（4万）<br>4.酒席费用双方自担（接亲，婚车，婚庆：1万）<br>5.三金首饰（2万）<br>6.婚纱，婚纱照（1万）<br>7.度蜜月，旅游（2万）<br>8.备用储备金（2万）<br>总计：45万</p><h3 id="能瘦小腿肚的走路方式"><a href="#能瘦小腿肚的走路方式" class="headerlink" title="能瘦小腿肚的走路方式"></a>能瘦小腿肚的走路方式</h3><p>挺胸抬头<br>从胯部开始迈腿<br>走路时不要弯曲膝盖<br>脚跟先着地（不要脚尖先着地），想象着脚趾蹬地，缓缓行走<br>不要拖脚蹭地行走<br>放大步伐<br>脚尖方向一致</p><h3 id="瘦"><a href="#瘦" class="headerlink" title="瘦"></a>瘦</h3><p>女孩子是一定要瘦的<br>瘦到锁骨清晰可见<br>瘦到双腿笔直，马甲线清晰<br>瘦到可以肆无忌惮的穿任何衣服<br>瘦到让前男友悔不当初的别离<br>瘦到让现男友不得不把你捧在手心<br>没人会知道你背后有多苦<br>没人会关心你是否有表现的幸福<br>但是你是胖是瘦别人一眼就看的清楚</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> list </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>201902西藏之旅</title>
      <link href="/2019/03/06/201902%E8%A5%BF%E8%97%8F%E4%B9%8B%E6%97%85/"/>
      <url>/2019/03/06/201902%E8%A5%BF%E8%97%8F%E4%B9%8B%E6%97%85/</url>
      
        <content type="html"><![CDATA[<p><center><img src="/assets/201902_xizang/xizang_girl.jpg" alt="&quot;girl&quot;"></center><br><a id="more"></a></p><p>自强上进优秀超级正能量的97妹子，辞掉体制内的工作游22个国家的经历丰富的有趣大哥，在藏工作四年了解当地文化免费带游解说介绍拉萨附近一天还请喝甜茶的大哥，江湖路远，有缘再见，希望生活对你们温柔以待！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>todo list</title>
      <link href="/2019/03/06/todo-list/"/>
      <url>/2019/03/06/todo-list/</url>
      
        <content type="html"><![CDATA[<p><center><img src="/assets/imgs/change.png" alt="&quot;抽象画&quot;"></center><br><a id="more"></a></p><h1 id="todo-list"><a href="#todo-list" class="headerlink" title="todo list"></a>todo list</h1><h2 id="2019-todo-list"><a href="#2019-todo-list" class="headerlink" title="2019 todo list"></a>2019 todo list</h2><p>2019 todo list</p><ul><li>美甲</li><li>纹身</li><li>隐形眼镜</li><li>体重105</li><li>驾照</li><li>坐游艇</li><li>学游泳</li><li>草原</li><li>沙漠</li><li>攀岩</li><li>崇礼滑雪</li><li>学英语/日语/韩语</li><li>水彩</li></ul><h2 id="long-todo"><a href="#long-todo" class="headerlink" title="long todo"></a>long todo</h2><p>马拉松<br>飞机，跳伞，热气球</p><h2 id="travel-list"><a href="#travel-list" class="headerlink" title="travel list"></a>travel list</h2><p>北京：欢乐谷，大观园，世界公园<br>承德：双塔山<br>山西：云冈石窟、悬空寺、平遥古城、恒山<br>陕西：西安、华山、兵马俑<br>甘肃：敦煌莫高窟、麦积山石窟、大地之子<br>河南：洛阳牡丹、嵩山、龙门石窟<br>山东：青岛、养马岛<br>扬州、南京、苏州、杭州、乌镇、温州<br>湖南：张家界、凤凰古城、 芙蓉古镇<br>湖北：神农架<br>上海：迪斯尼<br>福建：厦门<br>广东：广州、深圳<br>广西：桂林<br>海南：三亚<br>云南：大理、昆明、西双版纳、苍山洱海、玉龙雪山、梅里雪山、蓝月谷、紫霞殿、米勒、香格里拉<br>贵州：百里杜鹃，黄果树瀑布、凯里、梵净山<br>四川：成都、甘孜、色达、亚丁稻城、四姑娘山、大邑西岭雪山阴阳界<br>重庆：鸿恩阁、万州大瀑布群<br>青海：青海湖骑行、茶卡盐湖<br>新疆：巴音布鲁克、鹿角湾<br>西藏：然乌湖<br>港澳台<br>东北：哈尔滨、漠河、雪乡、长白山、吉林延边</p><ul><li>护照：泰国、越南、缅甸、印度、孟加拉、尼泊尔、埃及，马来西亚（仙本那，卡帕莱岛水屋），柬埔寨、巴厘岛（天空之门）、新加坡（樟宜国际机场）、圣托里尼</li></ul><h2 id="done"><a href="#done" class="headerlink" title="done"></a>done</h2><p>160417 天安门<br>160713 清华 圆明园<br>161001 唐山，秦皇岛，北京<br>161113 香山<br>161127 八达岭</p><p>170408 玉渊潭<br>170507 植物园<br>170509 颐和园<br>170416 十渡 飞拉达，蹦极<br>170514 天坛<br>170604 798<br>170729 张北草原音乐</p><p>180506 杨梅竹斜街，烟袋斜街，国子监街，五道营胡同<br>180526 话剧<br>180430 五月天演唱会<br>180721 小海山岛<br>181001 内蒙古阿尔山 鹿晗演唱会</p><p>190201 西藏<br>190223 东灵山<br>190309 泰山<br>190324 音乐会（宫崎骏）<br>190414 耳洞<br>190415 天安门升旗<br>190501 长岛、林海峰山、仙境源、月牙湾、九丈崖、蓬莱</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> list </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>名言</title>
      <link href="/2019/02/22/%E5%90%8D%E8%A8%80/"/>
      <url>/2019/02/22/%E5%90%8D%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<center><img src="/assets/imgs/zhaichao.png" alt="&quot;&quot;"></center><br><a id="more"></a><br><br>## 始料未及<br>&gt; 你如果认识从前的我,也许你会原谅现在的我。                              ——张爱玲《倾城之恋》<br><em> 如果你认识从前的我，也许你会纳闷现在的我怎么胖成这逼样了。——张爱玲<br><br>&gt; 如果你给我的，和你给别人的是一样的，那我就不要了。   ——三毛</em> 如果你给我的，和你给别人的是一样的，那你挺够意思的。——三毛<br><br>&gt; 春风十里，不如你。         ——冯唐<br><em> 春风十里，那就是五千米。——冯唐<br>&gt; 我们站着，不说话，就十分美好。      ——顾城</em> 我们站着，不说话，场面一度很尴尬。——顾城<br><br>&gt; 每一个不曾起舞的日子，都是对生命的辜负。  ——尼采<br><em> 每一个不曾起舞的日子，都是感冒了蹦不动迪。——尼采<br><br>&gt; 听过很多道理 却依然过不好这一生。——韩寒</em> 听过很多道理 关键是没记住啊。——韩寒<br><br>&gt; 在有生的瞬间能遇见你，竟花光我所有的运气——林夕<br><em> 有生之年能遇到你，竟花光我三个月生活费和黄牛票。——林夕<br><br>&gt; 你走，我不送你。你来，无论多大风多大雨，我要去接你。     ——梁实秋</em> 你走，我不送你，你来，风雨交加，我接不接你心里没点B数吗——梁实秋<br><br>&gt; 哪里会有人喜欢孤独,不过是不喜欢失望。       ——村上春树《挪威的森林》<br><em>  哪里会有人喜欢孤独,不过是没钱出去玩罢了。——村上春树《挪威的森林》<br><br>## 影视作品台词</em> 总觉得什么事都要有意义，这是人类的恶习——伊坂幸太郎<br><em> 我的人生就是不断扩大的一塌糊涂。——马修·麦康纳《真探》</em> “妈的，我脸上怎么有水？”——苏茜《了不起的麦瑟尔夫人》<br><em> 世界上只有一种真正的英雄主义，那就是在认清生活的残酷真相后依然热爱它”。——罗曼·罗兰</em> “只要还活着，就不会有坏结局，我们仍然在故事的中途。”——德永《火花》<br><em> “这个世界让我感到挫败，但我还不想离开。”——奥丽芙《奥丽芙基特里奇》</em> I do not know where to go,but I have been on the road. 我不知道将去何方，但我已在路上。——《千与千寻》<br>* 得到的全是侥幸，失去的才是人生——《少年派》<br><br>## 名言<br>&gt; 如果有来生，要做一棵树，站成永恒，没有悲欢的姿势。一半在土里安详，一半在风里飞扬，一半洒落阴凉，一半沐浴阳光，非常沉默，非常骄傲，从不依靠，从不寻找。     ——三毛<br><br>&gt; 我相信生命，我相信尚未认识的你，因为总有一天你会成为我最爱的东西：空气，流水，植物，那个少年。     ——塞尔努达<br><br>&gt; 所谓父母子女一场，不过意味着你和他的缘分就是今生今世不断地目送他渐行渐远，你站在路的这一端，看着他渐渐消失在小路转弯的地方，然后，他用背影默默地告诉你：“不必追。”        ——龙应台<br><br>&gt; 你要接受这世界上总有突如其来的失去，洒了的牛奶，遗失的钱包，走散的爱人，断掉的友情等。当你做什么都于事无补的时候，唯一能做的，就是努力让自己过的好一点，丢都丢了，就别再哭了。<br><br>&gt; 你如果认识从前的我,也许你会原谅现在的我.——张爱玲《倾城之恋》<br>&gt; 如果你给我的,和你给别人的是一样的,那我就不要了——三毛<br><center><br>草在结它的种子<br>风在摇它的叶子<br>我们站着，不说话<br>就十分美好——顾城<br></center><blockquote><p>每一个不曾起舞的日子，都是对生命的辜负。一个人知道自己为什么而活，就可以忍受任何一种生活。其实人跟树是一样的，越是向往高处的阳光，它的根就越要伸向黑暗的地底。 ——尼采<br>听过很多道理 却依然过不好这一生。——韩寒<br>在有生的瞬间能遇见你，竟花光我所有的运气——林夕<br>你走，我不送你。你来，无论多大风多大雨，我要去接你。——梁实秋<br>哪里会有人喜欢孤独,不过是不喜欢失望。——村上春树《挪威的森林》<br>曾以为走不出的日子，现在都回不去了。——村上春树<br>在茫茫人海中相遇相知相守，无论谁都不会一帆风顺，只有一颗舍得付出懂得感恩的心，才能拥有一生的爱和幸福。——宫崎骏<br>尽可能爱的单纯一点，尽可能活的纯洁一点，尽可能活的有良心一点，尽可能在成为一个成功的人同时成为一个可爱的人，尽可能活的美一点。——陈果<br>肉体是每个人的神殿，不管里面供奉的是什么，都应该好好保持它的强韧、美丽和清洁。——村上春树</p></blockquote><ul><li>你不愿意种花，你说，“我不愿意看见它，一点点凋落”，是的，为了避免结束，你避免了一切开始。——顾城《避免》</li><li>刻意去找的东西，往往是找不到的，天下万物的来和去，都有他的时间。——三毛</li><li>往好里说是变得顽强了，往坏里说是自己身上纯真的感受性磨损掉了。——村上春树</li><li>在一回首间，才突然发现，原来，我一生的种种努力，不过是为了周遭的人对我满意而已。为了博得他人的称许与微笑，我战战兢兢的将自己，套入所有的模式所有的桎梏。走到途中才忽然发现，我只剩下一副模糊的面目，和一条不能回头的路。——席慕容《独白》</li><li>我愿意像茶，把苦涩留在心里，散发出来的都是清香——《独白》</li><li>你只管往前走，碰到什么是什么——亦舒</li><li>世界上有两件东西不能直视：一是太阳，二是人心。——东野圭吾</li><li>人生最困难的三件事：保守秘密，忘掉所受的创伤，充分利用余暇。——吉罗</li><li>我，一团火，灼人，也将自焚。——臧克家</li><li>像他明天就会来一样期待 像他永远不会来一样生活——张爱玲</li><li>满天星光，满屋月亮，人生何如，为什么这么荒凉——萧红</li><li>当你因为太过迷茫，太过偏执，以至于曲解了梦想和责任，不如先学会生活。——皮囊</li><li>唯有身处卑微的人最有机会看到世态人情的真相。——杨绛</li><li>在这个世界上一定有另一个人我，做着你不敢做的事，过着你想过的生活，并且跟喜欢的人在——《蓝，另一种蓝》</li><li>想做什么就去做吧 每一个犹豫不决的挣扎 都是对人生最大的浪费——《不认命 就拼命》</li><li>这短短的一生，我们最终都会失去。你不妨大胆一些，爱一个人，攀一座山，追一个梦。——《大鱼海棠》</li><li>人生既不能延长，也没有赞美。既然这样，就觉得不如做些想都没想过的事，当做回忆也好啊。——伊坂幸太郎</li><li>不管你怎么样都好，尝试各式各样的事情，就是人生——伊坂幸太郎</li><li>当我们面对不同的时候，不要急着去嘲笑，不要急着去批判，先试着去理解——斯宾诺莎</li></ul>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> list </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>普鲁斯特问卷</title>
      <link href="/2019/01/25/%E6%99%AE%E9%B2%81%E6%96%AF%E7%89%B9%E9%97%AE%E5%8D%B7/"/>
      <url>/2019/01/25/%E6%99%AE%E9%B2%81%E6%96%AF%E7%89%B9%E9%97%AE%E5%8D%B7/</url>
      
        <content type="html"><![CDATA[<p>普鲁斯特问卷<br>1.你认为最完美的快乐是怎样的？<br><!--身边的一切都是自己喜欢的--><br>2.你最希望拥有那种才华？<br><!--语言，唱歌，跳舞--><br>3.你最恐惧的是什么？<br><a id="more"></a><br>4.你目前的心境怎样？<br><!--孤独，什么都不在乎--><br>5.还在世的人中你最佩服的是谁？</p><p>6.你认为自己最伟大的成就是什么？</p><p>7.你自己的哪个特点让你最觉得痛恨？<br><!--麻木--><br>8.你最喜欢的旅行是哪一次？<br><!--下一次--><br>9.你最痛恨别人的什么特点？<br><!--虚伪--><br>10.你最珍惜的财产是什么？</p><p>11.你最奢侈的是什么？</p><p>12.你认为程度最浅的痛苦是什么？</p><p>13.你认为那种美德是被过高评估的？</p><p>14.你最喜欢的职业是什么？</p><p>15.你对自己的外表哪一点不满意？<br><!--脸型--><br>16.你最后悔的事情是什么？</p><p>17.还在世的人当中你最鄙视的是谁？</p><p>18.你最喜欢男性身上的什么品质？<br><!--给人安全感，可靠，顾全大局，主动--><br>19.你使用过最多的单词或词语是什么？</p><p>20.你最喜欢女性身上的什么品质？</p><p>21.你最伤痛的事情是什么？</p><p>22.你最看重朋友的什么特点？<br>真诚<br>23.你这一生中最爱的人或东西是什么？</p><p>24.你希望以什么样的方式死去？</p><p>25.何时何地让你感觉到最快乐？</p><p>26.如果你可以改变你家庭的一件事，那会是什么？</p><p>27.如果你能选择，你希望让什么重现？</p><p>28.你的座右铭是什么？</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>OC进阶书籍阅读笔记</title>
      <link href="/2019/01/03/OC%E8%BF%9B%E9%98%B6%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/01/03/OC%E8%BF%9B%E9%98%B6%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="《编写高质量iOS与OS-X代码的52个有效方法》"><a href="#《编写高质量iOS与OS-X代码的52个有效方法》" class="headerlink" title="《编写高质量iOS与OS X代码的52个有效方法》"></a>《编写高质量iOS与OS X代码的52个有效方法》</h1><h2 id="熟悉Objective-C"><a href="#熟悉Objective-C" class="headerlink" title="熟悉Objective-C"></a>熟悉Objective-C</h2><h3 id="1-了解Objective-C语言的起源"><a href="#1-了解Objective-C语言的起源" class="headerlink" title="1.了解Objective-C语言的起源"></a>1.了解Objective-C语言的起源</h3><h3 id="2-在类的头文件中尽量少引入其他头文件"><a href="#2-在类的头文件中尽量少引入其他头文件" class="headerlink" title="2.在类的头文件中尽量少引入其他头文件"></a>2.在类的头文件中尽量少引入其他头文件</h3><ul><li>@class 向前声明<a id="more"></a><h3 id="3-多用literal字面量语法，少用与之等价的方法"><a href="#3-多用literal字面量语法，少用与之等价的方法" class="headerlink" title="3.多用literal字面量语法，少用与之等价的方法"></a>3.多用literal字面量语法，少用与之等价的方法</h3></li><li>用literal语法创建数组或字典时，若值中有nil，则会抛出异常。因此，务必确保值里不含nil。</li></ul><h3 id="4-多用类型常量，少用-define预处理指令"><a href="#4-多用类型常量，少用-define预处理指令" class="headerlink" title="4.多用类型常量，少用#define预处理指令"></a>4.多用类型常量，少用#define预处理指令</h3><ul><li>不要用预处理指令定义常量。这样定义出来的常量不含类型信息，编译器只是会在编译前据此执行查找与替换操作。即使有人重新定义了常量值，编译器也不会产生警告信息，这将导致应用程序中的常量值不一致。</li><li>在实现文件中使用static const来定义只在编译单元内可见的常量。由于此类常量不在全局符号表中，所以无需为其名称加前缀。</li><li>在头文件中使用extern来声明全局常量，并在相关实现文件中定义其值。这种常量要出现在全局符号表中，所以其名称要加以区隔，通常用与之相关的类名做前缀。<br>注意：static const定义的常量中不能加变量<br>注意：const修饰符在常量类型中的位置，常量定义应从右至左解读。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.h</span><br><span class="line">extern NSString *const EOCStringConstant;</span><br><span class="line">.m</span><br><span class="line">NSString *const EOCStringConstant = &quot;VALUE&quot;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-用枚举表示状态、选项、状态码"><a href="#5-用枚举表示状态、选项、状态码" class="headerlink" title="5.用枚举表示状态、选项、状态码"></a>5.用枚举表示状态、选项、状态码</h3><ul><li>应该用枚举来表示状态机的状态、传递给方法的选项遗迹状态码等值，给这些值起个易懂的名字。</li><li>如果把传递给某个方法的选项表示为枚举型，而多个选项又可同时使用，那么就将各选项值定义为2的幂，以便通过按位或者操作将其组合起来。</li><li>用NS_ENUM与NS_OPTIONS宏来定义枚举类型，并指明其底层数据类型。这样做可以确保枚举是用开发者所选的底层数据类型实现出来的，而不会采用编译器所选的类型。（需要以按位或操作来组合的枚举都应使用NS_OPTIONS定义，若是枚举不需要互相组合，则应使用NS_ENUM来定义。）</li><li>在处理枚举类型的switch语句中不要实现default分支。这样的话，加入新枚举之后，编译器就会提示开发者：switch语句并未处理所有的枚举。</li></ul><h2 id="对象、消息、runtime"><a href="#对象、消息、runtime" class="headerlink" title="对象、消息、runtime"></a>对象、消息、runtime</h2><h3 id="6-理解“属性”这一概念"><a href="#6-理解“属性”这一概念" class="headerlink" title="6.理解“属性”这一概念"></a>6.理解“属性”这一概念</h3><ul><li>可以通过@property语法来定义对象中所封装的数据。</li><li>通过“特质”来指定存储数据所需的正确语义</li><li>在设置属性所对应的实例变量时，一定要遵从该属性所声明的语义。</li><li>开发iOS程序时，应该使用nonatomic属性，因为atomic属性会严重影响性能。</li></ul><h3 id="7-在对象内部尽量直接访问实例变量"><a href="#7-在对象内部尽量直接访问实例变量" class="headerlink" title="7.在对象内部尽量直接访问实例变量"></a>7.在对象内部尽量直接访问实例变量</h3><ul><li>在对象内部读取数据时，应该直接通过实例变量来读，而写入数据时，应该通过属性来写。</li><li>在初始化方法及dealloc方法中，总是应该直接通过实例变量来读写数据。</li><li>有时会使用惰性初始化技术配置某份数据，这种情况下，需要通过属性来读取数据。</li></ul><h3 id="8-理解“对象等同性”这一概念"><a href="#8-理解“对象等同性”这一概念" class="headerlink" title="8.理解“对象等同性”这一概念"></a>8.理解“对象等同性”这一概念</h3><ul><li>若想检测对象的等同性，请提供“isEqual:”与hash方法。</li><li>相同的对象必须具有相同的hash码，但是两个hash码相同的对象却未必相同。</li><li>不要盲目的逐个监测每条属性，而是应该依照具体需求来制定检测方案。</li><li>编写hash方法时，应该使用计算速度快而且哈希码碰撞几率低的算法。</li></ul><h3 id="9-以“类族模式”隐藏实现细节"><a href="#9-以“类族模式”隐藏实现细节" class="headerlink" title="9.以“类族模式”隐藏实现细节"></a>9.以“类族模式”隐藏实现细节</h3><ul><li>类族模式可以把实现细节隐藏在一套简单的公共接口后面。</li><li>系统框架中经常使用类族。</li><li>从类族的公共抽象基类中继承子类时要当心，若有开发文档，则应首先阅读。</li></ul><h3 id="10-在既有类中，使用关联对象-Associated-Object-存放自定义数据（关联对象）"><a href="#10-在既有类中，使用关联对象-Associated-Object-存放自定义数据（关联对象）" class="headerlink" title="10.在既有类中，使用关联对象(Associated Object)存放自定义数据（关联对象）"></a>10.在既有类中，使用关联对象(Associated Object)存放自定义数据（关联对象）</h3><ul><li>可以通过“关联对象”机制来把两个对象连起来。</li><li>定义关联对象时可指定内存管理语义，用以模仿定义属性时所采用的“拥有关系”与“非拥有关系”。</li><li>只有在其他做法不可行时才应选用关联对象，因为这种做法通常会引入难于查找的bug。</li></ul><h3 id="11-理解objc-msgSend的作用（消息传递-消息发送）"><a href="#11-理解objc-msgSend的作用（消息传递-消息发送）" class="headerlink" title="11.理解objc_msgSend的作用（消息传递/消息发送）"></a>11.理解objc_msgSend的作用（消息传递/消息发送）</h3><ul><li>C语言中的函数调用与OC中的消息传递的区别：OC是C的超集，C语言使用”静态绑定”，在编译期就能决定运行时所应调用的函数。OC中，如果向某对象传递消息，使用动态绑定机制来决定需要调用的方法。</li><li>消息由接受者，selector及参数构成。给某对象“发送消息”也就相当于在该对象上调用方法。</li><li>发给某对象的全部消息都要由“动态消息派发系统”来处理，该系统会查出对应的方法，并执行其代码。</li></ul><h3 id="12-理解消息转发机制（消息转发）"><a href="#12-理解消息转发机制（消息转发）" class="headerlink" title="12.理解消息转发机制（消息转发）"></a>12.理解消息转发机制（消息转发）</h3><p>1.动态方法解析 + (BOOL)resolveInstanceMethod:(SEL)selector (resolveClassMethod)<br>2.备援接收者  - (id)forwardingTargetForSelector:(SEL)selector<br>3.完整的消息转发  - (void)forwardInvocation:(NSInvocation *)invocation</p><ul><li>若对象无法响应某个selector，则进入消息转发流程。</li><li>通过运行期的动态方法解析功能，我们可以在需要用到某个方法时再将其加入类中。</li><li>对象可以将其无法解读的某些selector转交给其他对象处理。</li><li>经过上述两步后，如果还是没办法处理selector，那就启动完整的消息转发机制。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// @interface EOCAutoDictionary : NSObject</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel&#123;</span><br><span class="line"></span><br><span class="line">NSString *selectorString = NSStringFromSelector(sel);</span><br><span class="line">if ([selectorString hasPrefix:@&quot;set&quot;]) &#123;</span><br><span class="line">class_addMethod(self, sel, (IMP)autoDictionarySetter, &quot;v@:@&quot;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">class_addMethod(self, sel, (IMP)autoDictionaryGetter, &quot;@@:&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void autoDictionarySetter(id self, SEL _cmd, id value)&#123;</span><br><span class="line"></span><br><span class="line">EOCAutoDictionary *typedSelf = (EOCAutoDictionary *)self;</span><br><span class="line">NSMutableDictionary *backingStore = typedSelf.backingStore;</span><br><span class="line">NSString *selectorString = NSStringFromSelector(_cmd);</span><br><span class="line">NSMutableString *key = [selectorString mutableCopy];</span><br><span class="line">[key deleteCharactersInRange:NSMakeRange(key.length-1, 1)];</span><br><span class="line">[key deleteCharactersInRange:NSMakeRange(0, 3)];</span><br><span class="line"></span><br><span class="line">NSString *lowercaseFirstChar = [[key substringToIndex:1]lowercaseString];</span><br><span class="line">[key replaceCharactersInRange:NSMakeRange(0, 1) withString:lowercaseFirstChar];</span><br><span class="line">if (value) &#123;</span><br><span class="line">[backingStore setObject:value forKey:key];</span><br><span class="line">&#125;else&#123;</span><br><span class="line">[backingStore removeObjectForKey:key];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id autoDictionaryGetter(id self, SEL _cmd)&#123;</span><br><span class="line"></span><br><span class="line">EOCAutoDictionary *typedSelf = (EOCAutoDictionary *)self;</span><br><span class="line">NSMutableDictionary *backingStore = typedSelf.backingStore;</span><br><span class="line">NSString *key = NSStringFromSelector(_cmd);</span><br><span class="line">return [backingStore objectForKey:key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="13-用method-swizzling调试黑盒方法（黑魔法）"><a href="#13-用method-swizzling调试黑盒方法（黑魔法）" class="headerlink" title="13.用method swizzling调试黑盒方法（黑魔法）"></a>13.用method swizzling调试黑盒方法（黑魔法）</h3><p>IMP：函数指针</p><ul><li>在runtime中，可以向类中新增或替换selector所对应的方法实现。</li><li>使用另一份实现来替换原有的方法实现，这道工序叫做method swizzling，开发者常用此技术向原有视线中添加功能。</li><li>一般来说，只有调试程序的时候才需要在runtime中修改方法实现，这种做法不宜滥用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSString+EOCMyAdditions.h</span><br><span class="line">- (NSString *)eoc_myLowercaseString;</span><br><span class="line">//NSString+EOCMyAdditions.m</span><br><span class="line">- (NSString *)eoc_myLowercaseString&#123;</span><br><span class="line">NSString *lowercase = [self eoc_myLowercaseString];</span><br><span class="line">NSLog(@&quot;%@ =&gt; %@&quot;,self,lowercase);</span><br><span class="line">return lowercase;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Method originalMethod = class_getInstanceMethod([NSString class], @selector(lowercaseString));</span><br><span class="line">Method swappedMethod = class_getInstanceMethod([NSString class], @selector(eoc_myLowercaseString));</span><br><span class="line">method_exchangeImplementations(originalMethod, swappedMethod);</span><br></pre></td></tr></table></figure></li></ul><h3 id="14-理解“类对象”的用意"><a href="#14-理解“类对象”的用意" class="headerlink" title="14.理解“类对象”的用意"></a>14.理解“类对象”的用意</h3><p>isKindOfClass / isMemberOfClass</p><ul><li>每个实例都有一个指向Class对象的指针，用以表明其类型，而这些Class对象则构成了累的继承体系。</li><li>如果对象类型无法在编译期确定，那么就应该使用类型信息查询方法来探知。</li><li>尽量使用类型信息查询方法来确定对象类型，而不要直接比较类对象，因为某些对象可能实现了消息转发功能。</li></ul><h2 id="接口与API设计"><a href="#接口与API设计" class="headerlink" title="接口与API设计"></a>接口与API设计</h2><h3 id="15-用前缀避免命名空间冲突"><a href="#15-用前缀避免命名空间冲突" class="headerlink" title="15.用前缀避免命名空间冲突"></a>15.用前缀避免命名空间冲突</h3><ul><li>选择与你公司、应用程序或者二者皆有关联之名称作为类名的前缀，并在所有代码中均使用这一前缀。</li><li>若自己所开发的程序库中用到了第三方库，则应为其中的名称加上前缀。</li><li>Apple宣称保留使用所有两字母前缀的权利，所以自己所选用的前缀最好是三字母的。</li></ul><h3 id="16-提供“全能初始化方法”"><a href="#16-提供“全能初始化方法”" class="headerlink" title="16.提供“全能初始化方法”"></a>16.提供“全能初始化方法”</h3><ul><li>在类中提供一个全能初始化方法，并于文档里指明。其它初始化方法均应调用此方法。</li><li>若全能初始化方法与超类不同，则需覆写超类中对应方法。</li><li>如果超类的初始化方法并不适用于子类，那么应该覆写这个超类方法，并在其中抛出异常。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(instancetype)init&#123;</span><br><span class="line">@throw [NSException exceptionWithName:NSInternalInconsistencyException reason:@&quot;&quot; userInfo:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//&lt;NSCoding&gt;</span><br><span class="line">-(instancetype)initWithCoder:(NSCoder *)aDecoder&#123;</span><br><span class="line">if (self = [super init]) &#123;</span><br><span class="line">_width = [aDecoder decodeFloatForKey:@&quot;width&quot;];</span><br><span class="line">_height = [aDecoder decodeFloatForKey:@&quot;height&quot;];</span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17-实现description方法"><a href="#17-实现description方法" class="headerlink" title="17.实现description方法"></a>17.实现description方法</h3><ul><li>实现description方法返回一个有意义的字符串，用以描述该实例。</li><li>若想在调试时打印出更详尽的对象描述信息，则应该实现debugDescription方法。</li></ul><h3 id="18-尽量使用不可变对象"><a href="#18-尽量使用不可变对象" class="headerlink" title="18.尽量使用不可变对象"></a>18.尽量使用不可变对象</h3><ul><li>尽量创建不可变的对象。</li><li><p>若某属性仅可于对象内部修改，则在“class-continuation分类”中将其由readonly属性扩展为readwrite属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@interface EOCPerson : NSObject</span><br><span class="line">@property (nonatomic, readonly, copy) NSString *firstName;</span><br><span class="line">@property (nonatomic, readonly, copy) NSString *lastName;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface EOCPerson ()</span><br><span class="line">@property (nonatomic, readwrite, copy) NSString *firstName;</span><br><span class="line">@property (nonatomic, readwrite, copy) NSString *lastName;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li><li><p>不要把可变的collection作为属性公开，而应提供相关方法，一次修改对象中的可变collection。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, readonly, strong) NSSet *friends;</span><br><span class="line">&#123;</span><br><span class="line">NSMutableSet *_internalFriends;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(NSSet *)friends&#123;</span><br><span class="line">return [_internalFriends copy];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addFriend:(EOCPerson *)person&#123;</span><br><span class="line">[_internalFriends addObject:person];</span><br><span class="line">&#125;</span><br><span class="line">- (void)removeFriend:(EOCPerson *)person&#123;</span><br><span class="line">[_internalFriends removeObject:person];</span><br></pre></td></tr></table></figure></li></ul><h3 id="19-使用清晰而协调的命名方式"><a href="#19-使用清晰而协调的命名方式" class="headerlink" title="19.使用清晰而协调的命名方式"></a>19.使用清晰而协调的命名方式</h3><ul><li>起名时应遵从标准的Objective-C命名规范，这样创建出来的接口更容易为开发者所理解。</li><li>方法名要言简意赅，从左至右读起来要像个日常用语中的句子才好。</li><li>方法名利不要使用缩略后的类型名称。</li><li>给方法起名时的第一要务就是确保其风格与你自己的代码或所要集成的框架相符。</li><li>方法命名规则：<br>（1）如果方法的返回值是新创建的，那么方法名的首个词应是返回值的类型。<br>（2）应该把表示参数类型的名词放在参数前面。<br>（3）如果方法要在当前对象上执行操作，那么就应该包含动词；若执行操作时还需要参数，则应该在动词后面加上一个或多个名词。<br>（4）Boolean属性应加is前缀。如果某方法返回非属性的Boolean值，那么应该根据其功能选用has或is当前缀。<br>（5）将get这个前缀留给那些借由”输出参数”来保存返回值的方法，比如说，把返回值填充到”C语言式数组”里的那种方法就可以使用这个词做前缀。</li></ul><h3 id="20-为私有方法名加前缀"><a href="#20-为私有方法名加前缀" class="headerlink" title="20.为私有方法名加前缀"></a>20.为私有方法名加前缀</h3><p><code>OC语言没办法将方法标为私有。</code>每个对象都可以响应任意消息，而且可在运行期检视某个对象所能直接响应的消息。根据给定的消息查出其对应的方法，这一工作要在运行期才能完成，所以OC中没有那种约束方法调用的机制t用以限定谁能调用此方法、能在哪个对象上调用此方法以及何时能调用此方法。</p><ul><li>给私有方法的名称加上前缀，这样可以很容易的将其同公共方法区分开。</li><li>不要单用一个下划线做私有方法的前缀，因为这种做法的预留给苹果公司用的。可以把自己一贯使用的类名前缀用作子类私有方法的前缀。</li></ul><h3 id="21-理解Objective-C错误模型"><a href="#21-理解Objective-C错误模型" class="headerlink" title="21.理解Objective-C错误模型"></a>21.理解Objective-C错误模型</h3><ul><li>只有发生了可使整个应用程序崩溃的严重错误时，才使用异常。</li><li>在错误不那么严重的情况下，可以指派委托方法来处理错误，也可把错误信息放在NSError对象里，经由输出参数返回给调用者。<br>NSError 对象里封装了三条信息：<br>（1）Error domain：错误范围，类型为字符串，通常用一个特有的全局常量来定义<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern NSString *const EOCErrorDomain;</span><br><span class="line">NSString *const EOCErrorDomain = @&quot;EOCErrorDomain&quot;;</span><br></pre></td></tr></table></figure></li></ul><p>（2）Error code：错误码，类型为整数，一般定义为枚举值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSUInteger,EOCError) &#123;</span><br><span class="line">    EOCErrorUnknown     = -1,</span><br><span class="line">    EOCErrorBadInpur    = 100,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>（3）User info：用户信息，类型为字典</p><p>传递错误的方式：<br>（1）委托协议<br>（2）由方法的”输出参数”返回给调用者，一般会返回Boolean值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)doSomething:(NSError**)error &#123;</span><br><span class="line">    if (/* there was an error */) &#123;</span><br><span class="line">        if (error)&#123;</span><br><span class="line">        //不关心具体错误时，传入nil</span><br><span class="line">        // 解引用，必须保证error参数不是nil，空指针解引用会导致错误</span><br><span class="line">            *error = [NSError errorWithDomain:domain code:code userInfo:userInfo];</span><br><span class="line">        &#125;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NSError *error = nil;</span><br><span class="line">BOOL ret = [object doSomething:&amp;error];</span><br><span class="line">//关注具体错误</span><br><span class="line">if (error)&#123;</span><br><span class="line">    //</span><br><span class="line">&#125;</span><br><span class="line">//不关注具体的错误信息</span><br><span class="line">if (ret)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="22-理解NSCopying协议"><a href="#22-理解NSCopying协议" class="headerlink" title="22.理解NSCopying协议"></a>22.理解NSCopying协议</h3><ul><li><p>若想令自己所写的对象具有拷贝功能，则需实现NSCopying协议。该协议只有一个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-(id)copyWithZone:(NSZone *)zone&#123;</span><br><span class="line">    // 全能初始化方法</span><br><span class="line">    EOCPerson *copy = [[[self class]allocWithZone:zone]initWithFirstName:_firstName andLastName:_lastName];</span><br><span class="line">    // </span><br><span class="line">    copy-&gt;_internalFriends = [_internalFriends mutableCopy];</span><br><span class="line">    return copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果自定义的对象分为可变版本与不可变版本，那么就要同时实现NSCopying与NSMutableCopying协议。<br>对于不可变的NSArray 与可变的NSMutableArray 来说，下列关系总是成立的：</p></li></ul><ul><li>[NSMutableArray copy] =&gt; NSArray</li><li>[NSArray mutableCopy] =&gt; NSMutableArray<br><code>无论当前对象是否可变，若需获取其可变版本的拷贝，均应调用mutableCopy 方法，若需不可变的拷贝，则总应通过copy 方法来获取。</code></li></ul><ul><li>复制对象时需决定采用浅拷贝还是深拷贝，一般情况下应该尽量执行浅拷贝。Foudation框架中的所有collection类在默认情况下都执行浅拷贝。<br>深拷贝：在拷贝对象自身时，将底层数据也一并复制过去。<br>浅拷贝：只拷贝容器对象本身，而不复制其中数据。</li><li>如果你所写的对象需要深拷贝，那么可考虑新增一个专门执行深拷贝的方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-(id)copyWithZone:(NSZone *)zone&#123;</span><br><span class="line">    // 全能初始化方法</span><br><span class="line">    EOCPerson *copy = [[[self class]allocWithZone:zone]initWithFirstName:_firstName andLastName:_lastName];</span><br><span class="line">    // </span><br><span class="line">    copy-&gt;_internalFriends = [[NSMutableSet alloc]initWithSet:_internalFriends copyItems:YES];</span><br><span class="line">    return copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="协议与分类"><a href="#协议与分类" class="headerlink" title="协议与分类"></a>协议与分类</h2><h3 id="23-通过委托与数据源协议进行对象间通信"><a href="#23-通过委托与数据源协议进行对象间通信" class="headerlink" title="23.通过委托与数据源协议进行对象间通信"></a>23.通过委托与数据源协议进行对象间通信</h3><ul><li>存放委托对象的属性要么定义成weak，要么定义成unsafe_unretained，前者在相关对象销毁时自动清空，后者不需要清空。</li><li><p>在委托对象上调用可选方法，必须提前使用类型信息查询方法判断这个委托对象是否响应相关方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ([_delegate respondsToSelector:@selector(fetchData)])&#123;</span><br><span class="line">    [_delegate fetchData];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在调用delegate对象中的方法时，总是应该把发起委托的实例也一并传入方法中，这样，delegate对象再实现相关方法时，就能根据传入的实例分别执行不同的代码了。</p></li><li>若有必要，可实现含有位段的结构体，将委托对象是否能响应相关协议方法这一信息缓存至其中。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//define</span><br><span class="line">struct &#123;</span><br><span class="line">    unsigned int didReceiveData      : 1;</span><br><span class="line">    unsigned int didFailWithError    : 1;</span><br><span class="line">    unsigned int didUpdateProgressTo : 1;</span><br><span class="line">&#125; _delegateFlags;</span><br><span class="line">//set flag</span><br><span class="line">- (void)setDelegate:(id&lt;EOCNetworkFetcher&gt;)delegate&#123;</span><br><span class="line">    _delegate = delegate;</span><br><span class="line">    _delegate.didReceiveData = [delegate respondsToSelector:@selector(networkFetcher:didReceiveData:)];</span><br><span class="line">&#125;</span><br><span class="line">//check flag</span><br><span class="line">if (_delegateFlags.didReceiveData)&#123;</span><br><span class="line">    [_delegate networkFetcher:self didReceiveData:data];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="24-将类的实现代码分散到便于管理的数个分类之中"><a href="#24-将类的实现代码分散到便于管理的数个分类之中" class="headerlink" title="24.将类的实现代码分散到便于管理的数个分类之中"></a>24.将类的实现代码分散到便于管理的数个分类之中</h3><ul><li>使用分类机制把类的实现代码划分成易于管理的小块。类的基本要素（诸如属性和初始化方法等）都声明在主实现里，执行不同类型的操作所用的另外几套方法则归入各个分类中。<code>需要引入分类的头文件</code></li><li>将应该视为私有的方法归入名叫Private的分类中，以隐藏实现细节。</li></ul><h3 id="25-总是为第三方类的分类名称加前缀"><a href="#25-总是为第三方类的分类名称加前缀" class="headerlink" title="25.总是为第三方类的分类名称加前缀"></a>25.总是为第三方类的分类名称加前缀</h3><ul><li>向第三方类中添加分类时，总应给其名称加上你专用的前缀。</li><li>向第三方类中添加分类时，总应给其中的方法名加上你专用的前缀。</li></ul><h3 id="26-勿在分类中声明属性"><a href="#26-勿在分类中声明属性" class="headerlink" title="26.勿在分类中声明属性"></a>26.勿在分类中声明属性</h3><ul><li>把封装数据所用的全部属性都定义在主接口里。分类机制，目标在于扩展累的功能，而非封装数据。<code>属性只是定义实例变量及相关存取方法所用的语法糖</code></li><li>在class-continuation分类之外的其他分类中，可以定义存取方法，但尽量不要定义属性。应该直接声明一个方法，用以获取数据。</li></ul><h3 id="27-使用class-continuation分类隐藏实现细节"><a href="#27-使用class-continuation分类隐藏实现细节" class="headerlink" title="27.使用class-continuation分类隐藏实现细节"></a>27.使用class-continuation分类隐藏实现细节</h3><p><code>OC动态消息系统的工作方式决定了其不可能实现真正的私有方法或私有实例变量</code></p><ul><li>通过class-continuation分类向类中新增实例变量。必须定义在其所续接的那个类的实现文件里，是唯一能声明实例变量的分类，而且此分类没有特定的实现文件，其中的方法都应该定义在类的主实现文件里。</li><li>如果某属性在主接口中声明为只读，而类的内部又要用设置方法修改此属性，那么就在class-continuation分类中将其扩展为可读写。</li><li>把私有方法的原型声明在class-continuation分类里面。</li><li>若想使类遵循的协议不为人所知，则可于class-continuation分类中声明。</li></ul><h3 id="28-通过协议提供匿名对象"><a href="#28-通过协议提供匿名对象" class="headerlink" title="28.通过协议提供匿名对象"></a>28.通过协议提供匿名对象</h3><ul><li>协议可在某种程度上提供匿名类型。具体的对象类型可以淡化成遵从某些一的id类型，协议里规定了对象所应实现的方法。</li><li>使用匿名对象来隐藏类型名称或类名。</li><li>如果具体类型不重要，重要的是对象能够响应（定义在协议里的）特定方法，那么可使用匿名对象来表示。</li></ul><p><code>NSDictionary 建的标准内存管理语义是 设置时拷贝，值得语义是 设置时保留。</code></p><blockquote><p>setValue和setObject的区别：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface NSMutableDictionary&lt;KeyType, ObjectType&gt; : NSDictionary&lt;KeyType, ObjectType&gt;</span><br><span class="line"></span><br><span class="line">/* Send -setObject:forKey: to the receiver, unless the value is nil, in which case send -removeObjectForKey:.</span><br><span class="line">*/</span><br><span class="line">- (void)setValue:(nullable ObjectType)value forKey:(NSString *)key;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject(NSKeyValueCoding)</span><br><span class="line">- (void)setObject:(ObjectType)anObject forKey:(KeyType &lt;NSCopying&gt;)aKey;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>1.<br>setObject：forkey：中value是不能够为nil的，不然会报错。<br>setValue：forKey：中value能够为nil，但是当value为nil的时候，会自动调用removeObject：forKey方法<br>2.<br>setObject:forKey:方法NSMutabledictionary特有的,而<br>setValue:forKey:方法是KVC（键-值编码）的主要方法。<br>3.</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="29-理解引用计数"><a href="#29-理解引用计数" class="headerlink" title="29.理解引用计数"></a>29.理解引用计数</h3><p>引用计数机制通过可以递增递减的计数器来管理内存。对象创建好后，其保留计数至少为1.若保留计数为正，则对象继续存活。当保留计数降为0时，对象就被销毁了。<br>在对象生命期中，其余对象通过引用来保留或释放此对象。保留与释放操作分别会递增及递减保留计数。</p><h3 id="30-以ARC简化引用计数"><a href="#30-以ARC简化引用计数" class="headerlink" title="30.以ARC简化引用计数"></a>30.以ARC简化引用计数</h3><p>在ARC之后，程序员就无须担心内存管理问题了。使用ARC来编程，可省去类中的许多样板代码。<br>ARC管理对象生命期的办法基本上就是：在合适的地方插入保留及释放操作。在ARC环境下，变量的内存管理语义总是通过方法名来体现。ARC将此确定为开发者必须遵守的规则。<br>ARC只负责管理Objective-C对象的内存。尤其要注意：CoreFoundation对象不归ARC管理，开发者必须适时调用CFRetain/CFRelease。</p><h3 id="31-在dealloc方法中只释放引用并解除监听"><a href="#31-在dealloc方法中只释放引用并解除监听" class="headerlink" title="31.在dealloc方法中只释放引用并解除监听"></a>31.在dealloc方法中只释放引用并解除监听</h3><p>在dealloc方法里，应该做的事情就是释放指向其它对象的引用，并取消原来订阅的键值观测或NSNotificationCenter等通知，不要做其他事情。<br>如果对象持有文件描述符等系统资源，那么应该专门编写一个方法来释放此种资源。这样的类要和其使用者约定“用完资源后必须调用close方法。<br>执行异步任务的方法不应在dealloc里调用；只能在正常状态下执行的那些方法也不应在dealloc里调用，因为此时对象已处于正在回收的状态了。</p><h3 id="32-编写异常安全代码时留意内存管理问题"><a href="#32-编写异常安全代码时留意内存管理问题" class="headerlink" title="32.编写异常安全代码时留意内存管理问题"></a>32.编写异常安全代码时留意内存管理问题</h3><p>捕获异常时，一定要注意将try块内所创立的对象清理干净。<br>在默认情况下，ARC不生成安全处理异常所需的清理代码。开启编译器标志后，可生成这种代码，不过会导致应用程序变大，而且会降低运行效率。</p><h3 id="33-以弱引用避免重复引用"><a href="#33-以弱引用避免重复引用" class="headerlink" title="33.以弱引用避免重复引用"></a>33.以弱引用避免重复引用</h3><p>将某些引用设为weak，可避免出现重复引用。<br>weak引用可以自动清空，也可以不自动清空。自动清空是随着ARC而引入的新特性，由runtime来实现，在具备自动清空功能的弱引用上，可以随意读取其数据，因为这种引用不会指向已经回收过的对象。</p><h3 id="34-以自动释放池块降低内存峰值"><a href="#34-以自动释放池块降低内存峰值" class="headerlink" title="34.以自动释放池块降低内存峰值"></a>34.以自动释放池块降低内存峰值</h3><p>自动释放池排布在栈中，对象收到autorelease消息后，系统将其放入最顶端的池里。<br>合理运用自动释放池，可降低应用程序的内存峰值。<br>@autoreleasepool这种新式写法能创建出更为轻便的自动释放池。</p><h3 id="35-用“僵尸对象”调试内存管理问题"><a href="#35-用“僵尸对象”调试内存管理问题" class="headerlink" title="35.用“僵尸对象”调试内存管理问题"></a>35.用“僵尸对象”调试内存管理问题</h3><p>系统在回收对象时，可以不将其真的回收，而是把它转化为僵尸对象。通过环境变量NSZombieEnabled可开启此功能。<br>系统会修改对象的isa指针，令其指向特殊的僵尸类，从而使该对象变为僵尸对象。僵尸类能够响应所有的selector响应方式为：打印一条包含消息内容及其接受者的消息，然后终止应用程序。</p><h3 id="36-不要使用retainCount"><a href="#36-不要使用retainCount" class="headerlink" title="36.不要使用retainCount"></a>36.不要使用retainCount</h3><p>对象的保留计数看似有用，实则不然，因为任何给定时间点上的绝对保留计数都无法反映对象生命期的全貌。<br>引入ARC后，retainCount方法就正式废止了，在ARC下调用该方法会导致编译器报错。</p><h2 id="block与GCD"><a href="#block与GCD" class="headerlink" title="block与GCD"></a>block与GCD</h2><h3 id="37-理解block的概念"><a href="#37-理解block的概念" class="headerlink" title="37.理解block的概念"></a>37.理解block的概念</h3><p>block是C、C++、Objective-C中的词法闭包。<br>block可接收参数，也可返回值。<br>block可以分配在栈或堆上，也可以是全局的。分配在栈上的block可拷贝到堆里，这样的话，就和标准的Objective-C对象一样，具备引用计数了。</p><h3 id="38-为常用的block类型创建typedef"><a href="#38-为常用的block类型创建typedef" class="headerlink" title="38.为常用的block类型创建typedef"></a>38.为常用的block类型创建typedef</h3><p>以typedef重新定义block类型，可以令block变量用起来更加简单。<br>定义新类型时应遵循现有的命名习惯，勿使其名称与别的的类型相冲突。<br>不妨为同一个block签名定义多个类型别名。如果要重构的代码使用了block类型的某个别名，那么只需修改相应的typedef中的block签名即可，无需改动其他typedef。</p><h3 id="39-用handler块降低代码分散程度"><a href="#39-用handler块降低代码分散程度" class="headerlink" title="39.用handler块降低代码分散程度"></a>39.用handler块降低代码分散程度</h3><p>在创建对象时，使用内联的handler块将相关业务逻辑一并声明。<br>在有多个实例需要监控时，如果采用委托模式，那么经常需要根据传入的对象来切换，而若改用handler块来实现，则可直接将block与相关对象放在一起。<br>设计API时如果用到了handler块，那么可以增加一个参数，使调用者可通过此参数来决定应该把block安排在哪个队列上执行。</p><h3 id="40-用block引用其所属对象时不要出现循环引用"><a href="#40-用block引用其所属对象时不要出现循环引用" class="headerlink" title="40.用block引用其所属对象时不要出现循环引用"></a>40.用block引用其所属对象时不要出现循环引用</h3><p>如果block所捕获的对象直接或间接的保留了block本身，那么就得当心循环引用的问题。<br>一定要找个适当的时机解除循环引用，而不能把责任推给API的调用者。</p><h3 id="41-多用派发队列，少用同步锁"><a href="#41-多用派发队列，少用同步锁" class="headerlink" title="41.多用派发队列，少用同步锁"></a>41.多用派发队列，少用同步锁</h3><p>派发队列可用来表述同步语义，这种做法要比使用@synchronized块或NSLock对象更简单。<br>将同步与异步派发结合起来，可以实现与普通加锁机制一样的同步行为，而这么做却不会阻塞执行异步派发的线程。<br>使用同步队列及栅栏块，可以领同步行为更加高效。</p><h3 id="42-多用GCD，少用performSelector系列方法"><a href="#42-多用GCD，少用performSelector系列方法" class="headerlink" title="42.多用GCD，少用performSelector系列方法"></a>42.多用GCD，少用performSelector系列方法</h3><p>performSelector系列方法在内存管理方面容易有疏失。它无法确定将要执行的selector具体是什么，因而ARC编译器就无法插入适当的内存管理方法。<br>performSelector系列方法所能处理的selector太过局限了，selector的返回值类型及发送给方法的参数个数都受到限制。<br>如果想把人物放在另一个线程上执行，那么最好不要用performSelector系列方法而是应该把任务封装到block里然后调用GCD机制的相关方法来实现。</p><h3 id="43-掌握GCD及操作队列的使用时机"><a href="#43-掌握GCD及操作队列的使用时机" class="headerlink" title="43.掌握GCD及操作队列的使用时机"></a>43.掌握GCD及操作队列的使用时机</h3><p>在解决多线程与任务管理问题时，派发队列并非唯一方案。<br>操作队列提供了一套高层的Objective-C API，能实现纯GCD所具备的绝大部分功能，而且还能完成一些更为复杂的操作，那些操作若改用GCD来实现，则需另外编写代码。</p><h3 id="44-通过Dispatch-Group机制根据系统资源状况来执行任务"><a href="#44-通过Dispatch-Group机制根据系统资源状况来执行任务" class="headerlink" title="44.通过Dispatch Group机制根据系统资源状况来执行任务"></a>44.通过Dispatch Group机制根据系统资源状况来执行任务</h3><p>一系列任务可贵如一个dispatch group之中。开发者可以在这组任务执行完毕时获得通知。<br>通过dispatch group，可以在并发式派发队列里同时执行多项任务。此时GCD会根据系统资源状况来调度这些并发执行的任务。开发者若自己来实现此功能，则需编写大量代码。</p><h3 id="45-使用dispatch-once来执行只需运行一次的线程安全代码"><a href="#45-使用dispatch-once来执行只需运行一次的线程安全代码" class="headerlink" title="45.使用dispatch_once来执行只需运行一次的线程安全代码"></a>45.使用dispatch_once来执行只需运行一次的线程安全代码</h3><p>经常需要编写只需执行一次的线程安全代码。通过GCD所提供的dispatch_once函数，很容易就能实现此功能。<br>标记应该声明在static或global作用域中，这样的话，在把只需执行一次的block传给dispatch_once函数时，传进去的标记也是相同的。</p><h3 id="46-不要使用dispatch-get-current-queue"><a href="#46-不要使用dispatch-get-current-queue" class="headerlink" title="46.不要使用dispatch_get_current_queue"></a>46.不要使用dispatch_get_current_queue</h3><p>dispatch_get_current_queue函数的行为常常与开发者所预期的不同。此函数已废弃，只应做调试之用。<br>由于派发队列是按层级来组织的，所以无法单用某个队列对象来描述当前队列这一概念。<br>dispatch_get_current_queue函数用于解决由不可重入的代码所引发的死锁，然而能用此函数解决的问题，通常也能改用“队列特定数据”来解决。</p><h2 id="系统框架"><a href="#系统框架" class="headerlink" title="系统框架"></a>系统框架</h2><h3 id="47-熟悉系统框架"><a href="#47-熟悉系统框架" class="headerlink" title="47.熟悉系统框架"></a>47.熟悉系统框架</h3><p>许多系统框架都可以直接使用。其中最重要的是Foundation与CoreFoundation，这两个框架提供了构建应用程序所需的许多核心功能。<br>很多常见任务都能用框架来做，例如音频与视频处理、网络通信<br>数据管理等。<br>请记住，用纯C写成的框架与用Objective-C写成的一样重要，若想成为优秀的Objective-C开发者，应该掌握C语言的核心概念。</p><h3 id="48-多用块枚举，少用for循环"><a href="#48-多用块枚举，少用for循环" class="headerlink" title="48.多用块枚举，少用for循环"></a>48.多用块枚举，少用for循环</h3><p>遍历collection有4种方式。最基本的办法是for循环，其次是NSEnumerator遍历方法及快速遍历方法，最新、最先进的方式则是块枚举法。<br>块枚举法本身就能通过GCD来并发执行遍历操作，无需另行编写代码。而采用其他遍历方式则无法轻易实现这一点。<br>若提前知道待遍历的collection含有何种对象，则应修改块签名，指出对象的具体类型。</p><h3 id="49-队自定义其内存管理语义的collection使用无缝桥接"><a href="#49-队自定义其内存管理语义的collection使用无缝桥接" class="headerlink" title="49.队自定义其内存管理语义的collection使用无缝桥接"></a>49.队自定义其内存管理语义的collection使用无缝桥接</h3><p>通过无缝桥接技术，可以在Foundation框架中的Objective-C对象与CoreFoundation框架中的C语言数据结构之前来回转换。<br>在CoreFoundation层面创建collection时，可以指定许多回调函数，这些函数表示此collection应如何处理其元素。然后，可运用无缝桥接技术，将其转换成具备特殊内存管理语义的Objective-C collection。</p><h3 id="50-构建缓存是选用NSCachae而非NSDictionary"><a href="#50-构建缓存是选用NSCachae而非NSDictionary" class="headerlink" title="50.构建缓存是选用NSCachae而非NSDictionary"></a>50.构建缓存是选用NSCachae而非NSDictionary</h3><p>实现缓存时应选用NSCache而非NSDictionary对象。因为NSCache可以提供优雅的自动删减功能，而且是线程安全的，此外，它与字典不同，并不会拷贝键。<br>可以给NSCache对象设置上限，用以限制缓存中的对象总个数及总成本，而这些尺度则定义了缓存删减其中对象的时机。但是绝对不要把这些尺度当成可靠的硬限制，他们仅对NSCache起指导作用。<br>将NSPurgeableData与NSCache搭配使用，可实现自动清除数据的功能，也就是说，当NSPurgeableData对象所占内存为系统丢弃时，该对象自身也会从缓存中移除4.<br>如果缓存使用得当。那么应用程序的响应速度就能提高。只有那种重新计算起来很费事的数据，才值得放入缓存，比如那些需要从网络获取或从磁盘读取的数据。</p><h3 id="51-精简initialize与load的实现代码"><a href="#51-精简initialize与load的实现代码" class="headerlink" title="51.精简initialize与load的实现代码"></a>51.精简initialize与load的实现代码</h3><p>在加载阶段，如果实现了load方法，那么系统就会调用它。分类里也可以定义此方法，类load方法要比分类中的先调用。与其他方法不同，load方法不参与覆写机制。<br>首次使用某个类之前，系统会向其发送initialize消息。由于此方法遵从普通的复写规则，所以通常应该在里面判断当前要初始化的是哪个类。<br>load与initialize方法都应该实现的精简一些，这有助于保持应用程序的响应能力，也能减少引入依赖环的几率。<br>无法在编译期设定的全局常量，可以放在initialize方法里初始化。</p><h3 id="52-别忘了NSTimer会保留其目标对象"><a href="#52-别忘了NSTimer会保留其目标对象" class="headerlink" title="52.别忘了NSTimer会保留其目标对象"></a>52.别忘了NSTimer会保留其目标对象</h3><p>NSTimer对象会保留其目标，直到计时器本身失效为止，调用invalidate方法可令计时器失效，另外，一次性的计时器在触发完任务之后也会失效。<br>反复执行任务的计时器，很容易引入循环引用，进入过这种计时器的目标对象又保留了计时器本身，那肯定会导致循环引用。这种循环引用，可能是直接发生的，也可能是通过对象图里的其他对象间接发生的。<br>可以扩充NSTimer的功能，用块来打破循环引用。不过，除非NSTimer将来在公共接口里提供此功能，否则必须创建分类，将相关实现代码加入其中。</p><h1 id="《Objective-C高级编程：iOS与OS-X多线程和内存管理》"><a href="#《Objective-C高级编程：iOS与OS-X多线程和内存管理》" class="headerlink" title="《Objective-C高级编程：iOS与OS X多线程和内存管理》"></a>《Objective-C高级编程：iOS与OS X多线程和内存管理》</h1>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> OC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>OC中属性关键字相关</title>
      <link href="/2018/12/14/OC%E4%B8%AD%E5%B1%9E%E6%80%A7%E5%85%B3%E9%94%AE%E5%AD%97%E7%9B%B8%E5%85%B3/"/>
      <url>/2018/12/14/OC%E4%B8%AD%E5%B1%9E%E6%80%A7%E5%85%B3%E9%94%AE%E5%AD%97%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="property"><a href="#property" class="headerlink" title="@property"></a>@property</h2><p>1.本质：@property 其实就是在编译阶段由编译器自动帮我们生成ivar成员变量，getter方法，setter方法。</p><p>3.NSString *name，非ARC下重写setter,getter方法<br><code>一旦重写了getter,setter方法,必须使用@synthesize variable = _variable来区分属性名与方法名.</code><br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-(void)setName:(NSString *)name&#123;</span><br><span class="line">    if (_name != name) &#123;    //首先判断要赋值的变量和当前成员变量是不是同一个变量</span><br><span class="line">        [_name release];        //释放之前的对象(换房间操作，释放之前的房间)</span><br><span class="line">        _name = [name copy];    //赋值时重新retain（对房间进行持有）</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (NSString *)name&#123;</span><br><span class="line">return [[_name retain]autorelease];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="4"><li>写一个setter方法用于完成@property(nonatomic,retain)NSString <em>name;写一个setter方法用于完成@property(nonatomic, copy)NSString </em>name;<br>答:<br>retain表示持有特性，setter方法将传入参数先保留，再赋值，传入参数的retaincount会+1;<br>copy表示拷贝特性，setter方法将传入对象复制一份；需要完全一份新的变量时。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-(void)setName:(NSString *)str&#123;</span><br><span class="line">[str retain];</span><br><span class="line">[name release];</span><br><span class="line">name = str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setName:(NSString *)str&#123;</span><br><span class="line">id t = [str copy];</span><br><span class="line">[name release];</span><br><span class="line">name = t;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>5.为什么不能同时重写getter,setter？<br>用@property声明的成员属性,相当于自动生成了setter getter方法,如果重写了set和get方法,与@property声明的成员属性就不是一个成员属性了，是另外一个实例变量，而这个实例变量需要手动声明。所以会报错误。</p><h2 id="属性关键字"><a href="#属性关键字" class="headerlink" title="属性关键字"></a>属性关键字</h2><ul><li>默认值：atomic，readwrite，assign/strong(基本数据类型／对象)<h3 id="atomic-nonatomic"><a href="#atomic-nonatomic" class="headerlink" title="atomic/nonatomic"></a>atomic/nonatomic</h3></li><li>atomic和nonatomic用来决定编译器生成的getter和setter是否为原子操作。</li></ul><ol><li>atomic：系统生成的 getter/setter 会保证 get、set 操作的完整性，不受其他线程影响。getter 还是能得到一个完好无损的对象（可以保证数据的完整性），但这个对象在多线程的情况下是不能确定的。<br>也就是说：如果有多个线程同时调用setter的话，不会出现某一个线程执行完setter全部语句之前，另一个线程开始执行setter情况，相当于函数头尾加了锁一样，每次只能有一个线程调用对象的setter方法，所以可以保证数据的完整性。<br>总结：atomic所说的线程安全只是保证了getter和setter存取方法的线程安全，并不能保证整个对象是线程安全的。</li><li>nonatomic：就没有这个保证了，nonatomic返回你的对象可能就不是完整的value。因此，在多线程的环境下原子操作是非常必要的，否则有可能会引起错误的结果。但仅仅使用atomic并不会使得对象线程安全，我们还要为对象线程添加lock来确保线程的安全。</li></ol><ul><li>nonatomic的速度要比atomic的快</li><li>atomic与nonatomic的本质区别其实也就是在setter方法上的操作不同。<br>nonatomic对象setter和getter方法的实现:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)setCurrentImage:(UIImage *)currentImage</span><br><span class="line">&#123;</span><br><span class="line">    if (_currentImage != currentImage) &#123;</span><br><span class="line">        [_currentImage release];</span><br><span class="line">        _currentImage = [currentImage retain];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (UIImage *)currentImage&#123;</span><br><span class="line">    return _currentImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>atomic对象setter和getter方法的实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)setCurrentImage:(UIImage *)currentImage</span><br><span class="line">&#123;</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">        if (_currentImage != currentImage) &#123;</span><br><span class="line">            [_currentImage release];</span><br><span class="line">            _currentImage = [currentImage retain];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIImage *)currentImage&#123;</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">        return _currentImage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="内存管理语义"><a href="#内存管理语义" class="headerlink" title="内存管理语义"></a>内存管理语义</h3><p>assign：不更改引用计数，一般用于CCRect之类的结构体以及基本数据类型，代码实现是直接赋值<br>retain：一般用于OC对象类型用于MRC模式，代码实现是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(_temp != temp) &#123; </span><br><span class="line">    [_temp release]; </span><br><span class="line">    _temp = [temp retain]</span><br><span class="line">&#125;;  </span><br><span class="line">return _temp;</span><br></pre></td></tr></table></figure></p><p>copy：建立一个引用计数为1的对象，与 strong 类似，然而在设置新属性值时并不保留新值，而是拷贝一份，一般用于NSString类型以及Block，代码实现是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(_temp != temp) &#123; </span><br><span class="line">    [_temp release]; </span><br><span class="line">    _temp = [temp copy]</span><br><span class="line">&#125;;  </span><br><span class="line">return _temp;</span><br></pre></td></tr></table></figure></p><p>strong：一般用于OC对象用于ARC模式，代表用强指针指向对象<br>weak：一般用于OC对象用于ARC模式，代表用弱指针指向对象，对象消失后，指针自动置nil<br>unsafe_unretained：与weak类似，引用计数为0时，不会置nil，<strong>unsafe_unretained 比 </strong>weak 快。当明确知道对象的生命期时，选择 __unsafe_unretained 会有一些性能提升</p><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p>copy/mutableCopy:用copy从一个可变对象拷贝出一个不可变对象时, 这种情况就属于深拷贝而不是浅拷贝.<br>浅拷贝/深拷贝:默认状态下深拷贝指的是不完全深拷贝, 如要实现完全深拷贝, 则要重写copyWithZone: 方法<br>block:copy.block在创建的时候它的内存是默认是分配在栈(stack)上, 而不是堆(heap)上的. 所以它的作用域仅限创建时候的当前上下文(函数, 方法…), 当你在该作用域外调用该block时, 程序就会崩溃.一般情况下你不需要自行调用copy或者retain一个block. 只有当你需要在block定义域以外的地方使用时才需要copy. Copy将block从内存栈区移到堆区.<br>其实block使用copy是MRC留下来的也算是一个传统吧, 在MRC下, 如上述, 在方法中的block创建在栈区, 使用copy就能把他放到堆区, 这样在作用域外调用该block程序就不会崩溃. 但在ARC下, 使用copy与strong其实都一样, 因为block的retain就是用copy来实现的<br>NSArray:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray* dataSour = [NSMutableArray arrayWithObjects:@&quot;90&quot;,@&quot;80&quot;,@&quot;100&quot;,nil];</span><br><span class="line">// 获取数据，进行展示。</span><br><span class="line">self.rankArray = dataSour;</span><br><span class="line">// 正常显示排行。</span><br><span class="line">NSLog(@&quot;%@&quot;,self.rankArray);</span><br><span class="line">[dataSour addObject:@&quot;25&quot;];</span><br><span class="line">//  说好的不可变数组呢？ 为什么？突然冒出来了个 25？</span><br><span class="line">NSLog(@&quot;%@&quot;,self.rankArray); // 90,80,100,25</span><br></pre></td></tr></table></figure></p><p>1.使用场景</p><ul><li>NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本.</li><li><p>用于block：编译器会自动对 block 进行了 copy 操作。使用 copy 是从 MRC 遗留下来的“传统”，在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区.在 ARC 中写不写都行:对于 block 使用 copy 还是 strong 效果是一样的,但是建议写上 copy,因为这样显示告知调用者“编译器会自动对 block 进行了 copy 操作。<br>因为block默认申请的是栈内存，当block所在的方法执行完之后内存空间就被释放。为了可以在外部使用block，需要把block放入堆内存中。MRC中只有copy做到这一点，ARC中copy可以。</p></li><li><p>为什么NSString要用copy，而不用用strong？  (block  字典   数组同理)<br>一个场景：如果用NSString指向一个NSMutableString的内存空间的话，用strong修饰。当NSMutableString中内容改变时，NSString指针指向的也会改变，而用copy不会<br>必须使用copy的场景：A对象持有string记做A.string，然后赋值给B对象，记做B.string，若希望B.string的内容改变时A.string不改变就必须用copy<br>必须用strong的场景：若希望B.string的内容改变时同时A.string也改变则必须用strong</p></li></ul><p>2.浅拷贝/深拷贝<br>区别：浅拷贝就是只拷贝对象，但是属性不拷贝，拷贝出来的对象和原来的对象共用属性，即指向同一个属性地址。<br>浅拷贝：指只是将对象内存地址多了一个引用，也就是说，拷贝结束之后，两个对象的值不仅相同，而且对象所指的内存地址都是一样的。<br>深拷贝：指拷贝一个对象的具体内容，拷贝结束之后，两个对象的值虽然是相同的，但是指向的内存地址是不同的。两个对象之间也互不影响，互不干扰。<br>深拷贝 : 拷贝出来的对象与源对象地址不一致! 这意味着我修改拷贝对象的值对源对象的值没有任何影响.<br>浅拷贝 : 拷贝出来的对象与源对象地址一致! 这意味着我修改拷贝对象的值会直接影响到源对象.<br>非集合类对象的copy和mutableCopy：</p><ul><li>对不可变对象进行copy操作，只仅仅是指针复制（浅拷贝），进行mutableCopy操作，是内容复制（深拷贝）。</li><li>对可变对象进行copy和mutableCopy操作，都是内容复制（深拷贝）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">NSString *string = @&quot;abc&quot;;</span><br><span class="line">NSString *stringCopy = [string copy];</span><br><span class="line">NSMutableString *stringMCopy = [string mutableCopy];</span><br><span class="line">NSLog(@&quot;string: %p, %p&quot;, string, &amp;string);</span><br><span class="line">//浅拷贝：新对象的内存地址并没有发生变化，改变的仅仅是指针的地址</span><br><span class="line">NSLog(@&quot;stringCopy: %p, %p&quot;, stringCopy, &amp;stringCopy);</span><br><span class="line">//深拷贝：内存地址已经发生了变化，并且指针地址发生变化</span><br><span class="line">NSLog(@&quot;stringMCopy: %p, %p&quot;, stringMCopy, &amp;stringMCopy);</span><br><span class="line"></span><br><span class="line">NSMutableString *string = [NSMutableString stringWithFormat:@&quot;abc&quot;];</span><br><span class="line">NSString *stringCopy = [string copy];</span><br><span class="line">NSMutableString *stringMCopy = [string mutableCopy];</span><br><span class="line">NSLog(@&quot;string: %p, %p&quot;, string, &amp;string);</span><br><span class="line">//深拷贝：内存地址和指针地址都发生了变化</span><br><span class="line">NSLog(@&quot;stringCopy: %p, %p&quot;, stringCopy, &amp;stringCopy);</span><br><span class="line">//深拷贝：内存地址和指针地址都发生了变化</span><br><span class="line">NSLog(@&quot;stringMCopy: %p, %p&quot;, stringMCopy, &amp;stringMCopy);</span><br></pre></td></tr></table></figure></li></ul><p>集合类对象的copy和mutableCopy：</p><ul><li>对于不可变的集合类对象进行copy操作，只是改变了指针，其内存地址并没有发生变化；进行mutableCopy操作，内存地址发生了变化，但是其中的元素内存地址并没有发生变化。</li><li>对于可变集合类对象，不管是进行copy操作还是mutableCopy操作，其内存地址都发生了变化，但是其中的元素内存地址都没有发生变化，属于单层深拷贝。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">NSString *element_01 = @&quot;abc&quot;;</span><br><span class="line">NSString *element_02 = @&quot;def&quot;;</span><br><span class="line">NSString *element_03 = @&quot;ghi&quot;;</span><br><span class="line">NSArray *array = @[element_01, element_02, element_03];</span><br><span class="line">NSArray *arrayCopy = [array copy];</span><br><span class="line">NSMutableArray *arrayMCopy = [array mutableCopy];</span><br><span class="line">NSLog(@&quot;array: %p, %p; array.firstObject: %p&quot;, array, &amp;array, array.firstObject);</span><br><span class="line">//浅拷贝：只是改变了指针，其内存地址并没有发生变化，但是其中的元素内存地址并没有发生变化。</span><br><span class="line">NSLog(@&quot;arrayCopy: %p, %p; arrayCopy.firstObject: %p&quot;, arrayCopy, &amp;arrayCopy, arrayCopy.firstObject);</span><br><span class="line">//单层深拷贝：内存地址和指针地址都发生了变化，但是其中的元素内存地址并没有发生变化。</span><br><span class="line">NSLog(@&quot;arrayMCopy: %p, %p; arrayMCopy.firstObject: %p&quot;, arrayMCopy, &amp;arrayMCopy, arrayMCopy.firstObject);</span><br><span class="line"></span><br><span class="line">NSString *element_01 = @&quot;abc&quot;;</span><br><span class="line">NSString *element_02 = @&quot;def&quot;;</span><br><span class="line">NSString *element_03 = @&quot;ghi&quot;;</span><br><span class="line">NSMutableArray *array = [NSMutableArray arrayWithArray:@[element_01, element_02, element_03]];</span><br><span class="line">NSArray *arrayCopy = [array copy];</span><br><span class="line">NSMutableArray *arrayMCopy = [array mutableCopy];</span><br><span class="line">NSLog(@&quot;array: %p, %p; array.firstObject: %p&quot;, array, &amp;array, array.firstObject);</span><br><span class="line">//单层深拷贝：内存地址和指针地址都发生了变化，但是其中的元素内存地址并没有发生变化。</span><br><span class="line">NSLog(@&quot;arrayCopy: %p, %p; arrayCopy.firstObject: %p&quot;, arrayCopy, &amp;arrayCopy, arrayCopy.firstObject);</span><br><span class="line">//单层深拷贝：内存地址和指针地址都发生了变化，但是其中的元素内存地址并没有发生变化。</span><br><span class="line">NSLog(@&quot;arrayMCopy: %p, %p; arrayMCopy.firstObject: %p&quot;, arrayMCopy, &amp;arrayMCopy, arrayMCopy.firstObject);</span><br></pre></td></tr></table></figure></li></ul><p>如何实现完全复制?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSArray *copyArray = [[NSArray alloc] initWithArray:array copyItems:YES];  // 完全复制</span><br></pre></td></tr></table></figure></p><p>3.为什么我们声明NSString, NSArray或者NSDictionary的时候，经常使用copy关键字，使用strong有什么区别？可变对象使用copy会有什么问题？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) NSString *strStrong;</span><br><span class="line">@property (nonatomic, copy) NSString *strCopy;</span><br><span class="line"></span><br><span class="line">NSMutableString *string = [NSMutableString stringWithFormat:@&quot;abc&quot;];</span><br><span class="line">self.strStrong = string;</span><br><span class="line">self.strCopy = string;</span><br><span class="line">NSLog(@&quot;旧strStrong: %@&quot;, self.strStrong);//abc</span><br><span class="line">NSLog(@&quot;旧strCopy: %@&quot;, self.strCopy);//abc</span><br><span class="line"></span><br><span class="line">[string appendFormat:@&quot;def&quot;];</span><br><span class="line">NSLog(@&quot;新strStrong: %@&quot;, self.strStrong);//abcdef</span><br><span class="line">NSLog(@&quot;新strCopy: %@&quot;, self.strCopy);//abc</span><br></pre></td></tr></table></figure></p><p>注意： <code>@property (copy) NSMutableArray *array;</code>会有什么问题：<br>1) 因为copy是复制出一个不可变的对象，在不可变对象上运行可变对象的方法，添加,删除,修改数组内的元素的时候，程序会因为找不到对应的方法而崩溃<br>2) 使用了 atomic 属性会严重影响性能 。</p><p>4.自定义对象实现copy：<br><code>copy</code>需要实现<code>NSCopying</code>协议，然后实现<code>NSCopying</code>协议方法，否则copy会crash；<br><code>mutableCopy</code>时，需要实现<code>NSMutableCopying</code>协议，否则mutableCopy会crash。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@interface CopyModel : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *title;</span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation CopyModel</span><br><span class="line"></span><br><span class="line">- (instancetype)copyWithZone:(NSZone *)zone &#123;</span><br><span class="line">CopyModel *copyModel = [[CopyModel allocWithZone:zone] init];</span><br><span class="line">copyModel.title = self.title;</span><br><span class="line">copyModel.name = self.name;</span><br><span class="line">return copyModel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CopyModel *model = [[CopyModel alloc] init];</span><br><span class="line">model.title = @&quot;title&quot;;</span><br><span class="line">model.name = @&quot;name&quot;;</span><br><span class="line"></span><br><span class="line">CopyModel *modelStrong = model;</span><br><span class="line">CopyModel *modelCopy = [model copy];</span><br><span class="line">NSLog(@&quot;model: %p, %p&quot;, model, &amp;model);</span><br><span class="line">//其内存地址并没有发生变化，只是改变了指针</span><br><span class="line">NSLog(@&quot;modelStrong: %p, %p&quot;, modelStrong, &amp;modelStrong);</span><br><span class="line">//内存地址和指针地址都发生了变化</span><br><span class="line">NSLog(@&quot;modelCopy: %p, %p&quot;, modelCopy, &amp;modelCopy);</span><br></pre></td></tr></table></figure><h3 id="weak"><a href="#weak" class="headerlink" title="weak"></a>weak</h3><p>weak是弱引用，用weak描述修饰或者所引用对象的计数器不会加一，并且会在引用的对象被释放的时候自动被设置为nil，大大避免了野指针访问坏内存引起崩溃的情况，另外weak还可以用于解决循环引用。<br>1.为什么IBOutlet修饰的UIView也适用weak关键字<br>UIViewController-&gt;UIView-&gt;subViews-&gt;UIButton<br>一般的IBOutlet直接关联到viewcontroller。但是跟其关联的控件并不是添加在controller上，而是添加到controller的view上，比如[self.view addSubView：xxx]; 这个时候self.view已经对xxx 强引用过了，self.view才是持有xxx的对象。这样子才符合引用计数的规则。所以直接IBOutlet顶级view的时候肯定是strong的。<br>如果将weak改为strong，也是没有问题的，并不会造成强引用循环。</p><p>2.runtime 如何实现 weak 属性<br>runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。hash 表用于存储指向某个对象的所有weak指针，Key是所指对象的地址，value是weak指针的地址（这个地址的值是所指对象指针的地址）数组。为什么value是数组？因为一个对象可能被多个弱引用指针指向。假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。</p><p>3.weak，__unsafe_unretained, unowned 与 assign区别</p><ul><li>__unsafe_unretained: 不会对对象进行retain,当对象销毁时,会依然指向之前的内存空间(野指针)</li><li>weak: 不会对对象进行retain,当对象销毁时,会自动指向nil</li><li>assign: 实质与__unsafe_unretained等同</li><li>assigin 可以用非OC对象，而weak必须用于OC对象</li><li>unsafe_unretained也可以修饰代表简单数据类型的property，weak不能修饰用来代表简单数据类型的property。</li><li><strong>unsafe_unretained 与 weak 比较，使用 weak 是有代价的，因为</strong>weak需要检查对象是否已经消亡，而为了知道是否已经消亡，自然也需要一些信息去跟踪对象的使用情况。也正因此，<strong>unsafe_unretained 比 </strong>weak快,所以当明确知道对象的生命期时，选择<strong>unsafe_unretained 会有一些性能提升，这种性能提升是很微小的。但当很清楚的情况下，</strong>unsafe_unretained 也是安全的，自然能快一点是一点。而当情况不确定的时候，应该优先选用 __weak 。</li><li>unowned使用在Swift中，也会分 weak 和 unowned。unowned 的含义跟 __unsafe_unretained 差不多。假如很明确的知道对象的生命期，也可以选择 unowned。</li></ul><h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><ul><li>当A强引用B，B强引用A。这会让两个都有强指针指向结果都无法释放。解决办法把其中一个用weak申明</li><li>当block用copy属性修饰的时候，block会对其中用到的OC对象有强引用。解决办法：ARC把用到的oc对象用<strong>weak声明，MRC用</strong>block申明</li></ul><h3 id="什么情况会出现内存泄漏"><a href="#什么情况会出现内存泄漏" class="headerlink" title="什么情况会出现内存泄漏"></a>什么情况会出现内存泄漏</h3><ul><li>当调用一些C语言的API用完没有关闭（如利用UIGraphicsBeginImageContextWithOptions打开了图形上下文，没有close），导致资源没有释放</li><li>出现循环引用的情况，导致资源没有释放</li><li>MRC中将OC对象的释放权交给自动释放池，在池子被销毁前程序创建n个oc对象，将导致内存泄漏。</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>synthesize/dynamic<br>默认：@syntheszie var = _var;<br>@synthesize：编译期间，让编译器自动生成getter／setter方法，当有自定义的存或取方法时屏蔽自动生成的方法<br>@dynamic：告诉编译器:属性的 setter 与 getter 方法由用户自己实现,不自动生成。(当然对于 readonly 的属性只需提供 getter 即可)</li></ul><p>假如一个属性被声明为 @dynamic var；然后你没有提供@setter 方法和@getter 方法,编译的时候没问题,但是当程序运行到 instance.var = someVar,由于缺 setter方法会导致程序崩溃;或者当运行到 someVar = instance.var 时,由于缺 getter 方法同样会导致崩溃。编译时没问题,运行时才执行相应的方法,这就是所谓的动态绑定。</p><ul><li><p>方法名：getter=<name>、setter=<name></name></name></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//getter</span><br><span class="line">@property (nonatomic, getter=isOn) BOOL on;</span><br></pre></td></tr></table></figure></li><li><p>不常用：nonnull,null_resettable,nullable</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>OC中的设计模式</title>
      <link href="/2018/12/14/OC%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/12/14/OC%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="block"><a href="#block" class="headerlink" title="block"></a>block</h3><p><a href="https://guchunli.github.io/2017/07/01/OC中的block/">OC中的block</a><br>实质是OC对象<br><a id="more"></a></p><ul><li>为什么在默认情况下无法修改被block捕获的变量？<br>Block只捕获Block中会用到的变量。由于只捕获了自动变量(自动变量是以值传递方式传递到Block的构造函数里面)的值，并非内存地址，所以Block内部不能改变自动变量的值。Block捕获的外部变量可以改变值的是静态变量，静态全局变量，全局变量。</li></ul><h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><h3 id="为什么代理用weak，delegate和dataSource有什么区别，delegate和block的区别"><a href="#为什么代理用weak，delegate和dataSource有什么区别，delegate和block的区别" class="headerlink" title="为什么代理用weak，delegate和dataSource有什么区别，delegate和block的区别"></a>为什么代理用weak，delegate和dataSource有什么区别，delegate和block的区别</h3><p>1.weak指明该对象不会保持delegate，delegate这个对象的销毁由外部控制，strong会强引用delegate，外界不能销毁delegate，会导致循环引用。<br>2.datasource是关于数据的，都有哪些属性，值等；delegate时关于操作的，有什么方法可以调用。<br>3.delegate和block都可以回调。delegate是个对象，调用代理协议函数完成操作。block是传递一个函数指针，利用函数指针执行来进行回调。内存管理上，delegate不需要保存引用，block对数据又copy的处理。</p><h3 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h3><h3 id="delegate"><a href="#delegate" class="headerlink" title="delegate"></a>delegate</h3><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><h4 id="delegate与通知的区别"><a href="#delegate与通知的区别" class="headerlink" title="delegate与通知的区别"></a>delegate与通知的区别</h4><ul><li>协议有控制链(has-a)的关系，通知没有。</li><li>通知：一对多。代理/block：一对一。</li><li>OC中的多继承用委托代理实现</li></ul><h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><h3 id="MVC-MVP-MVVM"><a href="#MVC-MVP-MVVM" class="headerlink" title="MVC/MVP/MVVM"></a>MVC/MVP/MVVM</h3><p>1.MVC<br>视图（view）：用户界面<br>模型（model）：数据保存<br>控制器（controller）：业务逻辑</p><p>通信方式：view-&gt;controller-&gt;model-&gt;view</p><p>2.MVP<br>将controller改名为presenter<br>各部分之间的通信都是双向的，view与model不发生联系，都通过presenter传递，view薄，controller厚。</p><p>通信方式：view<- &-="">presenter<- &-="">model</-></-></p><p>3.MVVM<br>将presenter改名为viewmodel<br>双向绑定，view的变动自动反应在viewmodel，反之亦然。</p><p>通信方式：view<->viewmodel<- &-="">model</-></-></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS中操作PDF文件</title>
      <link href="/2018/12/10/iOS%E4%B8%AD%E6%93%8D%E4%BD%9CPDF%E6%96%87%E4%BB%B6/"/>
      <url>/2018/12/10/iOS%E4%B8%AD%E6%93%8D%E4%BD%9CPDF%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="加载PDF文件"><a href="#加载PDF文件" class="headerlink" title="加载PDF文件"></a>加载PDF文件</h2><h3 id="UIWebView-加载本地或网络文件"><a href="#UIWebView-加载本地或网络文件" class="headerlink" title="UIWebView 加载本地或网络文件"></a>UIWebView 加载本地或网络文件</h3><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;WebKit/WebKit.h&gt;</span><br><span class="line">- (void)loadPDFFile&#123;</span><br><span class="line"></span><br><span class="line">    //初始化myWebView</span><br><span class="line">    WKWebView *myWebView = [[WKWebView alloc] initWithFrame:self.view.bounds];</span><br><span class="line">    myWebView.backgroundColor = [UIColor whiteColor];</span><br><span class="line">    //本地文件</span><br><span class="line">    //NSURL *filePath = [NSURL fileURLWithPath:[[NSBundle mainBundle] pathForResource:@&quot;photos&quot; ofType:@&quot;pdf&quot;]];</span><br><span class="line">    //网络文件</span><br><span class="line">    NSURL *filePath = [NSURL URLWithString:@&quot;https://xxx.pdf&quot;];</span><br><span class="line">    NSURLRequest *request = [NSURLRequest requestWithURL: filePath];</span><br><span class="line">    [myWebView loadRequest:request];</span><br><span class="line">    [self.view addSubview:myWebView];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="QLPreviewController"><a href="#QLPreviewController" class="headerlink" title="QLPreviewController"></a>QLPreviewController</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;QuickLook/QuickLook.h&gt;</span><br><span class="line">&lt;QLPreviewControllerDataSource,QLPreviewControllerDelegate&gt;</span><br><span class="line"></span><br><span class="line">- (void)loadPDFFile&#123;</span><br><span class="line">    QLPreviewController *QLPVC = [[QLPreviewController alloc] init];</span><br><span class="line">    QLPVC.dataSource = self;</span><br><span class="line">    QLPVC.delegate = self;</span><br><span class="line">    [self presentViewController:QLPVC animated:YES completion:nil];</span><br><span class="line">&#125;</span><br><span class="line">#pragma mark QLPreviewControllerDataSource</span><br><span class="line">/*</span><br><span class="line">*所要加载pdf文档的个数</span><br><span class="line">*/</span><br><span class="line">- (NSInteger)numberOfPreviewItemsInPreviewController:(QLPreviewController *)controller&#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">* 返回每个index pdf文档所对应的文档路径</span><br><span class="line">*/</span><br><span class="line">- (id&lt;QLPreviewItem&gt;)previewController:(QLPreviewController *)controller previewItemAtIndex:(NSInteger)index&#123;</span><br><span class="line">//    NSArray *arr = @[FILE_PATH1,FILE_PATH2];</span><br><span class="line">//    return [NSURL fileURLWithPath:arr[index]];</span><br><span class="line">    NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;photos&quot; ofType:@&quot;pdf&quot;];</span><br><span class="line">    return [NSURL fileURLWithPath:path];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第三方框架vfr-Reader加载pdf文档"><a href="#第三方框架vfr-Reader加载pdf文档" class="headerlink" title="第三方框架vfr/Reader加载pdf文档"></a>第三方框架vfr/Reader加载pdf文档</h3><p>github地址：<a href="https://github.com/vfr/Reader.git" target="_blank" rel="noopener">vfr/Reader</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ReaderViewController.h&quot;</span><br><span class="line">&lt;ReaderViewControllerDelegate&gt;</span><br><span class="line"></span><br><span class="line">- (void)loadPDFFile&#123;</span><br><span class="line"></span><br><span class="line">    NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;photos&quot; ofType:@&quot;pdf&quot;];</span><br><span class="line">    ReaderDocument *doc = [[ReaderDocument alloc] initWithFilePath:path password:nil];</span><br><span class="line">    ReaderViewController *rvc = [[ReaderViewController alloc] initWithReaderDocument:doc];</span><br><span class="line">    rvc.delegate = self;</span><br><span class="line">    [self presentViewController:rvc animated:YES completion:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - ReaderViewControllerDelegate</span><br><span class="line">- (void)dismissReaderViewController:(ReaderViewController *)viewController &#123;</span><br><span class="line">[self dismissViewControllerAnimated:YES completion:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="下载PDF文件"><a href="#下载PDF文件" class="headerlink" title="下载PDF文件"></a>下载PDF文件</h2><h3 id="data-writeToFile"><a href="#data-writeToFile" class="headerlink" title="data writeToFile"></a>data writeToFile</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)downloadPDFFile&#123;</span><br><span class="line"></span><br><span class="line">    NSString *filePath = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]stringByAppendingPathComponent:@&quot;test.pdf&quot;];</span><br><span class="line">    NSLog(@&quot;下载到：%@&quot;,filePath);</span><br><span class="line"></span><br><span class="line">    NSString *pdfPath = @&quot;https://xxx.pdf&quot;;</span><br><span class="line">    NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:pdfPath]];</span><br><span class="line"></span><br><span class="line">    BOOL isWrite = [data writeToFile:filePath atomically:YES];</span><br><span class="line">    if (isWrite) &#123;</span><br><span class="line">    NSLog(@&quot;保存成功&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    NSLog(@&quot;写入失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AFNetworking"><a href="#AFNetworking" class="headerlink" title="AFNetworking"></a>AFNetworking</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (void)downloadPDFFile&#123;</span><br><span class="line"></span><br><span class="line">    NSString *filePath = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]stringByAppendingPathComponent:@&quot;test.pdf&quot;];</span><br><span class="line">    NSLog(@&quot;下载到：%@&quot;,filePath);</span><br><span class="line"></span><br><span class="line">    NSString *pdfPath = @&quot;https://xxx.pdf&quot;;</span><br><span class="line">    //创建 Request</span><br><span class="line">    NSURLRequest* request = [NSURLRequest requestWithURL:[NSURL URLWithString:pdfPath]];</span><br><span class="line"></span><br><span class="line">    //下载进行中的事件</span><br><span class="line">    [SVProgressHUD show];</span><br><span class="line">    /* 开始请求下载 */</span><br><span class="line">    AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];</span><br><span class="line">    NSURLSessionDownloadTask *downloadTask = [manager downloadTaskWithRequest:request progress:^(NSProgress * _Nonnull downloadProgress) &#123;</span><br><span class="line">    NSLog(@&quot;下载进度：%.0f％&quot;, downloadProgress.fractionCompleted * 100);</span><br><span class="line">    &#125; destination:^NSURL * _Nonnull(NSURL * _Nonnull targetPath, NSURLResponse * _Nonnull response) &#123;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        //如果需要进行UI操作，需要获取主线程进行操作</span><br><span class="line">        &#125;);</span><br><span class="line">        /* 设定下载到的位置 */</span><br><span class="line">        return [NSURL fileURLWithPath:filePath];</span><br><span class="line"></span><br><span class="line">    &#125; completionHandler:^(NSURLResponse * _Nonnull response, NSURL * _Nullable filePath, NSError * _Nullable error) &#123;</span><br><span class="line">        NSLog(@&quot;下载完成&quot;);</span><br><span class="line">        [SVProgressHUD dismiss];</span><br><span class="line">    &#125;];</span><br><span class="line">    [downloadTask resume];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="生成PDF文件"><a href="#生成PDF文件" class="headerlink" title="生成PDF文件"></a>生成PDF文件</h2><h3 id="各种格式文件生成PDF文件或生成图片文件"><a href="#各种格式文件生成PDF文件或生成图片文件" class="headerlink" title="各种格式文件生成PDF文件或生成图片文件"></a>各种格式文件生成PDF文件或生成图片文件</h3><p>通过WebView可以加载各种格式文件，然后可以生成PDF文件或生成图片文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (void)convertToPDF&#123;</span><br><span class="line"></span><br><span class="line">    NSData *pdfData = [self.webView convert2PDFData];</span><br><span class="line">    NSString *fileName = [NSString stringWithFormat:@&quot;PDF_%.0f.pdf&quot;,[[NSDate date] timeIntervalSince1970]];</span><br><span class="line">    NSString *pdfPath = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]stringByAppendingPathComponent:fileName];</span><br><span class="line">    BOOL result = [pdfData writeToFile:pdfPath atomically:YES];</span><br><span class="line">    if (result) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,pdfPath);</span><br><span class="line">        NSLog(@&quot;转换PDF成功&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        NSLog(@&quot;转换PDF失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)convertToImage&#123;</span><br><span class="line"></span><br><span class="line">    UIImage *image = [self.webView convert2Image];</span><br><span class="line">    NSData *imageData = UIImagePNGRepresentation(image);</span><br><span class="line">    //    NSString *imagePath = [WYPDFConverter saveDirectory:[NSString stringWithFormat:@&quot;%@_IMG.png&quot;,self.fileName]];</span><br><span class="line">    NSString *fileName = [NSString stringWithFormat:@&quot;IMG_%.0f.jpg&quot;,[[NSDate date] timeIntervalSince1970]];</span><br><span class="line">    NSString *imagePath = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]stringByAppendingPathComponent:fileName];</span><br><span class="line">    BOOL result = [imageData writeToFile:imagePath atomically:YES];</span><br><span class="line"></span><br><span class="line">    if (result) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,imagePath);</span><br><span class="line">        NSLog(@&quot;转换Image成功&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        NSLog(@&quot;转换Image失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>UIWebView+PDFFile.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface UIWebView (PDFFile)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">webView转换为PDF数据</span><br><span class="line">*/</span><br><span class="line">- (NSData *)convert2PDFData;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">转换成image图片</span><br><span class="line">*/</span><br><span class="line">- (UIImage *)convert2Image;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>UIWebView+PDFFile.m<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;UIWebView+PDFFile.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation UIWebView (PDFFile)</span><br><span class="line"></span><br><span class="line">- (NSData *)convert2PDFData&#123;</span><br><span class="line"></span><br><span class="line">    //    返回视图的打印格式化</span><br><span class="line">    UIViewPrintFormatter *format = [self viewPrintFormatter];</span><br><span class="line">    UIPrintPageRenderer *render = [[UIPrintPageRenderer alloc] init];</span><br><span class="line">    [render addPrintFormatter:format startingAtPageAtIndex:0];</span><br><span class="line"></span><br><span class="line">    // 设置PDF文件每页的尺寸</span><br><span class="line">    CGRect pageRect =  CGRectMake(0, 0, 600, 768);</span><br><span class="line">    //    呈现每个页面的上下文的尺寸大小</span><br><span class="line">    CGRect printableRect = CGRectInset(pageRect, 50, 50);</span><br><span class="line"></span><br><span class="line">    [render setValue:[NSValue valueWithCGRect:pageRect] forKey:@&quot;paperRect&quot;];</span><br><span class="line">    [render setValue:[NSValue valueWithCGRect:printableRect] forKey:@&quot;printableRect&quot;];</span><br><span class="line"></span><br><span class="line">    NSMutableData *pdfData = [NSMutableData data];</span><br><span class="line">    //    文档信息 可设置为nil</span><br><span class="line">    //    CFMutableDictionaryRef myDictionary = CFDictionaryCreateMutable(nil, 0,</span><br><span class="line">    //                                             &amp;kCFTypeDictionaryKeyCallBacks,</span><br><span class="line">    //                                             &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line"></span><br><span class="line">    //    CFDictionarySetValue(myDictionary, kCGPDFContextTitle, CFSTR(&quot;My PDF File&quot;));</span><br><span class="line">    //    CFDictionarySetValue(myDictionary, kCGPDFContextCreator, CFSTR(&quot;My Name&quot;));</span><br><span class="line"></span><br><span class="line">    UIGraphicsBeginPDFContextToData(pdfData, pageRect, NULL);</span><br><span class="line"></span><br><span class="line">    for (NSInteger i = 0; i &lt; [render numberOfPages]; i++) &#123;</span><br><span class="line"></span><br><span class="line">    UIGraphicsBeginPDFPage();</span><br><span class="line">    CGRect bounds = UIGraphicsGetPDFContextBounds();</span><br><span class="line">    [render drawPageAtIndex:i inRect:bounds];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UIGraphicsEndPDFContext();</span><br><span class="line"></span><br><span class="line">    return pdfData;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIImage *)convert2Image&#123;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    将 UIWebView 分屏截取，然后将截取的图片拼接成一张图片</span><br><span class="line">    将 UIWebView 从头，contentOffset = (0, 0)，开始截取webView.bounds.size.height高度的图片，</span><br><span class="line">    */</span><br><span class="line">    CGSize boundsSize = self.bounds.size;</span><br><span class="line">    CGFloat boundsWidth = self.bounds.size.width;</span><br><span class="line">    CGFloat boundsHeight = self.bounds.size.height;</span><br><span class="line">    CGPoint offset = self.scrollView.contentOffset;</span><br><span class="line"></span><br><span class="line">    [self.scrollView setContentOffset:CGPointMake(0, 0)];</span><br><span class="line"></span><br><span class="line">    CGFloat contentHeight = self.scrollView.contentSize.height;</span><br><span class="line">    NSMutableArray *images = [NSMutableArray array];</span><br><span class="line"></span><br><span class="line">    while (contentHeight &gt; 0) &#123;</span><br><span class="line">    UIGraphicsBeginImageContext(boundsSize);</span><br><span class="line"></span><br><span class="line">    [self.layer renderInContext:UIGraphicsGetCurrentContext()];</span><br><span class="line"></span><br><span class="line">    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line"></span><br><span class="line">    UIGraphicsEndImageContext();</span><br><span class="line"></span><br><span class="line">    [images addObject:image];</span><br><span class="line"></span><br><span class="line">    CGFloat offsetY = self.scrollView.contentOffset.y;</span><br><span class="line"></span><br><span class="line">    [self.scrollView setContentOffset:CGPointMake(0, offsetY + boundsHeight)];</span><br><span class="line"></span><br><span class="line">    contentHeight -= boundsHeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [self.scrollView setContentOffset:offset];</span><br><span class="line"></span><br><span class="line">    UIGraphicsBeginImageContext(self.scrollView.contentSize);</span><br><span class="line"></span><br><span class="line">    [images enumerateObjectsUsingBlock:^(UIImage *image, NSUInteger idx, BOOL *stop) &#123;</span><br><span class="line">    [image drawInRect:CGRectMake(0, boundsHeight * idx, boundsWidth, boundsHeight)];</span><br><span class="line">    &#125;];  </span><br><span class="line"></span><br><span class="line">    UIImage *fullImage = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line"></span><br><span class="line">    UIGraphicsEndImageContext();</span><br><span class="line"></span><br><span class="line">    return fullImage;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //    CGFloat scale = [UIScreen mainScreen].scale;</span><br><span class="line">    //    UIImage* image = nil;</span><br><span class="line">    //    </span><br><span class="line">    //    UIGraphicsBeginImageContextWithOptions(self.scrollView.contentSize, NO, scale);</span><br><span class="line">    //    //保存现在的位置和尺寸</span><br><span class="line">    //    CGPoint savedContentOffset = self.scrollView.contentOffset;</span><br><span class="line">    //    CGRect savedFrame = self.frame;</span><br><span class="line">    //    //设置尺寸和内容一样大</span><br><span class="line">    //    self.scrollView.contentOffset = CGPointZero;</span><br><span class="line">    //    self.frame = CGRectMake(0, 0, self.scrollView.contentSize.width, self.scrollView.contentSize.height);</span><br><span class="line">    //    </span><br><span class="line">    //    [self.layer renderInContext: UIGraphicsGetCurrentContext()];</span><br><span class="line">    //    image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">    //    </span><br><span class="line">    //    //恢复原来的位置和尺寸</span><br><span class="line">    //    self.scrollView.contentOffset = savedContentOffset;</span><br><span class="line">    //    self.frame = savedFrame;</span><br><span class="line">    //    </span><br><span class="line">    //    UIGraphicsEndImageContext();</span><br><span class="line">    //    </span><br><span class="line">    //    return image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h3 id="多张图片生成PDF文件"><a href="#多张图片生成PDF文件" class="headerlink" title="多张图片生成PDF文件"></a>多张图片生成PDF文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">- (void)convertImagesToPDFFile&#123;</span><br><span class="line"></span><br><span class="line">    NSString *fileName = [NSString stringWithFormat:@&quot;Images_%.0f.pdf&quot;,[[NSDate date] timeIntervalSince1970]];</span><br><span class="line">    NSString *pdfPath = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]stringByAppendingPathComponent:fileName];</span><br><span class="line"></span><br><span class="line">    NSMutableArray *selectImages = [NSMutableArray arrayWithCapacity:3];</span><br><span class="line">    // 默认添加九张不同大小的图片</span><br><span class="line">    for (NSInteger i = 0; i &lt; 9; i++) &#123;</span><br><span class="line">    UIImage *image = [UIImage imageNamed:[NSString stringWithFormat:@&quot;image%zd.jpg&quot;,i]];</span><br><span class="line">    [selectImages addObject:image];</span><br><span class="line">    &#125;</span><br><span class="line">    BOOL result = [self convertPDFWithImages:selectImages filePath:pdfPath];</span><br><span class="line">    if (result) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,pdfPath);</span><br><span class="line">        NSLog(@&quot;多张图片转换PDF成功&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        NSLog(@&quot;多张图片转换PDF失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)convertPDFWithImages:(NSArray&lt;UIImage *&gt;*)images filePath:(NSString *)filePath&#123;</span><br><span class="line"></span><br><span class="line">    if (!images || images.count == 0) return NO;</span><br><span class="line"></span><br><span class="line">    BOOL result = UIGraphicsBeginPDFContextToFile(filePath, CGRectZero, NULL);</span><br><span class="line"></span><br><span class="line">    // pdf每一页的尺寸大小</span><br><span class="line"></span><br><span class="line">    CGRect pdfBounds = UIGraphicsGetPDFContextBounds();</span><br><span class="line">    CGFloat pdfWidth = pdfBounds.size.width;</span><br><span class="line">    CGFloat pdfHeight = pdfBounds.size.height;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;%@&quot;,NSStringFromCGRect(pdfBounds));</span><br><span class="line"></span><br><span class="line">    [images enumerateObjectsUsingBlock:^(UIImage * _Nonnull image, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        // 绘制PDF</span><br><span class="line">        UIGraphicsBeginPDFPage();</span><br><span class="line"></span><br><span class="line">        // 获取每张图片的实际长宽</span><br><span class="line">        CGFloat imageW = image.size.width;</span><br><span class="line">        CGFloat imageH = image.size.height;</span><br><span class="line">        //        CGRect imageBounds = CGRectMake(0, 0, imageW, imageH);</span><br><span class="line">        //        NSLog(@&quot;%@&quot;,NSStringFromCGRect(imageBounds));</span><br><span class="line"></span><br><span class="line">        // 每张图片居中显示</span><br><span class="line">        // 如果图片宽高都小于PDF宽高</span><br><span class="line">        if (imageW &lt;= pdfWidth &amp;&amp; imageH &lt;= pdfHeight) &#123;</span><br><span class="line"></span><br><span class="line">            CGFloat originX = (pdfWidth - imageW) * 0.5;</span><br><span class="line">            CGFloat originY = (pdfHeight - imageH) * 0.5;</span><br><span class="line">            [image drawInRect:CGRectMake(originX, originY, imageW, imageH)];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            CGFloat w,h; // 先声明缩放之后的宽高</span><br><span class="line">            //            图片宽高比大于PDF</span><br><span class="line">            if ((imageW / imageH) &gt; (pdfWidth / pdfHeight))&#123;</span><br><span class="line">            w = pdfWidth - 20;</span><br><span class="line">            h = w * imageH / imageW;</span><br><span class="line"></span><br><span class="line">            &#125;else&#123;</span><br><span class="line">            //             图片高宽比大于PDF</span><br><span class="line">            h = pdfHeight - 20;</span><br><span class="line">            w = h * imageW / imageH;</span><br><span class="line">            &#125;</span><br><span class="line">            [image drawInRect:CGRectMake((pdfWidth - w) * 0.5, (pdfHeight - h) * 0.5, w, h)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    UIGraphicsEndPDFContext();</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文章：<br><a href="https://www.jianshu.com/p/b6fb4d662969" target="_blank" rel="noopener">iOS PDF文件格式转换</a><br><a href="https://www.jianshu.com/p/1d4305a02ea5" target="_blank" rel="noopener">iOS开发之pdf文档的加载与浏览的4种方式</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS马甲包混淆</title>
      <link href="/2018/11/30/iOS%E9%A9%AC%E7%94%B2%E5%8C%85%E6%B7%B7%E6%B7%86/"/>
      <url>/2018/11/30/iOS%E9%A9%AC%E7%94%B2%E5%8C%85%E6%B7%B7%E6%B7%86/</url>
      
        <content type="html"><![CDATA[<h2 id="马甲包混淆"><a href="#马甲包混淆" class="headerlink" title="马甲包混淆"></a>马甲包混淆</h2><p>对于OC和C++代码编译出的二进制文件：<br>删注释是没用的，因为注释是不会被编译进包里<br>改文件夹或者文件名应该是不太靠谱的，编译的时候会根据路径引用查找<br><a id="more"></a></p><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><ol><li><p>修改类名文件名<br>在xcode上修改文件名类名，然后在可能引用的地方替换类名和文件名</p></li><li><p>修改函数名，属性名：代码混淆</p></li><li><p>修改工程名，target，scheme<br>1)）在Xcode中点击工程名称直接修改，Rename<br>2）点击Edit Scheme，点击Duplicate Scheme命名为新的项目名，点击Manage Schemes选中新的scheme，删除旧的scheme<br>3）修改项目下与项目名同名的目录名称，实体文件夹名称，工程下查找旧的项目名称进行替换，如：Info.plist File，prefix header，framework search path 下的静态库路径。<br>4）修改.xcodeproj：右键显示包内容，打开.pbxproj文件，查找替换项目名<br>5）如果有pod，删除Podfile.lock文件、.xcodeproj文件以及Pods文件夹，重新 <code>pod install</code>。</p></li><li><p>修改资源路径和文件名，修改md5值<br>图片：修改icon、启动页、图标<br>文本文件：添加随机数量的空格或空行<br>音视频：待定</p></li><li><p>修改导出包的名称</p></li><li><p>info.plist会被打包进ipa，最好也多加几个字段上去</p></li></ol><h3 id="添加垃圾文件"><a href="#添加垃圾文件" class="headerlink" title="添加垃圾文件"></a>添加垃圾文件</h3><ol><li><p>创建垃圾类<br>可以写一个单独的头文件include了所有这些生成的垃圾类，然后在外部include了这个单独的头文件</p></li><li><p>创建垃圾函数<br>OC头文件的声明必然是在@interface @end之间，实现是在@implementation @end之间</p></li><li><p>创建垃圾资源文件</p></li></ol><h2 id="代码混淆"><a href="#代码混淆" class="headerlink" title="代码混淆"></a>代码混淆</h2><p>混淆原理：代码编译阶段将符号（方法名、属性名等）替换成随机生成的字符串。</p><h3 id="创建shell文件（confuse-sh）并配置相应的运行环境"><a href="#创建shell文件（confuse-sh）并配置相应的运行环境" class="headerlink" title="创建shell文件（confuse.sh）并配置相应的运行环境"></a>创建shell文件（confuse.sh）并配置相应的运行环境</h3><ul><li>在项目根目录下新建一个文件夹，取文件夹名称为CodeObfuscation。<strong>注意</strong> 这里的文件夹必须在目录中真实存在（Xcode9 New Group会自动创建对应的真实文件夹）</li><li><p>在上一步的文件下新建confuse.sh文件：新建文件 -&gt; other -&gt; Shell Script，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">TABLENAME=symbols</span><br><span class="line">SYMBOL_DB_FILE=&quot;$PROJECT_DIR/CodeObfuscation/symbols&quot;</span><br><span class="line">STRING_SYMBOL_FILE=&quot;$PROJECT_DIR/CodeObfuscation/func.list&quot;</span><br><span class="line">HEAD_FILE=&quot;$PROJECT_DIR/CodeObfuscation/codeObfuscation.h&quot;</span><br><span class="line">export LC_CTYPE=C</span><br><span class="line"></span><br><span class="line">#维护数据库方便日后作排重</span><br><span class="line">createTable()</span><br><span class="line">&#123;</span><br><span class="line">echo &quot;create table $TABLENAME(src text, des text);&quot; | sqlite3 $SYMBOL_DB_FILE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">insertValue()</span><br><span class="line">&#123;</span><br><span class="line">echo &quot;insert into $TABLENAME values(&apos;$1&apos; ,&apos;$2&apos;);&quot; | sqlite3 $SYMBOL_DB_FILE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">query()</span><br><span class="line">&#123;</span><br><span class="line">echo &quot;select * from $TABLENAME where src=&apos;$1&apos;;&quot; | sqlite3 $SYMBOL_DB_FILE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ramdomString()</span><br><span class="line">&#123;</span><br><span class="line">openssl rand -base64 64 | tr -cd &apos;a-zA-Z&apos; |head -c 16</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rm -f $SYMBOL_DB_FILE</span><br><span class="line">rm -f $HEAD_FILE</span><br><span class="line">createTable</span><br><span class="line"></span><br><span class="line">touch $HEAD_FILE</span><br><span class="line">echo &apos;#ifndef Demo_codeObfuscation_h</span><br><span class="line">#define Demo_codeObfuscation_h&apos; &gt;&gt; $HEAD_FILE</span><br><span class="line">echo &quot;//confuse string at `date`&quot; &gt;&gt; $HEAD_FILE</span><br><span class="line">cat &quot;$STRING_SYMBOL_FILE&quot; | while read -ra line; do</span><br><span class="line">if [[ ! -z &quot;$line&quot; ]]; then</span><br><span class="line">ramdom=`ramdomString`</span><br><span class="line">echo $line $ramdom</span><br><span class="line">insertValue $line $ramdom</span><br><span class="line">echo &quot;#define $line $ramdom&quot; &gt;&gt; $HEAD_FILE</span><br><span class="line">fi</span><br><span class="line">done</span><br><span class="line">echo &quot;#endif&quot; &gt;&gt; $HEAD_FILE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sqlite3 $SYMBOL_DB_FILE .dump</span><br></pre></td></tr></table></figure></li><li><p>给.sh文件添加运行环境：Build Phases -&gt; + -&gt; New Run Script Phase -&gt; $PROJECT_DIR/CodeObfuscation/confuse.sh</p></li></ul><h3 id="创建func-list文件"><a href="#创建func-list文件" class="headerlink" title="创建func.list文件"></a>创建func.list文件</h3><p>新建文件 -&gt; other -&gt; Empty，文件名：func.list</p><h3 id="创建codeObfuscation-h文件"><a href="#创建codeObfuscation-h文件" class="headerlink" title="创建codeObfuscation.h文件"></a>创建codeObfuscation.h文件</h3><p>新建文件 -&gt; Source -&gt; Header File，文件名：codeObfuscation.h</p><h3 id="包含codeObfuscation-h到pch文件中，添加要混淆的方法名或属性名到func-list"><a href="#包含codeObfuscation-h到pch文件中，添加要混淆的方法名或属性名到func-list" class="headerlink" title="包含codeObfuscation.h到pch文件中，添加要混淆的方法名或属性名到func.list"></a>包含codeObfuscation.h到pch文件中，添加要混淆的方法名或属性名到func.list</h3><h3 id="解决报错"><a href="#解决报错" class="headerlink" title="解决报错"></a>解决报错</h3><p>command + R运行项目，此时你会发现报错。<code>Permission denied</code>错误：.sh文件没有运行权限。<br>解决：<br>打开终端，cd到CodeObfuscation文件夹，更改confuse.sh文件运行权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 777 confuse.sh</span><br></pre></td></tr></table></figure></p><h3 id="查看结果"><a href="#查看结果" class="headerlink" title="查看结果"></a>查看结果</h3><p>codeObfuscation.h 中已经包含了要混淆的方法名和混淆之后的随机字符串</p><h3 id="确认结果"><a href="#确认结果" class="headerlink" title="确认结果"></a>确认结果</h3><p>找到替换的方法名或属性名，点击跳转到定义，会跳转到codeObfuscation.h中，说明替换成功。</p><p>参考文章：<br><a href="https://blog.csdn.net/lyzz0612/article/details/80390362" target="_blank" rel="noopener">iOS马甲包混淆</a><br><a href="https://www.jianshu.com/p/66bb2d45b3c2" target="_blank" rel="noopener">iOS代码混淆教程</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>IAP内购实现</title>
      <link href="/2018/11/30/IAP%E5%86%85%E8%B4%AD%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/11/30/IAP%E5%86%85%E8%B4%AD%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="IAP"><a href="#IAP" class="headerlink" title="IAP"></a>IAP</h2><ul><li><p>IAP：In-App-Purchase 应用内购买</p></li><li><p>苹果的内购分为以下四类商品：</p></li></ul><ol><li>消耗型项目</li><li>非消耗型项目</li><li>自动续期订阅</li><li><p>非续期订阅</p><a id="more"></a></li></ol><ul><li>恢复购买<br>在如下两种情况下，针对自动订阅或者非消耗性商品，需要使用恢复购买功能：<br>1.在消费者拥有的其他设备上安装它们。<br>2.在相关应用程序被删除的设备上重新安装它们。</li></ul><h2 id="开始内购前的配置项"><a href="#开始内购前的配置项" class="headerlink" title="开始内购前的配置项"></a>开始内购前的配置项</h2><ul><li>iTunesconnect后台配置内购项目<br>在“我的APP”——“功能”——“App内购买项目”添加适合自己的商品</li><li>Xcode工程配置：Capabilities -&gt; In-App Purchase -&gt; ON</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="原生"><a href="#原生" class="headerlink" title="原生"></a>原生</h3><p>加入头文件：<code>#import &lt;StoreKit/StoreKit.h&gt;</code><br>添加代理：<code>&lt;SKPaymentTransactionObserver,SKProductsRequestDelegate&gt;</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-(void)viewWillAppear:(BOOL)animated&#123;</span><br><span class="line">    [super viewWillAppear:animated];</span><br><span class="line"></span><br><span class="line">    [[SKPaymentQueue defaultQueue] addTransactionObserver:self];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)viewWillDisappear:(BOOL)animated&#123;</span><br><span class="line">    [super viewWillDisappear:animated];</span><br><span class="line"></span><br><span class="line">    [[SKPaymentQueue defaultQueue] removeTransactionObserver:self];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)inAppPurchase&#123;</span><br><span class="line">    if([SKPaymentQueue canMakePayments])&#123;</span><br><span class="line">        [self requestProductData:product];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        NSLog(@&quot;不允许程序内付费&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//请求商品</span><br><span class="line">- (void)requestProductData:(NSString *)type&#123;</span><br><span class="line">    NSLog(@&quot;-------------请求对应的产品信息----------------&quot;);</span><br><span class="line"></span><br><span class="line">    [SVProgressHUD showWithStatus:nil maskType:SVProgressHUDMaskTypeBlack];</span><br><span class="line"></span><br><span class="line">    NSArray *product = [[NSArray alloc] initWithObjects:type,nil];</span><br><span class="line"></span><br><span class="line">    NSSet *nsset = [NSSet setWithArray:product];</span><br><span class="line">    SKProductsRequest *request = [[SKProductsRequest alloc] initWithProductIdentifiers:nsset];</span><br><span class="line">    request.delegate = self;</span><br><span class="line">    [request start];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//收到产品返回信息</span><br><span class="line">- (void)productsRequest:(SKProductsRequest *)request didReceiveResponse:(SKProductsResponse *)response&#123;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;--------------收到产品反馈消息---------------------&quot;);</span><br><span class="line">    NSArray *product = response.products;</span><br><span class="line">    if([product count] == 0)&#123;</span><br><span class="line">        [SVProgressHUD dismiss];</span><br><span class="line">        NSLog(@&quot;--------------没有商品------------------&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;productID:%@&quot;, response.invalidProductIdentifiers);</span><br><span class="line">    NSLog(@&quot;产品付费数量:%lu&quot;,(unsigned long)[product count]);</span><br><span class="line"></span><br><span class="line">    SKProduct *p = nil;</span><br><span class="line">    for (SKProduct *pro in product) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, [pro description]);</span><br><span class="line">        NSLog(@&quot;%@&quot;, [pro localizedTitle]);</span><br><span class="line">        NSLog(@&quot;%@&quot;, [pro localizedDescription]);</span><br><span class="line">        NSLog(@&quot;%@&quot;, [pro price]);</span><br><span class="line">        NSLog(@&quot;%@&quot;, [pro productIdentifier]);</span><br><span class="line"></span><br><span class="line">        if([pro.productIdentifier isEqualToString:_currentProId])&#123;</span><br><span class="line">            p = pro;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SKPayment *payment = [SKPayment paymentWithProduct:p];</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;发送购买请求&quot;);</span><br><span class="line">    [[SKPaymentQueue defaultQueue] addPayment:payment];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//请求失败</span><br><span class="line">- (void)request:(SKRequest *)request didFailWithError:(NSError *)error&#123;</span><br><span class="line">    [SVProgressHUD showErrorWithStatus:@&quot;支付失败&quot;];</span><br><span class="line">    NSLog(@&quot;------------------错误-----------------:%@&quot;, error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)requestDidFinish:(SKRequest *)request&#123;</span><br><span class="line">    [SVProgressHUD dismiss];</span><br><span class="line">    NSLog(@&quot;------------反馈信息结束-----------------&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//沙盒测试环境验证</span><br><span class="line">#define SANDBOX @&quot;https://sandbox.itunes.apple.com/verifyReceipt&quot;</span><br><span class="line">//正式环境验证</span><br><span class="line">#define AppStore @&quot;https://buy.itunes.apple.com/verifyReceipt&quot;</span><br><span class="line">/**</span><br><span class="line">*  验证购买，避免越狱软件模拟苹果请求达到非法购买问题</span><br><span class="line">*</span><br><span class="line">*/</span><br><span class="line">-(void)verifyPurchaseWithPaymentTransaction&#123;</span><br><span class="line">    //从沙盒中获取交易凭证并且拼接成请求体数据</span><br><span class="line">    NSURL *receiptUrl=[[NSBundle mainBundle] appStoreReceiptURL];</span><br><span class="line">    NSData *receiptData=[NSData dataWithContentsOfURL:receiptUrl];</span><br><span class="line"></span><br><span class="line">    NSString *receiptString=[receiptData base64EncodedStringWithOptions:NSDataBase64EncodingEndLineWithLineFeed];//转化为base64字符串</span><br><span class="line"></span><br><span class="line">    NSString *bodyString = [NSString stringWithFormat:@&quot;&#123;\\&quot;receipt-data\\&quot; : \\&quot;%@\\&quot;&#125;&quot;, receiptString];//拼接请求数据</span><br><span class="line">    NSData *bodyData = [bodyString dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //创建请求到苹果官方进行购买验证</span><br><span class="line">    NSURL *url=[NSURL URLWithString:SANDBOX];</span><br><span class="line">    NSMutableURLRequest *requestM=[NSMutableURLRequest requestWithURL:url];</span><br><span class="line">    requestM.HTTPBody=bodyData;</span><br><span class="line">    requestM.HTTPMethod=@&quot;POST&quot;;</span><br><span class="line">    //创建连接并发送同步请求</span><br><span class="line">    NSError *error=nil;</span><br><span class="line">    NSData *responseData=[NSURLConnection sendSynchronousRequest:requestM returningResponse:nil error:&amp;error];</span><br><span class="line">    if (error) &#123;</span><br><span class="line">        NSLog(@&quot;验证购买过程中发生错误，错误信息：%@&quot;,error.localizedDescription);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    NSDictionary *dic=[NSJSONSerialization JSONObjectWithData:responseData options:NSJSONReadingAllowFragments error:nil];</span><br><span class="line">    NSLog(@&quot;%@&quot;,dic);</span><br><span class="line">    if([dic[@&quot;status&quot;] intValue]==0)&#123;</span><br><span class="line">        NSLog(@&quot;购买成功！&quot;);</span><br><span class="line">        NSDictionary *dicReceipt= dic[@&quot;receipt&quot;];</span><br><span class="line">        NSDictionary *dicInApp=[dicReceipt[@&quot;in_app&quot;] firstObject];</span><br><span class="line">        NSString *productIdentifier= dicInApp[@&quot;product_id&quot;];//读取产品标识</span><br><span class="line">        //如果是消耗品则记录购买数量，非消耗品则记录是否购买过</span><br><span class="line">        NSUserDefaults *defaults=[NSUserDefaults standardUserDefaults];</span><br><span class="line">        if ([productIdentifier isEqualToString:@&quot;123&quot;]) &#123;</span><br><span class="line">            int purchasedCount=[defaults integerForKey:productIdentifier];//已购买数量</span><br><span class="line">            [[NSUserDefaults standardUserDefaults] setInteger:(purchasedCount+1) forKey:productIdentifier];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            [defaults setBool:YES forKey:productIdentifier];</span><br><span class="line">        &#125;</span><br><span class="line">    //在此处对购买记录进行存储，可以存储到开发商的服务器端</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        NSLog(@&quot;购买失败，未通过验证！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//监听购买结果</span><br><span class="line">- (void)paymentQueue:(SKPaymentQueue *)queue updatedTransactions:(NSArray *)transaction&#123;</span><br><span class="line"></span><br><span class="line">    for(SKPaymentTransaction *tran in transaction)&#123;</span><br><span class="line"></span><br><span class="line">        switch (tran.transactionState) &#123;</span><br><span class="line">            case SKPaymentTransactionStatePurchased:&#123;</span><br><span class="line">            NSLog(@&quot;交易完成&quot;);</span><br><span class="line">            [self verifyPurchaseWithPaymentTransaction];</span><br><span class="line">            [[SKPaymentQueue defaultQueue] finishTransaction:tran];</span><br><span class="line">        &#125;</span><br><span class="line">            break;</span><br><span class="line">        case SKPaymentTransactionStatePurchasing:</span><br><span class="line">            NSLog(@&quot;商品添加进列表&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case SKPaymentTransactionStateRestored:&#123;</span><br><span class="line">            NSLog(@&quot;已经购买过商品&quot;);</span><br><span class="line">            [[SKPaymentQueue defaultQueue] finishTransaction:tran];</span><br><span class="line">        &#125;</span><br><span class="line">            break;</span><br><span class="line">        case SKPaymentTransactionStateFailed:&#123;</span><br><span class="line">            NSLog(@&quot;交易失败&quot;);</span><br><span class="line">            [[SKPaymentQueue defaultQueue] finishTransaction:tran];</span><br><span class="line">            [SVProgressHUD showErrorWithStatus:@&quot;购买失败&quot;];</span><br><span class="line">        &#125;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//交易结束</span><br><span class="line">- (void)completeTransaction:(SKPaymentTransaction *)transaction&#123;</span><br><span class="line">NSLog(@&quot;交易结束&quot;);</span><br><span class="line"></span><br><span class="line">    [[SKPaymentQueue defaultQueue] finishTransaction:transaction];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="第三方库-XYIAPKit"><a href="#第三方库-XYIAPKit" class="headerlink" title="第三方库 XYIAPKit"></a>第三方库 XYIAPKit</h3><ul><li><p>购买</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - IAP</span><br><span class="line">-(void)inAppPurchase&#123;</span><br><span class="line"></span><br><span class="line">    if (![XYStore canMakePayments]) &#123;</span><br><span class="line">        [ProgressHUD showTextTipMsg:@&quot;This device is not able or allowed to make payments&quot;];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        self.HUD = [MBProgressHUD showHUDAddedTo:self.view animated:YES];</span><br><span class="line">        //1、查询在线商品</span><br><span class="line">        NSSet* dataSet = [[NSSet alloc] initWithObjects:IAPProductID, nil];</span><br><span class="line">        [[XYStore defaultStore]requestProducts:dataSet success:^(NSArray *products, NSArray *invalidProductIdentifiers) &#123;</span><br><span class="line"></span><br><span class="line">            if (products.count&gt;0) &#123;</span><br><span class="line">            //2、添加购买</span><br><span class="line">            BOOL flag = NO;</span><br><span class="line">            for (SKProduct *sKProduct in products) &#123;</span><br><span class="line"></span><br><span class="line">                if([sKProduct.productIdentifier isEqualToString: IAPProductID])&#123;</span><br><span class="line">                    flag = YES;</span><br><span class="line">                    [XYStoreiTunesReceiptVerifier shareInstance].sharedSecretKey = IAPSharedKey;</span><br><span class="line">                    [[XYStore defaultStore] addPayment:IAPProductID</span><br><span class="line">                    success:^(SKPaymentTransaction *transaction)</span><br><span class="line">                    &#123;</span><br><span class="line">                        if ([[XYStoreiTunesReceiptVerifier shareInstance]isSubscribedWithAutoRenewProduct:IAPProductID]) &#123;</span><br><span class="line">                            //追踪收入</span><br><span class="line">                            [self.HUD hideAnimated:YES];</span><br><span class="line">                            [self tryForFree];</span><br><span class="line">                        &#125;else&#123;</span><br><span class="line">                            [self.HUD hideAnimated:NO];</span><br><span class="line">                            [ProgressHUD showTextTipMsg:@&quot;Verification Failed&quot;];</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125; failure:^(SKPaymentTransaction *transaction, NSError *error) &#123;</span><br><span class="line">                        /*</span><br><span class="line">                        内购验证凭据返回结果状态码说明</span><br><span class="line">                        21000 App Store无法读取你提供的JSON数据</span><br><span class="line">                        21002 收据数据不符合格式</span><br><span class="line">                        21003 收据无法被验证</span><br><span class="line">                        21004 你提供的共享密钥和账户的共享密钥不一致</span><br><span class="line">                        21005 收据服务器当前不可用</span><br><span class="line">                        21006 收据是有效的，但订阅服务已经过期。当收到这个信息时，解码后的收据信息也包含在返回内容中</span><br><span class="line">                        21007 收据信息是测试用（sandbox），但却被发送到产品环境中验证</span><br><span class="line">                        21008 收据信息是产品环境中使用，但却被发送到测试环境中验证</span><br><span class="line">                        */</span><br><span class="line">                        [self.HUD hideAnimated:NO];</span><br><span class="line">                        if (transaction.error.code == SKErrorPaymentCancelled) &#123;</span><br><span class="line">                            [ProgressHUD showTextTipMsg:@&quot;Purchase Cancel&quot;];</span><br><span class="line">                        &#125;else&#123;</span><br><span class="line">                            [ProgressHUD showTextTipMsg:transaction.error.localizedDescription];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;];</span><br><span class="line">                    break;</span><br><span class="line"></span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    //NSLog(@&quot;不相同&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!flag) &#123;</span><br><span class="line">                [self.HUD hideAnimated:NO];</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                [self.HUD hideAnimated:NO];</span><br><span class="line">                [ProgressHUD showTextTipMsg:@&quot;Failed to get product information&quot;];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; failure:^(NSError *error) &#123;</span><br><span class="line">            [self.HUD hideAnimated:NO];</span><br><span class="line">            [ProgressHUD showTextTipMsg:@&quot;Failed to get product information&quot;];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>恢复购买</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark 恢复购买(主要是针对非消耗产品，自动订阅)</span><br><span class="line">- (void)restoreClick&#123;</span><br><span class="line"></span><br><span class="line">    self.HUD = [MBProgressHUD showHUDAddedTo:self.view animated:YES];</span><br><span class="line">    [[XYStore defaultStore] restoreTransactionsOnSuccess:^(NSArray *transactions) &#123;</span><br><span class="line"></span><br><span class="line">        [self.HUD hideAnimated:NO];</span><br><span class="line">        for (SKPaymentTransaction *transaction in transactions)</span><br><span class="line">        &#123;</span><br><span class="line">            NSString *purchased = transaction.payment.productIdentifier;</span><br><span class="line">            if([purchased isEqualToString:IAPProductID])</span><br><span class="line">            &#123;</span><br><span class="line">                if ([[XYStoreiTunesReceiptVerifier shareInstance]isSubscribedWithAutoRenewProduct:IAPProductID]) &#123;</span><br><span class="line">                    [ProgressHUD showTextTipMsg:@&quot;Verification Succeed&quot;];</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    [ProgressHUD showTextTipMsg:@&quot;Verification Failed&quot;];</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; failure:^(NSError *error) &#123;</span><br><span class="line">        [self.HUD hideAnimated:NO];</span><br><span class="line">        [ProgressHUD showTextTipMsg:error.localizedDescription];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="沙箱测试"><a href="#沙箱测试" class="headerlink" title="沙箱测试"></a>沙箱测试</h2><h3 id="添加沙盒测试员"><a href="#添加沙盒测试员" class="headerlink" title="添加沙盒测试员"></a>添加沙盒测试员</h3><p>非正式环境下测试需要添加沙盒测试员</p><h3 id="生成共享密钥"><a href="#生成共享密钥" class="headerlink" title="生成共享密钥"></a>生成共享密钥</h3><p>共享密钥：是一个32位随机生成的字母数字字符串，在联系苹果服务器获取APP内购买项目收据时使用的唯一代码。没有共享密钥，将无法再沙箱技术模式下测试自动续订APP内购买项目。另外，共享密钥不能在 APP Store 使用。<br> 生成共享密钥：进入 Features，点击 In-App Purchases 表格左上角的 View Share Secret。有可能，你还需要点击 Generate Shared Secret 按钮。<br> 当传递用户 receipt-data 和 shared key 时，会返回一个包含用户购买历史的json数据，里面包含了订阅的详细信息：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">     &quot;status&quot;: 0,</span><br><span class="line">     &quot;environment&quot;: &quot;Sandbox&quot;,</span><br><span class="line">     &quot;receipt&quot;: &#123;</span><br><span class="line">     &quot;receipt_type&quot;: &quot;ProductionSandbox&quot;,</span><br><span class="line">     &quot;adam_id&quot;: 0,</span><br><span class="line">     &quot;app_item_id&quot;: 0,</span><br><span class="line">     &quot;bundle_id&quot;: &quot;xxx&quot;,</span><br><span class="line">     &quot;application_version&quot;: &quot;101&quot;,</span><br><span class="line">     &quot;download_id&quot;: 0,</span><br><span class="line">     &quot;version_external_identifier&quot;: 0,</span><br><span class="line">     &quot;receipt_creation_date&quot;: &quot;2018-11-29 08:30:30 Etc/GMT&quot;,</span><br><span class="line">     &quot;receipt_creation_date_ms&quot;: &quot;1543480230000&quot;,</span><br><span class="line">     &quot;receipt_creation_date_pst&quot;: &quot;2018-11-29 00:30:30 America/Los_Angeles&quot;,</span><br><span class="line">     &quot;request_date&quot;: &quot;2018-11-29 08:30:50 Etc/GMT&quot;,</span><br><span class="line">     &quot;request_date_ms&quot;: &quot;1543480250216&quot;,</span><br><span class="line">     &quot;request_date_pst&quot;: &quot;2018-11-29 00:30:50 America/Los_Angeles&quot;,</span><br><span class="line">     &quot;original_purchase_date&quot;: &quot;2013-08-01 07:00:00 Etc/GMT&quot;,</span><br><span class="line">     &quot;original_purchase_date_ms&quot;: &quot;1375340400000&quot;,</span><br><span class="line">     &quot;original_purchase_date_pst&quot;: &quot;2013-08-01 00:00:00 America/Los_Angeles&quot;,</span><br><span class="line">     &quot;original_application_version&quot;: &quot;1.0&quot;,</span><br><span class="line">     &quot;in_app&quot;: [&#123;</span><br><span class="line">         &quot;quantity&quot;: &quot;1&quot;,</span><br><span class="line">         &quot;product_id&quot;: &quot;product_id_xxx&quot;,</span><br><span class="line">         &quot;transaction_id&quot;: &quot;1000000479728157&quot;,</span><br><span class="line">         &quot;original_transaction_id&quot;: &quot;1000000479726062&quot;,</span><br><span class="line">         &quot;purchase_date&quot;: &quot;2018-11-29 08:29:26 Etc/GMT&quot;,</span><br><span class="line">         &quot;purchase_date_ms&quot;: &quot;1543480166000&quot;,</span><br><span class="line">         &quot;purchase_date_pst&quot;: &quot;2018-11-29 00:29:26 America/Los_Angeles&quot;,</span><br><span class="line">         &quot;original_purchase_date&quot;: &quot;2018-11-29 08:27:26 Etc/GMT&quot;,</span><br><span class="line">         &quot;original_purchase_date_ms&quot;: &quot;1543480046000&quot;,</span><br><span class="line">         &quot;original_purchase_date_pst&quot;: &quot;2018-11-29 00:27:26 America/Los_Angeles&quot;,</span><br><span class="line">         &quot;expires_date&quot;: &quot;2018-11-29 09:29:26 Etc/GMT&quot;,</span><br><span class="line">         &quot;expires_date_ms&quot;: &quot;1543483766000&quot;,</span><br><span class="line">         &quot;expires_date_pst&quot;: &quot;2018-11-29 01:29:26 America/Los_Angeles&quot;,</span><br><span class="line">         &quot;web_order_line_item_id&quot;: &quot;1000000041543390&quot;,</span><br><span class="line">         &quot;is_trial_period&quot;: &quot;false&quot;,</span><br><span class="line">         &quot;is_in_intro_offer_period&quot;: &quot;false&quot;</span><br><span class="line">     &#125;]</span><br><span class="line">     &#125;,</span><br><span class="line">     &quot;latest_receipt_info&quot;: [&#123;</span><br><span class="line">         &quot;quantity&quot;: &quot;1&quot;,</span><br><span class="line">         &quot;product_id&quot;: &quot;product_id_xxx&quot;,</span><br><span class="line">         &quot;transaction_id&quot;: &quot;1000000479726062&quot;,</span><br><span class="line">         &quot;original_transaction_id&quot;: &quot;1000000479726062&quot;,</span><br><span class="line">         &quot;purchase_date&quot;: &quot;2018-11-29 08:27:26 Etc/GMT&quot;,</span><br><span class="line">         &quot;purchase_date_ms&quot;: &quot;1543480046000&quot;,</span><br><span class="line">         &quot;purchase_date_pst&quot;: &quot;2018-11-29 00:27:26 America/Los_Angeles&quot;,</span><br><span class="line">         &quot;original_purchase_date&quot;: &quot;2018-11-29 08:27:26 Etc/GMT&quot;,</span><br><span class="line">         &quot;original_purchase_date_ms&quot;: &quot;1543480046000&quot;,</span><br><span class="line">         &quot;original_purchase_date_pst&quot;: &quot;2018-11-29 00:27:26 America/Los_Angeles&quot;,</span><br><span class="line">         &quot;expires_date&quot;: &quot;2018-11-29 08:29:26 Etc/GMT&quot;,</span><br><span class="line">         &quot;expires_date_ms&quot;: &quot;1543480166000&quot;,</span><br><span class="line">         &quot;expires_date_pst&quot;: &quot;2018-11-29 00:29:26 America/Los_Angeles&quot;,</span><br><span class="line">         &quot;web_order_line_item_id&quot;: &quot;1000000041543389&quot;,</span><br><span class="line">         &quot;is_trial_period&quot;: &quot;true&quot;,</span><br><span class="line">         &quot;is_in_intro_offer_period&quot;: &quot;false&quot;</span><br><span class="line">     &#125;],</span><br><span class="line">     &quot;latest_receipt&quot;: &quot;MIIVQQYJKoZIhvcNAQcCoIIVMjCCFS4CAQExCzAJBgUrDgMCGgUAMIIE4gYJKoZIhvcNAQcBoIIE0wSCBM8xggTLMAoCAQgCAQEEAhYAMAoCARQCAQEEAgwAMAsCAQECAQEEAwIBADALAgELAgEBBAMCAQAwCwIBDwIBAQQDAgEAMAsCARACAQEEAwIBADALAgEZAgEBBAMCAQMwDAIBCgIBAQQEFgI0KzAMAgEOAgEBBAQCAgCJMA0CAQMCAQEEBQwDMTAxMA0CAQ0CAQEEBQIDAdTAMA0CARMCAQEEBQwDMS4wMA4CAQkCAQEEBgIEUDI1MDAYAgEEAgECBBDb7hM/NDDixzwcSFwyEYz6MBsCAQACAQEEEwwRUHJvZHVjdGlvblNhbmRib3gwGwIBAgIBAQQTDBFjb20ueW9tb2IuSUFQdGVzdDAcAgEFAgEBBBSjmkMQuPUKeGNrG4sbzGLFAheRNTAeAgEMAgEBBBYWFDIwMTgtMTEtMjlUMDg6MzA6NTBaMB4CARICAQEEFhYUMjAxMy0wOC0wMVQwNzowMDowMFowNAIBBwIBAQQs+ShyhwCpCHo89GeCq7TC2786bv7fQvMTnKnxms+by8hrfzotUYrSp4eeeEgwRwIBBgIBAQQ/VCTun3UN9p9x7o+3H/JgU7dfdClagEEBVsIPrGeNf30h2dK7xQ5qb6HewswOgB9L0HGFLgWsUBUaJQZ6kOxjMIIBcAIBEQIBAQSCAWYxggFiMAsCAgatAgEBBAIMADALAgIGsAIBAQQCFgAwCwICBrICAQEEAgwAMAsCAgazAgEBBAIMADALAgIGtAIBAQQCDAAwCwICBrUCAQEEAgwAMAsCAga2AgEBBAIMADAMAgIGpQIBAQQDAgEBMAwCAgarAgEBBAMCAQMwDAICBq4CAQEEAwIBADAMAgIGsQIBAQQDAgEAMAwCAga3AgEBBAMCAQAwDgICBqYCAQEEBQwDdmlwMBICAgavAgEBBAkCBwONfqdAZt4wGwICBqcCAQEEEgwQMTAwMDAwMDQ3OTcyODE1NzAbAgIGqQIBAQQSDBAxMDAwMDAwNDc5NzI2MDYyMB8CAgaoAgEBBBYWFDIwMTgtMTEtMjlUMDg6Mjk6MjZaMB8CAgaqAgEBBBYWFDIwMTgtMTEtMjlUMDg6Mjc6MjZaMB8CAgasAgEBBBYWFDIwMTgtMTEtMjlUMDk6Mjk6MjZaMIIBcAIBEQIBAQSCAWYxggFiMAsCAgatAgEBBAIMADALAgIGsAIBAQQCFgAwCwICBrICAQEEAgwAMAsCAgazAgEBBAIMADALAgIGtAIBAQQCDAAwCwICBrUCAQEEAgwAMAsCAga2AgEBBAIMADAMAgIGpQIBAQQDAgEBMAwCAgarAgEBBAMCAQMwDAICBq4CAQEEAwIBADAMAgIGsQIBAQQDAgEBMAwCAga3AgEBBAMCAQAwDgICBqYCAQEEBQwDdmlwMBICAgavAgEBBAkCBwONfqdAZt0wGwICBqcCAQEEEgwQMTAwMDAwMDQ3OTcyNjA2MjAbAgIGqQIBAQQSDBAxMDAwMDAwNDc5NzI2MDYyMB8CAgaoAgEBBBYWFDIwMTgtMTEtMjlUMDg6Mjc6MjZaMB8CAgaqAgEBBBYWFDIwMTgtMTEtMjlUMDg6Mjc6MjZaMB8CAgasAgEBBBYWFDIwMTgtMTEtMjlUMDg6Mjk6MjZaoIIOZTCCBXwwggRkoAMCAQICCA7rV4fnngmNMA0GCSqGSIb3DQEBBQUAMIGWMQswCQYDVQQGEwJVUzETMBEGA1UECgwKQXBwbGUgSW5jLjEsMCoGA1UECwwjQXBwbGUgV29ybGR3aWRlIERldmVsb3BlciBSZWxhdGlvbnMxRDBCBgNVBAMMO0FwcGxlIFdvcmxkd2lkZSBEZXZlbG9wZXIgUmVsYXRpb25zIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MB4XDTE1MTExMzAyMTUwOVoXDTIzMDIwNzIxNDg0N1owgYkxNzA1BgNVBAMMLk1hYyBBcHAgU3RvcmUgYW5kIGlUdW5lcyBTdG9yZSBSZWNlaXB0IFNpZ25pbmcxLDAqBgNVBAsMI0FwcGxlIFdvcmxkd2lkZSBEZXZlbG9wZXIgUmVsYXRpb25zMRMwEQYDVQQKDApBcHBsZSBJbmMuMQswCQYDVQQGEwJVUzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAKXPgf0looFb1oftI9ozHI7iI8ClxCbLPcaf7EoNVYb/pALXl8o5VG19f7JUGJ3ELFJxjmR7gs6JuknWCOW0iHHPP1tGLsbEHbgDqViiBD4heNXbt9COEo2DTFsqaDeTwvK9HsTSoQxKWFKrEuPt3R+YFZA1LcLMEsqNSIH3WHhUa+iMMTYfSgYMR1TzN5C4spKJfV+khUrhwJzguqS7gpdj9CuTwf0+b8rB9Typj1IawCUKdg7e/pn+/8Jr9VterHNRSQhWicxDkMyOgQLQoJe2XLGhaWmHkBBoJiY5uB0Qc7AKXcVz0N92O9gt2Yge4+wHz+KO0NP6JlWB7+IDSSMCAwEAAaOCAdcwggHTMD8GCCsGAQUFBwEBBDMwMTAvBggrBgEFBQcwAYYjaHR0cDovL29jc3AuYXBwbGUuY29tL29jc3AwMy13d2RyMDQwHQYDVR0OBBYEFJGknPzEdrefoIr0TfWPNl3tKwSFMAwGA1UdEwEB/wQCMAAwHwYDVR0jBBgwFoAUiCcXCam2GGCL7Ou69kdZxVJUo7cwggEeBgNVHSAEggEVMIIBETCCAQ0GCiqGSIb3Y2QFBgEwgf4wgcMGCCsGAQUFBwICMIG2DIGzUmVsaWFuY2Ugb24gdGhpcyBjZXJ0aWZpY2F0ZSBieSBhbnkgcGFydHkgYXNzdW1lcyBhY2NlcHRhbmNlIG9mIHRoZSB0aGVuIGFwcGxpY2FibGUgc3RhbmRhcmQgdGVybXMgYW5kIGNvbmRpdGlvbnMgb2YgdXNlLCBjZXJ0aWZpY2F0ZSBwb2xpY3kgYW5kIGNlcnRpZmljYXRpb24gcHJhY3RpY2Ugc3RhdGVtZW50cy4wNgYIKwYBBQUHAgEWKmh0dHA6Ly93d3cuYXBwbGUuY29tL2NlcnRpZmljYXRlYXV0aG9yaXR5LzAOBgNVHQ8BAf8EBAMCB4AwEAYKKoZIhvdjZAYLAQQCBQAwDQYJKoZIhvcNAQEFBQADggEBAA2mG9MuPeNbKwduQpZs0+iMQzCCX+Bc0Y2+vQ+9GvwlktuMhcOAWd/j4tcuBRSsDdu2uP78NS58y60Xa45/H+R3ubFnlbQTXqYZhnb4WiCV52OMD3P86O3GH66Z+GVIXKDgKDrAEDctuaAEOR9zucgF/fLefxoqKm4rAfygIFzZ630npjP49ZjgvkTbsUxn/G4KT8niBqjSl/OnjmtRolqEdWXRFgRi48Ff9Qipz2jZkgDJwYyz+I0AZLpYYMB8r491ymm5WyrWHWhumEL1TKc3GZvMOxx6GUPzo22/SGAGDDaSK+zeGLUR2i0j0I78oGmcFxuegHs5R0UwYS/HE6gwggQiMIIDCqADAgECAggB3rzEOW2gEDANBgkqhkiG9w0BAQUFADBiMQswCQYDVQQGEwJVUzETMBEGA1UEChMKQXBwbGUgSW5jLjEmMCQGA1UECxMdQXBwbGUgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkxFjAUBgNVBAMTDUFwcGxlIFJvb3QgQ0EwHhcNMTMwMjA3MjE0ODQ3WhcNMjMwMjA3MjE0ODQ3WjCBljELMAkGA1UEBhMCVVMxEzARBgNVBAoMCkFwcGxlIEluYy4xLDAqBgNVBAsMI0FwcGxlIFdvcmxkd2lkZSBEZXZlbG9wZXIgUmVsYXRpb25zMUQwQgYDVQQDDDtBcHBsZSBXb3JsZHdpZGUgRGV2ZWxvcGVyIFJlbGF0aW9ucyBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMo4VKbLVqrIJDlI6Yzu7F+4fyaRvDRTes58Y4Bhd2RepQcjtjn+UC0VVlhwLX7EbsFKhT4v8N6EGqFXya97GP9q+hUSSRUIGayq2yoy7ZZjaFIVPYyK7L9rGJXgA6wBfZcFZ84OhZU3au0Jtq5nzVFkn8Zc0bxXbmc1gHY2pIeBbjiP2CsVTnsl2Fq/ToPBjdKT1RpxtWCcnTNOVfkSWAyGuBYNweV3RY1QSLorLeSUheHoxJ3GaKWwo/xnfnC6AllLd0KRObn1zeFM78A7SIym5SFd/Wpqu6cWNWDS5q3zRinJ6MOL6XnAamFnFbLw/eVovGJfbs+Z3e8bY/6SZasCAwEAAaOBpjCBozAdBgNVHQ4EFgQUiCcXCam2GGCL7Ou69kdZxVJUo7cwDwYDVR0TAQH/BAUwAwEB/zAfBgNVHSMEGDAWgBQr0GlHlHYJ/vRrjS5ApvdHTX8IXjAuBgNVHR8EJzAlMCOgIaAfhh1odHRwOi8vY3JsLmFwcGxlLmNvbS9yb290LmNybDAOBgNVHQ8BAf8EBAMCAYYwEAYKKoZIhvdjZAYCAQQCBQAwDQYJKoZIhvcNAQEFBQADggEBAE/P71m+LPWybC+P7hOHMugFNahui33JaQy52Re8dyzUZ+L9mm06WVzfgwG9sq4qYXKxr83DRTCPo4MNzh1HtPGTiqN0m6TDmHKHOz6vRQuSVLkyu5AYU2sKThC22R1QbCGAColOV4xrWzw9pv3e9w0jHQtKJoc/upGSTKQZEhltV/V6WId7aIrkhoxK6+JJFKql3VUAqa67SzCu4aCxvCmA5gl35b40ogHKf9ziCuY7uLvsumKV8wVjQYLNDzsdTJWk26v5yZXpT+RN5yaZgem8+bQp0gF6ZuEujPYhisX4eOGBrr/TkJ2prfOv/TgalmcwHFGlXOxxioK0bA8MFR8wggS7MIIDo6ADAgECAgECMA0GCSqGSIb3DQEBBQUAMGIxCzAJBgNVBAYTAlVTMRMwEQYDVQQKEwpBcHBsZSBJbmMuMSYwJAYDVQQLEx1BcHBsZSBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTEWMBQGA1UEAxMNQXBwbGUgUm9vdCBDQTAeFw0wNjA0MjUyMTQwMzZaFw0zNTAyMDkyMTQwMzZaMGIxCzAJBgNVBAYTAlVTMRMwEQYDVQQKEwpBcHBsZSBJbmMuMSYwJAYDVQQLEx1BcHBsZSBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTEWMBQGA1UEAxMNQXBwbGUgUm9vdCBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAOSRqQkfkdseR1DrBe1eeYQt6zaiV0xV7IsZid75S2z1B6siMALoGD74UAnTf0GomPnRymacJGsR0KO75Bsqwx+VnnoMpEeLW9QWNzPLxA9NzhRp0ckZcvVdDtV/X5vyJQO6VY9NXQ3xZDUjFUsVWR2zlPf2nJ7PULrBWFBnjwi0IPfLrCwgb3C2PwEwjLdDzw+dPfMrSSgayP7OtbkO2V4c1ss9tTqt9A8OAJILsSEWLnTVPA3bYharo3GSR1NVwa8vQbP4++NwzeajTEV+H0xrUJZBicR0YgsQg0GHM4qBsTBY7FoEMoxos48d3mVz/2deZbxJ2HafMxRloXeUyS0CAwEAAaOCAXowggF2MA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBQr0GlHlHYJ/vRrjS5ApvdHTX8IXjAfBgNVHSMEGDAWgBQr0GlHlHYJ/vRrjS5ApvdHTX8IXjCCAREGA1UdIASCAQgwggEEMIIBAAYJKoZIhvdjZAUBMIHyMCoGCCsGAQUFBwIBFh5odHRwczovL3d3dy5hcHBsZS5jb20vYXBwbGVjYS8wgcMGCCsGAQUFBwICMIG2GoGzUmVsaWFuY2Ugb24gdGhpcyBjZXJ0aWZpY2F0ZSBieSBhbnkgcGFydHkgYXNzdW1lcyBhY2NlcHRhbmNlIG9mIHRoZSB0aGVuIGFwcGxpY2FibGUgc3RhbmRhcmQgdGVybXMgYW5kIGNvbmRpdGlvbnMgb2YgdXNlLCBjZXJ0aWZpY2F0ZSBwb2xpY3kgYW5kIGNlcnRpZmljYXRpb24gcHJhY3RpY2Ugc3RhdGVtZW50cy4wDQYJKoZIhvcNAQEFBQADggEBAFw2mUwteLftjJvc83eb8nbSdzBPwR+Fg4UbmT1HN/Kpm0COLNSxkBLYvvRzm+7SZA/LeU802KI++Xj/a8gH7H05g4tTINM4xLG/mk8Ka/8r/FmnBQl8F0BWER5007eLIztHo9VvJOLr0bdw3w9F4SfK8W147ee1Fxeo3H4iNcol1dkP1mvUoiQjEfehrI9zgWDGG1sJL5Ky+ERI8GA4nhX1PSZnIIozavcNgs/e66Mv+VNqW2TAYzN39zoHLFbr2g8hDtq6cxlPtdk2f8GHVdmnmbkyQvvY1XGefqFStxu9k0IkEirHDx22TZxeY8hLgBdQqorV2uT80AkHN7B1dSExggHLMIIBxwIBATCBozCBljELMAkGA1UEBhMCVVMxEzARBgNVBAoMCkFwcGxlIEluYy4xLDAqBgNVBAsMI0FwcGxlIFdvcmxkd2lkZSBEZXZlbG9wZXIgUmVsYXRpb25zMUQwQgYDVQQDDDtBcHBsZSBXb3JsZHdpZGUgRGV2ZWxvcGVyIFJlbGF0aW9ucyBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eQIIDutXh+eeCY0wCQYFKw4DAhoFADANBgkqhkiG9w0BAQEFAASCAQCjcfsTWu8CEuiq/iSnawpcND/8jwbRHBTsxBMvAQxNhg1LDyd4z8TVQ/Ybmi3gPign2bTdtdLxKweme/ATH3RsLG9B99pMhPLdQJDpt8cgdVJ/QSdCG6TMU+l2N3CaE5wwK6tG+xboNog/nQ0t0wu59GghWbFGE73Hkk/gp0YJ+FeSW/Y1Ipt5PEBHQeGb4M+qWpSdA8MEL8WRzL7WCh2yeBInB40At0LaJoAHcohMCT2QZ9eVeWJUb6NvRBScSPY5niTJLpXQi+kKK3u5lLgZ7VuKfLi7oTwlcVXn2RrpBX3Efv2ANqDwtOTUtAuxU3ANDHZivazx0rEbTL3NvN9P&quot;,</span><br><span class="line">     &quot;pending_renewal_info&quot;: [&#123;</span><br><span class="line">         &quot;auto_renew_product_id&quot;: &quot;product_id_xxx&quot;,</span><br><span class="line">         &quot;original_transaction_id&quot;: &quot;1000000479726062&quot;,</span><br><span class="line">         &quot;product_id&quot;: &quot;product_id_xxx&quot;,</span><br><span class="line">         &quot;auto_renew_status&quot;: &quot;1&quot;</span><br><span class="line">     &#125;]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><p>退出自己的账号，用沙盒测试账号登录</p></li><li><p>沙箱环境自动续费时间缩短了，1周 对应 3分钟，1个月 对应 5分钟，2个月 对应 10分钟，3个月 对应 15分钟，6个月 对应 30分钟，一年 对应 1小时。</p></li><li><p>购买完一个一周 类型订阅，不要在APP不退出的情况等待了，必须3分钟 或是 10分钟后重新登录，Apple才会主动告知你结果。</p></li><li><p>沙箱环境自动续费是不一定的，要多测几个账号。</p></li></ul><p> 参考文章：<br> <a href="https://www.jianshu.com/p/17e0d11149f3" target="_blank" rel="noopener">iOS内购编程指南</a><br> <a href="https://www.jianshu.com/p/ebdeea271352" target="_blank" rel="noopener">IAP开发的那些坑</a><br> <a href="https://blog.csdn.net/kmyhy/article/details/75489241" target="_blank" rel="noopener">获取共享密钥</a><br> <a href="https://yimouleng.com/2015/12/17/ios-AppStore/" target="_blank" rel="noopener">iOS开发之内购-AppStore</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IAP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS人脸识别</title>
      <link href="/2018/11/29/iOS%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"/>
      <url>/2018/11/29/iOS%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="人脸识别的几种实现方式"><a href="#人脸识别的几种实现方式" class="headerlink" title="人脸识别的几种实现方式"></a>人脸识别的几种实现方式</h2><h3 id="Core-Image-静态识别"><a href="#Core-Image-静态识别" class="headerlink" title="Core Image 静态识别"></a>Core Image 静态识别</h3><h3 id="AVFoundation-动态识别"><a href="#AVFoundation-动态识别" class="headerlink" title="AVFoundation 动态识别"></a>AVFoundation 动态识别</h3><p><a href="https://github.com/guchunli/FaceDetectorDemo" target="_blank" rel="noopener">CoreImage和AVFoundation Demo</a></p><a id="more"></a><h3 id="OPENCV"><a href="#OPENCV" class="headerlink" title="OPENCV"></a>OPENCV</h3><p>OpenCV 是一个 C++ 的 API。</p><h4 id="集成-OpenCV-的常见错误"><a href="#集成-OpenCV-的常见错误" class="headerlink" title="集成 OpenCV 的常见错误"></a>集成 OpenCV 的常见错误</h4><ul><li><p>报错1：’opencv2/highgui/cap_ios.h’ file not found<br>解决：其在3.2.0版中已经移到videoio文件夹下，所以需要把 <code>#import &lt;opencv2/highgui/cap_ios.h&gt;</code> 改为 <code>#import &lt;opencv2/videoio/cap_ios.h&gt;</code>。</p></li><li><p>报错2：enum { NO, GAIN, GAIN_BLOCKS };    Expected identifier<br>只要把NO修改成 NO_EXPOSURE_COMPENSATOR 或 NO_EXPOSURE_COMPENSATOR = 0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//    enum &#123; NO, GAIN, GAIN_BLOCKS &#125;;</span><br><span class="line">enum &#123; NO_EXPOSURE_COMPENSATOR = 0, GAIN, GAIN_BLOCKS &#125;;</span><br></pre></td></tr></table></figure></li><li><p>设置OC与C++混合编译：Build Settings -&gt; Compile Source As：Objective-C++。</p></li></ul><p><a href="https://github.com/guchunli/OpenCVFaceDemo" target="_blank" rel="noopener">OpenCV Demo</a></p><h3 id="Vision"><a href="#Vision" class="headerlink" title="Vision"></a>Vision</h3><p>Apple 在 WWDC 2017 伴随iOS 11推出的基于CoreML的图像识别框架。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (void)beginRecognize&#123;</span><br><span class="line">    __block NSError *error;</span><br><span class="line">    // 创建处理requestHandler</span><br><span class="line">    VNImageRequestHandler *handler = [[VNImageRequestHandler alloc] initWithCIImage:[[CIImage alloc] initWithImage:image] options:@&#123;&#125;];</span><br><span class="line">    VNImageBasedRequest *request = [[VNImageBasedRequest alloc] init];</span><br><span class="line">    request = [[VNDetectFaceLandmarksRequest alloc] initWithCompletionHandler:^(VNRequest * _Nonnull request, NSError * _Nullable error) &#123;</span><br><span class="line">        NSArray *vnobservations = request.results;</span><br><span class="line"></span><br><span class="line">        if (vnobservations.count&lt;=0) &#123;</span><br><span class="line"></span><br><span class="line">        UIAlertController *alertContrller = [UIAlertController alertControllerWithTitle:@&quot;No face detected!&quot; message:@&quot;Sorry, we are NOT able to detect any face in this photo!&quot; preferredStyle:UIAlertControllerStyleAlert];</span><br><span class="line">        UIAlertAction *confirmAction = [UIAlertAction actionWithTitle:@&quot;Confirm&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;];</span><br><span class="line">        [alertContrller addAction:confirmAction];</span><br><span class="line">        [self presentViewController:alertContrller animated:YES completion:nil];</span><br><span class="line"></span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    request.preferBackgroundProcessing = YES;</span><br><span class="line">    // 发送识别请求 在后台执行 在更新UI的时候记得切换到主线程</span><br><span class="line">    //    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    //        [handler performRequests:@[requset] error:&amp;error];</span><br><span class="line">    //    &#125;);</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        [handler performRequests:@[request] error:&amp;error];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    if (error) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,error.localizedDescription);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="第三方"><a href="#第三方" class="headerlink" title="第三方"></a>第三方</h3><p>讯飞，腾讯，百度，七牛云，美摄，Amazon recognition,dlib，Face++。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人脸识别 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>redux学习笔记</title>
      <link href="/2018/10/30/redux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/10/30/redux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>在Javascript中，不可变操作有三种不同的实现方式：<br>1.使用Immutable.js创建不可变的数据结构。<br>2.使用JavaScript库(如Underscore和Lodash)来执行不可变的操作。<br>3.使用ES6方法执行不可变操作，<code>b = Object.assign([],a)</code>，也可以使用操作符(…)执行不可变操作。<br><a id="more"></a></p><h2 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h2><p>1.store：在Redux中，所有的数据（比如state）被保存在一个被称为store的容器中 → 在一个应用程序中只能有一个。store本质上是一个状态树，保存了所有对象的状态。任何UI组件都可以直接从store访问特定对象的状态。<br>2.action：要通过本地或远程组件更改状态，需要分发一个action。分发在这里意味着将可执行信息发送到store。当一个store接收到一个action，它将把这个action代理给相关的reducer。<br>3.reducer：reducer是一个纯函数，它可以查看之前的状态，执行一个action并且返回一个新的状态。<br>4.type - 一个简单的字符串常量，例如ADD, UPDATE, DELETE等。<br>5.payload - 用于更新状态的数据。</p><p>Redux工具调试：time-travelling tool</p><h2 id="安装React"><a href="#安装React" class="headerlink" title="安装React"></a>安装React</h2><p>react-redux帮助你完成数据订阅<br>redux-thunk可以放你实现异步action<br>redux-logger是redux的日志中间件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save redux react-redux redux-thunk</span><br><span class="line">npm install --save-dev redux-logger</span><br></pre></td></tr></table></figure></p><h2 id="注意八个问题"><a href="#注意八个问题" class="headerlink" title="注意八个问题"></a>注意八个问题</h2><p>1.<br>第一种更新本地状态的方式：this.setState()<br>通过this.setState()方法来更新状态.状态对象(state object)的更新过程是一次浅合并.因此你可以只更新本地状态中特定的某一部分状态,而其余的状态都不会受到影响.一旦状态更新完,组件就会重新渲染.<br>this.setState()方法是异步更新本地状态的.<br>问题：当你用this.setState()更新本地状态时,而本地状态又在异步执行更新完成之前改变了,这时你就操作了一个旧的状态.</p><p>第二种更新React本地状态的方式.<br>this.setState()函数可以接受一个函数作为参数而非对象.而这个回调函数的调用会传入在当下this.setState()异步执行后的本地状态作为参数.这个回调执行的时候就能获取到当前最新的,可信赖的本地状态.所以当你需要根据之前的本地状态来更新时,就可以使用传入函数给this.setState()而非对象.<br>this.setState(previousState =&gt; ({ counter: previousState.counter + 1 }));</p><p>另外,这也适用于依赖props的更新.在异步执行更新之前,从父组件获取到的props也有可能被改变过.所以传入this.setState()的回调会被注入第二个参数props.<br>this.setState((prevState, props) =&gt; …);</p><p>使用回调函数时的另外一个好处是能单独对状态更新进行测试.简单地把this.setState(fn)中的回调函数提取出来并导出(export)即可.这个回调函数应该是一个纯函数,你可以根据输入进行简单的输出测试.</p><p>2.React的State和Props<br>Props随着组件树往下传递,而State则由组件自己维护,此外通过往上层组件冒泡的函数可以改变组件中的State,而更新过后的State又以Props的形式往下传递.<br>组件可以管理很多State,这些State可以作为Props往下传递给子组件并且Props中可以传递函数给予子组件修改父组件的State.</p><p>3.提取React的State<br>往上提取：当更多的组件需要用到特定的State时,可以往上提取State,直到需要访问该State的组件的公共组件.此外,本地状态管理依然保持着可维护性,因为一个组件根据自身需求管理尽可能多的状态。<br>往下提取：如果组件或其子组件不需要该State的话,则可以往下提取State放置在需要的地方.就不会出现传递Props需要遍历整个组件树的情况了.</p><p>4.React高阶组件(HOC)<br>高阶组件是React中一种高级设计模式.你可以使用它来抽象功能,并将其作为其他多个组件的可选功能重用.高阶组件接受一个组件和其他可选配置作为参数并返回一个增强版本的组件.它建立在Javascript的高阶函数(返回函数的函数)的原则之上.</p><p>5.React上下文(Context)</p><p>6.React Stateful组件(带状态的组件)<br>React中有两种声明组件的方式: ES6类组件和函数(不带状态)组件.<br>（1）类组件：React类组件是可以保持State和能出发声明周期函数的.这些组件能访问this.state和调用this.setState()方法.这就说明了ES类组件是能带状态的组件.而如果他们不需要保持本地State的话,也可以是无状态组件.通常无状态的类组件也会需要使用声明周期函数.<br>（2）函数组件：一个不带状态的函数组件仅仅是一个接收Props并返回JSX的函数.其中不保持任何的State也不会触发任何React生命周期函数.顾名思义就是无状态的.</p><p>结论：<code>只有ES6类组件是可以带状态的,但是他们也可以是无状态的.而函数组件则是无状态的.</code><br>还可以使用高阶组件来添加状态到React组件上.当使用高阶组件时,你可以选择传递任意局部状态到React组件中去.</p><p>7.容器组件与展示组件<br>组件分为两类:容器组件和展示组件.<br>容器组件负责描述组件是如何工作的,展示组件负责组件内容的展示.容器组件一般是一个类组件,因为容器组件是需要管理本地状态的.<br>展示组件是一个无状态函数组件,因为一般只用于展示Props和调用从父组件传递过来的函数.</p><p>8.MobX &amp; Redux </p><p>参考资料：<br><a href="https://segmentfault.com/a/1190000011474522" target="_blank" rel="noopener">Redux入门教程（快速上手）</a><br><a href="https://segmentfault.com/a/1190000013725571" target="_blank" rel="noopener">在使用Redux前你需要知道关于React的8件事</a><br><a href="https://www.jianshu.com/p/06f5285e2620" target="_blank" rel="noopener">在React中使用Redux</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Go语言学习笔记</title>
      <link href="/2018/10/10/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/10/10/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="语言结构"><a href="#语言结构" class="headerlink" title="语言结构"></a>语言结构</h2><h3 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">/* 这是我的第一个简单的程序 */</span><br><span class="line">fmt.Println(&quot;Hello, World!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<code>{ 不能单独放在一行</code>。<br><a id="more"></a></p><ul><li>必须在源文件中非注释的第一行指明这个文件属于哪个包</li><li>import 导入包</li><li>main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。</li><li>Print 和 Println 输出</li><li>当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected ）。</li></ul><h3 id="执行-Go-程序"><a href="#执行-Go-程序" class="headerlink" title="执行 Go 程序"></a>执行 Go 程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go run hello.go</span><br></pre></td></tr></table></figure><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><ul><li>一行代表一个语句结束，不需要以分号 ; 结尾，多个语句写在同一行则必须使用 ; 区分。</li><li><code>//</code> 单行注释。 <code>/*</code>  <code>*/</code>多行注释 。</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>布尔<br>数字<br>字符串<br>派生类型</p><h2 id="语句变量"><a href="#语句变量" class="headerlink" title="语句变量"></a>语句变量</h2><h3 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title=":= 赋值操作符"></a>:= 赋值操作符</h3><p>注意：<code>:=</code>左侧的变量不应该是已经声明过的，否则会导致编译错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v_name := value</span><br></pre></td></tr></table></figure></p><h3 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h3><ul><li><p>值类型<br>int、float、bool 和 string 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值。<br>当使用等号 = 将一个变量的值赋值给另一个变量时，如：j = i，实际上是在内存中将 i 的值进行了拷贝。<br>可以通过 &amp;i 来获取变量 i 的内存地址，每次的地址都可能不一样。<br>值类型的变量的值存储在栈中。<br>内存地址会根据机器的不同而有所不同，甚至相同的程序在不同的机器上执行后也会有不同的内存地址。因为每台机器可能有不同的存储器布局，并且位置分配也可能不同。</p></li><li><p>引用类型<br>一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址（数字），或内存地址中第一个字所在的位置。这个内存地址为称之为指针，这个指针实际上也被存在另外的某一个字中。<br>同一个引用类型的指针指向的多个字可以是在连续的内存地址中（内存布局是连续的），这也是计算效率最高的一种存储形式；也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址。<br>当使用赋值语句 r2 = r1 时，只有引用（地址）被复制。<br>如果 r1 的值被改变了，那么这个值的所有引用都会指向被修改后的内容，在这个例子中，r2 也会受到影响。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python学习笔记</title>
      <link href="/2018/09/27/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/09/27/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="中文编码"><a href="#中文编码" class="headerlink" title="中文编码"></a>中文编码</h2><p> <code># -*- coding: UTF-8 -*-</code> 或者 <code>#coding=utf-8</code> 。</p><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><p>交互式编程<br>脚本式编程<br><a id="more"></a></p><h3 id="行和缩进"><a href="#行和缩进" class="headerlink" title="行和缩进"></a>行和缩进</h3><ul><li>python 最具特色的就是使用缩进来表示代码块。不使用大括号 {} 。</li><li>缩进的空白数量是可变的，但是同一个代码块的语句必须包含相同的缩进空格。<h3 id="多行"><a href="#多行" class="headerlink" title="多行"></a>多行</h3>可以使用斜杠（ \）将一行的语句分为多行显示，语句中包含 [], {} 或 () 括号就不需要使用多行连接符。<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3>单行注释采用 <code>#</code> 开头。多行注释使用三个单引号(‘’’)或三个双引号(“””)。<h3 id="等待用户输入"><a href="#等待用户输入" class="headerlink" title="等待用户输入"></a>等待用户输入</h3><code>input(&quot;按下 enter 键退出，其他任意键显示...\n&quot;)</code><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3>print() 默认输出是换行的，如果要实现不换行需要在变量末尾加上 <code>end=&quot;&quot;</code>，<code>print (&#39;hello&#39;, end=&quot; &quot;)</code>。<h3 id="代码组"><a href="#代码组" class="headerlink" title="代码组"></a>代码组</h3>首行以关键字开始，以冒号( : )结束<h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><code>$ python -h</code></li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li>Python 中的变量赋值不需要类型声明。</li><li>每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。</li><li>可以使用del语句删除一些对象的引用。<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="Numbers（数字）"><a href="#Numbers（数字）" class="headerlink" title="Numbers（数字）"></a>Numbers（数字）</h4></li><li>int bool float complex</li><li>isinstance 和 type 的区别在于：<br>  type()不会认为子类是一种父类类型。<br>  isinstance()会认为子类是一种父类类型。<br>注意：</li><li>变量在使用前必须先”定义”（即赋予变量一个值），否则会出现错误</li><li>可以同时为多个变量赋值，如a, b = 1, 2</li><li>一个变量可以通过赋值指向不同类型的对象</li><li>数值的除法包含两个运算符：<code>/</code> 返回一个浮点数，<code>//</code> 返回一个整数。</li><li><code>//</code> 得到的并不一定是整数类型的数，它与分母分子的数据类型有关系。<h4 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h4></li><li>使用引号(‘或”)来创建字符串</li><li><code>\</code>转义，<code>r</code>不转义。</li><li>\：在行尾时作为续行符。也可以使用 三引号”””…””” 或者 ‘’’…’’’ 跨越多行。</li><li>三引号：多行，可用在一块HTML或者SQL。</li><li>[头下标:尾下标]：截取，包含头下标的字符，但不包含尾下标的字符。下标是从 0 开始算起，可以是正数或负数，下标可以为空表示取到头或尾。</li><li>[]：获取字符串中的字符</li><li>+：连接运算符</li><li>*：重复操作</li><li>in/not in</li><li>%：格式化，<code>print (&quot;我叫 %s 今年 %d 岁!&quot; % (&#39;小明&#39;, 10))</code><br>注意：</li><li>不支持单字符类型，单字符在 Python 中也是作为一个字符串使用</li><li>字符串不能改变。</li><li>python的字串列表有2种取值顺序:<br>从左到右索引默认0开始的，最大范围是字符串长度少1（0，1，2，3，4，5）<br>从右到左索引默认-1开始的，最大范围是字符串开头（-6，-5，-4，-3，-2，-1）<h4 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h4></li><li><code>[]</code> 标识</li><li>列表中元素的类型可以不相同</li><li>截取：[头下标:尾下标]，包含头下标的元素，但不包含尾下标的元素。下标是从 0 开始算起，可以是正数或负数，下标可以为空表示取到头或尾。</li><li>加号（+）是字符串连接运算符，星号（*）是重复操作</li><li>列表中的元素是可以改变的</li><li>删除列表元素：<code>del list1[2]</code></li><li>列表元素个数：<code>len(list)</code></li><li>[]：获取列表中的元素</li><li>+：连接运算符</li><li>*：重复操作</li><li>in/not in</li><li>截取：list[2]  list[-2]  list[1:]</li><li>list(seq)：将元组转换为列表</li></ul><h4 id="Tuple（元组）"><a href="#Tuple（元组）" class="headerlink" title="Tuple（元组）"></a>Tuple（元组）</h4><ul><li><code>()</code> 标识</li><li>与列表类似，不同之处在于元组的元素不能修改。元组不能二次赋值，相当于只读列表。</li><li>元组中的元素类型也可以不相同</li><li>元组中只包含一个元素时，需要在元素后面添加逗号，<code>tup1 = (50,)</code>，否则括号会被当作运算符使用。</li><li>组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组</li><li>无关闭分隔符：任意无符号的对象，以逗号隔开，默认为元组<h4 id="Dictionary（字典）"><a href="#Dictionary（字典）" class="headerlink" title="Dictionary（字典）"></a>Dictionary（字典）</h4></li><li><code>{}</code> 标识</li><li>键的特性<ul><li>键(key)必须是唯一的</li><li>键必须不可变，所以可以用数字，字符串或元组充当，所以用列表就不行</li></ul></li><li>str(dict)：输出字典可打印的字符串表示。</li><li>dict.clear() 清空字典，del dict 删除字典<h4 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h4></li><li>是一个无序不重复元素的序列。基本功能是进行成员关系测试和删除重复元素。</li><li>大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典</li><li>add，update，remove(如果元素不存在，会发生错误)，discard(如果元素不存在，不会发生错误)，clear，<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3>将数据类型作为函数名</li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul><li><code>//</code>：取整除 - 返回商的整数部分（向下取整）</li><li>整数除整数，只能得出整数。如果要得到小数部分，把其中一个数改成浮点数即可。</li><li>==/!=</li><li>身份运算符：is/is not</li><li>成员运算符：in/not in</li><li>逻辑运算符：and/or/not</li><li>优先级：赋值&gt;身份&gt;成员&gt;逻辑</li></ul><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if condition_1:</span><br><span class="line">    statement_block_1</span><br><span class="line">elif condition_2:</span><br><span class="line">    statement_block_2</span><br><span class="line">else:</span><br><span class="line">    statement_block_3</span><br></pre></td></tr></table></figure><ul><li>指定任何非0和非空（null）值为true，0 或者 null为false。`</li><li>执行内容可以多行，以缩进来区分表示同一范围</li><li>不支持 <code>switch</code> 语句，所以多个条件判断，只能用 <code>elif</code> 来实现<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2></li><li>for循环和while循环（在Python中没有do..while循环）</li><li>循环控制：break continue pass(空语句)</li><li><p><code>while … else</code> 和 <code>for … else</code> 在循环条件为 false 时执行 else 语句块</p><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>for循环语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for iterating_var in sequence:</span><br><span class="line">    statements(s)</span><br></pre></td></tr></table></figure></li><li><p>通过序列索引迭代：<code>for index in range(len(fruits)):</code></p></li><li>遍历数字序列：<code>for num in range(10,20):</code></li></ul><h2 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h2><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器是一个可以记住遍历的位置的对象。<br>迭代器有两个基本的方法：iter() 和 next()。<br>迭代器对象可以使用常规for语句进行遍历：<br>iter()：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list=[1,2,3,4]</span><br><span class="line">it = iter(list)    # 创建迭代器对象</span><br><span class="line">for x in it:</span><br><span class="line">    print (x, end=&quot; &quot;)</span><br></pre></td></tr></table></figure></p><p>next()：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import sys         # 引入 sys 模块</span><br><span class="line"></span><br><span class="line">list=[1,2,3,4]</span><br><span class="line">it = iter(list)    # 创建迭代器对象</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    try:</span><br><span class="line">        print (next(it))</span><br><span class="line">    except StopIteration:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure></p><p>创建一个迭代器：需要在类中实现两个方法 <strong>iter</strong>() 与 <strong>next</strong>() 。</p><ul><li><strong>iter</strong>() 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 <strong>next</strong>() 方法并通过 StopIteration 异常标识迭代的完成。</li><li><strong>next</strong>() 方法（Python 2 里是 next()）会返回下一个迭代器对象。<br>可以在 <strong>next</strong>() 方法中触发 StopIteration 异常来结束迭代。</li></ul><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>使用了 yield 的函数被称为生成器（generator）。<br>生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。<br>在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。<br>调用一个生成器函数，返回的是一个迭代器对象。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def functionname( parameters ):</span><br><span class="line">    &quot;函数_文档字符串&quot;</span><br><span class="line">    function_suite</span><br><span class="line">    return [expression]</span><br></pre></td></tr></table></figure><ul><li>在 python 中，类型属于对象，变量是没有类型的，仅仅是一个对象的引用（一个指针）。</li><li>在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。</li><li>python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。<ul><li>不可变类型：传递的只是参数的值，没有影响参数本身。</li><li>可变类型：修改后fun外部的参数也会受影响<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3></li></ul></li><li>必备参数：须以正确的顺序传入函数。调用时的数量必须和声明时的一样。</li><li>关键字参数：允许函数调用时参数的顺序与声明时不一致。<code>printinfo( age=50, name=&quot;miki&quot; );</code></li><li>默认参数：<code>def printinfo( name, age = 35 ):</code>，调用<code>printinfo( name=&quot;miki&quot; );</code></li><li>不定长参数：加了星号（<em>）的变量名会存放所有未命名的变量参数。`def functionname([formal_args,] </em>var_args_tuple ):`</li><li>加了两个星号 <strong> 的参数会以字典的形式导入：`def functionname([formal_args,] </strong>var_args_dict ):`。</li><li>单独出现星号 <em> 后的参数必须用关键字传入：`def f(a,b,</em>,c):<code>，调用</code>f(1,2,c=3)`。</li></ul><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 可写函数说明</span><br><span class="line">sum = lambda arg1, arg2: arg1 + arg2;</span><br></pre></td></tr></table></figure><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><ul><li>L （Local） 局部作用域</li><li>E （Enclosing） 闭包函数外的函数中</li><li>G （Global） 全局作用域</li><li>B （Built-in） 内建作用域<br>以 L –&gt; E –&gt; G –&gt;B 的规则查找：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = int(2.9)  # 内建作用域</span><br><span class="line"></span><br><span class="line">g_count = 0  # 全局作用域</span><br><span class="line">def outer():</span><br><span class="line">    o_count = 1  # 闭包函数外的函数中</span><br><span class="line">    def inner():</span><br><span class="line">        i_count = 2  # 局部作用域</span><br></pre></td></tr></table></figure></li></ul><p><code>Python 中只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如 if/elif/else/、try/except、for/while等）是不会引入新的作用域的，也就是说这些语句内定义的变量，外部也可以访问。</code></p><p>global：内部作用域可以修改外部作用域的变量，修改全局变量。<br>nonlocal：修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li>将列表当做堆栈使用：append() pop()</li><li>列表推导式</li><li><code>del a[2:4]</code>删除一个切割，  <code>del a[:]</code>清空列表。</li><li>遍历技巧：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//遍历字典，同时获取key和value</span><br><span class="line">for k, v in dict.items():</span><br><span class="line">//遍历序列m，同时获取索引位置和对应值</span><br><span class="line">for i, v in enumerate(list1):</span><br><span class="line">//同时遍历两个或更多的序列，可以使用 zip() 组合</span><br><span class="line">for q, a in zip(questions, answers):</span><br><span class="line">//反向遍历一个序列</span><br><span class="line">for i in reversed(range(1, 10, 2)):</span><br><span class="line">//排序</span><br><span class="line">for f in sorted(basket):</span><br><span class="line">//去重</span><br><span class="line">for f in sorted(set(basket)):</span><br></pre></td></tr></table></figure></li></ul><h2 id="模块-Module"><a href="#模块-Module" class="headerlink" title="模块(Module)"></a>模块(Module)</h2><p>一个 Python 文件，以 .py 结尾。</p><h3 id="模块引入"><a href="#模块引入" class="headerlink" title="模块引入"></a>模块引入</h3><ul><li><p>import<br>模块引入：<code>import module1[, module2[,... moduleN]]</code><br>不管你执行了多少次import，一个模块只会被导入一次。<br>调用模块中的函数：模块名.函数名</p></li><li><p>from…import<br>从模块中导入一个指定的部分到当前命名空间中</p></li><li>from…import*<br>把一个模块的所有内容全都导入到当前的命名空间</li></ul><h3 id="搜索路径"><a href="#搜索路径" class="headerlink" title="搜索路径"></a>搜索路径</h3><ul><li>当前目录</li><li>PYTHONPATH</li><li>默认路径。UNIX下，默认路径一般为/usr/local/lib/python/。</li></ul><h3 id="name"><a href="#name" class="headerlink" title="name"></a><strong>name</strong></h3><p>一个模块被另一个程序第一次引入时，其主程序将运行。每个模块都有一个<strong>name</strong>属性，当其值是’<strong>main</strong>‘时，表明该模块自身在运行，否则是被引入。</p><h3 id="命名空间和作用域"><a href="#命名空间和作用域" class="headerlink" title="命名空间和作用域"></a>命名空间和作用域</h3><ul><li>如果要给函数内的全局变量赋值，必须使用 global 语句</li></ul><h3 id="特殊函数"><a href="#特殊函数" class="headerlink" title="特殊函数"></a>特殊函数</h3><ul><li>dir() 函数：一个排好序的字符串列表，内容是一个模块里定义过的名字</li><li>reload() 函数：重新导入之前导入过的模块</li></ul><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><ul><li>包是一种管理 Python 模块命名空间的形式</li><li><strong>init</strong>.py 用于标识当前文件夹是一个包。</li></ul><h2 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h2><ul><li>print</li><li>str()： 函数返回一个用户易读的表达形式。repr()： 产生一个解释器易读的表达形式。</li><li><p>str.format()：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;hello! I\&apos;m &#123;&#125;. &#123;&#125; years old.&apos;.format(&apos;Jack&apos;,18))</span><br><span class="line">print(&apos;hello! I\&apos;m &#123;name&#125;. &#123;age&#125; years old.&apos;.format(name=&apos;Jack&apos;,age=18))</span><br><span class="line">print(&apos;hello! I\&apos;m &#123;0&#125;. &#123;age&#125; years old.&apos;.format(&apos;Jack&apos;, age=18))</span><br><span class="line"></span><br><span class="line">//旧</span><br><span class="line">print(&apos;常量 PI 的值近似为：%5.3f。&apos; % math.pi)</span><br><span class="line">//新</span><br><span class="line">print(&apos;常量 PI 的值近似为 &#123;0:.3f&#125;。&apos;.format(math.pi))</span><br></pre></td></tr></table></figure></li><li><p>raw_input：读取键盘输入</p></li><li>input：可以接收一个Python表达式作为输入</li><li>文件：open/close/write/read/tell/seek/rename/remove/</li><li>pickle模块实现了基本的数据序列和反序列化。</li></ul><h2 id="文件-目录"><a href="#文件-目录" class="headerlink" title="文件/目录"></a>文件/目录</h2><p>os.mkdir/chdir/rmdir/</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>如果在try子句执行时没有发生异常，python将执行else语句后的语句（如果有else的话），然后控制流通过整个try语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">&lt;语句&gt;        #运行别的代码</span><br><span class="line">except &lt;名字&gt;：</span><br><span class="line">&lt;语句&gt;        #如果在try部份引发了&apos;name&apos;异常</span><br><span class="line">except &lt;名字&gt;，&lt;数据&gt;:</span><br><span class="line">&lt;语句&gt;        #如果引发了&apos;name&apos;异常，获得附加的数据</span><br><span class="line">else:</span><br><span class="line">&lt;语句&gt;        #如果没有异常发生</span><br></pre></td></tr></table></figure></p><p>try-finally 语句无论是否发生异常都将执行最后的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">&lt;语句&gt;</span><br><span class="line">finally:</span><br><span class="line">&lt;语句&gt;    #退出try时总会执行</span><br><span class="line">raise</span><br></pre></td></tr></table></figure></p><p>触发异常：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 定义函数</span><br><span class="line">def mye( level ):</span><br><span class="line">    if level &lt; 1:</span><br><span class="line">        raise Exception,&quot;Invalid level!&quot;</span><br><span class="line">        # 触发异常后，后面的代码就不会再执行</span><br><span class="line">try:</span><br><span class="line">    mye(0)            # 触发异常</span><br><span class="line">except Exception,err:</span><br><span class="line">    print 1,err</span><br><span class="line">else:</span><br><span class="line">    print 2</span><br></pre></td></tr></table></figure></p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="创建类"><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">class Employee:</span><br><span class="line">    &apos;所有员工的基类&apos;</span><br><span class="line">    empCount = 0</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, salary):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.salary = salary</span><br><span class="line">        Employee.empCount += 1</span><br><span class="line"></span><br><span class="line">    def displayCount(self):</span><br><span class="line">        print &quot;Total Employee %d&quot; % Employee.empCount</span><br><span class="line"></span><br><span class="line">    def displayEmployee(self):</span><br><span class="line">        print &quot;Name : &quot;, self.name,  &quot;, Salary: &quot;, self.salary</span><br></pre></td></tr></table></figure><ul><li>self代表类的实例，而非类</li></ul><h3 id="对象销毁（垃圾回收）"><a href="#对象销毁（垃圾回收）" class="headerlink" title="对象销毁（垃圾回收）"></a>对象销毁（垃圾回收）</h3><ul><li>使用引用计数</li><li>析构函数 <strong>del</strong> ：当对象不再被使用时，<strong>del</strong>方法运行</li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li><p>可以继承多个类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class C(A, B):   # 继承类 A 和 B</span><br></pre></td></tr></table></figure></li><li><p>issubclass()  isinstance()</p></li></ul><h3 id="类属性和方法"><a href="#类属性和方法" class="headerlink" title="类属性和方法"></a>类属性和方法</h3><ul><li><strong>private_attrs：两个下划线开头，声明该属性为私有属性，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.</strong>private_attrs。</li><li>类方法必须包含参数 self,且为第一个参数</li><li><strong>private_method：两个下划线开头，声明该方法为私有方法，不能在类的外部调用。在类的内部调用 self.</strong>private_methods。</li><li>Python不允许实例化的类访问私有数据，但你可以使用 object.<em>className__attrName（ 对象名.</em>类名__私有属性名 ）访问属性</li></ul><h3 id="单下划线、双下划线、头尾双下划线说明："><a href="#单下划线、双下划线、头尾双下划线说明：" class="headerlink" title="单下划线、双下划线、头尾双下划线说明："></a>单下划线、双下划线、头尾双下划线说明：</h3><ul><li><strong>foo</strong>: 定义的是特殊方法，一般是系统定义名字 ，类似 <strong>init</strong>() 之类的。</li><li>_foo: 以单下划线开头的表示的是 protected 类型的变量，即保护类型只能允许其本身与子类进行访问，不能用于 from module import *。</li><li>__foo: 双下划线的表示的是私有类型(private)的变量, 只能是允许这个类本身进行访问了。</li></ul><h1 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h1><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p><code>import re</code><br>从字符串的起始位置匹配一个模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.match(pattern, string, flags=0)</span><br></pre></td></tr></table></figure></p><p>扫描整个字符串并返回第一个成功的匹配：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.search(pattern, string, flags=0)</span><br></pre></td></tr></table></figure></p><p>compile 函数：用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。<br>findall：找到正则表达式所匹配的所有子串</p><h3 id="正则表达式模式"><a href="#正则表达式模式" class="headerlink" title="正则表达式模式"></a>正则表达式模式</h3><p>^                开头<br>$                结尾<br>.                匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，使用 ‘[.\n]’ 的模式。<br>[…]             一组字符<br>[^…]           一组字符之外<br>re<em>              0/n<br>re+             1/n<br>re?             0/1<br>re{ n}          n 个<br>re{ n, }        大于等于n个。”o{1,}” 等价于 “o+”。”o{0,}” 则等价于 “o</em>“。<br>re{ n, m}     n 到 m 次<br>|                  或者<br>\w              匹配字母数字及下划线，等价于[A-Za-z0-9_]。<br>\W             匹配非字母数字及下划线，等价于 [^A-Za-z0-9_]。<br>\s              匹配任意空白字符，等价于 [\t\n\r\f]。<br>\S              匹配任意非空字符，等价于 [^ \f\n\r\t\v]。<br>\d              匹配任意数字，等价于 [0-9]。<br>\D              匹配任意非数字，等价于 [^0-9]。</p><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>微信小程序学习笔记</title>
      <link href="/2018/09/13/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/09/13/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="代码构成"><a href="#代码构成" class="headerlink" title="代码构成"></a>代码构成</h1><ul><li>json 后缀的 JSON 配置文件</li><li>js 后缀的 JS 脚本逻辑文件</li><li>wxml 后缀的 WXML 模板文件</li><li>wxss 后缀的 WXSS 样式文件<a id="more"></a><h2 id="JSON-配置"><a href="#JSON-配置" class="headerlink" title="JSON 配置"></a>JSON 配置</h2><h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3>app.json：当前小程序的全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。写在 pages 字段的第一个页面就是这个小程序的首页（打开小程序看到的第一个页面）。<h3 id="页面配置"><a href="#页面配置" class="headerlink" title="页面配置"></a>页面配置</h3>page.json：可以独立定义每个页面的一些属性，页面中配置项会覆盖 app.json 的 window 中相同的配置项。<h3 id="工具配置"><a href="#工具配置" class="headerlink" title="工具配置"></a>工具配置</h3>project.config.json</li></ul><h2 id="JS-逻辑"><a href="#JS-逻辑" class="headerlink" title="JS 逻辑"></a>JS 逻辑</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ul><li>App() 函数用来注册一个小程序</li><li><p>onLaunch：小程序初始化完成时（全局只触发一次）</p></li><li><p>data：页面的初始数据</p><h4 id="生命周期回调函数"><a href="#生命周期回调函数" class="headerlink" title="生命周期回调函数"></a>生命周期回调函数</h4></li><li>onLoad：监听页面加载</li><li>onShow：监听页面显示，或从后台进入前台显示时</li><li>onReady：监听页面初次渲染完成，一个页面只会调用一次</li><li>onHide：监听页面隐藏/切入后台时</li><li>onUnload：监听页面卸载<h4 id="页面事件处理函数"><a href="#页面事件处理函数" class="headerlink" title="页面事件处理函数"></a>页面事件处理函数</h4></li><li>onPullDownRefresh：监听用户下拉动作</li><li>onReachBottom：页面上拉触底事件的处理函数</li><li>onShareAppMessage：用户点击右上角转发</li><li>onPageScroll：页面滚动触发事件的处理函数</li><li>onTabItemTap：当前是 tab 页时，点击 tab 时触发<h4 id="组件事件处理函数"><a href="#组件事件处理函数" class="headerlink" title="组件事件处理函数"></a>组件事件处理函数</h4></li><li><p>bindtap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;view bindtap=&quot;viewTap&quot;&gt; click me &lt;/view&gt;</span><br><span class="line">Page(&#123;</span><br><span class="line">viewTap: function() &#123;</span><br><span class="line">console.log(&apos;view tap&apos;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>Page.route</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">    onShow: function() &#123;</span><br><span class="line">        console.log(this.route)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>Page.prototype.setData(Object data, Function callback)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.直接修改 this.data 而不调用 this.setData 是无法改变页面的状态的，还会造成数据不一致。</span><br><span class="line">2.仅支持设置可 JSON 化的数据。</span><br><span class="line">3.单次设置的数据不能超过1024kB，请尽量避免一次设置过多的数据。</span><br><span class="line">4.请不要把 data 中任何一项的 value 设为 undefined ，否则这一项将不被设置并可能遗留一些潜在问题。</span><br></pre></td></tr></table></figure></li></ul><h4 id="other"><a href="#other" class="headerlink" title="other"></a>other</h4><ul><li>onError：小程序发生脚本错误，或者 api 调用失败时触发，会带上错误信息</li><li>onPageNotFound：小程序要打开的页面不存在时触发，会带上页面信息回调该函数</li></ul><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><h4 id="路由方式"><a href="#路由方式" class="headerlink" title="路由方式"></a>路由方式</h4><ul><li>初始化：小程序打开的第一个页面（新页面入栈）</li><li>打开新页面：调用 <code>API wx.navigateTo</code> 或使用组件 <code>&lt;navigator open-type=&quot;navigateTo&quot;/&gt;</code>（新页面入栈）</li><li>页面重定向：调用 <code>API wx.redirectTo</code> 或使用组件 <code>&lt;navigator open-type=&quot;redirectTo&quot;/&gt;</code>（当前页面出栈，新页面入栈）</li><li>页面返回：调用 <code>API wx.navigateBack</code> 或使用组件<code>&lt;navigator open-type=&quot;navigateBack&quot;&gt;</code>或用户按左上角返回按钮（页面不断出栈，直到目标返回页）</li><li>Tab 切换：调用 <code>API wx.switchTab</code> 或使用组件 <code>&lt;navigator open-type=&quot;switchTab&quot;/&gt;</code> 或用户切换 Tab（页面全部出栈，只留下新的 Tab 页面）</li><li>重启动：<code>调用 API wx.reLaunch</code> 或使用组件 <code>&lt;navigator open-type=&quot;reLaunch&quot;/&gt;</code>（页面全部出栈，只留下新的页面）</li></ul><h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips:"></a>Tips:</h4><ul><li>navigateTo, redirectTo 只能打开非 tabBar 页面。switchTab 只能打开 tabBar 页面。reLaunch 可以打开任意页面。</li><li>页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。</li><li>调用页面路由带的参数可以在目标页面的onLoad中获取。</li></ul><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><ul><li>通过全局函数 <code>getApp()</code> 可以获取全局的应用实例，如果需要全局的数据可以在 <code>App()</code> 中设置<h4 id="暴露"><a href="#暴露" class="headerlink" title="暴露"></a>暴露</h4></li><li>模块只有通过 module.exports 或者 exports 才能对外暴露接口。</li><li>exports 是 module.exports 的一个引用，因此在模块里边随意更改 exports 的指向会造成未知的错误。所以更推荐开发者采用 module.exports 来暴露模块接口。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// common.js</span><br><span class="line">function sayHello(name) &#123;</span><br><span class="line">console.log(`Hello $&#123;name&#125; !`)</span><br><span class="line">&#125;</span><br><span class="line">function sayGoodbye(name) &#123;</span><br><span class="line">console.log(`Goodbye $&#123;name&#125; !`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports.sayHello = sayHello</span><br><span class="line">exports.sayGoodbye = sayGoodbye</span><br></pre></td></tr></table></figure></li></ul><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>​在需要使用这些模块的文件中，使用 require(path) 将公共代码引入（tip: require 暂时不支持绝对路径）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">​var common = require(&apos;common.js&apos;)​</span><br></pre></td></tr></table></figure></p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><ul><li>以 on 开头的 API 用来监听某个事件是否触发</li><li>以 Sync 结尾的 API 都是同步 API</li><li><code>注意：多数 API 的回调都是异步，需要处理好代码逻辑的异步问题。</code></li></ul><h2 id="视图层"><a href="#视图层" class="headerlink" title="视图层"></a>视图层</h2><h3 id="WXML"><a href="#WXML" class="headerlink" title="WXML"></a>WXML</h3><p>Mustache 语法，双括号</p><h4 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;view&gt; &#123;&#123;message&#125;&#125; &lt;/view&gt;</span><br></pre></td></tr></table></figure><h4 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;view wx:for=&quot;&#123;&#123;array&#125;&#125;&quot; wx:for-index=&quot;idx&quot; wx:for-item=&quot;itemName&quot;&gt;</span><br><span class="line">&#123;&#123;idx&#125;&#125;: &#123;&#123;itemName.message&#125;&#125;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><h4 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;view wx:if=&quot;&#123;&#123;condition&#125;&#125;&quot;&gt; &lt;/view&gt;</span><br><span class="line">Page(&#123;</span><br><span class="line">data: &#123;</span><br><span class="line">condition: true</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p>定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;template name=&quot;msgItem&quot;&gt;</span><br><span class="line">&lt;view&gt;</span><br><span class="line">&lt;text&gt; &#123;&#123;index&#125;&#125;: &#123;&#123;msg&#125;&#125; &lt;/text&gt;</span><br><span class="line">&lt;text&gt; Time: &#123;&#123;time&#125;&#125; &lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p><p>使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template is=&quot;msgItem&quot; data=&quot;&#123;&#123;...item&#125;&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure></p><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>以bind或catch开头，然后跟上事件的类型。bind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;view bindtap=&quot;add&quot;&gt; &#123;&#123;count&#125;&#125; &lt;/view&gt;</span><br></pre></td></tr></table></figure></p><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><ul><li>import 有作用域的概念，即只会 import 目标文件中定义的 template，而不会 import 目标文件 import 的 template。</li><li>include 可以将目标文件除了 <template> <wxs> 外的整个代码引入，相当于是拷贝到 include 位置</wxs></template></li></ul><h3 id="WXSS样式"><a href="#WXSS样式" class="headerlink" title="WXSS样式"></a>WXSS样式</h3><ul><li>app.wxss 作为全局样式，page.wxss 仅对当前页面生效，会覆盖 app.wxss 中相同的选择器。</li><li>尺寸单位<br>rpx（responsive pixel）: 750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。</li><li><p>样式导入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;common.wxss&quot;;</span><br></pre></td></tr></table></figure></li><li><p>内联样式：<br>style：静态的样式统一写到 class 中。style 接收动态的样式，在运行时会进行解析，请尽量避免将静态的样式写进 style 中，以免影响渲染速度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;view style=&quot;color:&#123;&#123;color&#125;&#125;;&quot; /&gt;</span><br></pre></td></tr></table></figure></li></ul><p>class：用于指定样式规则，其属性值是样式规则中类选择器名(样式类名)的集合，样式类名不需要带上.，样式类名之间用空格分隔。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;view class=&quot;normal_view&quot; /&gt;</span><br></pre></td></tr></table></figure></p><ul><li>选择器：.class  #id  element  element,element  ::after  ::before</li></ul><h3 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h3><h4 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h4><p>Boolean,Number,String,Array,Object,EventHandler,Any</p><h4 id="公共属性"><a href="#公共属性" class="headerlink" title="公共属性"></a>公共属性</h4><p>id,class,style,hidden,<code>data-*</code>,<code>bind*</code>/<code>catch*</code></p><h3 id="WSX（WeiXin-Script）"><a href="#WSX（WeiXin-Script）" class="headerlink" title="WSX（WeiXin Script）"></a>WSX（WeiXin Script）</h3><p>WXS 代码可以编写在 wxml 文件中的 <wxs> 标签内，或以 .wxs 为后缀名的文件内。<br>wxs 模块均为单例，wxs 模块在第一次被引用时，会自动初始化为单例对象。多个页面，多个地方，多次引用，使用的都是同一个 wxs 模块对象。</wxs></p><ul><li>module 属性：当前 <wxs> 标签的模块名</wxs></li><li>src 属性可以用来引用其他的 wxs 文件模块。</li><li>exports: 通过该属性，可以对外共享本模块的私有变量与函数。</li><li>引入方式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var tools = require(&quot;./tools.wxs&quot;);</span><br><span class="line">//或者</span><br><span class="line">&lt;wxs src=&quot;./../tools.wxs&quot; module=&quot;tools&quot; /&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>number ： 数值<br>string ：字符串<br>boolean：布尔值<br>object：对象<br>function：函数<br>array : 数组<br>date：日期<br>regexp：正则</p><p><a href="https://developers.weixin.qq.com/miniprogram/dev/" target="_blank" rel="noopener">微信小程序开发文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android学习笔记</title>
      <link href="/2018/08/22/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/08/22/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="工程架构分解"><a href="#工程架构分解" class="headerlink" title="工程架构分解"></a>工程架构分解</h1><p>java：我们写Java代码的地方，业务功能都在这里实现<br>res：存放我们各种资源文件的地方，有图片，字符串，动画，音频等，还有各种形式的XML文件<br><a id="more"></a></p><h2 id="res"><a href="#res" class="headerlink" title="res"></a>res</h2><h3 id="图片资源："><a href="#图片资源：" class="headerlink" title="图片资源："></a>图片资源：</h3><p>drawable：存放各种位图文件，(.png，.jpg，.9png，.gif等)除此之外可能是一些其他的drawable类型的XML文件<br>mipmap-hdpi：高分辨率，一般我们把图片丢这里<br>mipmap-mdpi：中等分辨率，很少，除非兼容的的手机很旧<br>mipmap-xhdpi：超高分辨率，手机屏幕材质越来越好，以后估计会慢慢往这里过渡<br>mipmap-xxhdpi：超超高分辨率，这个在高端机上有所体现</p><h3 id="布局资源："><a href="#布局资源：" class="headerlink" title="布局资源："></a>布局资源：</h3><p>layout：该目录下存放的就是我们的布局文件，另外在一些特定的机型上，我们做屏幕适配，比如480*320这样的手机，我们会另外创建一套布局，就行：layout-480x320这样的文件夹！</p><h3 id="菜单资源："><a href="#菜单资源：" class="headerlink" title="菜单资源："></a>菜单资源：</h3><p>menu：在以前有物理菜单按钮，即menu键的手机上，用的较多，现在用的并不多，菜单项相关的资源xml可在这里编写，不知道谷歌会不会出新的东西来替代菜单了~</p><h3 id="values目录："><a href="#values目录：" class="headerlink" title="values目录："></a>values目录：</h3><p>demens.xml：定义尺寸资源<br>string.xml：定义字符串资源<br>styles.xml：定义样式资源<br>colors.xml：定义颜色资源<br>arrays.xml：定义数组资源<br>attrs.xml：自定义控件时用的较多，自定义控件的属性！<br>theme主题文件，和styles很相似，但是会对整个应用中的Actvitiy或指定Activity起作用，一般是改变窗口外观的！可在Java代码中通过setTheme使用，或者在Androidmanifest.xml中为&lt;application…&gt;添加theme的属性！ PS:你可能看到过这样的values目录：values-w820dp，values-v11等，前者w代表平板设备，820dp代表屏幕宽度；而v11这样代表在API(11)，即android 3.0后才会用到的！</p><h3 id="raw目录"><a href="#raw目录" class="headerlink" title="raw目录"></a>raw目录</h3><p>用于存放各种原生资源(音频，视频，一些XML文件等)，我们可以通过openRawResource(int id)来获得资源的二进制流！其实和Assets差不多，不过这里面的资源会在R文件那里生成一个资源id而已</p><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>动画有两种：属性动画和补间动画：<br>animator：存放属性动画的XML文件<br>anim：存放补间动画的XML文件</p><h2 id="三个重要文件"><a href="#三个重要文件" class="headerlink" title="三个重要文件"></a>三个重要文件</h2><p>MainActivity.java<br>activity_main：布局文件<br>AndroidManifest.xml ：Android配置文件</p><h2 id="签名打包"><a href="#签名打包" class="headerlink" title="签名打包"></a>签名打包</h2><p>Build -&gt; Generate Signed APK</p><h1 id="Android中的UI组件"><a href="#Android中的UI组件" class="headerlink" title="Android中的UI组件"></a>Android中的UI组件</h1><h2 id="View和ViewGroup"><a href="#View和ViewGroup" class="headerlink" title="View和ViewGroup"></a>View和ViewGroup</h2><p>在Android APP中，所有的用户界面元素都是由View和ViewGroup的对象构成的。</p><ul><li>View：所有可视化控件的父类,提供组件描绘和时间处理方法 </li><li>ViewGroup： View类的子类，可以拥有子控件,可以看作是容器<br>Android为我们提供了一个View和ViewGroup子类的集合，集合中提供了一些常用的输入控件(比如按钮和文本域)和各种各样的布局模式（比如线性或相对布局）。<h2 id="Android中有六大布局"><a href="#Android中有六大布局" class="headerlink" title="Android中有六大布局"></a>Android中有六大布局</h2><h3 id="LinearLayout-线性布局"><a href="#LinearLayout-线性布局" class="headerlink" title="LinearLayout(线性布局)"></a>LinearLayout(线性布局)</h3>wrap_content：按比例，orientation决定哪个方向比例划分<br>match_parent(fill_parent):需要计算</li></ul><ul><li>分割线：view或者LinearLayout divider + image<br><img src="/assets/20180822_Android/LinearLayout.jpg" alt="LinearLayout"></li></ul><h3 id="RelativeLayout-相对布局"><a href="#RelativeLayout-相对布局" class="headerlink" title="RelativeLayout(相对布局)"></a>RelativeLayout(相对布局)</h3><ul><li>gravity ignoreGravity</li><li>parent父容器</li><li>兄弟容器</li><li>margin：针对的是容器中的组件，可以设置为负数</li><li>padding：针对的是组件中的元素<br><img src="/assets/20180822_Android/RelativeLayout.png" alt="RelativeLayout"></li></ul><h3 id="TableLayout-表格布局"><a href="#TableLayout-表格布局" class="headerlink" title="TableLayout(表格布局)"></a>TableLayout(表格布局)</h3><ul><li>android:collapseColumns:设置需要被隐藏的列的序号</li><li>android:shrinkColumns:设置允许被收缩的列的列序号</li><li><p>android:stretchColumns:设置运行被拉伸的列的列序号<br><code>列号从0开始算</code>，<code>可以设置多个,用逗号隔开比如&quot;0,2&quot;,如果是所有列都生效,则用&quot;*&quot;号即可</code></p></li><li><p>android:layout_column=”2”:跳过第二个,直接显示到第三个格子处,从1开始算的!</p></li><li>android:layout_span=”4”:合并4个单元格,也就说这个组件占4个单元格</li></ul><h3 id="FrameLayout-帧布局"><a href="#FrameLayout-帧布局" class="headerlink" title="FrameLayout(帧布局)"></a>FrameLayout(帧布局)</h3><ul><li>android:foreground:*设置改帧布局容器的前景图像</li><li>android:foregroundGravity:设置前景图像显示的位置</li></ul><h3 id="AbsoluteLayout-绝对布局"><a href="#AbsoluteLayout-绝对布局" class="headerlink" title="AbsoluteLayout(绝对布局)"></a>AbsoluteLayout(绝对布局)</h3><h3 id="GridLayout-网格布局"><a href="#GridLayout-网格布局" class="headerlink" title="GridLayout(网格布局)"></a>GridLayout(网格布局)</h3><ul><li>先定义组件的对齐方式 <code>android:orientation</code> 水平或者竖直,设置多少行与多少列<code>android:columnCount</code>，<code>android:rowCount</code></li><li>设置组件所在的行或者列,记得是从0开始算的,不设置默认每个组件占一行一列</li><li>设置组件横跨几行<code>android:layout_columnSpan</code>或者几列;设置完毕后,需要在设置一个填充:android:layout_gravity = “fill”</li></ul><h2 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h2><h3 id="长度、宽度单位"><a href="#长度、宽度单位" class="headerlink" title="长度、宽度单位"></a>长度、宽度单位</h3><ul><li>dp(dip): device independent pixels(设备独立像素). 不同设备有不同的显示效果,这个和设备硬件有关，一般我们为了支持WVGA、HVGA和QVGA 推荐使用这个，不依赖像素。 </li><li>px: pixels(像素). 不同设备显示效果相同，一般我们HVGA代表320x480像素，这个用的比较多。 </li><li>pt: point，是一个标准的长度单位，1pt＝1/72英寸，用于印刷业，非常简单易用； </li><li>sp: scaled pixels(放大像素). 主要用于字体显示best for textsize。<h3 id="字体单位"><a href="#字体单位" class="headerlink" title="字体单位"></a>字体单位</h3>textSize：字体大小，单位一般是用sp</li></ul><h2 id="UI组件"><a href="#UI组件" class="headerlink" title="UI组件"></a>UI组件</h2><h3 id="TextView-文本框"><a href="#TextView-文本框" class="headerlink" title="TextView(文本框)"></a>TextView(文本框)</h3><ul><li>id：为TextView设置一个组件id，根据id，我们可以在Java代码中通过findViewById()的方法获取到该对象，然后进行相关属性的设置，又或者使用RelativeLayout时，参考组件用的也是id。</li><li>layout_width：组件的宽度，一般写：<strong>wrap_content</strong>或者<strong>match_parent(fill_parent)</strong>，前者是控件显示的内容多大，控件就多大，而后者会填满该控件所在的父容器；当然也可以设置成特定的大小，比如我这里为了显示效果，设置成了200dp。</li><li>layout_height：组件的高度，内容同上。</li><li>gravity：设置控件中内容的对齐方向，TextView中是文字，ImageView中是图片等等。</li><li>autoLink识别链接类型</li><li>html</li><li>SpannableString&amp;SpannableStringBuilder定制文本，前者针对的是不可变文本，而后者则是针对可变文本</li><li>marqueeRepeatLimit跑马灯效果</li><li>字间距：android:textScaleX：控制字体水平方向的缩放，默认值1.0f，值是float。Java中setScaleX(2.0f)。</li><li>行间距：android:lineSpacingExtra：设置行间距，如”3dp” android:lineSpacingMultiplier：设置行间距的倍数，如”1.2”。Java代码中可以通过: setLineSpacing方法来设置。</li><li>自动换行： android:singleLine 设置，默认为 false。</li></ul><h3 id="EditText-输入框"><a href="#EditText-输入框" class="headerlink" title="EditText(输入框)"></a>EditText(输入框)</h3><h3 id="Button-按钮-与-ImageButton-图像按钮"><a href="#Button-按钮-与-ImageButton-图像按钮" class="headerlink" title="Button(按钮)与 ImageButton(图像按钮)"></a>Button(按钮)与 ImageButton(图像按钮)</h3><h3 id="ImageView-图像视图"><a href="#ImageView-图像视图" class="headerlink" title="ImageView(图像视图)"></a>ImageView(图像视图)</h3><ul><li><p>src/background<br>1.background通常指的都是背景,而src指的是内容<br>2.当使用src填入图片时,是按照图片大小直接填充,并不会进行拉伸，而使用background填入图片,则是会根据ImageView给定的宽度来进行拉伸<br>3.Java代码中设置blackground和src属性:<br>前景(对应src属性):setImageDrawable( );<br>背景(对应background属性):setBackgroundDrawable( );</p></li><li><p>adjustViewBounds设置缩放是否保存原图长宽比<br>adjustViewBounds为true才会生效的属性：<br>android:maxHeight:设置ImageView的最大高度<br>android:maxWidth:设置ImageView的最大宽度</p></li><li><p>scaleType设置缩放类型</p></li></ul><h3 id="RadioButton-单选按钮-amp-Checkbox-复选框"><a href="#RadioButton-单选按钮-amp-Checkbox-复选框" class="headerlink" title="RadioButton(单选按钮)&amp;Checkbox(复选框)"></a>RadioButton(单选按钮)&amp;Checkbox(复选框)</h3><ul><li>getChildCount( )获得按钮组中的单选按钮的数目；</li><li>getChinldAt(i):根据索引值获取我们的单选按钮</li><li>isChecked( ):判断按钮是否选中</li></ul><p>获得选中的值的两种方式：<br>1.为每个CheckBox添加事件：setOnCheckedChangeListener<br>2.弄一个按钮，在点击后，对每个checkbox进行判断:isChecked()；</p><h3 id="开关按钮ToggleButton和开关Switch"><a href="#开关按钮ToggleButton和开关Switch" class="headerlink" title="开关按钮ToggleButton和开关Switch"></a>开关按钮ToggleButton和开关Switch</h3><h3 id="ProgressBar-进度条"><a href="#ProgressBar-进度条" class="headerlink" title="ProgressBar(进度条)"></a>ProgressBar(进度条)</h3><h3 id="SeekBar-拖动条"><a href="#SeekBar-拖动条" class="headerlink" title="SeekBar(拖动条)"></a>SeekBar(拖动条)</h3><h3 id="RatingBar-星级评分条"><a href="#RatingBar-星级评分条" class="headerlink" title="RatingBar(星级评分条)"></a>RatingBar(星级评分条)</h3><h3 id="ScrollView-滚动条"><a href="#ScrollView-滚动条" class="headerlink" title="ScrollView(滚动条)"></a>ScrollView(滚动条)</h3><h2 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h2><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>1.Java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//要显示的数据</span><br><span class="line">String[] strs = &#123;&quot;基神&quot;,&quot;B神&quot;,&quot;翔神&quot;,&quot;曹神&quot;,&quot;J神&quot;&#125;;</span><br><span class="line">//创建ArrayAdapter</span><br><span class="line">ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this,android.R.layout.simple_expandable_list_item_1,strs);</span><br><span class="line">//获取ListView对象，通过调用setAdapter方法为ListView设置Adapter设置适配器</span><br><span class="line">ListView list_test = (ListView) findViewById(R.id.list_test);</span><br><span class="line">list_test.setAdapter(adapter);</span><br></pre></td></tr></table></figure></p><p>2.Java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayAdapter&lt;CharSequence&gt; adapter = ArrayAdapter.createFromResource(this,</span><br><span class="line">R.array.myarray,android.R.layout.simple_list_item_multiple_choice );</span><br></pre></td></tr></table></figure></p><p>arrays.xml：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  </span><br><span class="line">&lt;resources&gt;  </span><br><span class="line">&lt;string-array name=&quot;myarray&quot;&gt;  </span><br><span class="line">&lt;item&gt;语文&lt;/item&gt;  </span><br><span class="line">&lt;item&gt;数学&lt;/item&gt;  </span><br><span class="line">&lt;item&gt;英语&lt;/item&gt;  </span><br><span class="line">&lt;/string-array&gt;      </span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SimpleAdapter myAdapter = new SimpleAdapter(getApplicationContext(), listitem, R.layout.list_item, new String[]&#123;&quot;touxiang&quot;, &quot;name&quot;, &quot;says&quot;&#125;, new int[]&#123;R.id.imgtou, R.id.name, R.id.says&#125;);</span><br></pre></td></tr></table></figure><h3 id="BaseAdapter及复用"><a href="#BaseAdapter及复用" class="headerlink" title="BaseAdapter及复用"></a>BaseAdapter及复用</h3><p>复用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public View getView(int position, View convertView, ViewGroup parent) &#123;</span><br><span class="line">    ViewHolder holder = null;</span><br><span class="line">    if(convertView == null)&#123;</span><br><span class="line">        convertView = LayoutInflater.from(mContext).inflate(R.layout.item_list_animal,parent,false);</span><br><span class="line">        holder = new ViewHolder();</span><br><span class="line">        holder.img_icon = (ImageView) convertView.findViewById(R.id.img_icon);</span><br><span class="line">        holder.txt_aName = (TextView) convertView.findViewById(R.id.txt_aName);</span><br><span class="line">        holder.txt_aSpeak = (TextView) convertView.findViewById(R.id.txt_aSpeak);</span><br><span class="line">        convertView.setTag(holder);   //将Holder存储到convertView中</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        holder = (ViewHolder) convertView.getTag();</span><br><span class="line">    &#125;</span><br><span class="line">    holder.img_icon.setBackgroundResource(mData.get(position).getaIcon());</span><br><span class="line">    holder.txt_aName.setText(mData.get(position).getaName());</span><br><span class="line">    holder.txt_aSpeak.setText(mData.get(position).getaSpeak());</span><br><span class="line">    return convertView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class ViewHolder&#123;</span><br><span class="line">    ImageView img_icon;</span><br><span class="line">    TextView txt_aName;</span><br><span class="line">    TextView txt_aSpeak;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="数据为空时，setEmptyView-设置空页面"><a href="#数据为空时，setEmptyView-设置空页面" class="headerlink" title="数据为空时，setEmptyView 设置空页面"></a>数据为空时，setEmptyView 设置空页面</h3><h3 id="更新数据，重新绘制"><a href="#更新数据，重新绘制" class="headerlink" title="更新数据，重新绘制"></a>更新数据，重新绘制</h3><p>notifyDataSetChanged()：判断是否需要重新渲染，如果当前item没有必要重新渲染 是不会重新渲染的，如果某个Item的状态发生改变，都会导致View的重绘，而重绘的并不是 所有的Item，而是View状态发生变化的那个Item</p><h2 id="GridView-网格视图"><a href="#GridView-网格视图" class="headerlink" title="GridView(网格视图)"></a>GridView(网格视图)</h2><h2 id="Spinner-列表选项框"><a href="#Spinner-列表选项框" class="headerlink" title="Spinner(列表选项框)"></a>Spinner(列表选项框)</h2><h2 id="AutoCompleteTextView-自动完成文本框"><a href="#AutoCompleteTextView-自动完成文本框" class="headerlink" title="AutoCompleteTextView(自动完成文本框)"></a>AutoCompleteTextView(自动完成文本框)</h2><h2 id="ExpandableListView-可折叠列表"><a href="#ExpandableListView-可折叠列表" class="headerlink" title="ExpandableListView(可折叠列表)"></a>ExpandableListView(可折叠列表)</h2><h2 id="ViewFlipper-翻转视图"><a href="#ViewFlipper-翻转视图" class="headerlink" title="ViewFlipper(翻转视图)"></a>ViewFlipper(翻转视图)</h2><p>和ViewPager不同，ViewPager是一页页的，而ViewFlipper则是一层层的</p><h2 id="Toast-吐司"><a href="#Toast-吐司" class="headerlink" title="Toast(吐司)"></a>Toast(吐司)</h2><h2 id="AlertDialog-对话框"><a href="#AlertDialog-对话框" class="headerlink" title="AlertDialog(对话框)"></a>AlertDialog(对话框)</h2><h2 id="ProgressDialog-进度条对话框"><a href="#ProgressDialog-进度条对话框" class="headerlink" title="ProgressDialog(进度条对话框)"></a>ProgressDialog(进度条对话框)</h2><h2 id="DatePickerDialog-日期选择对话框-与TimePickerDialog-时间选择对话框"><a href="#DatePickerDialog-日期选择对话框-与TimePickerDialog-时间选择对话框" class="headerlink" title="DatePickerDialog(日期选择对话框)与TimePickerDialog(时间选择对话框)"></a>DatePickerDialog(日期选择对话框)与TimePickerDialog(时间选择对话框)</h2><h2 id="PopupWindow-悬浮框"><a href="#PopupWindow-悬浮框" class="headerlink" title="PopupWindow(悬浮框)"></a>PopupWindow(悬浮框)</h2><h2 id="菜单-Menu"><a href="#菜单-Menu" class="headerlink" title="菜单(Menu)"></a>菜单(Menu)</h2><h2 id="ViewPager"><a href="#ViewPager" class="headerlink" title="ViewPager"></a>ViewPager</h2><h2 id="DrawerLayout-官方侧滑菜单"><a href="#DrawerLayout-官方侧滑菜单" class="headerlink" title="DrawerLayout(官方侧滑菜单)"></a>DrawerLayout(官方侧滑菜单)</h2><h1 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h1><h2 id="基于监听的事件处理机制"><a href="#基于监听的事件处理机制" class="headerlink" title="基于监听的事件处理机制"></a>基于监听的事件处理机制</h2><p>1.直接用匿名内部类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">btnshow.setOnClickListener(new OnClickListener() &#123;    </span><br><span class="line">    //重写点击事件的处理方法onClick()    </span><br><span class="line">    @Override    </span><br><span class="line">    public void onClick(View v) &#123;    </span><br><span class="line">        //显示Toast信息    </span><br><span class="line">        Toast.makeText(getApplicationContext(), &quot;你点击了按钮&quot;, Toast.LENGTH_SHORT).show();    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>2.使用内部类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//直接new一个内部类对象作为参数    </span><br><span class="line">btnshow.setOnClickListener(new BtnClickListener());    </span><br><span class="line"></span><br><span class="line">//定义一个内部类,实现View.OnClickListener接口,并重写onClick()方法    </span><br><span class="line">class BtnClickListener implements View.OnClickListener    </span><br><span class="line">&#123;    </span><br><span class="line">@Override    </span><br><span class="line">public void onClick(View v) &#123;    </span><br><span class="line">Toast.makeText(getApplicationContext(), &quot;按钮被点击了&quot;, Toast.LENGTH_SHORT).show();   </span><br><span class="line">&#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.直接使用Activity作为事件监听器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//直接写个this    </span><br><span class="line">btnshow.setOnClickListener(this);    </span><br><span class="line">  </span><br><span class="line">//重写接口中的抽象方法    </span><br><span class="line">@Override    </span><br><span class="line">public void onClick(View v) &#123;    </span><br><span class="line">Toast.makeText(getApplicationContext(), &quot;点击了按钮&quot;, Toast.LENGTH_SHORT).show();         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4.直接绑定到标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">android:onClick=&quot;myclick&quot;/&gt;</span><br><span class="line"></span><br><span class="line">setContentView(R.layout.activity_main);     </span><br><span class="line"></span><br><span class="line">//自定义一个方法,传入一个view组件作为参数    </span><br><span class="line">public void myclick(View source)    </span><br><span class="line">&#123;    </span><br><span class="line">Toast.makeText(getApplicationContext(), &quot;按钮被点击了&quot;, Toast.LENGTH_SHORT).show();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><ul><li><ol><li>Activity用于显示用户界面，用户通过Activity交互完成相关操作</li></ol></li><li><ol start="2"><li>一个App允许有多个Activity<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><h2 id="BroadCastReceiver"><a href="#BroadCastReceiver" class="headerlink" title="BroadCastReceiver"></a>BroadCastReceiver</h2><h2 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h2></li></ol></li></ul><h1 id="Drawable"><a href="#Drawable" class="headerlink" title="Drawable"></a>Drawable</h1><h2 id="Drawable分为两种"><a href="#Drawable分为两种" class="headerlink" title="Drawable分为两种"></a>Drawable分为两种</h2><ul><li>普通的图片资源，在Android Studio中我们一般放到res/mipmap目录下， 另外我们如果把工程切换成Android项目模式，我们直接 往mipmap目录下丢图片即可，AS会自动分hdpi，xhdpi…</li><li>编写的XML形式的Drawable资源，我们一般把他们放到res/drawable目录 下，比如最常见的按钮点击背景切换的Selector</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>1.在XML我们直接通过@mipmap或者@drawable设置Drawable即可 比如: android:background = “@mipmap/iv_icon_zhu” / “@drawable/btn_back_selctor”<br>2.在Java代码中我们可以通过Resource的getDrawable(R.mipmap.xxx)可以获得drawable资源 如果是为某个控件设置背景，比如ImageView，我们可以直接调用控件.getDrawale()同样 可以获得drawable对象</p><h2 id="Android中drawable中的资源名称的约束"><a href="#Android中drawable中的资源名称的约束" class="headerlink" title="Android中drawable中的资源名称的约束"></a>Android中drawable中的资源名称的约束</h2><ul><li>必须是：[a-z0-9_.]，注意小写</li><li>不能以数字开头，否则编译会报错</li></ul><h2 id="13种Drawable"><a href="#13种Drawable" class="headerlink" title="13种Drawable"></a>13种Drawable</h2><h3 id="ColorDrawable（）"><a href="#ColorDrawable（）" class="headerlink" title="ColorDrawable（）"></a>ColorDrawable（<color>）</color></h3><p>1）Java中定义ColorDrawable:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ColorDrawable drawable = new ColorDrawable(0xffff2200);  </span><br><span class="line">txtShow.setBackground(drawable);</span><br></pre></td></tr></table></figure></p><p>2）建立一个color.xml文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">比如：</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  </span><br><span class="line">&lt;resources&gt;  </span><br><span class="line">&lt;color name=&quot;material_grey_100&quot;&gt;#fff5f5f5&lt;/color&gt;</span><br><span class="line">&lt;color name=&quot;material_grey_300&quot;&gt;#ffe0e0e0&lt;/color&gt;</span><br><span class="line">&lt;color name=&quot;material_grey_50&quot;&gt;#fffafafa&lt;/color&gt;</span><br><span class="line">&lt;color name=&quot;material_grey_600&quot;&gt;#ff757575&lt;/color&gt;</span><br><span class="line">&lt;color name=&quot;material_grey_800&quot;&gt;#ff424242&lt;/color&gt;</span><br><span class="line">&lt;color name=&quot;material_grey_850&quot;&gt;#ff303030&lt;/color&gt;</span><br><span class="line">&lt;color name=&quot;material_grey_900&quot;&gt;#ff212121&lt;/color&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></p><p>获取颜色：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int mycolor = getResources().getColor(R.color.mycolor);    </span><br><span class="line">btn.setBackgroundColor(mycolor);</span><br></pre></td></tr></table></figure></p><p>注意：直接定义颜色值要加上0x,而且不能把透明度漏掉。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int mycolor = 0xff123456;    </span><br><span class="line">btn.setBackgroundColor(mycolor);</span><br></pre></td></tr></table></figure></p><p>3）使用系统定义好的color:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">btn.setBackgroundColor(Color.BLUE); </span><br><span class="line">//或者</span><br><span class="line">int getcolor = Resources.getSystem().getColor(android.R.color.holo_green_light);  </span><br><span class="line">btn.setBackgroundColor(getcolor);</span><br></pre></td></tr></table></figure></p><p>4）利用静态方法argb来设置颜色:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">txtShow.setBackgroundColor(Color.argb(0xff, 0x00, 0x00, 0x00));</span><br></pre></td></tr></table></figure></p><h3 id="NinePatchDrawable（-9图）（）"><a href="#NinePatchDrawable（-9图）（）" class="headerlink" title="NinePatchDrawable（.9图）（）"></a>NinePatchDrawable（.9图）（<nine-patch>）</nine-patch></h3><p>Android FrameWork在显示点九图时使用了高效的 图形优化算法,我们不需要特殊的处理，就可以实现图片拉伸的自适应<br>1.点9图不能放在mipmap目录下，而需要放在drawable目录下！<br>2.AS中的.9图，必须要有黑线，不然编译都不会通过</p><h3 id="ShapeDrawable（）"><a href="#ShapeDrawable（）" class="headerlink" title="ShapeDrawable（）"></a>ShapeDrawable（<shape>）</shape></h3><p>定义基本的几何图形。</p><h3 id="GradientDrawable"><a href="#GradientDrawable" class="headerlink" title="GradientDrawable"></a>GradientDrawable</h3><p>可以实现线性渐变,发散渐变和平铺渐变效果，核心节点：<gradient>。</gradient></p><h3 id="BitmapDrawable（）"><a href="#BitmapDrawable（）" class="headerlink" title="BitmapDrawable（）"></a>BitmapDrawable（<bitmap>）</bitmap></h3><p>可以设置它包装的bitmap在BitmapDrawable区域中的绘制方式,有: 平铺填充,拉伸填充或保持图片原始大小。</p><h3 id="InsertDrawable（）"><a href="#InsertDrawable（）" class="headerlink" title="InsertDrawable（）"></a>InsertDrawable（<insert>）</insert></h3><p>padding表示的是Drawable的内容与Drawable本身的边距<br>InsetDrawable表示的是两个Drawable与容器之间的边距<br>当控件需要的背景比实际的边框 小的时候,比较适合使用InsetDrawable</p><h3 id="ClipDrawable（）"><a href="#ClipDrawable（）" class="headerlink" title="ClipDrawable（）"></a>ClipDrawable（<clip>）</clip></h3><p>从位图上剪下一个部分</p><h3 id="RotateDrawable（）"><a href="#RotateDrawable（）" class="headerlink" title="RotateDrawable（）"></a>RotateDrawable（<rotate>）</rotate></h3><h3 id="AnimationDrawable（）"><a href="#AnimationDrawable（）" class="headerlink" title="AnimationDrawable（）"></a>AnimationDrawable（<animation-list>）</animation-list></h3><h3 id="LayerDrawable（）"><a href="#LayerDrawable（）" class="headerlink" title="LayerDrawable（）"></a>LayerDrawable（<layer-list>）</layer-list></h3><h3 id="TransitionDrawable（）"><a href="#TransitionDrawable（）" class="headerlink" title="TransitionDrawable（）"></a>TransitionDrawable（<transition>）</transition></h3><p>LayerDrawable的一个子类，TransitionDrawable只管理两层的Drawable。并且提供了透明度变化的动画，可以控制一层Drawable过度到另一层Drawable的动画效果。</p><h3 id="LevelListDrawable（）"><a href="#LevelListDrawable（）" class="headerlink" title="LevelListDrawable（）"></a>LevelListDrawable（<level-list>）</level-list></h3><p>用来管理一组Drawable的,我们可以为里面的drawable设置不同的level， 当他们绘制的时候，会根据level属性值获取对应的drawable绘制到画布上</p><h3 id="StateListDrawable（）"><a href="#StateListDrawable（）" class="headerlink" title="StateListDrawable（）"></a>StateListDrawable（<selector>）</selector></h3><p>可以为按钮设置不同状态的drawable。<br>selctor_btn.xml：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">&lt;item android:state_pressed=&quot;true&quot; android:drawable=&quot;@drawable/shape_btn_pressed&quot;/&gt;</span><br><span class="line">&lt;item android:drawable=&quot;@drawable/shape_btn_normal&quot;/&gt;</span><br><span class="line">&lt;/selector&gt;</span><br></pre></td></tr></table></figure></p><p>按钮设置：android:background=”@drawable/selctor_btn”</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>圣托里尼</title>
      <link href="/2018/08/11/%E5%9C%A3%E6%89%98%E9%87%8C%E5%B0%BC/"/>
      <url>/2018/08/11/%E5%9C%A3%E6%89%98%E9%87%8C%E5%B0%BC/</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/20180811_Santorini/01.jpg" alt="圣托里尼"><br><a id="more"></a><br>圣托里尼由三个小岛组成。岛的一边紧靠火山口有四个小镇费拉（Fhira），Imerovigli，Firostefani以及伊亚（Oia）。<br><img src="/assets/20180811_Santorini/02.jpg" alt="圣托里尼"><br>伊亚镇建立在海边的悬崖上，是圣托里尼岛第二大镇，被认为是世界上观看落日最美的地方。每天都会有成千上万的来自世界各地的游客聚集在这里享受落日落的余晖，在太阳落下的那一瞬间，时间仿佛停滞了，太阳慢慢消失在地平线，镇上却突然变得宁静安详。每个人脸上都突然带上微笑，安静的送走夕阳的最后一抹余晖，每个人都陶醉在这人间美景中，大家都会情不自禁的鼓掌，他们被大自然的美景折服了。<br><img src="/assets/20180811_Santorini/03.png" alt="圣托里尼"><br><img src="/assets/20180811_Santorini/04.jpg" alt="圣托里尼"><br>伊亚以日落景色最迷人。当黄昏，游人便会纷至沓来，威尼斯城堡或风车总是人满为患。因为在这里，才能欣赏到圣托里尼岛最著名的“日落爱琴海”的美景。 与费拉市一样，伊亚在临海的断崖上。那些建在悬崖上的蓝顶教堂与彩色小屋十分突出。这里也有无数精致的白色房屋，还有传统的希腊式风车，在柔和的夕阳照耀下令人迷醉。伊亚是费拉市西北尽头的一个美丽城镇，位于圣托里尼岛北面，从费拉市可乘巴士直达。爱悠闲宁静的人不妨在这里多住几天。<br><img src="/assets/20180811_Santorini/05.jpg" alt="圣托里尼"></p><p>世界上有三座蓝城，圣托里尼，摩洛哥，突尼斯。（如果用纯净来形容一个地方）</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>iOS中layoutSubviews</title>
      <link href="/2018/08/09/iOS%E4%B8%ADlayoutSubviews/"/>
      <url>/2018/08/09/iOS%E4%B8%ADlayoutSubviews/</url>
      
        <content type="html"><![CDATA[<h2 id="触发layoutSubviews方法的条件"><a href="#触发layoutSubviews方法的条件" class="headerlink" title="触发layoutSubviews方法的条件"></a>触发layoutSubviews方法的条件</h2><ul><li>初始化不会触发layoutSubviews，但是如果设置了不为CGRectZero的frame的时候就会触发。</li><li>addSubview会触发layoutSubviews</li><li>设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化<a id="more"></a></li><li>滚动一个UIScrollView会触发layoutSubviews</li><li>旋转Screen会触发父UIView上的layoutSubviews事件</li><li>改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件</li></ul><h2 id="setNeedsLayOut-setNeedsDisplay"><a href="#setNeedsLayOut-setNeedsDisplay" class="headerlink" title="setNeedsLayOut / setNeedsDisplay"></a>setNeedsLayOut / setNeedsDisplay</h2><ul><li>当需要刷新布局时，用setNeedsLayOut方法</li><li>当需要重新绘画时，调用setNeedsDisplay方法。</li></ul><h2 id="setNeedsLayout-layoutIfNeeded"><a href="#setNeedsLayout-layoutIfNeeded" class="headerlink" title="setNeedsLayout / layoutIfNeeded"></a>setNeedsLayout / layoutIfNeeded</h2><ul><li>layoutIfNeeded不一定会调用layoutSubviews方法。</li><li>setNeedsLayout一定会调用layoutSubviews方法（有延迟，在下一轮runloop结束前）。<br>如果想在当前runloop中立即刷新，调用顺序应该是<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[self setNeedsLayout];</span><br><span class="line">[self layoutIfNeeded];</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>iOS中view的生命周期</title>
      <link href="/2018/08/03/iOS%E4%B8%ADview%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2018/08/03/iOS%E4%B8%ADview%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="app-的生命周期"><a href="#app-的生命周期" class="headerlink" title="app 的生命周期"></a>app 的生命周期</h2><h3 id="APP的5种状态"><a href="#APP的5种状态" class="headerlink" title="APP的5种状态"></a>APP的5种状态</h3><ul><li>Not running未运行：app没启动或被迫终止。<a id="more"></a></li><li>Inactive未激活：当前应用正在前台运行，但是并不接收事件（当前或许正在执行其它代码）。一般每当应用要从一个状态切换到另一个不同的状态时，中途过渡会短暂停留在此状态。唯一在此状态停留时间比较长的情况是：当用户锁屏时，或者系统提示用户去响应某些（诸如电话来电、有未读短信等）事件的时候。</li><li>Active激活：当前应用正在前台运行，并且接收事件。这是应用正在前台运行时所处的正常状态。</li><li>Backgroud后台：程序在后台而且能执行代码，大多数程序进入这个状态后会在在这个状态上停留一会。时间到之后会进入挂起状态(Suspended)。经过特殊的请求后可以长期处于Backgroud状态。</li><li>Suspended挂起：程序在后台不能执行代码。系统会自动把程序变成这个状态而且不会发出通知。当挂起时，程序还是停留在内存中的，当系统内存低时，系统就把挂起的程序清除掉，为前台程序提供更多的内存。</li></ul><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p>application:didFinishLaunchingWithOptions:   这是程序启动时调用的函数。<br>applicationDidBecomeActive:  应用在准备进入前台运行时执行的函数。<br>applicationWillResignActive:   应用当前正要从前台运行状态离开时执行的函数。<br>applicationDidEnterBackground: 此时应用处在background状态，并且没有执行任何代码，未来将被挂起进入suspended状态。<br>applicationWillEnterForeground:  当前应用正从后台移入前台运行状态，但是当前还没有到Active状态时执行的函数。<br>applicationWillTerminate:  当前应用即将被终止，在终止前调用的函数。如果应用当前处在suspended，此方法不会被调用。</p><p><img src="/assets/20180803_lifecycle/AppDelegate.png" alt="app运行流程"></p><ul><li><p>APP启动<br>application:didFinishLaunchingWithOptions:<br>applicationDidBecomeActive</p></li><li><p>按home键<br>applicationWillResignActive<br>applicationDidEnterBackground</p></li><li><p>再次回到前台<br>applicationWillEnterForeground<br>applicationDidBecomeActive</p></li><li><p>当URL请求到达时，如果你的应用没在正在运行，则会被启动并且移到前台运行以打开URL。<br>application:didFinishLaunchingWithOptions:<br>application:openURL:sourceApplication:<br>applicationDidBecomeActive</p></li><li><p>当URL请求到来时，如果你的应用正在background运行或被suspended，它将会被移到前台以打开URL。<br>从第三方分享回来：<br>applicationWillEnterForeground<br>application:openURL:sourceApplication:<br>applicationDidBecomeActive</p></li><li><p>当一个基于警告的中断（诸如电话来电）发生时，应用会暂时从active状态切换到Inactive状态，以给系统提供机会提示用户，让用户决定如何处理。在用户决定如何处理此中断警告之前，应用将一直处于Inactive状态。 在用户做出选择后，当前应用或者回到active状态继续运行，或者直接切换到background状态以让位于其它的应用运行。<br>对于基于警告的中断将会导致用户暂时对应用失去控制。当前应用继续在前台foreground运行，但是不再接收任何触控事件。（事实上，应用只是不再接收触控类事件，其它类型的事件比如accelerometer事件，和通知Notification，应用仍然接收。）</p></li><li><p>当系统内存不足时，系统会强行关闭那些尚在内存中但处于后台状态的 app，以腾出足够的内存供使用。但是那些被强行关闭的程序不会调用任何UIApplicationDelegate的委托方法，只会得到一个KILL 信号。当我们长按app icon，强行关闭app，也是同样的处理过程。</p></li></ul><h2 id="ViewController-的生命周期"><a href="#ViewController-的生命周期" class="headerlink" title="ViewController 的生命周期"></a>ViewController 的生命周期</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">init</span><br><span class="line">//第一次加载到内存</span><br><span class="line">loadView                //加载view</span><br><span class="line">viewDidLoad             //view加载完毕</span><br><span class="line"></span><br><span class="line">//显示布局相关</span><br><span class="line">viewWillAppear          //view将要显示</span><br><span class="line">viewWillLayoutSubViews  //view将要布局子视图</span><br><span class="line">viewDidLayoutSubViews   //view完成布局子视图</span><br><span class="line">viewDidAppear           //view完全显示</span><br><span class="line">viewWillDisAppear       //view即将消失</span><br><span class="line">viewDidDisappear        //view完全消失</span><br></pre></td></tr></table></figure><ul><li>init<br>init里不要出现创建view的代码。良好的设计，在init里应该只有相关数据的初始化，而且这些数据都是比较关键的数据。init里不要掉self.view，否则会导致viewcontroller创建view。（因为view是lazyinit的）。</li><li>loadView<br>loadView只初始化view，一般用于创建比较关键的view如tableViewController的tabView，UINavigationController的navgationBar，不可掉用view的getter（在掉super loadView前），最好也不要初始化一些非关键的view。如果你是从nib文件中创建的viewController在这里一定要首先调用super的loadView方法，但建议不要重载这个方法。</li><li>didReceiveMemoryWarning<br>当app收到内存警告的时候会发消息给视图控制器。<br>app从来不会直接调用这个方法，而是当系统确定可用内存不足的时候采取调用。<br>如果你想覆写这个方法来释放一些控制器使用的额外内存，你应该在你的实现方法中调用父类的实现方法。</li><li>viewWillUnload：（iOS6废除）</li><li>viewDidUnload：（iOS6废除）</li></ul><h3 id="view的加载过程"><a href="#view的加载过程" class="headerlink" title="view的加载过程"></a>view的加载过程</h3><p><img src="/assets/20180803_lifecycle/view_lifecycle.png" alt="view的加载过程"></p><p>1.View创建:loadView<br>1.从Storyboard／Xib加载视图时会调用的方法<br>1).initWithCoder<br>2).awakeFromNib: 此时frameh还没有完成。</p><p>2.手写代码：<br>1).initWithCoder<br>2).initWithFrame，创建时init会调用此方法。不过此时frame为0,除非显示调用此方法,frame才会有值。</p><p>view采用懒加载的方式，只有用到view时才会被创建，即才会被调用loadView-&gt;viewDidLoad这一系列函数，控制器的View是延迟加载的: 创建控制器并不一定会创建控制器的view,等用到时再加载。</p><h3 id="layoutSubViews"><a href="#layoutSubViews" class="headerlink" title="layoutSubViews"></a>layoutSubViews</h3><ul><li>layoutSubViews方法由系统来调用，不能程序员来调用。</li><li>可以调用setNeedsLayout方法进行标记,以保证在UI下个刷屏系统中会调用layoutSubviews。</li><li>可以调用layoutIfNeeded直接请求系统调用layoutSubviews。</li></ul><p>layoutSubViews的被调用时机：<br>1.addSubView会触发layoutSubviews,比如ivewA add ViewB，第一次添加A和B的layoutSubviews都会被调用，而第二次( viewA 已经有了viewB)只调用viewB的。<br>2.view的frame改变会触发layoutSubViews。<br>3.滚动一个UIScrollView会触发layoutSubviews。<br>4.旋转Screen会触发UIView的layoutSubviews。<br>5.改变transform属性时，当然frame也会变。<br>6.处于key window的UIView才会被调用( 程序同一时间只有一个window为keyWindow，可以简单理解为显示在最前面的window的keywindow)。</p><h2 id="UIScrollView-的代理方法调用顺序"><a href="#UIScrollView-的代理方法调用顺序" class="headerlink" title="UIScrollView 的代理方法调用顺序"></a>UIScrollView 的代理方法调用顺序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/***手离开屏幕时没有移动的速度（Pan）***/</span><br><span class="line">//开始移动（并没有移动只是touch上去）</span><br><span class="line">- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView;  </span><br><span class="line"></span><br><span class="line">//移动之后就会改变contentOffset，所以就会调用改方法</span><br><span class="line">- (void)scrollViewDidScroll:(UIScrollView *)scrollView; </span><br><span class="line"></span><br><span class="line">//将要结束移动（手指停止移动但是没有离开屏幕）</span><br><span class="line">- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset  </span><br><span class="line">//结束移动和是否要减速</span><br><span class="line">- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate;</span><br><span class="line"></span><br><span class="line">/***手离开屏幕时有速度（Swipe）***/</span><br><span class="line">//将要开始减速</span><br><span class="line">- (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView;</span><br><span class="line">//减速时的屏幕出现content Offset改变</span><br><span class="line">- (void)scrollViewDidScroll:(UIScrollView *)scrollView; </span><br><span class="line">//结束减速  </span><br><span class="line">- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView;</span><br></pre></td></tr></table></figure><h2 id="initialize-与-load"><a href="#initialize-与-load" class="headerlink" title="+initialize 与 +load"></a>+initialize 与 +load</h2><h3 id="调用时机"><a href="#调用时机" class="headerlink" title="调用时机"></a>调用时机</h3><ul><li><ul><li>initialize 方法：这个方法会在 <code>第一次初始化这个类之前</code> 被调用，我们用它来初始化静态变量。</li></ul></li></ul><ul><li>initialize 方法类似一个懒加载，如果没有使用这个类，那么系统默认不会去调用这个方法，且默认只加载一次；</li><li>initialize 的调用发生在 +init 方法之前。<br>创建子类的时候，子类会去调用父类的 + initialize 方法。</li></ul><ul><li>load 方法：会在<code>加载类的时候就被调用</code>，也就是 ios 应用启动的时候，就会加载所有的类，就会调用每个类的 + load 方法。<br>没有对类做任何操作的情况下，+load 方法会被默认执行，并且是在 main 函数之前执行的。</li></ul><p>参考文章：<a href="https://www.cnblogs.com/wodemeng/p/ios1.html" target="_blank" rel="noopener">IOS app生命周期</a><br><a href="https://www.jianshu.com/p/42eb5a930d66" target="_blank" rel="noopener">ios中的view生命周期</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生命周期 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS中addChildViewController相关</title>
      <link href="/2018/08/01/iOS%E4%B8%ADaddChildViewController%E7%9B%B8%E5%85%B3/"/>
      <url>/2018/08/01/iOS%E4%B8%ADaddChildViewController%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="添加Controller"><a href="#添加Controller" class="headerlink" title="添加Controller"></a>添加Controller</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TowController *towCol = [[TowController alloc]init];</span><br><span class="line">towCol.view.frame = self.view.bounds;</span><br><span class="line">[self addChildViewController:towCol];//1</span><br><span class="line">[self.view addSubview:towCol.view];//2</span><br><span class="line">//addChildViewController 会调用 [child willMoveToParentViewController:self] 方法，但是不会调用 didMoveToParentViewController:方法，官方建议显示调用</span><br><span class="line">[towCol didMoveToParentViewController:self];//3</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="移除一个Controller"><a href="#移除一个Controller" class="headerlink" title="移除一个Controller:"></a>移除一个Controller:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">////移除oldController，但在removeFromParentViewController：方法前不会调用willMoveToParentViewController:nil 方法，所以需要显示调用</span><br><span class="line">[towCol willMoveToParentViewController:nil]; //1</span><br><span class="line">[towCol.view removeFromSuperview]; //2</span><br><span class="line">[towCol removeFromParentViewController]; //3</span><br></pre></td></tr></table></figure><h2 id="viewWillAppear-amp-viewDidAppear"><a href="#viewWillAppear-amp-viewDidAppear" class="headerlink" title="viewWillAppear &amp; viewDidAppear"></a>viewWillAppear &amp; viewDidAppear</h2><p>Controller里面的viewWillAppear:(BOOL)animated在subview真正加到父view之前调用，viewDidAppear:(BOOL)animated在真正被add到父view之后调用，视图消失也是一样。</p><p>[towCol beginAppearanceTransition:YES animated:YES]触发towCol的viewWillAppear，[towCol beginAppearanceTransition:NO animated:YES]触发towCol的viewWillDisappear，和他们配套的[towCol endAppearanceTransition]分别触发viewDidAppear和viewDidDisappear</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>1.[self.scrollView addSubview:childVC.view]会调用childVC的viewDidLoad方法。<br><!--2.如果把childVC.view添加到collectionView的cell上，当点击cell时会无法触发navigationController的push或者present操作。--></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>五笔输入法学习</title>
      <link href="/2018/07/25/%E4%BA%94%E7%AC%94%E8%BE%93%E5%85%A5%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/07/25/%E4%BA%94%E7%AC%94%E8%BE%93%E5%85%A5%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="五笔字型字根助记词"><a href="#五笔字型字根助记词" class="headerlink" title="五笔字型字根助记词"></a>五笔字型字根助记词</h2><h3 id="横-GFDSA"><a href="#横-GFDSA" class="headerlink" title="横 GFDSA"></a>横 GFDSA</h3><p>11 G 王旁青头戋五一<br>12 F 土士二干十寸雨<br><a id="more"></a><br>13 D 大犬三羊古石厂<br>14 S 木丁西<br>15 A 工戈草头右框七</p><h3 id="竖-HJKLM"><a href="#竖-HJKLM" class="headerlink" title="竖 HJKLM"></a>竖 HJKLM</h3><p>21 H 目具上止卜虎皮<br>22 J 日早两竖与虫依<br>23 K 口与川，字根稀<br>24 L 田甲方框四车力<br>25 M 山由贝，下框几</p><h3 id="撇-TREWQ"><a href="#撇-TREWQ" class="headerlink" title="撇 TREWQ"></a>撇 TREWQ</h3><p>31 T 禾竹一撇双人立， 反文条头共三一<br>32 R 白手看头三二斤<br>33 E 月衫乃用家衣底，豹头豹尾与舟底<br>34 W 人和八三四里，祭头登头在其底<br>35 Q  金勺缺点无尾鱼。犬旁留儿一点儿夕，氏无七（妻）</p><h3 id="捺-YUIOP"><a href="#捺-YUIOP" class="headerlink" title="捺 YUIOP"></a>捺 YUIOP</h3><p>41 Y 言文方广在四一，高头一捺谁人去<br>42 U 立辛两点六门病<br>43 I 水旁兴头小倒立<br>44 O 火业头，四点米<br>45 P 之宝盖，摘礻(示)衤(衣)</p><h3 id="折-NBVCX"><a href="#折-NBVCX" class="headerlink" title="折 NBVCX"></a>折 NBVCX</h3><p>51 N 已半巳满不出己，左框折尸心和羽<br>52 B 子耳了也框向上，两折也在五二里<br>53 V 女刀九臼山朝西<br>54 C 又巴马，经有上，勇字头，丢矢矣<br>55 X 慈母无心弓和匕，幼无力</p><p><img src="/assets/20180725_wubi/wubi.gif" alt="五笔键盘"></p><h2 id="一级编码"><a href="#一级编码" class="headerlink" title="一级编码"></a>一级编码</h2><p>GFDSA 一地在要工<br>HJKLM 上是中国同<br>TREWQ 和的有人我<br>YUIOP 主产不为这<br>NBVCX 民了发以经</p><ul><li>在中国，工人和地主是不同的；经我同以，民工上了工地；我要发了！在我国这一主要工地上有的产不了。</li><li>打词组时要以汉字的全码为基础，打词组时跟一级简码没有任何关系！<br><img src="/assets/20180725_wubi/yijibianma.png" alt="一级编码"></li></ul><h2 id="键面字"><a href="#键面字" class="headerlink" title="键面字"></a>键面字</h2><p>GFDSA 王土大木工<br>HJKLM 目日口田山<br>TREWQ 禾白月人金<br>YUIOP 言立水火之<br>NBVCX 已子女又比<br><img src="/assets/20180725_wubi/jianmianzi.png" alt="键面字"></p><h2 id="五笔字型输入法拆字原则"><a href="#五笔字型输入法拆字原则" class="headerlink" title="五笔字型输入法拆字原则"></a>五笔字型输入法拆字原则</h2><p>① 顺序拆分：按正确的书写顺序进行<br>例：新：应为“立、木、斤”而非“立、斤、木”<br>中：应为“口、丨”而非“丨、口”<br>夷：应为“一、弓、人”而非“大、弓” </p><p>② 取大优先：再添一笔画便不能称为字根。“字根尽可能大，尽可能笔画多”<br>例：世：应为“廿、乙”而非“艹、一、乙” </p><p>③ 兼顾直观：为照顾汉字的完整性，暂且牺牲下“书写顺序”和“取大优先”原则。<br>例：国：按书写顺序拆分“冂、王、丶、一”，这样就破坏了这个字的直观性，所以我们把它拆成“囗、王、丶”<br>自：按取大优先的及书写顺序为“亻、乙、三”，很不直观，所以我们把它拆分为“丿、目” </p><p>④ 能散不连：笔画和字根之间，字根和字根之间的关系，可以有“散、连、交”三种。但有时一个汉字拆成的几个部分都是“复笔”（字根都不是单笔画），它们之间的关系常常在“散”和“连”之间，模棱两可，如：占、卜、严、像这样既能“散”，又能“连”时，五笔规定，只要不是单笔画一律按“能散不连”判别。这样的字还有“足、充、首、左、布、页、美、易、麦等。 </p><p>⑤ 能连不交：当一个字既可拆成相连的几个部分，又可拆分成相交的几部分时，我们认为“相连“正确。如生：应为“丿、青头”，开：“一、廾”， 拆分时还要注意：一个笔画不能割断在两个字根之间。<br>如：果：应为“日、木”<br>拆分口诀为：单勿需拆、散拆简单、难在交连、笔画勿断、能散不连、兼顾直观、能连不交、取大优先</p><h3 id="五笔字根拆分口决"><a href="#五笔字根拆分口决" class="headerlink" title="五笔字根拆分口决"></a>五笔字根拆分口决</h3><p>键名汉字打四下，基本字根请照搬；<br>一二三末取四码，顺序拆分大优先；<br>不足四码要注意，交叉识别补后边。</p><h3 id="单字"><a href="#单字" class="headerlink" title="单字"></a>单字</h3><p>一、键名字：字根的第一个字<br>输入方法:击键四次    如: 王(GGGG)</p><p>二、成字字：每键上除键名字以外的独体字 (即属于汉字又是字根)<br>输入方法:报户口+首笔+次笔+末笔    如: 五(GGHG)</p><h3 id="合体字"><a href="#合体字" class="headerlink" title="合体字"></a>合体字</h3><p>合体字特例：一级简码 二级简码 三级简码<br>一级简码: 只要击键一次，再加击一次空格键的25个字<br>如: 一(G+空格) 地(F+空格)<br>二级简码: 前两码+空格(只用前两个字根编码)<br>如: 于(GF+空格) 玫(GT+空格)<br>三级简码: 前三码+空格<br>如: 脑(EYB+空格)<br>合体字不足四字字根:</p><ol><li>补空格 </li><li>使用末笔字根</li><li>使用末笔字根输不出按空格</li></ol><p>单字输入的基本规则<br>在五笔字根键位图上，除键面上的字根以外的汉字的输入规则（大部分汉字的输入方法，键面字，识别码字，成字字根字除外）:<br>一，如果只能拆分为两个字根， 就打：第一字根 + 第二字根 + 空格<br>如“明”字，拆分为“日”和“月”两个字根打“J” “E”再打空格</p><p>二，如果只能拆分为三个字根， 就打：第一字根 + 第二字根 + 第三字根 + 空格<br>如“些”字，拆分为“止”和“匕” “二” 三个字根打“H” “X” “F”再打空格</p><p>三，如果只能拆分为四个字根， 就打：第一字根 + 第二字根 + 第三字根 + 第四字根<br>如“命”字，拆分为“人” “一” “口” “卩”四个字根打“W” “G” “K” “B”</p><p>四，如果拆分超过四个字根， 就打：第一字根 + 第二字根 + 第三字根 + 最末字根<br>如“厨”字，拆分为“厂” “一” “口” “寸”四个字根打“D” “G” “K” “F”</p><h3 id="识别码"><a href="#识别码" class="headerlink" title="识别码"></a>识别码</h3><p>本来按上述规则就可打所有的单个汉字了，但五笔字型为了减少重码，为了避免因打字选字降低打字速度，当一个字拆不够4个码元时就加一个识别码，它的输入编码是：先打完码元码，再追加一个“末笔字型识别码”，简称“识别码”。</p><ol><li>看末笔画——–决定区</li><li>看结构  ——–决定键<br>左右结构在1号键<br>如:礼(PYNN)末笔是在折区 结构是左右在1号键<br>上下结构在2号键<br>如:美(UGDU)末笔是在捺区 结构是上下在2号键<br>杂合结构在3号键<br>如:同(MGKD)末笔是在横区 结构是杂合在3号键</li></ol><p><img src="/assets/20180725_wubi/wubi2.png" alt="末笔字型交叉识别码图1"><br><img src="/assets/20180725_wubi/wubi1.jpg" alt="末笔字型交叉识别码图2"></p><h3 id="规律"><a href="#规律" class="headerlink" title="规律"></a>规律</h3><p>G 横横 一横<br>F 横竖 二横<br>D 横撇 三横</p><p>H 一竖<br>J 二竖<br>K 三竖<br>L 四</p><p>T 撇横<br>R 撇竖<br>E 撇折</p><p>Y 一点<br>U 两点<br> I  三点<br>O 四点</p><p>1：“王”这个字根的第一笔是“一”，第二笔是“一”，所以“横中横”，在中行左边横区5个键中的从中间往外数的横位上（第1个键，G键）<br>2：“土”这个字根的第一笔是“一”，第二笔是“丨”，所以“横中竖”，在中行左边横区5个键中的从中间往外数的竖位上（第2个键，F键）<br>3：“大”这个字根的第一笔是“一”，第二笔是“丿”，所以“横中撇”，在中行左边横区5个键中的从中间往外数的撇位上（第3个键，D键，而且还有发音为”D”这个特殊记忆方式）</p><h2 id="词语"><a href="#词语" class="headerlink" title="词语"></a>词语</h2><ul><li>二字词<br>取每个汉字的前两码<br>如:文明(YYJE)</li><li>三字词<br>取前两字的第一码加上第三字的前两码<br>如:电视机(JPSM)</li><li>四字词<br>取每字的第一码<br>如:同心协力(MNFL)</li><li>多字词<br>取前三字和最末字的第一码<br>如:中华人民共和国(KWWL)</li></ul><p>参考文章：<a href="http://www.wb86.com/wbwz/86help.htm" target="_blank" rel="noopener">五笔打字教程（86版简明教程）</a><br><a href="https://jingyan.baidu.com/article/00a07f3853872e82d028dc9b.html" target="_blank" rel="noopener">教你轻松快速的熟记五笔字根</a><br><a href="http://www.360doc.com/content/15/0917/19/1204156_499795201.shtml" target="_blank" rel="noopener">5分钟学会五笔 (不用背口诀)</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 五笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS中CoreData的使用</title>
      <link href="/2018/07/03/iOS%E4%B8%ADCoreData%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/07/03/iOS%E4%B8%ADCoreData%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="创建工程时选择-use-Core-Data"><a href="#创建工程时选择-use-Core-Data" class="headerlink" title="创建工程时选择 use Core Data"></a>创建工程时选择 use Core Data</h2><a id="more"></a><h3 id="写数据"><a href="#写数据" class="headerlink" title="写数据"></a>写数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)writeData&#123;</span><br><span class="line"></span><br><span class="line">    //暂存器</span><br><span class="line">    AppDelegate *appDelegate = (AppDelegate *)[UIApplication sharedApplication].delegate;</span><br><span class="line">    NSManagedObjectContext *managedContext = appDelegate.persistentContainer.viewContext;</span><br><span class="line"></span><br><span class="line">    NSEntityDescription *entity = [NSEntityDescription entityForName:@&quot;Student&quot; inManagedObjectContext:managedContext];</span><br><span class="line"></span><br><span class="line">    NSManagedObject *student = [[NSManagedObject alloc]initWithEntity:entity insertIntoManagedObjectContext:managedContext];</span><br><span class="line"></span><br><span class="line">    NSString *name = @&quot;zhangsan&quot;;</span><br><span class="line">    [student setValue:name forKey:@&quot;name&quot;];</span><br><span class="line"></span><br><span class="line">    NSError *error = nil;</span><br><span class="line">    if (![managedContext save:&amp;error]) &#123;</span><br><span class="line">        NSLog(@&quot;Could not save (%@), (%@)&quot;,error,error.userInfo);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        NSLog(@&quot;student 存储成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读数据"><a href="#读数据" class="headerlink" title="读数据"></a>读数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)readData&#123;</span><br><span class="line"></span><br><span class="line">    //暂存器</span><br><span class="line">    AppDelegate *appDelegate = (AppDelegate *)[UIApplication sharedApplication].delegate;</span><br><span class="line">    NSManagedObjectContext *managedContext = appDelegate.persistentContainer.viewContext;</span><br><span class="line"></span><br><span class="line">    NSFetchRequest *fetchRequest = [[NSFetchRequest alloc]initWithEntityName:@&quot;Student&quot;];</span><br><span class="line">    NSError *error = nil;</span><br><span class="line">    NSArray *fetchedResults = [managedContext executeFetchRequest:fetchRequest error:&amp;error];</span><br><span class="line">    if (!fetchedResults) &#123;</span><br><span class="line">        NSLog(@&quot;Could not fetch (%@), (%@)&quot;,error,error.userInfo);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        for (NSManagedObject *each in fetchedResults) &#123;</span><br><span class="line">            NSLog(@&quot;%@&quot;,[each valueForKey:@&quot;name&quot;]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建工程之后关联core-data"><a href="#创建工程之后关联core-data" class="headerlink" title="创建工程之后关联core data"></a>创建工程之后关联core data</h2><h3 id="新建一个Data-Model对象，添加实体（必须大写），属性，类型等"><a href="#新建一个Data-Model对象，添加实体（必须大写），属性，类型等" class="headerlink" title="新建一个Data Model对象，添加实体（必须大写），属性，类型等"></a>新建一个Data Model对象，添加实体（必须大写），属性，类型等</h3><p>注意：</p><ul><li>Codegen：Manual/None</li><li>Language<h3 id="创建实体"><a href="#创建实体" class="headerlink" title="创建实体"></a>创建实体</h3>Editor-&gt;Create NSManagedObject Subclass<h3 id="生成上下文-关联数据库"><a href="#生成上下文-关联数据库" class="headerlink" title="生成上下文 关联数据库"></a>生成上下文 关联数据库</h3>NSManagedObjectContext 管理对象，上下文，持久性存储模型对象，处理数据与应用的交互<br>NSManagedObjectModel 被管理的数据模型，数据结构<br>NSPersistentStoreCoordinator 添加数据库，设置数据存储的名字，位置，存储方式<br>NSManagedObject 被管理的数据记录<br>NSFetchRequest 数据请求<br>NSEntityDescription 表格实体结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//创建数据库</span><br><span class="line">- (void)createSqlite&#123;</span><br><span class="line"></span><br><span class="line">    //1、创建模型对象</span><br><span class="line">    //获取模型路径</span><br><span class="line">    NSURL *modelURL = [[NSBundle mainBundle] URLForResource:@&quot;Model&quot; withExtension:@&quot;momd&quot;];</span><br><span class="line">    //根据模型文件创建模型对象</span><br><span class="line">    NSManagedObjectModel *model = [[NSManagedObjectModel alloc] initWithContentsOfURL:modelURL];</span><br><span class="line"></span><br><span class="line">    //2、创建持久化存储助理：数据库</span><br><span class="line">    //利用模型对象创建助理对象</span><br><span class="line">    NSPersistentStoreCoordinator *store = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:model];</span><br><span class="line"></span><br><span class="line">    //数据库的名称和路径</span><br><span class="line">    NSString *docStr = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];</span><br><span class="line">    NSString *sqlPath = [docStr stringByAppendingPathComponent:@&quot;coreData.sqlite&quot;];</span><br><span class="line">    NSLog(@&quot;数据库 path = %@&quot;, sqlPath);</span><br><span class="line">    NSURL *sqlUrl = [NSURL fileURLWithPath:sqlPath];</span><br><span class="line"></span><br><span class="line">    NSError *error = nil;</span><br><span class="line">    //设置数据库相关信息 添加一个持久化存储库并设置类型和路径，NSSQLiteStoreType：SQLite作为存储库</span><br><span class="line">    [store addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:sqlUrl options:nil error:&amp;error];</span><br><span class="line"></span><br><span class="line">    if (error) &#123;</span><br><span class="line">        NSLog(@&quot;添加数据库失败:%@&quot;,error);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        NSLog(@&quot;添加数据库成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3、创建上下文 保存信息 对数据库进行操作</span><br><span class="line">    NSManagedObjectContext *context = [[NSManagedObjectContext alloc] initWithConcurrencyType:NSMainQueueConcurrencyType];</span><br><span class="line"></span><br><span class="line">    //关联持久化助理</span><br><span class="line">    context.persistentStoreCoordinator = store;</span><br><span class="line">    _context = context;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="增删改查排"><a href="#增删改查排" class="headerlink" title="增删改查排"></a>增删改查排</h3><p>写入数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)wirteData&#123;</span><br><span class="line">    // 1.根据Entity名称和NSManagedObjectContext获取一个新的继承于NSManagedObject的子类Student</span><br><span class="line">    Student * student = [NSEntityDescription  insertNewObjectForEntityForName:@&quot;Student&quot;  inManagedObjectContext:_context];</span><br><span class="line"></span><br><span class="line">    //2.根据表Student中的键值，给NSManagedObject对象赋值</span><br><span class="line">    student.name = [NSString stringWithFormat:@&quot;Mr-%d&quot;,arc4random()%100];</span><br><span class="line">    student.age = arc4random()%20;</span><br><span class="line">    student.sex = arc4random()%2 == 0 ?  @&quot;美女&quot; : @&quot;帅哥&quot; ;</span><br><span class="line">    student.height = arc4random()%180;</span><br><span class="line">    student.number = arc4random()%100</span><br><span class="line"></span><br><span class="line">    //   3.保存插入的数据</span><br><span class="line">    NSError *error = nil;</span><br><span class="line">    if ([_context save:&amp;error]) &#123;</span><br><span class="line">    [self alertViewWithMessage:@&quot;数据插入到数据库成功&quot;];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">    [self alertViewWithMessage:[NSString stringWithFormat:@&quot;数据插入到数据库失败, %@&quot;,error]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>删除数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (void)deleteData&#123;</span><br><span class="line"></span><br><span class="line">//创建删除请求</span><br><span class="line">NSFetchRequest *deleRequest = [NSFetchRequest fetchRequestWithEntityName:@&quot;Student&quot;];</span><br><span class="line"></span><br><span class="line">//删除条件</span><br><span class="line">NSPredicate *pre = [NSPredicate predicateWithFormat:@&quot;age &lt; %d&quot;, 10];</span><br><span class="line">deleRequest.predicate = pre;</span><br><span class="line"></span><br><span class="line">//返回需要删除的对象数组</span><br><span class="line">NSArray *deleArray = [_context executeFetchRequest:deleRequest error:nil];</span><br><span class="line"></span><br><span class="line">//从数据库中删除</span><br><span class="line">for (Student *stu in deleArray) &#123;</span><br><span class="line">[_context deleteObject:stu];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NSError *error = nil;</span><br><span class="line">//保存--记住保存</span><br><span class="line">if ([_context save:&amp;error]) &#123;</span><br><span class="line">[self alertViewWithMessage:@&quot;删除 age &lt; 10 的数据&quot;];</span><br><span class="line">&#125;else&#123;</span><br><span class="line">NSLog(@&quot;删除数据失败, %@&quot;, error);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>更改数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//更新，修改</span><br><span class="line">- (void)updateData&#123;</span><br><span class="line"></span><br><span class="line">//创建查询请求</span><br><span class="line">NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@&quot;Student&quot;];</span><br><span class="line">NSPredicate *pre = [NSPredicate predicateWithFormat:@&quot;sex = %@&quot;, @&quot;帅哥&quot;];</span><br><span class="line">request.predicate = pre;</span><br><span class="line"></span><br><span class="line">//发送请求</span><br><span class="line">NSArray *resArray = [_context executeFetchRequest:request error:nil];</span><br><span class="line"></span><br><span class="line">//修改</span><br><span class="line">for (Student *stu in resArray) &#123;</span><br><span class="line">stu.name = @&quot;且行且珍惜_iOS&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//保存</span><br><span class="line">NSError *error = nil;</span><br><span class="line">if ([_context save:&amp;error]) &#123;</span><br><span class="line">[self alertViewWithMessage:@&quot;更新所有帅哥的的名字为“且行且珍惜_iOS”&quot;];</span><br><span class="line">&#125;else&#123;</span><br><span class="line">NSLog(@&quot;更新数据失败, %@&quot;, error);</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>读取数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">//读取查询</span><br><span class="line">- (void)readData&#123;</span><br><span class="line"></span><br><span class="line">/* 谓词的条件指令</span><br><span class="line">1.比较运算符 &gt; 、&lt; 、== 、&gt;= 、&lt;= 、!=</span><br><span class="line">例：@&quot;number &gt;= 99&quot;</span><br><span class="line"></span><br><span class="line">2.范围运算符：IN 、BETWEEN</span><br><span class="line">例：@&quot;number BETWEEN &#123;1,5&#125;&quot;</span><br><span class="line">@&quot;address IN &#123;&apos;shanghai&apos;,&apos;nanjing&apos;&#125;&quot;</span><br><span class="line"></span><br><span class="line">3.字符串本身:SELF</span><br><span class="line">例：@&quot;SELF == &apos;APPLE&apos;&quot;</span><br><span class="line"></span><br><span class="line">4.字符串相关：BEGINSWITH、ENDSWITH、CONTAINS</span><br><span class="line">例：  @&quot;name CONTAIN[cd] &apos;ang&apos;&quot;  //包含某个字符串</span><br><span class="line">@&quot;name BEGINSWITH[c] &apos;sh&apos;&quot;    //以某个字符串开头</span><br><span class="line">@&quot;name ENDSWITH[d] &apos;ang&apos;&quot;    //以某个字符串结束</span><br><span class="line"></span><br><span class="line">5.通配符：LIKE</span><br><span class="line">例：@&quot;name LIKE[cd] &apos;*er*&apos;&quot;   //*代表通配符,Like也接受[cd].</span><br><span class="line">@&quot;name LIKE[cd] &apos;???er*&apos;&quot;</span><br><span class="line"></span><br><span class="line">*注*: 星号 &quot;*&quot; : 代表0个或多个字符</span><br><span class="line">问号 &quot;?&quot; : 代表一个字符</span><br><span class="line"></span><br><span class="line">6.正则表达式：MATCHES</span><br><span class="line">例：NSString *regex = @&quot;^A.+e$&quot;; //以A开头，e结尾</span><br><span class="line">@&quot;name MATCHES %@&quot;,regex</span><br><span class="line"></span><br><span class="line">注:[c]*不区分大小写 , [d]不区分发音符号即没有重音符号, [cd]既不区分大小写，也不区分发音符号。</span><br><span class="line"></span><br><span class="line">7. 合计操作</span><br><span class="line">ANY，SOME：指定下列表达式中的任意元素。比如，ANY children.age &lt; 18。</span><br><span class="line">ALL：指定下列表达式中的所有元素。比如，ALL children.age &lt; 18。</span><br><span class="line">NONE：指定下列表达式中没有的元素。比如，NONE children.age &lt; 18。它在逻辑上等于NOT (ANY ...)。</span><br><span class="line">IN：等于SQL的IN操作，左边的表达必须出现在右边指定的集合中。比如，name IN &#123; &apos;Ben&apos;, &apos;Melissa&apos;, &apos;Nick&apos; &#125;。</span><br><span class="line"></span><br><span class="line">提示:</span><br><span class="line">1. 谓词中的匹配指令关键字通常使用大写字母</span><br><span class="line">2. 谓词中可以使用格式字符串</span><br><span class="line">3. 如果通过对象的key</span><br><span class="line">path指定匹配条件，需要使用%K</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//创建查询请求</span><br><span class="line">NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@&quot;Student&quot;];</span><br><span class="line">//查询条件</span><br><span class="line">NSPredicate *pre = [NSPredicate predicateWithFormat:@&quot;sex = %@&quot;, @&quot;美女&quot;];</span><br><span class="line">request.predicate = pre;</span><br><span class="line"></span><br><span class="line">// 从第几页开始显示</span><br><span class="line">// 通过这个属性实现分页</span><br><span class="line">//request.fetchOffset = 0;</span><br><span class="line">// 每页显示多少条数据</span><br><span class="line">//request.fetchLimit = 6;</span><br><span class="line"></span><br><span class="line">//发送查询请求</span><br><span class="line">NSArray *resArray = [_context executeFetchRequest:request error:nil];</span><br><span class="line"></span><br><span class="line">[self alertViewWithMessage:@&quot;查询所有的美女&quot;];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//排序</span><br><span class="line">- (void)sort&#123;</span><br><span class="line">//创建排序请求</span><br><span class="line">NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@&quot;Student&quot;];</span><br><span class="line">//实例化排序对象</span><br><span class="line">NSSortDescriptor *ageSort = [NSSortDescriptor sortDescriptorWithKey:@&quot;age&quot;ascending:YES];</span><br><span class="line">NSSortDescriptor *numberSort = [NSSortDescriptor sortDescriptorWithKey:@&quot;number&quot;ascending:YES];</span><br><span class="line">request.sortDescriptors = @[ageSort,numberSort];</span><br><span class="line">//发送请求</span><br><span class="line">NSError *error = nil;</span><br><span class="line">NSArray *resArray = [_context executeFetchRequest:request error:&amp;error];</span><br><span class="line">if (error == nil) &#123;</span><br><span class="line">[self alertViewWithMessage:@&quot;按照age和number排序&quot;];</span><br><span class="line">&#125;else&#123;</span><br><span class="line">NSLog(@&quot;排序失败, %@&quot;, error);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="CoreData调试"><a href="#CoreData调试" class="headerlink" title="CoreData调试:"></a>CoreData调试:</h3><p>打开Product，选择Edit Scheme.<br>选择Arguments，在下面的ArgumentsPassed On Launch中添加下面两个选项，如图：<br>(1)-com.apple.CoreData.SQLDebug<br>(2)1</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>C语言复习笔记</title>
      <link href="/2018/06/29/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0/"/>
      <url>/2018/06/29/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><h4 id="常用基本数据类型占用空间（64位机器为例）"><a href="#常用基本数据类型占用空间（64位机器为例）" class="headerlink" title="常用基本数据类型占用空间（64位机器为例）"></a>常用基本数据类型占用空间（64位机器为例）</h4><p>char ： 1个字节<br>int ：4个字节<br>float：4个字节<br>double：8个字节</p><ul><li>sizeof(type) 得到对象或类型的存储字节大小，如：sizeof(int)。<a id="more"></a><h4 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h4></li><li>默认为10进制 ，10 ，20。</li><li>以0开头为8进制，045，021。</li><li>以0b开头为2进制，0b11101101。</li><li>以0x开头为16进制，0x21458adf。</li></ul><h4 id="浮点类型精度"><a href="#浮点类型精度" class="headerlink" title="浮点类型精度"></a>浮点类型精度</h4><ul><li>单精度常量：2.3f 。</li><li>双精度常量：2.3，默认为双精度。</li></ul><h4 id="字符型常量"><a href="#字符型常量" class="headerlink" title="字符型常量"></a>字符型常量</h4><p>用英文单引号括起来，只保存一个字符’a’、’b’ 、’*’ ，还有转义字符 ‘\n’ 、’\t’。</p><h4 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h4><p>用英文的双引号引起来 可以保存多个字符：”abc”。</p><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><ul><li>自动转换规则：<br>a）浮点数赋给整型，该浮点数小数被舍去；<br>b）整数赋给浮点型，数值不变，但是被存储到相应的浮点型变量中；</li><li>强制类型转换形式: (类型说明符)(表达式)</li></ul><h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><h3 id="void类型"><a href="#void类型" class="headerlink" title="void类型"></a>void类型</h3><p>通常用于三种情况：</p><ul><li>函数返回为空：void exit (int status);</li><li>函数参数为空：例如 int rand(void);</li><li>指针指向void：类型为 void <em> 的指针代表对象的地址，而不是类型。例如，内存分配函数 void </em>malloc( size_t size ); 返回指向 void 的指针，可以转换为任何数据类型。</li></ul><h3 id="派生类型"><a href="#派生类型" class="headerlink" title="派生类型"></a>派生类型</h3><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>带有静态存储持续时间的变量会被隐式初始化为 NULL（所有字节的值都是 0），其他所有变量的初始值是未定义的。</p><h3 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h3><p>变量的声明有两种情况：<br>1、一种是需要建立存储空间的。例如：int a 在声明的时候就已经建立了存储空间。<br>2、另一种是不需要建立存储空间的，通过使用extern关键字声明变量名而不定义它。 例如：extern int a 其中变量 a 可以在别的文件中定义的。<br>除非有extern关键字，否则都是变量的定义。<br>extern int i; //声明，不是定义<br>int i; //声明，也是定义</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>整数常量后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。</p><h3 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h3><p>在 C 中，有两种简单的定义常量的方式（一般把常量定义为大写字母形式）：</p><ul><li>使用 #define 预处理器。</li><li>使用 const 关键字。</li></ul><p>####<br>const T ：定义一个常量，声明的同时必须进行初始化。一旦声明，这个值将不能被改变。<br>const T* ：指向常量的指针，不能用于改变其所指向的对象的值。</p><ul><li>const int<em> ：指针指向的对象不可以改变，但指针本身的值可以改变；int</em> const ：指针本身的值不可改变，但其指向的对象可以改变。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const int i = 5;</span><br><span class="line">const int i2 = 10;</span><br><span class="line">const int* pInt = &amp;i;           //正确，指向一个const int对象，即i的地址</span><br><span class="line">//*pInt = 10;                   //错误，不能改变其所指缶的对象</span><br><span class="line">pInt = &amp;i2;                     //正确，可以改变pInt指针本身的值,此时pInt指向的是i2的地址</span><br><span class="line">const int* p2 = new int(8);     //正确，指向一个new出来的对象的地址</span><br><span class="line">delete p2;                      //正确</span><br><span class="line">//int* pInt = &amp;i;               //错误，i是const int类型，类型不匹配，不能将const int * 初始化为int *</span><br><span class="line">int nValue = 15;</span><br><span class="line">const int * pConstInt = &amp;nValue;    //正确，可以把int *赋给const int *，但是pConstInt不能改变其所指向对象的值，即nValue</span><br><span class="line">*pConstInt = 40;                    //错误，不能改变其所指向对象的值</span><br></pre></td></tr></table></figure></li></ul><p>const T&amp; ：对常量(const)的引用，又称为常量引用，常量引用不能修改其邦定的对象。允许为一个常量引用邦定一个非常量对象、字面值，甚至是表达式；引用的类型与引用所指向的类型必须一致。<br>const T<em>&amp;与T </em>const&amp; ：指向常量对象的指针的引用，这可以分两步来理解：1.const T<em>是指向常量的指针；2.const T</em>&amp;指向常量的指针的引用。</p><h2 id="存储类"><a href="#存储类" class="headerlink" title="存储类"></a>存储类</h2><h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><p><code>auto 存储类是所有局部变量默认的存储类</code>，auto 只能用在函数内，即 auto 只能修饰局部变量。</p><h3 id="register"><a href="#register" class="headerlink" title="register"></a>register</h3><p>register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。</p><ul><li>定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3></li><li>使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。</li><li>static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。<code>static 是全局变量的默认存储类</code>。<h3 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h3>extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 ‘extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。</li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示：<br>A = 0011 1100<br>B = 0000 1101</p><ul><li>&amp;：如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。</li><li>| ：如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。</li><li>^：如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。</li><li>~ ：二进制补码运算符是一元运算符，具有”翻转”位效果，即0变成1，1变成0。</li><li>&lt;&lt; ：二进制左移运算符。左操作数的值向左移动右操作数指定的位数。    A &lt;&lt; 2 将得到 240，即为 1111 0000</li><li><code>&gt;&gt;</code> ：二进制右移运算符。左操作数的值向右移动右操作数指定的位数。    A <code>&gt;&gt;</code>2 将得到 15，即为 0000 1111</li></ul><h3 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h3><p>sizeof()  ： 返回变量的大小。返回的结果是size_t类型；    sizeof(a) 将返回 4，其中 a 是整数。<br>&amp;  ： 返回变量的地址。    &a; 将给出变量的实际地址。</p><ul><li>： 指向一个变量。    *a; 将指向一个变量。</li></ul><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><table><thead><tr><th style="text-align:center">类别</th><th style="text-align:center">运算符</th><th style="text-align:center">结合性</th></tr></thead><tbody><tr><td style="text-align:center">后缀</td><td style="text-align:center">() [] -&gt; . ++ - -</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">一元</td><td style="text-align:center">+ - ! ~ ++ - - (type)* &amp; sizeof     从右到左</td></tr><tr><td style="text-align:center">乘除</td><td style="text-align:center">* / %</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">加减</td><td style="text-align:center">+ -</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">移位</td><td style="text-align:center"><code>&lt;&lt; &gt;&gt;</code></td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">关系</td><td style="text-align:center"><code>&lt; &lt;= &gt; &gt;=</code></td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">相等</td><td style="text-align:center">== !=</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">位与 AND</td><td style="text-align:center">&amp;</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">位异或 XOR</td><td style="text-align:center">^</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">位或 OR</td><td style="text-align:center"></td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">逻辑与 AND</td><td style="text-align:center">&amp;&amp;</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">逻辑或 OR</td><td style="text-align:center"></td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">条件</td><td style="text-align:center">?:</td><td style="text-align:center">从右到左</td></tr><tr><td style="text-align:center">赋值</td><td style="text-align:center"></td><td style="text-align:center">从右到左</td></tr><tr><td style="text-align:center">逗号</td><td style="text-align:center">,</td><td style="text-align:center">从左到右</td></tr></tbody></table><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">return_type function_name( parameter list )</span><br><span class="line">&#123;</span><br><span class="line">body of the function</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>当调用函数时，有两种向函数传递参数的方式：</p><ul><li>传值调用    该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。</li><li>引用调用    通过指针传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。</li></ul><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><table><thead><tr><th style="text-align:center">变量</th><th>定义</th><th>作用域</th></tr></thead><tbody><tr><td style="text-align:center">局部变量</td><td>在某个函数或块的内部声明的变量</td><td>只能被该函数或该代码块内部的语句使用。局部变量在函数外部是不可知的。</td></tr><tr><td style="text-align:center">全局变量</td><td>定义在函数外部，通常是在程序的顶部</td><td>全局变量在整个程序生命周期内都是有效的，可以被任何函数访问。全局变量在声明后整个程序中都是可用的。</td></tr><tr><td style="text-align:center">形式参数</td><td>函数的参数，被当作该函数内的局部变量，会优先覆盖全局变量</td><td>作用域</td></tr></tbody></table><h3 id="初始化局部变量和全局变量"><a href="#初始化局部变量和全局变量" class="headerlink" title="初始化局部变量和全局变量"></a>初始化局部变量和全局变量</h3><ul><li>当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动对其初始化<br>|数据类型 |   初始化默认值|<br>|:——–:|:——–:|<br>| int |   0 |<br>| char  |  ‘\0’ |<br>| float  |  0 |<br>| double  |  0 |<br>| pointer  |  NULL |</li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h3><p>在 C 中要声明一个数组，需要指定元素的类型和元素的数量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double balance[10];</span><br></pre></td></tr></table></figure></p><h3 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double balance[5] = &#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;;</span><br><span class="line">double balance[] = &#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;;</span><br></pre></td></tr></table></figure><h3 id="指向数组的指针"><a href="#指向数组的指针" class="headerlink" title="指向数组的指针"></a>指向数组的指针</h3><ul><li>balance 是一个指向 &amp;balance[0] 的指针，即数组 balance 的第一个元素的地址，*(balance + 4) 是一种访问 balance[4] 数据的合法方式</li><li>把 balance 的第一个元素的地址 赋值为 p (把第一个元素的地址存储在 p 中)，p 是一个指向 double 型的指针，可以使用 <em>p、</em>(p+1)、*(p+2) 等来访问数组元素<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">double balance[5] = &#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;;</span><br><span class="line">double *p;</span><br><span class="line">double balance[10];</span><br><span class="line">//p 是一个指向 double 型的指针</span><br><span class="line">p = balance;</span><br><span class="line"></span><br><span class="line">/* 输出数组中每个元素的值 */</span><br><span class="line">printf( &quot;使用指针的数组值\n&quot;);</span><br><span class="line">for ( i = 0; i &lt; 5; i++ )</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;*(p + %d) : %f\n&quot;,  i, *(p + i) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printf( &quot;使用 balance 作为地址的数组值\n&quot;);</span><br><span class="line">for ( i = 0; i &lt; 5; i++ )</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;*(balance + %d) : %f\n&quot;,  i, *(balance + i) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ul><li>内存地址：每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&amp;）运算符访问的地址，它表示了在内存中的一个地址。<h3 id="指针定义"><a href="#指针定义" class="headerlink" title="指针定义"></a>指针定义</h3>指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。星号是用来指定一个变量是指针</li></ul><h3 id="使用指针"><a href="#使用指针" class="headerlink" title="使用指针"></a>使用指针</h3><p>使用一元运算符 * 来返回位于操作数所指定地址的变量的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int  var = 20;</span><br><span class="line"></span><br><span class="line">//定义一个指针变量</span><br><span class="line">int  *ip;</span><br><span class="line"></span><br><span class="line">//把变量地址赋值给指针(在指针变量中存储 var 的地址)</span><br><span class="line">ip = &amp;var;</span><br><span class="line"></span><br><span class="line">//访问指针变量中可用地址的值</span><br><span class="line">printf(&quot;Value of *ip variable: %d\n&quot;, *ip );</span><br></pre></td></tr></table></figure></p><h3 id="NULL指针"><a href="#NULL指针" class="headerlink" title="NULL指针"></a>NULL指针</h3><p>NULL 指针是一个定义在标准库中的值为零的常量。<br>检查一个空指针：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int  *ptr = NULL;</span><br><span class="line">if(ptr)     /* 如果 p 非空，则完成 */</span><br><span class="line">if(!ptr)    /* 如果 p 为空，则完成 */</span><br></pre></td></tr></table></figure></p><h3 id="指针的算术运算"><a href="#指针的算术运算" class="headerlink" title="指针的算术运算"></a>指针的算术运算</h3><h4 id="递增一个指针"><a href="#递增一个指针" class="headerlink" title="递增一个指针"></a>递增一个指针</h4><p>在程序中可以使用指针代替数组，递增变量指针，以便顺序访问数组中的每一个元素。</p><ul><li>变量指针可以递增，而数组不能递增，因为数组是一个常量指针。</li></ul><h4 id="递减一个指针"><a href="#递减一个指针" class="headerlink" title="递减一个指针"></a>递减一个指针</h4><p>对指针进行递减运算，即把值减去其数据类型的字节数。</p><h3 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h3><p>ptr 声明为一个数组，由 MAX 个整数指针组成。因此，ptr 中的每个元素，都是一个指向 int 值的指针。下面的实例用到了三个整数，它们将存储在一个指针数组中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const int MAX = 3;</span><br><span class="line">int  var[] = &#123;10, 100, 200&#125;;</span><br><span class="line">int i, *ptr[MAX];</span><br><span class="line"></span><br><span class="line">for ( i = 0; i &lt; MAX; i++)</span><br><span class="line">&#123;</span><br><span class="line">    ptr[i] = &amp;var[i]; /* 赋值为整数的地址 */</span><br><span class="line">&#125;</span><br><span class="line">for ( i = 0; i &lt; MAX; i++)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Value of var[%d] = %d\n&quot;, i, *ptr[i] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用一个指向字符的指针数组来存储一个字符串列表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const int MAX = 4;</span><br><span class="line">const char *names[] = &#123;</span><br><span class="line">    &quot;Zara Ali&quot;,</span><br><span class="line">    &quot;Hina Ali&quot;,</span><br><span class="line">    &quot;Nuha Ali&quot;,</span><br><span class="line">    &quot;Sara Ali&quot;,</span><br><span class="line">&#125;;</span><br><span class="line">int i = 0;</span><br><span class="line"></span><br><span class="line">for ( i = 0; i &lt; MAX; i++)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Value of names[%d] = %s\n&quot;, i, names[i] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h3><p>当一个目标值被一个指针间接指向到另一个指针时，访问这个值需要使用两个星号运算符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int  var;</span><br><span class="line">int  *ptr;</span><br><span class="line">int  **pptr;</span><br><span class="line"></span><br><span class="line">var = 3000;</span><br><span class="line"></span><br><span class="line">/* 获取 var 的地址 */</span><br><span class="line">ptr = &amp;var;</span><br><span class="line"></span><br><span class="line">/* 使用运算符 &amp; 获取 ptr 的地址 */</span><br><span class="line">pptr = &amp;ptr;</span><br><span class="line"></span><br><span class="line">/* 使用 pptr 获取值 */</span><br><span class="line">printf(&quot;Value of var = %d\n&quot;, var );</span><br><span class="line">printf(&quot;Value available at *ptr = %d\n&quot;, *ptr );</span><br><span class="line">printf(&quot;Value available at **pptr = %d\n&quot;, **pptr);</span><br></pre></td></tr></table></figure></p><h3 id="传递指针给函数"><a href="#传递指针给函数" class="headerlink" title="传递指针给函数"></a>传递指针给函数</h3><p>通过引用或地址传递参数，使传递的参数在调用函数中被改变。<br>声明函数参数为指针类型即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"></span><br><span class="line">void getSeconds(unsigned long *par);</span><br><span class="line"></span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long sec;</span><br><span class="line"></span><br><span class="line">    getSeconds( &amp;sec );</span><br><span class="line"></span><br><span class="line">    /* 输出实际值 */</span><br><span class="line">    printf(&quot;Number of seconds: %ld\n&quot;, sec );</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">void getSeconds(unsigned long *par)</span><br><span class="line">&#123;</span><br><span class="line">    /* 获取当前的秒数 */</span><br><span class="line">    *par = time( NULL );</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>能接受指针作为参数的函数，也能接受数组作为参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">/* 函数声明 */</span><br><span class="line">double getAverage(int *arr, int size);</span><br><span class="line"></span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    /* 带有 5 个元素的整型数组  */</span><br><span class="line">    int balance[5] = &#123;1000, 2, 3, 17, 50&#125;;</span><br><span class="line">    double avg;</span><br><span class="line"></span><br><span class="line">    /* 传递一个指向数组的指针作为参数 */</span><br><span class="line">    avg = getAverage( balance, 5 ) ;</span><br><span class="line"></span><br><span class="line">    /* 输出返回值  */</span><br><span class="line">    printf(&quot;Average value is: %f\n&quot;, avg );</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double getAverage(int *arr, int size)</span><br><span class="line">&#123;</span><br><span class="line">    int    i, sum = 0;       </span><br><span class="line">    double avg;          </span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; size; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    avg = (double)sum / size;</span><br><span class="line"></span><br><span class="line">    return avg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="从函数返回指针"><a href="#从函数返回指针" class="headerlink" title="从函数返回指针"></a>从函数返回指针</h3><p><code>C 语言不支持在调用函数时返回局部变量的地址，除非定义局部变量为 static 变量</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/* 要生成和返回随机数的函数 */</span><br><span class="line">int * getRandom( )</span><br><span class="line">&#123;</span><br><span class="line">    static int  r[10];</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    /* 设置种子 */</span><br><span class="line">    srand( (unsigned)time( NULL ) );</span><br><span class="line">    for ( i = 0; i &lt; 10; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        r[i] = rand();</span><br><span class="line">        printf(&quot;%d\n&quot;, r[i] );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 要调用上面定义函数的主函数 */</span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    /* 一个指向整数的指针 */</span><br><span class="line">    int *p;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    p = getRandom();</span><br><span class="line">    for ( i = 0; i &lt; 10; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;*(p + [%d]) : %d\n&quot;, i, *(p + i) );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针是指向函数的指针变量。通常我们说的指针变量是指向一个整型、字符型或数组等变量，而函数指针是指向函数。</p><h3 id="函数指针变量的声明"><a href="#函数指针变量的声明" class="headerlink" title="函数指针变量的声明"></a>函数指针变量的声明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef int (*fun_ptr)(int,int); // 声明一个指向同样参数、返回值的函数指针类型</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int max(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    return x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    /* p 是函数指针 */</span><br><span class="line">    int (* p)(int, int) = &amp; max; // &amp;可以省略</span><br><span class="line">    int a, b, c, d;</span><br><span class="line"></span><br><span class="line">    printf(&quot;请输入三个数字:&quot;);</span><br><span class="line">    scanf(&quot;%d %d %d&quot;, &amp; a, &amp; b, &amp; c);</span><br><span class="line"></span><br><span class="line">    /* 与直接调用函数等价，d = max(max(a, b), c) */</span><br><span class="line">    d = p(p(a, b), c); </span><br><span class="line"></span><br><span class="line">    printf(&quot;最大的数字是: %d\n&quot;, d);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><ul><li>函数指针作为某个函数的参数</li><li>函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。</li><li>简单讲：回调函数是由别人的函数执行时调用你实现的函数。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 回调函数</span><br><span class="line">void populate_array(int *array, size_t arraySize, int (*getNextValue)(void))</span><br><span class="line">&#123;</span><br><span class="line">    for (size_t i=0; i&lt;arraySize; i++)</span><br><span class="line">    array[i] = getNextValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取随机值</span><br><span class="line">int getNextRandomValue(void)</span><br><span class="line">&#123;</span><br><span class="line">    return rand();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int myarray[10];</span><br><span class="line">    populate_array(myarray, 10, getNextRandomValue);</span><br><span class="line">    for(int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        printf(&quot;%d &quot;, myarray[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li>在 C 语言中，字符串实际上是使用 null 字符 ‘\0’ 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。</li><li>操作字符串的函数：<br>strcmp: string compare<br>strcat: string catenate<br>strcpy: string copy<br>strlen: string length<br>strlwr: string lowercase<br>strupr: string upercase</li></ul><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>C 数组允许定义可存储相同类型数据项的变量，结构体允许存储不同类型的数据项。</p><ul><li>在一般情况下，tag、member-list、variable-list 这 3 部分至少要出现 2 个。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct tag &#123; </span><br><span class="line">member-list</span><br><span class="line">member-list </span><br><span class="line">member-list  </span><br><span class="line">...</span><br><span class="line">&#125; variable-list ;</span><br></pre></td></tr></table></figure></li></ul><p>实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//1.声明了结构体变量s1，这个结构体并没有标明其标签</span><br><span class="line">struct </span><br><span class="line">&#123;</span><br><span class="line">int a;</span><br><span class="line">char b;</span><br><span class="line">double c;</span><br><span class="line">&#125; s1;</span><br><span class="line"></span><br><span class="line">//2.结构体的标签被命名为SIMPLE,没有声明变量</span><br><span class="line">struct SIMPLE</span><br><span class="line">&#123;</span><br><span class="line">int a;</span><br><span class="line">char b;</span><br><span class="line">double c;</span><br><span class="line">&#125;;</span><br><span class="line">//用SIMPLE标签的结构体，另外声明了变量t1、t2、t3</span><br><span class="line">struct SIMPLE t1, t2[20], *t3;</span><br><span class="line"></span><br><span class="line">//3.也可以用typedef创建新类型</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">int a;</span><br><span class="line">char b;</span><br><span class="line">double c; </span><br><span class="line">&#125; Simple2;</span><br><span class="line">//现在可以用Simple2作为类型声明新的结构体变量</span><br><span class="line">Simple2 u1, u2[20], *u3;</span><br></pre></td></tr></table></figure></p><h3 id="访问结构成员"><a href="#访问结构成员" class="headerlink" title="访问结构成员"></a>访问结构成员</h3><ul><li>使用成员访问运算符（.）访问结构的成员</li></ul><h2 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>共用体是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">union [union tag]</span><br><span class="line">&#123;</span><br><span class="line">member definition;</span><br><span class="line">member definition;</span><br><span class="line">...</span><br><span class="line">member definition;</span><br><span class="line">&#125; [one or more union variables];</span><br></pre></td></tr></table></figure></p><h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><h3 id="typedef-vs-define"><a href="#typedef-vs-define" class="headerlink" title="typedef vs #define"></a>typedef vs #define</h3><p>#define 是 C 指令，用于为各种数据类型定义别名，与 typedef 类似，但是它们有以下几点不同：</p><ul><li>typedef 仅限于为类型定义符号名称，#define 不仅可以为类型定义别名，也能为数值定义别名，比如您可以定义 1 为 ONE。</li><li>typedef 是由编译器执行解释的，#define 语句是由预编译器进行处理的。</li></ul><h2 id="输入-amp-输出"><a href="#输入-amp-输出" class="headerlink" title="输入 &amp; 输出"></a>输入 &amp; 输出</h2><h3 id="getchar-amp-putchar-函数"><a href="#getchar-amp-putchar-函数" class="headerlink" title="getchar() &amp; putchar() 函数"></a>getchar() &amp; putchar() 函数</h3><ul><li>int getchar(void) 函数从屏幕读取下一个可用的字符，并把它返回为一个整数。这个函数在同一个时间内只会读取一个单一的字符。</li><li>int putchar(int c) 函数把字符输出到屏幕上，并返回相同的字符。这个函数在同一个时间内只会输出一个单一的字符。</li></ul><h3 id="gets-amp-puts-函数"><a href="#gets-amp-puts-函数" class="headerlink" title="gets() &amp; puts() 函数"></a>gets() &amp; puts() 函数</h3><ul><li>char <em>gets(char </em>s) 函数从 stdin 读取一行到 s 所指向的缓冲区，直到一个终止符或 EOF。</li><li>int puts(const char *s) 函数把字符串 s 和一个尾随的换行符写入到 stdout。</li></ul><h3 id="scanf-和-printf-函数"><a href="#scanf-和-printf-函数" class="headerlink" title="scanf() 和 printf() 函数"></a>scanf() 和 printf() 函数</h3><ul><li>int scanf(const char *format, …) 函数从标准输入流 stdin 读取输入，并根据提供的 format 来浏览输入。</li><li>int printf(const char *format, …) 函数把输出写入到标准输出流 stdout ，并根据提供的格式产生输出。</li></ul><h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>FILE <em>fopen( const char </em> filename, const char * mode );</p><h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><p>int fclose( FILE *fp );</p><h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><p>int fputc( int c, FILE <em>fp );<br>int fputs( const char </em>s, FILE *fp );</p><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p>int fgetc( FILE <em> fp );<br>char </em>fgets( char <em>buf, int n, FILE </em>fp );</p><h3 id="二进制-I-O-函数"><a href="#二进制-I-O-函数" class="headerlink" title="二进制 I/O 函数"></a>二进制 I/O 函数</h3><p>这两个函数都是用于存储块的读写 - 通常是数组或结构体：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size_t fread(void *ptr, size_t size_of_elements, </span><br><span class="line">size_t number_of_elements, FILE *a_file);</span><br><span class="line"></span><br><span class="line">size_t fwrite(const void *ptr, size_t size_of_elements, </span><br><span class="line">size_t number_of_elements, FILE *a_file);</span><br></pre></td></tr></table></figure></p><h2 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h2><h3 id="预处理器指令"><a href="#预处理器指令" class="headerlink" title="预处理器指令"></a>预处理器指令</h3><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>#define</td><td>定义宏</td></tr><tr><td>#include</td><td>包含一个源代码文件</td></tr><tr><td>#undef</td><td>取消已定义的宏</td></tr><tr><td>#ifdef</td><td>如果宏已经定义，则返回真</td></tr><tr><td>#ifndef</td><td>如果宏没有定义，则返回真</td></tr><tr><td>#if</td><td>如果给定条件为真，则编译下面代码</td></tr><tr><td>#else</td><td>#if 的替代方案</td></tr><tr><td>#elif</td><td>如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码</td></tr><tr><td>#endif</td><td>结束一个 #if……#else 条件编译块</td></tr><tr><td>#error</td><td>当遇到标准错误时，输出错误消息</td></tr><tr><td>#pragma</td><td>使用标准化方法，向编译器发布特殊的命令到编译器中</td></tr></tbody></table><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><table><thead><tr><th>宏</th><th>描述</th></tr></thead><tbody><tr><td><strong>DATE</strong></td><td>当前日期，一个以 “MMM DD YYYY” 格式表示的字符常量。</td></tr><tr><td><strong>TIME</strong></td><td>当前时间，一个以 “HH:MM:SS” 格式表示的字符常量。</td></tr><tr><td><strong>FILE</strong></td><td>这会包含当前文件名，一个字符串常量。</td></tr><tr><td><strong>LINE</strong></td><td>这会包含当前行号，一个十进制常量。</td></tr><tr><td><strong>STDC</strong></td><td>当编译器以 ANSI 标准编译时，则定义为 1。</td></tr></tbody></table><h3 id="预处理器运算符"><a href="#预处理器运算符" class="headerlink" title="预处理器运算符"></a>预处理器运算符</h3><p>宏延续运算符（\）：宏太长，一个单行容纳不下时使用<br>字符串常量化运算符（#）：把一个宏的参数转换为字符串常量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define  message_for(a, b)  \</span><br><span class="line">printf(#a &quot; and &quot; #b &quot;: We love you!\n&quot;)</span><br></pre></td></tr></table></figure></p><p>标记粘贴运算符（##）：在宏定义中两个独立的标记被合并为一个标记<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define tokenpaster(n) printf (&quot;token&quot; #n &quot; = %d&quot;, token##n)</span><br><span class="line"></span><br><span class="line">tokenpaster(34);</span><br></pre></td></tr></table></figure></p><p>defined() 运算符：如果指定的标识符已定义，则值为真（非零）。如果指定的标识符未定义，则值为假（零）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#if !defined (MESSAGE)</span><br><span class="line">    #define MESSAGE &quot;You wish!&quot;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>阶乘<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">double factorial(unsigned int i)</span><br><span class="line">&#123;</span><br><span class="line">    if(i &lt;= 1)</span><br><span class="line">    &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return i * factorial(i - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>斐波那契数列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int fibonaci(int i)</span><br><span class="line">&#123;</span><br><span class="line">    if(i == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i == 1)</span><br><span class="line">    &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return fibonaci(i-1) + fibonaci(i-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p><code>void * 类型表示未确定类型的指针。C、C++ 规定 void * 类型可以通过类型转换强制转换为任何其它类型的指针。</code></p><h3 id="void-calloc-int-num-int-size"><a href="#void-calloc-int-num-int-size" class="headerlink" title="void *calloc(int num, int size);"></a>void *calloc(int num, int size);</h3><p>在<code>内存</code>中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是0。</p><h3 id="void-free-void-address"><a href="#void-free-void-address" class="headerlink" title="void free(void *address);"></a>void free(void *address);</h3><p>该函数释放 address 所指向的内存块,释放的是动态分配的内存空间。</p><h3 id="void-malloc-int-num"><a href="#void-malloc-int-num" class="headerlink" title="void *malloc(int num);"></a>void *malloc(int num);</h3><p>在<code>堆区</code>分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。</p><h3 id="void-realloc-void-address-int-newsize"><a href="#void-realloc-void-address-int-newsize" class="headerlink" title="void realloc(void address, int newsize);"></a>void <em>realloc(void </em>address, int newsize);</h3><p>该函数重新分配内存，把内存扩展到 newsize。</p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>命令行执行.c文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c</span><br><span class="line">./a.out</span><br></pre></td></tr></table></figure></p><p><a href="http://www.runoob.com/cprogramming/c-examples.html" target="_blank" rel="noopener">C 语言实例</a><br><a href="http://www.runoob.com/cprogramming/c-100-examples.html" target="_blank" rel="noopener">C 语言经典100例</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>to study</title>
      <link href="/2018/06/27/to-study/"/>
      <url>/2018/06/27/to-study/</url>
      
        <content type="html"><![CDATA[<p><center><img src="/assets/imgs/tostudy.jpeg" alt="&quot;抽象画&quot;"></center><br><a id="more"></a></p><p>MVVM MVC MVP<br>copy retain strong dealloc(ARC)<br>hit-test<br>awakefromnib initwithcoder<br>通知/代理/KVO/block/apns<br>sqlite 多线程（opration GCD）<br>消息发送 消息转发 runtime runloop<br>OC JS 交互<br>LLDB<br>整数反转<br>react native</p><p>工厂模式</p><p>UITableView滑动不加载，滑动停止加载<br>UICollectionViewLayout自定义</p><p>APP配置多环境变量和制作马甲包，私有APP，私有库，私有API<br>operation和GCD区别<br>工厂模式<br>AsyncDisplayKit<br>ComponentKit<br>RESTFUL API<br>jenkins 阿里云 自动化测试</p><p>通知中心-字典  timer-retain atomic-lock，mutablearray</p><ul><li>componentkit，三大特性<br>声明式 Declarative:</li></ul><p>Instead of implementing -sizeThatFits: and -layoutSubviews and positioning subviews manually, you declare the subcomponents of your component (here, we say “stack them vertically”).<br>相比原生设置UI需要手动设置位置，声明式的特性只需要我们做一个声明描述即可，比如垂直排列元素。<br>非常方便。</p><p>函数式Functional:</p><p>Data flows in one direction.<br>Methods take data models and return totally immutable components.<br>数据单向流动，数据流向UI<br>根据Data获取对应的不可变的Components组件</p><p>When state changes, ComponentKit re-renders from the root and reconciles the two component trees from the top with as few changes to the view hierarchy as possible.</p><p>状态改变时，ComponentKit会重新绘制。这时候有oldState和newState，会仔细核对两个组件树(Component tree),从root node到top node 尽量使用最少的重绘来更新view层级结构。</p><p>组合式Composable:</p><p>Here FooterComponent is used in an article, but it could be reused for other UI with a similar footer.<br>Reusing it is a one-liner.<br>CKFlexboxComponent is inspired by the flexbox model of the web and can easily be used to implement many layouts.<br>比如上文demo中的FooterComponent可以复用在别的组件里。<br>CKFlexboxComponent是类似于flexbox的Component。</p><p>APNS,cookie<br>APNS本地消息存储</p><p>layoutsubview调用时机</p><p><a href="https://github.com/targetcloud/baisibudejie" target="_blank" rel="noopener">百思不得姐demo</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>iOS中内存管理学习笔记</title>
      <link href="/2018/06/25/iOS%E4%B8%AD%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/06/25/iOS%E4%B8%AD%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="内存空间"><a href="#内存空间" class="headerlink" title="内存空间"></a>内存空间</h2><p><code>任何继承了NSObject的对象需要进行内存管理，非对象类型(int、char、float、double、struct、enum等) 不需要进行内存管理</code><br>内存（RAM）中的5大区都是什么？</p><ul><li>栈区（stack）：由操作系统自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈(先进后出)，非OC对象一般放在操作系统的栈里面。</li><li>堆区（heap）：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收，分配方式类似于链表，继承了NSObject的对象的存储在操作系统的堆里边。</li><li>全局区（静态区）（static）：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。</li><li>文字常量区：常量字符串就是放在这里的，还有const常量。程序结束后由系统释放。</li><li>程序代码区：存放函数体的二进制代码。</li></ul><h2 id="MRC"><a href="#MRC" class="headerlink" title="MRC"></a>MRC</h2><p>MRC：当调用这个对象的alloc、new、retain、copy、mutableCopy方法之后引用计数器自动在原来的基础上加1（ObjC中调用一个对象的方法就是给这个对象发送一个消息），当调用这个对象的release，autorelease方法之后它的引用计数器减1，如果一个对象的引用计数器为0，则系统会自动调用这个对象的dealloc方法来销毁这个对象。</p><table><thead><tr><th style="text-align:center">对象操作</th><th style="text-align:center">Objective-C方法</th><th style="text-align:right">对应的操作结果</th></tr></thead><tbody><tr><td style="text-align:center">生成并持有对象</td><td style="text-align:center">alloc, new, copy,mutableCopy等方法</td><td style="text-align:right">生成对象并设置引用计数 =1</td></tr><tr><td style="text-align:center">持有对象</td><td style="text-align:center">reatain方法</td><td style="text-align:right">使引用计数 +1</td></tr><tr><td style="text-align:center">释放对象</td><td style="text-align:center">release方法</td><td style="text-align:right">使引用计数 -1</td></tr><tr><td style="text-align:center">废弃对象</td><td style="text-align:center">dealloc方法</td><td style="text-align:right">引用计数 = 0 时调用（系统自动调用）</td></tr></tbody></table><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+(id)alloc</span><br><span class="line">&#123;</span><br><span class="line">return [self allocWithZone:NSDefaultMallocZone()];</span><br><span class="line">&#125;</span><br><span class="line">+(instancetype)allocWithZone:(struct _NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">//NSAllocateObject方法开辟了一块内存空间</span><br><span class="line">return NSAllocateObject(self, 0, zone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="new与alloc-init"><a href="#new与alloc-init" class="headerlink" title="new与alloc/init"></a>new与alloc/init</h3><p>两种方式创建对象现在基本上一样，区别就是使用new只能默认init进行初始化，alloc方式可以使用其它的init开头的方法进行初始化。</p><h3 id="dealloc"><a href="#dealloc" class="headerlink" title="dealloc"></a>dealloc</h3><p>当一个对象的引用计数为0的时候,也就意味着没有任何地方需要该对象,系统会自动回收对该对象所占用的内存,在系统销毁对象的时候,会自动调用该对象的 dealloc 方法来执行一些回收的操作,如果此时该对象还对其他对象有引用的话,那么就需要重写 dealloc 方法来释放该对象对其他对象的引用 以确保该对象能正常释放销毁<br>重写 dealloc 方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)dealloc &#123;</span><br><span class="line"></span><br><span class="line">// 处理该对象的其他引用(通过release方法)</span><br><span class="line"></span><br><span class="line">/** 回调父类的dealloc方法 */</span><br><span class="line">[super dealloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h2><p>当调用这个对象的alloc、new、retain、copy、mutableCopy方法之后引用计数器自动在原来的基础上加1（ObjC中调用一个对象的方法就是给这个对象发送一个消息），当调用这个对象的release，autorelease方法之后它的引用计数器减1，如果一个对象的引用计数器为0，则系统会自动调用这个对象的dealloc方法来销毁这个对象。<br>当一个autorelease pool(自动释放池)被drain(销毁)的时候会对pool里的对象发送一条release的消息.</p><ul><li>在ARC项目中我们同样可以创建NSAutoreleasePool类对象去帮助我们更精确的管理内存问题。</li><li>NSAutoreleasePool的管理范围是在NSAutoreleasePool *pool = [[NSAutoreleasePool alloc]init];与[pool release];之间的对象</li><li>既然ARC项目中设置了ARC，为什么还要使用@autoreleasepool?（注意a的案例解释）ARC 并不是舍弃了@autoreleasepool，而是在编译阶段帮你插入必要的 retain/release/autorelease的代码调用。所以，跟你想象的不一样，ARC 之下依然是延时释放的，依然是依赖于 NSAutoreleasePool，跟非 ARC模式下手动调用那些函数本质上毫无差别，只是编译器来做会保证引用计数的正确性</li><li>NSAutoreleasePool *pool=[[NSAutoreleasePool alloc] init]; 当执行[pool autorelease]的时候，系统会进行一次内存释放，把autorelease的对象释放掉，如果没有NSAutoreleasePool, 那这些内存不会释放<br>注意，对象并不是自动被加入到当前pool中，而是需要对对象发送autorelease消息，这样，对象就被加到当前pool的管理里了。当当前pool接受到drain消息时，它就简单的对它所管理的所有对象发送release消息。</li><li>在ARC项目中.不能直接使用autorelease pools,而是使用@autoreleasepool{},@autoreleasepool{}比直接使用NSAutoreleasePool效率高。不使用ARC的时候也可以使用(autorelease嵌套）</li></ul><h3 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h3><ul><li>只要给对象发送一条autorelease消息，会将对象放到一个自动释放池中，当该pool被释放时,该pool中的所有对象会被调用一次release。</li><li><p>自动释放池是以栈的形式存在，栈顶就是离调用autorelease方法最近的自动释放池</p></li><li><p>AutoreleasePool的使用<br>注意：放到自动释放池代码中的对象，只有调用了 autorelease 方法，对象才会加入到自动释放池</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSAutoreleasePool *autoreleasePool = [[NSAutoreleasePool alloc] init];</span><br><span class="line">Person *p = [[[Person alloc] init] autorelease];</span><br><span class="line">[autoreleasePool drain];</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool</span><br><span class="line">&#123; // 开始代表创建自动释放池</span><br><span class="line">Person *p = [[Person new] autorelease];</span><br><span class="line">// 将代码写到这里就放入了自动释放池</span><br><span class="line">&#125; // 结束代表销毁自动释放池(会给池子中所有对象发送一条release消息)</span><br></pre></td></tr></table></figure><ul><li><p>autoReleasePool 什么时候释放?<br>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。<br>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是 -2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。<br>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop()  和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。<br>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p></li><li><p>autorelease<br>返回对象本身，只是把对release的调用延迟了，调用完autorelease方法后，对象的计数器不变</p></li><li><p>drain<br>销毁一个自动释放池.</p></li><li><p>dealloc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-(void)dealloc&#123;</span><br><span class="line">NSLog(@&quot;Invoke Person&apos;s dealloc method.&quot;);</span><br><span class="line">[super dealloc];//注意：super dealloc一定要写到所有代码的最后（两个目的：一是父类可能有其他引用对象需要释放；二是：当前对象真正的释放操作是在super的dealloc中完成的）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>野指针/空指针<br>野指针：一个指针指向一个僵尸对象（被释放的对象），给一个野指针发送消息就会报错(EXC_BAD_ACCESS错误)<br>空指针：没有指向存储空间的指针(里面存的是nil, 也就是0)，给空指针发消息是没有任何反应的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//如果不设置p=nil，则p就是一个野指针,此时如果再调用对象release会报错</span><br><span class="line">//但是如果此时p已经是空指针了，则在ObjC中给空指针发送消息是不会报错的</span><br><span class="line">p=nil;</span><br><span class="line">[p release];</span><br></pre></td></tr></table></figure></li></ul><h3 id="ARC下的dealloc"><a href="#ARC下的dealloc" class="headerlink" title="ARC下的dealloc"></a>ARC下的dealloc</h3><p>ARC下,系统可以帮我们释放该对象，及其包含的对象，但是却无法释放不属于该对象的一些东西。</p><ul><li>移除通知的观察者,或KVO的观察者</li><li>对象强委托/引用的解除(例如XMPPMannerger的delegateQueue)</li><li>做一些其他的注销之类的操作(关闭程序运行期间没有关闭的资源)</li></ul><h2 id="block使用时的一些情况以及防止循环引用"><a href="#block使用时的一些情况以及防止循环引用" class="headerlink" title="block使用时的一些情况以及防止循环引用"></a>block使用时的一些情况以及防止循环引用</h2><ul><li><p>block 在实现时就会对它引用到的它所在方法中定义的栈变量进行一次只读拷贝，然后在 block 块内使用该只读拷贝。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">-(void)testVariable</span><br><span class="line">&#123;</span><br><span class="line">    NSInteger outsideVariable = 10;</span><br><span class="line">    // __block NSInteger outsideVariable = 10;</span><br><span class="line">    NSMutableArray * outsideArray = [[NSMutableArray alloc] init];</span><br><span class="line">    void (^blockObject)(void) = ^(void)&#123;</span><br><span class="line">        NSInteger insideVariable = 20;</span><br><span class="line">        NSLog(@&quot;  &gt; member variable = %d&quot;, self.memberVariable);</span><br><span class="line">        NSLog(@&quot;  &gt; outside variable = %ld&quot;, (long)outsideVariable);</span><br><span class="line">        NSLog(@&quot;  &gt; inside variable = %ld&quot;, (long)insideVariable);</span><br><span class="line"></span><br><span class="line">        [outsideArray addObject:@&quot;AddedInsideBlock&quot;];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    outsideVariable = 30;</span><br><span class="line">    self.memberVariable = 30;</span><br><span class="line"></span><br><span class="line">    blockObject();</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;  &gt; %lu items in outsideArray&quot;, (unsigned long)[outsideArray count]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; member variable = 30</span><br><span class="line">&gt; outside variable = 10 //&gt;使用__block修饰则输出 outside variable = 30 </span><br><span class="line">&gt; inside variable = 20</span><br><span class="line">&gt; 1 items in outsideArray</span><br></pre></td></tr></table></figure></li><li><p>局部变量：blockObject 在实现时会对 outside 变量进行只读拷贝，在 block 块内使用该只读拷贝。因此这里输出的是拷贝时的变量值 10。如果，我们想要让 blockObject 修改或同步使用 outside 变量就需要用 __block 来修饰 outside 变量。</p></li><li>static 变量，全局变量：在 block 中是有读写权限的，因为在 block 的内部实现中，拷贝的是指向这些变量的指针。</li><li>数组：我们往 outsideArray 数组中添加了值，但并未修改 outsideArray 自身，这是允许的，因为拷贝的是 outsideArray 自身。</li><li><strong>block：</strong>block 变量的内部实现要复杂许多，__block 变量其实是一个结构体对象，拷贝的是指向该结构体对象的指针。</li></ul><h3 id="strong-weak-unsafe-unretain-autoreleasing"><a href="#strong-weak-unsafe-unretain-autoreleasing" class="headerlink" title="strong/weak/unsafe_unretain/autoreleasing"></a><strong>strong/</strong>weak/<strong>unsafe_unretain/</strong>autoreleasing</h3><ul><li>强指针/弱指针<br>强指针：被<strong>strong修饰的指针，默认所有对象的指针变量都是强指针<br>弱指针：被</strong>weak修饰的指针，不要使用弱指针保存新创建的对象，否则对象会被立即释放<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__strong  Person *p1 = [[Person alloc] init];</span><br><span class="line">__weak  Person *p2 = [[Person alloc] init];</span><br></pre></td></tr></table></figure></li></ul><h4 id="weak"><a href="#weak" class="headerlink" title="__weak"></a>__weak</h4><p>如果局部变量block中retain了self，当block中的代码被执行完后，self就会被ARC释放。所以不需要处理weakself的情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSArray *anArray = @[@&quot;1&quot;, @&quot;2&quot;, @&quot;3&quot;];</span><br><span class="line">[anArray enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">    [self doSomething:obj];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><p>如果block被self strong引用。所以结果就是block中引用了self，self引用了block。那么这个时候，如果你不使用weakself，则self和block永远都不会被释放。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__weak SecondViewController *weakself = self;</span><br><span class="line">self.aBlock = ^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop)&#123;</span><br><span class="line">[weakself doSomething:idx];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="强弱引用转换"><a href="#强弱引用转换" class="headerlink" title="强弱引用转换"></a>强弱引用转换</h4><p>强弱引用转换，用于解决代码块（block）与强引用self之间的循环引用问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#ifndef    weakify_self</span><br><span class="line">#if __has_feature(objc_arc)</span><br><span class="line">#define weakify_self autoreleasepool&#123;&#125; __weak __typeof__(self) weakSelf = self;</span><br><span class="line">#else</span><br><span class="line">#define weakify_self autoreleasepool&#123;&#125; __block __typeof__(self) blockSelf = self;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line">#ifndef    strongify_self</span><br><span class="line">#if __has_feature(objc_arc)</span><br><span class="line">#define strongify_self try&#123;&#125; @finally&#123;&#125; __typeof__(weakSelf) self = weakSelf;</span><br><span class="line">#else</span><br><span class="line">#define strongify_self try&#123;&#125; @finally&#123;&#125; __typeof__(blockSelf) self = blockSelf;</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><p>调用方式：<code>@weakify_self</code>实现弱引用转换，<code>@strongify_self</code>实现强引用转换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, copy) void(^aBlock)(NSUInteger idx);</span><br><span class="line"></span><br><span class="line">@weakify_self</span><br><span class="line">self.aBlock = ^(NSUInteger idx)&#123;</span><br><span class="line">    [weakSelf doSomething:idx];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@weakify_self</span><br><span class="line">self.aBlock = ^(NSUInteger idx)&#123;</span><br><span class="line">    @strongify_self</span><br><span class="line">    [self doSomething:idx];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ul><li>__strong关键字与retain关似，用了它，引用计数自动＋1</li><li><p>__autoreleasing<br>表示在autorelease pool中自动释放对象的引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__autoreleasing NSString *str;</span><br><span class="line">@autoreleasepool &#123;</span><br><span class="line">str = [NSString stringWithFormat:@&quot;sunnyxx&quot;];</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;%@&quot;, str); // Console: (null)</span><br></pre></td></tr></table></figure></li><li><p><strong>weak：若附有</strong>weak修饰符的变量所引用的对象被废弃,则将 nil赋值给该变量，使用附有<strong>weak修饰符的变量,即是使用注册到</strong>autoreleasepool 中的对象</p></li><li><p><strong>autoreleasing：将对象赋值给附有</strong>autoreleasing修饰的变量等同于 ARC无效时调用对象的 autorelease 方法</p></li></ul><h2 id="enumerateObjectsUsingBlock"><a href="#enumerateObjectsUsingBlock" class="headerlink" title="enumerateObjectsUsingBlock"></a>enumerateObjectsUsingBlock</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[array enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123;</span><br><span class="line">// 这里被一个局部@autoreleasepool包围着</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">NSDictionary * dic = [NSDictionary dictionaryWithObjectsAndKeys:@&quot;obj1&quot;,@&quot;key1&quot;,@&quot;obj2&quot;,@&quot;key2&quot;, nil];</span><br><span class="line">[dic enumerateKeysAndObjectsUsingBlock:^(id key, id value, BOOL *stop) &#123;</span><br><span class="line">NSLog(@&quot;value for key %@ is %@ &quot;, key, value);</span><br><span class="line">if ([@&quot;key2&quot; isEqualToString:key]) &#123;</span><br><span class="line">*stop = YES;    //当需要结束循环的时候,调用stop,赋予YES</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>for in、经典for循环和EnumerateObjectsUsingBlock 的比较：</p><ul><li>对于集合中对象数很多的情况下，for in 的遍历速度非常之快，但小规模的遍历并不明显（还没普通for循环快）</li><li>Value查询index的时候, 面对大量的数组推荐使用 enumerateObjectsWithOptions的并行方法.</li><li>遍历字典类型的时候, 推荐使用enumerateKeysAndObjectsUsingBlock,block版本的字典遍历可以同时取key和value（forin只能取key再手动取value）</li></ul><p>遍历数组的同时删除元素：<br>如果在for in 循环里，对这个数组进行了修改的话，无论是增，删，修改数组元素位置，都会扔一个异常出来，枚举的过程中数组发生了突变（&lt;__NSArrayM: 0xa4fc000&gt; was mutated while being enumerated.），但是如果写成for循环或Enumerate都没有问题。</p><ul><li>NSString *name，非ARC下重写setter,getter方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-(void)setName:(NSString *)name&#123;</span><br><span class="line">if (_name != name) &#123;</span><br><span class="line">[_name release];</span><br><span class="line">_name = [name copy];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">- (NSString *)name&#123;</span><br><span class="line">return [[_name retain]autorelease];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><a href="https://blog.csdn.net/cyj_sky/article/details/51442732" target="_blank" rel="noopener">block使用时的一些情况以及防止循环引用</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS面试题总结</title>
      <link href="/2018/06/25/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2018/06/25/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p><a href="">iOS中内存管理学习笔记</a></p><h3 id="属性关键字"><a href="#属性关键字" class="headerlink" title="属性关键字"></a>属性关键字</h3><p><a href="">OC中属性关键字相关</a><br><a id="more"></a></p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p><a href="">OC中的设计模式</a></p><h2 id="runtime与runloop"><a href="#runtime与runloop" class="headerlink" title="runtime与runloop"></a>runtime与runloop</h2><p><a href="https://guchunli.github.io/2017/03/22/iOS-runtime学习笔记/">iOS runtime与runloop学习笔记</a></p><h3 id="iOS平台怎么做数据的持久化-coredata和sqlite有无必然联系-coredata是一个关系型数据库吗"><a href="#iOS平台怎么做数据的持久化-coredata和sqlite有无必然联系-coredata是一个关系型数据库吗" class="headerlink" title="iOS平台怎么做数据的持久化?coredata和sqlite有无必然联系?coredata是一个关系型数据库吗?"></a>iOS平台怎么做数据的持久化?coredata和sqlite有无必然联系?coredata是一个关系型数据库吗?</h3><!--more--><p>答：core data是对sqlite的封装，sqlite是c语言的api，core data把c的api翻译成oc的api，coredata还提供了一些管理的功能，使用更加方便。它提供了对象-关系映射(ORM)的功能，即能够将OC对象转化成数据，保存在SQLite数据库文件中，也能够将保存在数据库中的数据还原成OC对象。</p><h3 id="Object-c的类可以多重继承么-可以实现多个接口么-category是什么-重写一个类的方式用继承好还是分类好-为什么"><a href="#Object-c的类可以多重继承么-可以实现多个接口么-category是什么-重写一个类的方式用继承好还是分类好-为什么" class="headerlink" title="Object-c的类可以多重继承么?可以实现多个接口么?category是什么?重写一个类的方式用继承好还是分类好?为什么?"></a>Object-c的类可以多重继承么?可以实现多个接口么?category是什么?重写一个类的方式用继承好还是分类好?为什么?</h3><p>答: Object-c的类不可以多重继承；一般情况用分类好，用Category去重写类的方法，仅对本Category有效，不会影响到其他类与原有类的关系。</p><h2 id="import跟-include有什么区别-class呢-import-lt-gt-跟-import””有什么区别"><a href="#import跟-include有什么区别-class呢-import-lt-gt-跟-import””有什么区别" class="headerlink" title="#import跟#include有什么区别,@class呢?#import&lt;&gt;跟#import””有什么区别?"></a>#import跟#include有什么区别,@class呢?#import&lt;&gt;跟#import””有什么区别?</h2><p>答: #import是Objective-C导入头文件的关键字</p><p>#include是C/C++导入头文件的关键字<br>使用#import头文件会自动只导入一次，不会重复导入，相当于#include和#pragma once；<br>@class告诉编译器某个类的声明，当执行时，才去查看类的实现文件，可以解决头文件的相互包含；</p><p>#import&lt;&gt;用来包含系统的头文件，#import””用来包含用户头文件。</p><h3 id="对于语句NSString-obj-NSData-alloc-init-obj在编译时和运行时分别是什么类型的对象"><a href="#对于语句NSString-obj-NSData-alloc-init-obj在编译时和运行时分别是什么类型的对象" class="headerlink" title="对于语句NSString *obj =[[NSData alloc] init]; obj在编译时和运行时分别是什么类型的对象?"></a>对于语句NSString *obj =[[NSData alloc] init]; obj在编译时和运行时分别是什么类型的对象?</h3><p>答:编译时是NSString的类型；运行时是NSData类型的对象</p><h3 id="setObject-ForKey-setValue-ForKey-setValue-forKeyPath"><a href="#setObject-ForKey-setValue-ForKey-setValue-forKeyPath" class="headerlink" title="setObject:ForKey: setValue:ForKey: setValue:forKeyPath:"></a>setObject:ForKey: setValue:ForKey: setValue:forKeyPath:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[muDict setValue:&lt;#(nullable id)#&gt; forKey:&lt;#(nonnull NSString *)#&gt;];</span><br><span class="line">[muDict setValue:&lt;#(nullable id)#&gt; forKeyPath:&lt;#(nonnull NSString *)#&gt;];</span><br><span class="line">[muDict setObject:&lt;#(nonnull id)#&gt; forKey:&lt;#(nonnull id&lt;NSCopying&gt;)#&gt;];</span><br></pre></td></tr></table></figure><p>一、setObject:ForKey:与setValue:ForKey:存值区别与联系<br>1.setObject:ForKey: 是NSMutableDictionary特有的；setValue:ForKey:是KVC的主要方法；<br>2.setObject:ForKey:中key的参数只要是对象就可以，并不局限于 NSString；key，object对象不能为nil,不然会报错；<br>setValue:ForKey:中key 的参数只能是NSString类型；Value值可以为nil，此时会自动调用removeObject:forKey:方法；<br>3.nil与null是不同的,[NSNull null]表示是一个空的对象,并不是nil；<br>4.setValue:ForKey:是在NSObject对象中创建的,即所有的对象都有这个方法，可以用于任何类(方法调用者是对象的时候);<br>二、objectForKey:和valueForKey:取值区别与联系<br>NSDictioary取值的时候有两个方法,objectForKey:和valueForKey:(建议用objectForKey:)<br>1.若key值不是以@符合开头, 两者是相同的；若key值是以@开头, 例如：@“@aKey”,则valueForKey:会去掉@,然后用剩下的部分执行[super valueForKey];<br>2.valueForKey：取值是找和指定key同名的property accessor(属性访问)没有找到的时候执行valueForUndefinedKey:方法，而valueForUndefinedKey:方法默认是抛出crash异常；<br>三、valueForKey:和valueForKeyPath:<br>setValue:forKey: valueForKey:用于简单路径；<br>setValue:forKeyPath: valueForKeyPath:用于复合路径</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS中的通知/KVO/代理/block/APNs学习笔记</title>
      <link href="/2018/06/21/iOS%E4%B8%AD%E7%9A%84%E9%80%9A%E7%9F%A5:KVO:%E4%BB%A3%E7%90%86:block:APNs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/06/21/iOS%E4%B8%AD%E7%9A%84%E9%80%9A%E7%9F%A5:KVO:%E4%BB%A3%E7%90%86:block:APNs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="通知-KVO-代理"><a href="#通知-KVO-代理" class="headerlink" title="通知/KVO/代理"></a>通知/KVO/代理</h2><p>三者优缺点比较</p><h3 id="delegate"><a href="#delegate" class="headerlink" title="delegate"></a>delegate</h3><ul><li>优势 ：<br>1.非常严格的语法。所有监听到的事件必须是在delegate协议中有清晰的定义。<br>2.如果delegate中的一个方法没有实现那么就会出现编译警告/错误<a id="more"></a>3.协议必须在controller的作用域范围内定义<br>4.在一个应用中的控制流程是可跟踪的并且是可识别的；<br>5.在一个控制器中可以定义多个不同的协议，每个协议有不同的delegate<br>6.没有第三方对象要求保持/监视通信过程。<br>7.能够接收调用的协议方法的返回值。这意味着delegate能够提供反馈信息给controller<br>8.经常被用在存在父子关系的对象之间通信，例如控制器和控制器的view（自己加的理解）</li><li>缺点<br>1.需要定义很多代码：1.协议定义；2.controller的delegate属性；3.在delegate本身中实现delegate方法定义<br>2.在释放代理对象时，需要小心的将delegate改为nil。一旦设定失败，那么调用释放对象的方法将会出现内存crash<br>3.在一个controller中有多个delegate对象，并且delegate是遵守同一个协议，但还是很难告诉多个对象同一个事件，不过有可能。<br>4.经常用在一对一的通信。（不知道是缺点还是优点，只能算是特点）（自己加的理解）</li></ul><h3 id="notification"><a href="#notification" class="headerlink" title="notification"></a>notification</h3><ul><li>优势 ：<br>1.不需要编写多少代码，实现比较简单<br>2.对于一个发出的通知，多个对象能够做出反应，即一对多的方式实现简单<br>3.controller能够传递context对象（dictionary），context对象携带了关于发送通知的自定义的信息</li><li>缺点 ：<br>1.在编译期不会检查通知是否能够被观察者正确的处理；<br>2.在释放注册的对象时，需要在通知中心取消注册；<br>3.在调试的时候应用的工作以及控制过程难跟踪；<br>4.需要第三方对象来管理controller与观察者对象之间的联系；<br>5.controller和观察者需要提前知道通知名称、UserInfo dictionary keys。如果这些没有在工作区间定义，那么会出现不同步的情况；<br>6.通知发出后，controller不能从观察者获得任何的反馈信息（相比较delegate）。</li></ul><h3 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h3><ul><li>优势<br>1.能够提供一种简单的方法实现两个对象间的同步。例如：model和view之间同步；<br>2.能够对非我们创建的对象，即内部对象的状态改变作出响应，而且不需要改变内部对象（SKD对象）的实现；<br>3.能够提供观察的属性的最新值以及先前值；<br>4.用key paths来观察属性，因此也可以观察嵌套对象；<br>5.完成了对观察对象的抽象，因为不需要额外的代码来允许观察值能够被观察<br>6.可以一对多。</li><li>缺点<br>1.我们观察的属性必须使用strings来定义。因此在编译器不会出现警告以及检查；<br>2.对属性重构将导致我们的观察代码不再可用；<br>3.复杂的“IF”语句要求对象正在观察多个值。这是因为所有的观察代码通过一个方法来指向；<br>4.当释放观察者时不需要移除观察者。</li></ul><h3 id="delegate与NSNotification"><a href="#delegate与NSNotification" class="headerlink" title="delegate与NSNotification"></a>delegate与NSNotification</h3><p>通知：广播机制，可以将一个通知发送给多个监听者。随处都可以添加订阅<br>代理：一对一，每个对象的代理却只能有一个。用代理代码分布结构更加清晰</p><ul><li>效率 肯定是delegate比NSNotification高。<br>delegate方法比notification更加直接，最典型的特征是，delegate方法往往需要关注返回值， 也就是delegate方法的结果。比如-windowShouldClose:，需要关心返回的是yes还是no。所以delegate方法往往包含 should这个很传神的词。也就是好比你做我的delegate，我会问你我想关闭窗口你愿意吗？你需要给我一个答案，我根据你的答案来决定如何做下一 步。相反的，notification最大的特色就是不关心接受者的态度， 我只管把通告放出来，你接受不接受就是你的事情，同时我也不关心结果。所以notification往往用did这个词汇，比如 NSWindowDidResizeNotification，那么NSWindow对象放出这个notification后就什么都不管了也不会等待接 受者的反应。</li></ul><h3 id="KVO和NSNotification"><a href="#KVO和NSNotification" class="headerlink" title="KVO和NSNotification"></a>KVO和NSNotification</h3><p>和delegate一样，KVO和NSNotification的作用也是类与类之间的通信，与delegate不同的是<br>1）这两个都是负责发出通知，剩下的事情就不管了，所以没有返回值；<br>2）delegate只是一对一，而这两个可以一对多。这两者也有各自的特点。</p><h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//接受消息的类</span><br><span class="line">- (void)viewDidLoad &#123;  </span><br><span class="line">[super viewDidLoad];   </span><br><span class="line">// 1.向通知中心添加的观察者(通知接受者)</span><br><span class="line">// 2.观察者收到通知后进行的事件响应</span><br><span class="line">// 3.通知的名字</span><br><span class="line">// 4.接受固定对象的通知,当写成nil时,就是当前通知的消息发送者的通知都接收  </span><br><span class="line">[[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(notificationAction:) name:@&quot;96.1FM&quot; object:nil];&#125;</span><br><span class="line">//该参数就是发送过来的通知,接到通知后执行的方法</span><br><span class="line">- (void)notificationAction:(NSNotification *)notify</span><br><span class="line">&#123;   </span><br><span class="line">NSLog(@&quot;%@111&quot;,notify.userInfo);</span><br><span class="line">&#125;</span><br><span class="line">- (void)dealloc&#123; </span><br><span class="line">//移除观察者   </span><br><span class="line">[[NSNotificationCenter defaultCenter]removeObserver:self name:@&quot;96.1FM&quot; object:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//发送消息的类</span><br><span class="line">- (void)viewDidLoad &#123;  </span><br><span class="line">[super viewDidLoad];      </span><br><span class="line">//发送通知</span><br><span class="line">//如果发送的通知指定了object对象，那么观察者接收的通知设置的object对象与其一样，才会接收到通知，但是接收通知如果将这个参数设置为了nil，则会接收一切通知。</span><br><span class="line">[[NSNotificationCenter defaultCenter]postNotificationName:@&quot;96.1FM&quot; object:nil userInfo:@&#123;@&quot;name&quot;:@&quot;123&quot;&#125;];    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多线程下的通知"><a href="#多线程下的通知" class="headerlink" title="多线程下的通知"></a>多线程下的通知</h3><p>NSNotificationCenter消息的接受线程是基于发送消息的线程的，也就是同步的。</p><h2 id="KVO相关"><a href="#KVO相关" class="headerlink" title="KVO相关"></a>KVO相关</h2><h3 id="KVO-1"><a href="#KVO-1" class="headerlink" title="KVO"></a>KVO</h3><ul><li><p>使用场景：当需要检测其他类的属性值变化，但又不想被观察的类知道，就可以使用KVO了。<br>很适合实现 mode 模型和 view 视图之间的通讯。</p></li><li><p>触发<br>如果赋值没有通过 setter 方法或者 KVC，而是直接修改属性对应的成员变量，例如：仅调用 _name = @”newName”，这时是不会触发 KVO 机制，更加不会调用回调方法的。<br>所以使用 KVO 机制的前提是遵循 KVO 的属性设置方式来变更属性值。</p></li><li><p>底层实现原理<br>系统实现KVO有以下几个步骤：<br>1.当类A的对象第一次被观察的时候，系统会在运行期动态创建类A的派生类NSKVONotifying_A。该类继承自对象A的本类。<br>2.在派生类NSKVONotifying_A中重写类A的setter方法，NSKVONotifying_A类在被重写的setter方法中实现通知机制。setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象属性值的更改情况。<br>3.类NSKVONotifying_A会重写 class方法，将自己伪装成类A。类NSKVONotifying_A还会重写dealloc方法释放资源。<br>4.系统将所有指向类A对象的isa指针指向类NSKVONotifying_A的对象。</p></li></ul><p>KVC和KVO都属于键值编程而且底层实现机制都是isa-swizzing，依赖于Runtime机制。当观察者被注册为一个对象的属性的观察对象的isa指针被修改，指向一个中间类，而不是在真实的类。其结果是，isa指针的值并不一定反映实例的实际类。所以不能依靠isa指针来确定对象是否是一个类的成员。应该使用class方法来确定对象实例的类。<br>isa 指针的作用：每个对象都有 isa 指针，指向该对象的类，它告诉 Runtime 系统这个对象的类是什么。所以对象注册为观察者时，isa 指针指向新子类，那么这个被观察的对象就神奇地变成新子类的对象（或实例）了。</p><ul><li><p>KVO与线程<br>KVO的响应和KVO观察的值变化是在一个线程上的，所以，大多数时候，不要把KVO与多线程混合起来。除非能够保证所有的观察者都能线程安全的处理KVO。</p></li><li><p>手动KVO<br>首先，需要手动实现属性的 setter 方法，并在设置操作的前后分别调用 willChangeValueForKey: 和 didChangeValueForKey方法，这两个方法用于通知系统该 key 的属性值即将和已经变更了；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-(void)setName:(NSString *)newName&#123; </span><br><span class="line">    [self willChangeValueForKey:@&quot;name&quot;];    //KVO 在调用存取方法之前总调用 </span><br><span class="line">    [super setValue:newName forKey:@&quot;name&quot;]; //调用父类的存取方法 </span><br><span class="line">    [self didChangeValueForKey:@&quot;name&quot;];     //KVO 在调用存取方法之后总调用</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)setAge:(NSUInteger)age&#123;  </span><br><span class="line">    if (age &lt; 22) &#123;  </span><br><span class="line">        return;  </span><br><span class="line">    &#125;  </span><br><span class="line">    [self willChangeValueForKey:@age];  </span><br><span class="line">    _age = age;  </span><br><span class="line">    [self didChangeValueForKey:@age];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>其次，要实现类方法 automaticallyNotifiesObserversForKey，并在其中设置对该 key 不自动发送通知（返回 NO 即可）。这里要注意，对其它非手动实现的 key，要转交给 super 来处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key&#123;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h3><ul><li>可以通过字符串的名字（key）来访问类属性的机制。而不是通过调用Setter、Getter方法访问。</li><li>可以访问私有成员变量的值，可以间接修改私有成员变量的值。可以修改readonly属性。</li><li>关键方法定义在 NSKeyValueCodingProtocol</li><li><p>KVC支持类对象和内建基本数据类型。</p></li><li><p>使用：<br>获取值<br>valueForKey: 传入NSString属性的名字。<br>valueForKeyPath: 属性的路径，xx.xx<br>valueForUndefinedKey 默认实现是抛出异常，可重写这个函数做错误处理</p></li></ul><p>修改值<br>setValue:forKey:<br>setValue:forKeyPath:<br>setValue:forUnderfinedKey:<br>setNilValueForKey: 对非类对象属性设置nil时调用，默认抛出异常。</p><ul><li>解析json<br>重写2个方法 和 一个处理类型的方法；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark ---- 利用kvc解析json，一定要实现下面的两个方法！(属性名字用这个方法)</span><br><span class="line">-(void)setValue:(id)value forUndefinedKey:(NSString *)key&#123;</span><br><span class="line">    //找到和属性不一致名字的key，然后赋值给self的属性</span><br><span class="line">    if ([key isEqualToString:@&quot;description&quot;]) &#123;</span><br><span class="line">        // self.descriptionStr = value; // 不推荐使用</span><br><span class="line">        [self setValue:value forKey:@&quot;descriptionStr&quot;]; // 推荐</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(id)valueForUndefinedKey:(NSString *)key&#123;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark --- 对于处理“类型”，就用下面的方法</span><br><span class="line">// 处理特殊 ----（类型）例如：NSNumber--&gt; NSString</span><br><span class="line">- (void)setValue:(id)value forKey:(NSString *)key</span><br><span class="line">&#123;</span><br><span class="line">    // price 服务器是 NSNumber</span><br><span class="line">    // 服务器是 NSNumber ，模型表里是 NSString类型，所以，要处理</span><br><span class="line">    if ([value isKindOfClass:[NSNumber class]]) &#123;</span><br><span class="line">        // NSNumber--&gt; NSString</span><br><span class="line">        [self setValue:[NSString stringWithFormat:@&quot;%@&quot;,value] forKey:key];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        [super setValue:value forKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="底层实现原理"><a href="#底层实现原理" class="headerlink" title="底层实现原理"></a>底层实现原理</h4><p>KVC运用了isa-swizzing技术。isa-swizzing就是类型混合指针机制。KVC通过isa-swizzing实现其内部查找定位。isa指针（is kind of 的意思）指向维护分发表的对象的类，该分发表实际上包含了指向实现类中的方法的指针和其他数据。<br>比如说如下的一行KVC代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[site setValue:@&quot;sitename&quot; forKey:@&quot;name&quot;];</span><br><span class="line">//会被编译器处理成</span><br><span class="line">SEL sel = sel_get_uid(setValue:forKey);</span><br><span class="line">IMP method = objc_msg_loopup(site-&gt;isa,sel);</span><br><span class="line">method(site,sel,@&quot;sitename&quot;,@&quot;name&quot;);</span><br></pre></td></tr></table></figure></p><p>每个类都有一张方法表，是一个hash表，值是函数指针IMP，SEL的名称就是查表时所用的键。<br>SEL数据类型：查找方法表时所用的键。定义成char*，实质上可以理解成int值。<br>IMP数据类型：他其实就是一个编译器内部实现时候的函数指针。当Objective-C编译器去处理实现一个方法的时候，就会指向一个IMP对象，这个对象是C语言表述的类型。</p><ul><li><p>KVC的内部机制：<br>一个对象在调用setValue的时候进行了如下操作：<br>1.根据方法名找到运行方法的时候需要的环境参数<br>2.他会从自己的isa指针结合环境参数，找到具体的方法实现接口。<br>3.再直接查找得来的具体的实现方法</p></li><li><p>苹果为什么要用子类(就是C语言创建的那个子类)监听setter方法，而不用分类(Person+AWKVO)呢？<br>回答：原因是当你用分类监听setter方法的时候，Person类中setter方法就不会走了，这样不好，所以苹果使用了子类监听setter方法。</p></li></ul><h3 id="比较objectForKey与objectForKeyPath"><a href="#比较objectForKey与objectForKeyPath" class="headerlink" title="比较objectForKey与objectForKeyPath"></a>比较objectForKey与objectForKeyPath</h3><ul><li>区别<br>1.如:sum/average/max/min<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array1 = @[@1, @3, @5, @7, @9,@11, @13];</span><br><span class="line">NSInteger sum = [[array1 valueForKeyPath:@&quot;@sum.floatValue&quot;] integerValue];</span><br><span class="line">NSInteger avg = [[array1 valueForKeyPath:@&quot;@avg.floatValue&quot;] integerValue];</span><br><span class="line">NSInteger max = [[array1 valueForKeyPath:@&quot;@max.floatValue&quot;] integerValue];</span><br><span class="line">NSInteger min = [[array1 valueForKeyPath:@&quot;@min.floatValue&quot;] integerValue];</span><br><span class="line">NSLog(@&quot;sum--%ld--avg--%ld-max--%ld-min--%ld&quot;,(long)sum,(long)avg,(long)max,(long)min);</span><br><span class="line">//注意:此种写法将引起崩溃</span><br><span class="line">//    NSInteger sum = [[array1 valueForKey:@&quot;@sum.floatValue&quot;] integerValue];</span><br><span class="line">//    NSInteger avg = [[array1 valueForKey:@&quot;@avg.floatValue&quot;] integerValue];</span><br><span class="line">//    NSInteger max = [[array1 valueForKey:@&quot;@max.floatValue&quot;] integerValue];</span><br><span class="line">//    NSInteger min = [[array1 valueForKey:@&quot;@min.floatValue&quot;] integerValue];</span><br><span class="line">//    NSLog(@&quot;sum--%ld--avg--%ld-max--%ld-min--%ld&quot;,(long)sum,(long)avg,(long)max,(long)min);</span><br></pre></td></tr></table></figure></li></ul><p>2.删除数组中重复的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array2 = @[@1, @3, @5, @7, @9,@11, @13, @7, @9,@11];</span><br><span class="line">NSLog(@&quot;deleteKeyPath---%@&quot;,[array2 valueForKeyPath:@&quot;@distinctUnionOfObjects.self&quot;]);</span><br><span class="line">//下述写法不可取,会引起崩溃</span><br><span class="line">//NSLog(@&quot;deleteKey---%@&quot;,[array2 valueForKey:@&quot;@distinctUnionOfObjects.self&quot;]);</span><br></pre></td></tr></table></figure></p><p>3.深层次取字典中出子属性</p><ul><li>valueForKeyPath:可以深层次取到子属性，不管隐藏的多深，不只是字典套字典，对象套对象/对象套对象再套字典等情况，都可以通过链式调用到深层的值</li><li><p>valueForKey:无法取到深层次子属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary *dic = @&#123;@&quot;dic1&quot;:@&#123;@&quot;dic2&quot;:@&#123;@&quot;name&quot;:@&quot;zhangsanfeng&quot;,@&quot;info&quot;:@&#123;@&quot;age&quot;:@&quot;13&quot;&#125;&#125;&#125;&#125;;</span><br><span class="line">//可以深层次的取到子层级属性</span><br><span class="line">NSLog(@&quot;KeyPath---%@&quot;,[dic valueForKeyPath:@&quot;dic1.dic2.info.age&quot;]); //13</span><br><span class="line">//无法深层次取到子层级属性</span><br><span class="line">NSLog(@&quot;Key---%@&quot;,[dic valueForKey:@&quot;dic1.dic2.info.age&quot;]); //null</span><br></pre></td></tr></table></figure></li><li><p>相同<br>1.快速找到字典数组中key所对应的值<br>对于@[@{key:value},@{key:value},@{key:value}]的数组(数组元素是字典的),通过同一个key可以取到value的集合(数组)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NSArray *dicArray = @[</span><br><span class="line">@&#123;@&quot;company&quot;:@&quot;baidu&quot;,@&quot;person&quot;:@&#123;@&quot;name&quot;:@&quot;zhangsanfeng&quot;&#125;&#125;,</span><br><span class="line">@&#123;@&quot;company&quot;:@&quot;tencent&quot;,@&quot;position&quot;:@&quot;chengdu&quot;&#125;];</span><br><span class="line">NSLog(@&quot;keyPath---%@&quot;, [dicArray valueForKeyPath:@&quot;company&quot;]);</span><br><span class="line">NSLog(@&quot;key-- -%@&quot;, [dicArray valueForKey:@&quot;company&quot;]);</span><br><span class="line"></span><br><span class="line">keyPath---(</span><br><span class="line">baidu,</span><br><span class="line">tencent</span><br><span class="line">)</span><br><span class="line">key-- -(</span><br><span class="line">baidu,</span><br><span class="line">tencent</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><p>2.大小写字母转换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array3 = @[@&quot;name&quot;,@&quot;w&quot;,@&quot;b&quot;,@&quot;h&quot;,@&quot;g&quot;,@&quot;d&quot;,@&quot;r&quot;,@&quot;p&quot;];</span><br><span class="line">NSLog(@&quot;KeyPath---%@&quot;,[array3 valueForKeyPath:@&quot;uppercaseString&quot;]);</span><br><span class="line">NSArray *newArray = [array3 valueForKey:@&quot;uppercaseString&quot;];</span><br><span class="line">NSLog(@&quot;newArray---%@&quot;,newArray);</span><br></pre></td></tr></table></figure></p><h3 id="比较objectForKey与valueForKey"><a href="#比较objectForKey与valueForKey" class="headerlink" title="比较objectForKey与valueForKey"></a>比较objectForKey与valueForKey</h3><ul><li>valueforkey：是KVC的方法， Key只允许使用NSString类型。</li><li>objectforkey：是NSDictionary的方法，Key可以是任意类型。</li><li>在NSDictionary中的差异：一般来说 key 可以是任意字符串组合，如果 key 不是以 @ 符号开头，这时候 valueForKey: 等同于 objectForKey:，如果是以 @ 开头，objectForKey 可以正确取值，但是 valueForKey 取值会直接 crash 掉，所以在使用NSDictionary取值时，尽量使用objectForKey。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary *dict = [NSDictionary dictionaryWithObject:@&quot;theValue&quot; forKey:@&quot;@theKey&quot;];// 注意这个 key 是以 @ 开头</span><br><span class="line">NSString *value1 = [dict objectForKey:@&quot;@theKey&quot;];</span><br><span class="line">NSString *value2 = [dict valueForKey:@&quot;@theKey&quot;];</span><br></pre></td></tr></table></figure></li></ul><p>　　　　　</p><h2 id="APNs"><a href="#APNs" class="headerlink" title="APNs"></a>APNs</h2><h3 id="远程推送"><a href="#远程推送" class="headerlink" title="远程推送"></a>远程推送</h3><p>我们的设备和APNS服务器之间的通讯是基于SSL协议的TCP流通讯，二者之间维持一个长连接。</p><h3 id="远程推送的实现原理"><a href="#远程推送的实现原理" class="headerlink" title="远程推送的实现原理"></a>远程推送的实现原理</h3><p>1.打开App时: 发送UDID和BundleID给APNs加密后返回deviceToken<br>2.获取Token后，App调用接口,将用户身份信息和deviceToken发给服务器，服务器记录<br>3.当推送消息时, 服务器按照用户身份信息找到存储的deviceToken，将消息和deviToken发送给APNs<br>4.苹果的APNs通过deviceToken, 找到指定设备的指定程序, 并将消息推送给用户</p><h3 id="Feedback-service"><a href="#Feedback-service" class="headerlink" title="Feedback service"></a>Feedback service</h3><p>APNS会持续的更新Feedback service的列表，当我们的Provider将信息发给APNS推送到我们的设备时，如果这时设备无法将消息推送到指定的应用，就会向APNS服务器 报告一个反馈信息，而这个信息就记录在feedback service中。</p><p>参考文章：<br><a href="https://www.cnblogs.com/wsnb/p/4899719.html" target="_blank" rel="noopener">iOS中如何选择delegate、通知、KVO（以及三者的区别）</a><br><a href="http://www.cnblogs.com/zy1987/p/4616764.html" target="_blank" rel="noopener">深入理解 KVC\KVO 实现机制</a><br><a href="https://www.cnblogs.com/kenshincui/p/4168532.html" target="_blank" rel="noopener">iOS开发系列–通知与消息机制</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>iOS计时器timer学习笔记</title>
      <link href="/2018/06/20/iOS%E8%AE%A1%E6%97%B6%E5%99%A8timer%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/06/20/iOS%E8%AE%A1%E6%97%B6%E5%99%A8timer%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">initWithFireDate</span><br><span class="line">timerWithTimeInterval</span><br><span class="line">scheduledTimerWithTimeInterval</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>如果使用timerWithTimeInterval或initWithFireDate构造，需要手动添加到runloop上</li><li>使用<code>scheduledTimerWithTimeInterval</code>则不需要，scheduledTimerWithTimeInterval除了<code>构造timer</code>，还会把timer添加到<code>当前线程的runloop</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)timer1 &#123;</span><br><span class="line">    self.timer = [[NSTimer alloc] initWithFireDate:[NSDate dateWithTimeIntervalSinceNow:3] interval:3 target:self selector:@selector(timerTest:) userInfo:nil repeats:YES];</span><br><span class="line">    // 需要添加到runloop才能触发</span><br><span class="line">    [[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSDefaultRunLoopMode];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)timer2 &#123;</span><br><span class="line">    self.timer = [NSTimer timerWithTimeInterval:2 target:self selector:@selector(timerTest:) userInfo:nil repeats:YES];</span><br><span class="line">    // 正常触发</span><br><span class="line">    [[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSDefaultRunLoopMode];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)timer3 &#123;</span><br><span class="line">    // 自动添加到runloop</span><br><span class="line">    self.timer = [NSTimer scheduledTimerWithTimeInterval:2 target:self selector:@selector(timerTest:) userInfo:nil repeats:YES];</span><br><span class="line">&#125;</span><br><span class="line">- (void)timerTest:(NSObject *)obj &#123;</span><br><span class="line">    NSLog(@&quot;time fire&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="触发"><a href="#触发" class="headerlink" title="触发"></a>触发</h2><ul><li>NSTimer只有被添加到runloop才能生效，NSTimer在添加到runloop时，timer开始计时，即使runloop没有开启（run），在构造NSTimer的时候，如果不是马上开始计时，可以先使用timerWithTimeInterval再手动加入runloop上</li><li>没有添加到runloop的timer，调用fire的时候会立即触发，并且只触发一次（如果repeat:YES），该方法触发不影响计时器原本的计时，只是新增一次触发</li><li>当NSTimer进入后台的时，NSTimer计时暂停，进入前台继续</li></ul><h2 id="NSTimer与runloop"><a href="#NSTimer与runloop" class="headerlink" title="NSTimer与runloop"></a>NSTimer与runloop</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure><h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><p>NSTimer在构造函数会对target强引用，在调用invalidate时，会移除去target的强引用<br>NSTimer被加到Runloop的时候，会被runloop强引用持有，在调用invalidate的时候，会从runloop删除<br>当定时器是不重复的（repeat=NO），在执行完触发函数后，会自动调用invalidate解除runloop的注册和接触对target的强引用，如果repeats参数为YES，则需要程序员手动调取invalidate方法才能释放timer对target和userIfo的强引用。<br>由于NSTimer被加到runloop的时候会被runloop强引用，故如果使用scheduledTimerWithTimeInterval构造函数时，我们可以在viewcontroller使用weak引用NSTimer，而<code>当调用invalidate时，self.timer会被自动置为nil</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, weak) NSTimer *timer;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    self.timer = [NSTimer scheduledTimerWithTimeInterval:2 target:self selector:@selector(timerTest:) userInfo:nil repeats:YES];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>invalidate方法通常不能放在NStimer.target.dealloc里面，因为NSTimer会对target强引用，而如果target对NSTimer强引用就会造成循环引用<br>所以通常我们不能在dealloc方法让[timer invalidate], 因为timer在invalidate之前，会引用self（通常是ViewController），导致self无法释放，可以在viewDidDisappear或显式调用timer的invalidate方法</p><p>invalidate是唯一让timer从runloop删除的方法，也是唯一去除对target强引用的方法</p><h2 id="NSTimer与多线程"><a href="#NSTimer与多线程" class="headerlink" title="NSTimer与多线程"></a>NSTimer与多线程</h2><p>如果我们不在主线程使用Timer的时候，即使我们把timer添加到runloop，也不能被触发，因为主线程的runloop默认是开启的，而其他线程的runloop默认没有实现runloop，并且在后台线程使用NSTimer不能通过fire启动定时器，只能通过runloop不断的运行下去<br>非主线程需要手动运行runloop，run方法会阻塞，直到没有输入源的时候返回（例如：timer从runloop中移除，invalidate）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    // 使用新线程</span><br><span class="line">    [NSThread detachNewThreadSelector:@selector(startNewThread) toTarget:self withObject:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)startNewThread &#123;</span><br><span class="line">    self.timer = [NSTimer timerWithTimeInterval:2 target:self selector:@selector(timerTest:) userInfo:nil repeats:YES];</span><br><span class="line"></span><br><span class="line">    // 添加到runloop</span><br><span class="line">    NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</span><br><span class="line">    [runLoop addTimer:self.timer forMode:NSDefaultRunLoopMode];</span><br><span class="line"></span><br><span class="line">    //手动运行runloop</span><br><span class="line">    [runLoop run]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="GCD的定时器"><a href="#GCD的定时器" class="headerlink" title="GCD的定时器"></a>GCD的定时器</h3><p>如果对精度有要求，可以使用GCD的定时器<br>timer不是一种实时的机制，会存在延迟，而且延迟的程度跟当前线程的执行情况有关，timer并不会因为触发延迟而导致后面的触发时间发生延迟。。<br><!--NSTimer不支持暂停和继续，如果需要可以使用GCD的定时器--></p><h3 id="NSTimer的暂停-重启"><a href="#NSTimer的暂停-重启" class="headerlink" title="NSTimer的暂停/重启"></a>NSTimer的暂停/重启</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[timer setFireDate:[NSDate distantFuture]];//停止</span><br><span class="line">[timer setFireDate:[NSDate distantPast]];//运行</span><br></pre></td></tr></table></figure><h2 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h2><h3 id="让App支持后台运行（运行音频）（在后台可以触发）"><a href="#让App支持后台运行（运行音频）（在后台可以触发）" class="headerlink" title="让App支持后台运行（运行音频）（在后台可以触发）"></a>让App支持后台运行（运行音频）（在后台可以触发）</h3><p>Info.plist中，<code>Required background modes</code>添加<code>App plays audio or streams audio/video using AirPlay</code><br><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</code>中添加以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NSError *setCategoryErr = nil;</span><br><span class="line">NSError *activationErr  = nil;</span><br><span class="line">[[AVAudioSession sharedInstance]</span><br><span class="line">setCategory: AVAudioSessionCategoryPlayback</span><br><span class="line">error: &amp;setCategoryErr];</span><br><span class="line">[[AVAudioSession sharedInstance]</span><br><span class="line">setActive: YES</span><br><span class="line">error: &amp;activationErr];</span><br><span class="line">self.window.backgroundColor = [UIColor whiteColor];</span><br><span class="line">[self.window makeKeyAndVisible];</span><br></pre></td></tr></table></figure></p><p>3.程序进入后台进行以下操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (void)applicationDidEnterBackground:(UIApplication *)application &#123;</span><br><span class="line"></span><br><span class="line">UIApplication* app = [UIApplication sharedApplication];</span><br><span class="line">__block UIBackgroundTaskIdentifier bgTask;</span><br><span class="line"></span><br><span class="line">/*注册一个后台任务，告诉系统我们需要向系统借一些事件*/</span><br><span class="line">bgTask = [app beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">if (bgTask != UIBackgroundTaskInvalid)</span><br><span class="line">&#123;</span><br><span class="line">/*销毁后台任务标识符*/</span><br><span class="line">/*不管有没有完成，结束background_task任务*/</span><br><span class="line">bgTask = UIBackgroundTaskInvalid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">if (bgTask != UIBackgroundTaskInvalid)</span><br><span class="line">&#123;</span><br><span class="line">/*销毁后台任务标识符*/</span><br><span class="line">/*不管有没有完成，结束background_task任务*/</span><br><span class="line">bgTask = UIBackgroundTaskInvalid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="记录离开和进入App的时间，手动控制计时器（在后台不能触发）"><a href="#记录离开和进入App的时间，手动控制计时器（在后台不能触发）" class="headerlink" title="记录离开和进入App的时间，手动控制计时器（在后台不能触发）"></a>记录离开和进入App的时间，手动控制计时器（在后台不能触发）</h3><p>1.AppDelegate 发送通知<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// APP进入后台</span><br><span class="line">- (void)applicationDidEnterBackground:(UIApplication *)application</span><br><span class="line">&#123;</span><br><span class="line">NSLog(@&quot;APP进入后台&quot;);</span><br><span class="line">[[NSNotificationCenter defaultCenter]postNotificationName:UIApplicationDidEnterBackgroundNotification object:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// APP将要从后台返回</span><br><span class="line">- (void)applicationWillEnterForeground:(UIApplication *)application</span><br><span class="line">&#123;</span><br><span class="line">NSLog(@&quot;APP进入前台&quot;);</span><br><span class="line">[[NSNotificationCenter defaultCenter]postNotificationName:UIApplicationWillEnterForegroundNotification object:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.创建一个管理类：EnterBackgroundManager，添加观察者，接受通知<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic,strong) id observer_enterBack;</span><br><span class="line">@property(nonatomic,strong) id observer_enterFore;</span><br><span class="line"></span><br><span class="line">//添加两个观察者</span><br><span class="line">- (void)addObserverUsingBlock:(TGHandlerEnterBackgroundBlock)block &#123;</span><br><span class="line">__block CFAbsoluteTime enterBackgroundTime;</span><br><span class="line"></span><br><span class="line">self.observer_enterBack = [[NSNotificationCenter defaultCenter]addObserverForName:UIApplicationDidEnterBackgroundNotification object:nil queue:nil usingBlock:^(NSNotification * _Nonnull note) &#123;</span><br><span class="line">if (![note.object isKindOfClass:[UIApplication class]]) &#123;</span><br><span class="line">enterBackgroundTime = CFAbsoluteTimeGetCurrent();</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__block CFAbsoluteTime enterForegroundTime;</span><br><span class="line">self.observer_enterFore = [[NSNotificationCenter defaultCenter]addObserverForName:UIApplicationWillEnterForegroundNotification object:nil queue:nil usingBlock:^(NSNotification * _Nonnull note) &#123;</span><br><span class="line">if (![note.object isKindOfClass:[UIApplication class]]) &#123;</span><br><span class="line">enterForegroundTime = CFAbsoluteTimeGetCurrent();</span><br><span class="line">CFAbsoluteTime timeInterval = enterForegroundTime-enterBackgroundTime;</span><br><span class="line">NSLog(@&quot;APP在后台持续 time = %lf s&quot;,timeInterval);</span><br><span class="line">block? block(note, timeInterval): nil;</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line">NSLog(@&quot;通知中心添加监听者：进入前后台&quot;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//移除通知</span><br><span class="line">-(void)removeNotificationObserver&#123;</span><br><span class="line"></span><br><span class="line">[[NSNotificationCenter defaultCenter] removeObserver:self.observer_enterBack];</span><br><span class="line">[[NSNotificationCenter defaultCenter] removeObserver:self.observer_enterFore];</span><br><span class="line">self.observer_enterBack = nil;</span><br><span class="line">self.observer_enterFore = nil;</span><br><span class="line">NSLog(@&quot;通知中心释放监听者：进入前后台&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.获取停留后台时间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">//监听APP在后台的时间</span><br><span class="line">WS(weakSelf);</span><br><span class="line">self.backgroundManager = [[EnterBackgroundManager alloc]init];</span><br><span class="line">[self.backgroundManager addObserverUsingBlock:^(NSNotification * _Nonnull note, NSTimeInterval stayBackgroundTime) &#123;</span><br><span class="line">weakSelf.timeStr = weakSelf.timeStr - stayBackgroundTime;</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="performSelector"><a href="#performSelector" class="headerlink" title="performSelector"></a>performSelector</h2><p>NSObject对象有一个performSelector可以用于延迟执行一个方法，其实该方法内部是启用一个Timer并添加到当前线程的runloop，原理与NSTimer一样，所以在非主线程使用的时候，需要保证线程的runloop是运行的，否则不会得到执行</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>NSTimer只有被注册到runloop才能起作用，fire不是开启定时器的方法，只是触发一次定时器的方法</li><li>NSTimer会强引用target</li><li>invalidate取消runloop的注册和target的强引用，如果是非重复的定时器，则在触发时会自动调用invalidate<br>通常我们自己封装GCD定时器使用起来更为方便，不会有这些问题</li></ul><p>参考文章：<a href="https://segmentfault.com/a/1190000009404275" target="_blank" rel="noopener">NSTimer学习笔记</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> timer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>铅笔画</title>
      <link href="/2018/06/12/%E9%93%85%E7%AC%94%E7%94%BB/"/>
      <url>/2018/06/12/%E9%93%85%E7%AC%94%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<center><img src="/assets/20180531_draw/draw_08.jpg" alt="“08”"></center><br><a id="more"></a><br><center>小女孩</center><center><img src="/assets/20180531_draw/draw_06.jpg" alt="“06”"></center><br><center>眼睛</center><center><img src="/assets/20180531_draw/draw_07.jpg" alt="“07”"></center><br><center>古代美女</center><center><img src="/assets/20180531_draw/draw_02.jpg" alt="“02”"></center><br><center>猫</center><center><img src="/assets/20180531_draw/draw_01.jpg" alt="“01”"></center><br><center>女</center><center><img src="/assets/20180531_draw/draw_03.jpg" alt="“03”"></center><br><center>大树</center><center><img src="/assets/20180531_draw/draw_04.jpg" alt="“04”"></center><br><center>爱笑的女孩</center><center><img src="/assets/20180531_draw/draw_05.jpg" alt="“05”"></center><br><center>熊猫</center>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>iOS通过外部应用打开APP</title>
      <link href="/2018/06/12/iOS%E9%80%9A%E8%BF%87%E5%A4%96%E9%83%A8%E5%BA%94%E7%94%A8%E6%89%93%E5%BC%80APP/"/>
      <url>/2018/06/12/iOS%E9%80%9A%E8%BF%87%E5%A4%96%E9%83%A8%E5%BA%94%E7%94%A8%E6%89%93%E5%BC%80APP/</url>
      
        <content type="html"><![CDATA[<p>微信屏蔽了外部唤醒其他app，实现从微信浏览器唤醒APP的几种方法：</p><h2 id="1-加入微信白名单"><a href="#1-加入微信白名单" class="headerlink" title="1.加入微信白名单"></a>1.加入微信白名单</h2><h2 id="2-使用腾讯应用宝，魔窗第三方服务"><a href="#2-使用腾讯应用宝，魔窗第三方服务" class="headerlink" title="2.使用腾讯应用宝，魔窗第三方服务"></a>2.使用腾讯应用宝，魔窗第三方服务</h2><h2 id="3-微信右上角有个“更多”，点击后选择在浏览器中打开"><a href="#3-微信右上角有个“更多”，点击后选择在浏览器中打开" class="headerlink" title="3.微信右上角有个“更多”，点击后选择在浏览器中打开"></a>3.微信右上角有个“更多”，点击后选择在浏览器中打开</h2><a id="more"></a><p>例如：<code>test://com.xxx?name=zhangsan&amp;pwd=123</code></p><ul><li>URL Schemes：xxx，url.scheme = <code>test</code>。</li><li>URL Identifier：是自定义的 URL scheme 的名字，一般采用反转域名的方法保证该名字的唯一性，比如 com.domain。url.host =<code>com.xxx</code>。</li><li>URL query: 参数，url.query = <code>name=zhangsan&amp;pwd=123</code>。<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3>检验URL是否能够跳转：在浏览器中输入<code>URL Schemes://</code>，弹出提示框：”是否打开XXX”，那么证明该URL是支持跳转的。</li></ul><h2 id="4-universal-links"><a href="#4-universal-links" class="headerlink" title="4.universal links"></a>4.universal links</h2><h3 id="APPID打开Associated-Domains"><a href="#APPID打开Associated-Domains" class="headerlink" title="APPID打开Associated Domains"></a>APPID打开Associated Domains</h3><h3 id="配置你的App的Universal-Links（通用链接）"><a href="#配置你的App的Universal-Links（通用链接）" class="headerlink" title="配置你的App的Universal Links（通用链接）"></a>配置你的App的Universal Links（通用链接）</h3><p> targets-&gt;Capabilities-&gt;Associated Domains<br> 添加<code>applinks:domain.com</code>，可以配置多个</p><h3 id="apple-app-site-association"><a href="#apple-app-site-association" class="headerlink" title="apple-app-site-association"></a>apple-app-site-association</h3><ul><li><p>json文件，但文件不要加后缀名。上传apple-app-site-association到HTTPS(注意：配置的网站必须是https)服务器根目录下，可以通过Get请求拉取到：<a href="https://domain.com/apple-app-site-association。" target="_blank" rel="noopener">https://domain.com/apple-app-site-association。</a><br>apple-app-site-association文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;applinks&quot;: &#123;</span><br><span class="line">        &quot;apps&quot;: [],</span><br><span class="line">        &quot;details&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;appID&quot;: &quot;TeamID.com.domain.App&quot;,</span><br><span class="line">                &quot;paths&quot;:[ &quot;*&quot; ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>appID：APPID的Prefix.bundleID</p></li><li>paths：支持Universal Link，也就是可以跳转的路径。*代表此域名下所有路径都支持。</li></ul><h3 id="AppDelegate"><a href="#AppDelegate" class="headerlink" title="AppDelegate"></a>AppDelegate</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:(void (^)(NSArray * _Nullable))restorationHandler&#123;</span><br><span class="line"></span><br><span class="line">    if (![userActivity.activityType isEqualToString:NSUserActivityTypeBrowsingWeb]) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //读取url地址</span><br><span class="line">    NSURL *webUrl = userActivity.webpageURL;</span><br><span class="line">    NSLog(@&quot;%@&quot;,webUrl);</span><br><span class="line"></span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p>检验URL是否能够跳转：在系统原生App中（如短信、邮件等）长按URL，如果弹出的选项中有在“your app”中打开，那么证明该URL是支持跳转的。</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><p>1.配置的网站必须是https，不能为http；</p><p>2.[重要]展示地址和打开的地址不能在一个域名下，比如展示页的地址是<a href="https://a.domain.com/?id=10，打开的如果是https://a.domain.com/app/?id=10，系统默认是打开页面，而不是触发通用链接打开app；" target="_blank" rel="noopener">https://a.domain.com/?id=10，打开的如果是https://a.domain.com/app/?id=10，系统默认是打开页面，而不是触发通用链接打开app；</a></p><p>3.[重要]配置玩证书之后需要更新证书，才能内部打包和提测上传成功；</p><p>4.通用链接可被屏蔽，点击右上角配置的链接之后，通用链接就失效了，解决方案详见：《iOS通用链接（Universal Links）突然点击无效的解决方案》。</p><h2 id="打开APP设置页面"><a href="#打开APP设置页面" class="headerlink" title="打开APP设置页面"></a>打开APP设置页面</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[UIApplication sharedApplication]openURL:[NSURL URLWithString:UIApplicationOpenSettingsURLString] ];</span><br></pre></td></tr></table></figure><h3 id="打开APP设置具体页面："><a href="#打开APP设置具体页面：" class="headerlink" title="打开APP设置具体页面："></a>打开APP设置具体页面：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NSURL *url = [NSURL URLWithString:@&quot;App-Prefs:root=LOCATION_SERVICES&quot;];</span><br><span class="line">if ([[UIApplication sharedApplication] canOpenURL:url]) &#123;</span><br><span class="line"></span><br><span class="line">    if (@available(iOS 10, *) ) &#123;</span><br><span class="line"></span><br><span class="line">        //iOS10.0以上  使用的操作</span><br><span class="line">        [[UIApplication sharedApplication] openURL:url options:@&#123;&#125; completionHandler:nil];</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //iOS10.0以下  使用的操作</span><br><span class="line">        [[UIApplication sharedApplication] openURL:url];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在iOS10以上的系统，”App-Prefs”同样会跳到设置页，”prefs”或”Prefs”不会响应以上的跳转方法，且会报如下错误信息：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-canOpenURL: failed for URL: &quot;prefs:root=LOCATION_SERVICES&quot; - error: &quot;The operation couldn’t be completed. (OSStatus error -10814.)&quot;</span><br></pre></td></tr></table></figure></li></ul><p>附跳转到具体设置页面代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Swift</span><br><span class="line"></span><br><span class="line">UIApplication.sharedApplication().openURL(NSURL(string:&quot;prefs:root=General&quot;)!)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Objective-c</span><br><span class="line"></span><br><span class="line">[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&quot;prefs:root=General&quot;]];</span><br><span class="line"></span><br><span class="line">prefs:root=General&amp;path=About</span><br><span class="line">prefs:root=General&amp;path=ACCESSIBILITY</span><br><span class="line">prefs:root=AIRPLANE_MODE</span><br><span class="line">prefs:root=General&amp;path=AUTOLOCK</span><br><span class="line">prefs:root=General&amp;path=USAGE/CELLULAR_USAGE</span><br><span class="line">prefs:root=Brightness    //打开Brightness(亮度)设置界面</span><br><span class="line">prefs:root=Bluetooth    //打开蓝牙设置</span><br><span class="line">prefs:root=General&amp;path=DATE_AND_TIME    //日期与时间设置</span><br><span class="line">prefs:root=FACETIME    //打开FaceTime设置</span><br><span class="line">prefs:root=General    //打开通用设置</span><br><span class="line">prefs:root=General&amp;path=Keyboard    //打开键盘设置</span><br><span class="line">prefs:root=CASTLE    //打开iClound设置</span><br><span class="line">prefs:root=CASTLE&amp;path=STORAGE_AND_BACKUP    //打开iCloud下的储存空间</span><br><span class="line">prefs:root=General&amp;path=INTERNATIONAL    //打开通用下的语言和地区设置</span><br><span class="line">prefs:root=LOCATION_SERVICES    //打开隐私下的定位服务</span><br><span class="line">prefs:root=ACCOUNT_SETTINGS</span><br><span class="line">prefs:root=MUSIC    //打开设置下的音乐</span><br><span class="line">prefs:root=MUSIC&amp;path=EQ    //打开音乐下的均衡器</span><br><span class="line">prefs:root=MUSIC&amp;path=VolumeLimit  //打开音乐下的音量</span><br><span class="line">prefs:root=General&amp;path=Network    //打开通用下的网络</span><br><span class="line">prefs:root=NIKE_PLUS_IPOD</span><br><span class="line">prefs:root=NOTES    //打开设置下的备忘录设置</span><br><span class="line">prefs:root=NOTIFICATIONS_ID    //打开设置下的通知设置</span><br><span class="line">prefs:root=Phone    //打开电话设置</span><br><span class="line">prefs:root=Photos    //打开设置下照片和相机设置</span><br><span class="line">prefs:root=General&amp;path=ManagedConfigurationList    //打开通用下的描述文件</span><br><span class="line">prefs:root=General&amp;path=Reset    //打开通用下的还原设置</span><br><span class="line">prefs:root=Sounds&amp;path=Ringtone</span><br><span class="line">prefs:root=Safari    //打开设置下的safari设置</span><br><span class="line">prefs:root=General&amp;path=Assistant    //打开siri不成功</span><br><span class="line">prefs:root=Sounds    //打开设置下的声音设置</span><br><span class="line">prefs:root=General&amp;path=SOFTWARE_UPDATE_LINK    //打开通用下的软件更新</span><br><span class="line">prefs:root=STORE    //打开通用下的iTounes Store和App Store设置</span><br><span class="line">prefs:root=TWITTER    //打开设置下的twitter设置</span><br><span class="line">prefs:root=FACEBOOK    //打开设置下的Facebook设置</span><br><span class="line">prefs:root=General&amp;path=USAGE    //打开通用下的用量</span><br><span class="line">prefs:root=VIDEO</span><br><span class="line">prefs:root=General&amp;path=Network/VPN        //打开通用下的vpn设置</span><br><span class="line">prefs:root=Wallpaper    //打开设置下的墙纸设置</span><br><span class="line">prefs:root=WIFI    //打开wifi设置</span><br><span class="line">prefs:root=INTERNET_TETHERING</span><br></pre></td></tr></table></figure><p>官方配置文件：<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/AppSearch/UniversalLinks.html#//apple_ref/doc/uid/TP40016308-CH12-SW2" target="_blank" rel="noopener">https://developer.apple.com/library/archive/documentation/General/Conceptual/AppSearch/UniversalLinks.html#//apple_ref/doc/uid/TP40016308-CH12-SW2</a></p><p>参考文档：<a href="https://www.cnblogs.com/vipstone/p/7496008.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">微信中通过页面(H5)直接打开本地app的解决方案</a></p><p><a href="http://www.cocoachina.com/ios/20170904/20463.html" target="_blank" rel="noopener">Universal Link 前端部署采坑记</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>iOS命令行打包ipa</title>
      <link href="/2018/06/04/iOS%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%89%93%E5%8C%85ipa/"/>
      <url>/2018/06/04/iOS%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%89%93%E5%8C%85ipa/</url>
      
        <content type="html"><![CDATA[<h2 id="打包步骤"><a href="#打包步骤" class="headerlink" title="打包步骤"></a>打包步骤</h2><h3 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h3><p>使用cocoapods：<br><code>xcodebuild clean -workspace ${TARGET_NAME}.xcworkspace -scheme ${TARGET_NAME} -configuration ${BUILD_TYPE}</code></p><ul><li><code>-workspace</code>： 如果项目中没有使用到CocoaPods，则该命令可以不用。</li><li><code>-scheme</code>： 和工程名字一样，<a id="more"></a>没有使用cocoapods：<br><code>xcodebuild clean -project ${TARGET_NAME}.xcodeproj -configuration ${CONFIGURATION} -alltargets</code></li></ul><h3 id="archive：生成build文件夹"><a href="#archive：生成build文件夹" class="headerlink" title="archive：生成build文件夹"></a>archive：生成build文件夹</h3><p>1.<br><code>xcodebuild -target APPNAME -configuration Release</code></p><p>2.<br><code>xcodebuild archive -workspace ${TARGET_NAME}.xcworkspace -scheme ${TARGET_NAME} -archivePath {ARCHIVEPATH}</code></p><ul><li><code>-archivePath</code>：后面跟的是编译后生成的archive包的路径。</li></ul><p><code>xcodebuild archive -project /Users/xxx/Desktop/APPNAME/APPNAME.xcodeproj -scheme APPNAME -archivePath bin/APPNAME.xcarchive</code></p><ul><li><code>/Users/xxx/Desktop/APPNAME/APPNAME.xcodeproj</code>为工程路径</li><li><code>bin/APPNAME.xcarchive</code>为.xcarchive文件的目标路径</li></ul><h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><p><code>xcodebuild -exportArchive -archivePath &quot;${ARCHIVEPATH}/${TARGET_NAME}.xcarchive&quot; -exportPath ${EXPORTPATH} -exportOptionsPlist ${EXPORTOPTIONSPLIST}‘</code></p><ul><li><code>${TARGET_NAME}</code> 项目对应targets的名字</li><li><code>${BUILD_TYPE}</code> 打包类型 Debug，Release 等</li><li><code>${archivePath}</code> .xcarchive文件导出目录</li><li><code>${EXPORTPATH}</code> 导出.ipa包的目录</li><li><code>${EXPORTOPTIONSPLIST}</code> exportOptionsPlist文件所在目录，可判断development, ad-hoc等<br>1.根据配置文件名称导出：<br><code>xcodebuild -exportArchive -archivePath bin/APPNAME.xcarchive -exportPath APPNAME -exportFormat ipa -exportProvisioningProfile &quot;yourProvisioningProfileName&quot;</code></li><li><code>yourProvisioningProfileName</code>为配置文件（Provisioning Profile）的名称<br>2.直接导出<br><code>xcrun -sdk iphoneos  PackageApplication -v /Users/xxx/Desktop/APPNAME/build/Release-iphoneos/APPNAME.app -o /Users/xxx/Desktop/APPNAME/APPNAME.ipa</code></li><li><code>/Users/xxx/Desktop/APPNAME/APPNAME.ipa</code>为导出ipa的目标路径</li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xcodebuild clean -workspace ScalperMerchant.xcworkspace -scheme ScalperMerchant -configuration Debug</span><br><span class="line"></span><br><span class="line">xcodebuild archive -workspace ScalperMerchant.xcworkspace -scheme ScalperMerchant -archivePath build/ScalperMerchant.xcarchive archive</span><br><span class="line"></span><br><span class="line">xcodebuild -exportArchive -archivePath build/ScalperMerchant.xcarchive -exportPath build -exportOptionsPlist ExportOptions.plist</span><br></pre></td></tr></table></figure><h2 id="如果要打-release-的包"><a href="#如果要打-release-的包" class="headerlink" title="如果要打 release 的包"></a>如果要打 release 的包</h2><p>1.打包类型改为 release<br>2.在ExportOptions.plist 修改 method  为 app-store<br>method 包含四种： app-store, ad-hoc, enterprise, development<br>3.provisioningProfiles   修改为  上线配置文件<br>4.signingCertificate   修改为上线证书<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcodebuild clean -workspace ScalperMerchant.xcworkspace -scheme ScalperMerchant -configuration  Release</span><br></pre></td></tr></table></figure></p><p>报错：<code>xcode-select: error: tool &#39;xcodebuild&#39; requires Xcode, but active developer directory &#39;/Library/Developer/CommandLineTools&#39; is a command line tools instance</code><br>问题：Xcode的路径被改了。<br>解决：重置Xcode路径<br><code>sudo xcode-select -switch /Applications/Xcode8.2.1.app/Contents/Developer</code></p><p>参考文件：<a href="https://blog.csdn.net/qq_31942467/article/details/79665053" target="_blank" rel="noopener">iOS 命令打包</a></p><p>1.xcodebuild clean<br>2.xcodebuild -workspace BlockCar.xcworkspace  -scheme BlockCar -archivePath build/BlockCar.xcarchive archive</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 打包 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>区块链与比特币相关知识</title>
      <link href="/2018/05/31/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E6%AF%94%E7%89%B9%E5%B8%81%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
      <url>/2018/05/31/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E6%AF%94%E7%89%B9%E5%B8%81%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h2><p>区块链是一个分布式的公共数据库，可以永久保存数字交易的记录。换句话说，它是一个日志文件，存储所有的不可变的数字交易记录<br>一个区块链由“矿工”共同维护，他们是网络内的成员，通过解决与区块相关的复杂算法问题，在每个区块中竞争验证比特币交易。<br>区块链技术不限于比特币。 它可以用于创建任何使用自己的区块链的加密货币，如以太坊和莱特币。<br><a id="more"></a><br>1.去中心化<br>2.共识机制<br>3.激励机制：通过经济激励，以确保遵守规则。中本聪 比特币<br>关键字：去中心化（Decentralized）、去信任（Trustless）、集体维护（Collectively maintain）、可靠数据库（Reliable Database）。</p><h3 id="区块链类型"><a href="#区块链类型" class="headerlink" title="区块链类型"></a>区块链类型</h3><ul><li>公开区块链：Bitcoin(比特币)，Ethereum Frontier(以太坊)。所有人都可以访问，所有人都可以发出交易等待被写入区块链，是完全的分布式。</li><li>协作区块链：Hyperledger。参与区块链的节点是事先选择好的。</li><li>私有区块链：Eris Industries。参与的节点只有用户自己，数据的访问和使用有严格的权限管理。</li></ul><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><code>数字货币 = 交易记录</code><br>一个交易：<br>1.判断是否有足够余额；<br>2.判断是否需要找零<br>3.发出去，让全球节点认同并备份</p><h3 id="数据安全"><a href="#数据安全" class="headerlink" title="数据安全"></a>数据安全</h3><ul><li>保证交易记录再传输过程中不会被篡改</li><li>保证交易记录确实是由发起交易的人创造</li></ul><h4 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h4><p>1.SHA256()  2.非对称加密<br>A：明文str-&gt;SHA256()加密-&gt;固定长度str1-&gt;使用私钥进行再加密-&gt;数字签名str2<br>A将<code>明文str、数字签名str2、公钥</code>给B<br>B：明文str-&gt;SHA256()-&gt;固定长度str3-&gt;使用公钥进行解密-&gt;str4<br>判断str2是否等于str4</p><p>节点对区块的检验：检验交易记录的签名是否准确，输入值是否有效，输入值的数字和是否等于输出值</p><h3 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h3><ul><li>黑洞效应</li><li>唯一区块ID = SHA256(‘区块内所有记录的集合’+’即将与之相连的上一个区块ID’+‘挖矿节点的运气值’+’…’)</li><li>产生区块、挖出区块、检验区块的时间周期近乎相同</li></ul><h3 id="分叉"><a href="#分叉" class="headerlink" title="分叉"></a>分叉</h3><p><code>拥有最多区块的支链将是真正被认可有价值的，较短的支链将会被直接Kill掉。</code></p><ul><li>“听谁的”——中本聪破解“拜占庭将军问题”的算法</li><li>比特币挖矿：记录交易</li><li>挖矿难度：增加挖矿难度，避免较多的分叉</li><li>算力：分叉后抢占优先发言权</li><li>工作量证明链：新的规则</li></ul><h3 id="双花与51-攻击"><a href="#双花与51-攻击" class="headerlink" title="双花与51%攻击"></a>双花与51%攻击</h3><h2 id="比特币（Bitcoin）"><a href="#比特币（Bitcoin）" class="headerlink" title="比特币（Bitcoin）"></a>比特币（Bitcoin）</h2><p>比特币区块链之上的代币——比特币。<code>虚拟币</code></p><ul><li>每个代币都基于某个底层的区块链。<ul><li>比特币区块链之上的代币——比特币。</li><li>以太坊区块链之上的代币——以太币。<h3 id="数量"><a href="#数量" class="headerlink" title="数量"></a>数量</h3>通过挖矿（工作量证明）来发行的，总数量程序写死了2100万个，第一笔区块奖励也是硬编码写死的。矿工挖出一个区块所获得的奖励，每隔21万个区块将减少一半，按照平均10分钟挖出一个区块的执行效率，也就就说差不多每四年会锐减一次。2009年1月起每个区块奖励50个比特币，2012年11月减半为每个区块25个比特币，2016年7月减半为12.5个比特币。基于这个规则，到2140年，所有比特币(20,999,999,980)将全部发行完毕，之后不会再有新的比特币产生。</li></ul></li></ul><h3 id="挖矿收益"><a href="#挖矿收益" class="headerlink" title="挖矿收益"></a>挖矿收益</h3><ul><li>挖矿收益 = 挖出新区块的奖励+新区块中包含的交易费</li><li>随着挖矿奖励的递减，以及区块中交易的数量增加，交易费所占的比重将会逐渐增加。在2140年之后，所有的矿工收益将完全由交易费构成。</li></ul><h3 id="coinbase（比特币交易平台）"><a href="#coinbase（比特币交易平台）" class="headerlink" title="coinbase（比特币交易平台）"></a>coinbase（比特币交易平台）</h3><p>参考：<a href="https://www.zhihu.com/question/37290469" target="_blank" rel="noopener">区块链是什么，如何简单易懂地介绍区块链？</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mac终端常用命令</title>
      <link href="/2018/05/25/Mac%E7%BB%88%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/05/25/Mac%E7%BB%88%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="Unix命令基础"><a href="#Unix命令基础" class="headerlink" title="Unix命令基础"></a>Unix命令基础</h2><p>（1）创建文件夹：mkdir<br>（2）跳到指定路径：cd<br>（3）查看当前完整路径：pwd<br>（4）查看当前路径下的所有文件及文件夹：ls<br>（5）cat：可以显示文件内容，但是不能编辑<br>（6）touch：如果文件存在，使用touch指令可更改这个文件或目录的日期时间，包括存取时间和更改时间；<br>如果文件不存在，touch指令会在当前目录下新建一个空白文件<br><a id="more"></a><br>（7）vi/vim：打开文件后可以编辑<br>（8）echo：输出<br>（9）删除文件夹，如果文件夹为空，使用<code>rmdir dir</code>即可，如果文件夹不为空，使用<code>rm -rf dir</code>删除该目录以及该目录下的所有文件 ，<code>-r</code>–是删除目录，<code>-f</code>意思是–强制删除，不提示。(-f:force -r:recursive)</p><blockquote><p><code>man -k rmdir</code>查看rmdir命令作用，<code>info rmdir</code>查看rmdir命令详细信息</p></blockquote><h3 id="显示隐藏文件"><a href="#显示隐藏文件" class="headerlink" title="显示隐藏文件"></a>显示隐藏文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.finder AppleShowAllFiles Yes &amp;&amp; killall Finder</span><br></pre></td></tr></table></figure><h3 id="不显示隐藏文件"><a href="#不显示隐藏文件" class="headerlink" title="不显示隐藏文件"></a>不显示隐藏文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.finder AppleShowAllFiles No &amp;&amp; killall Finder</span><br></pre></td></tr></table></figure><h3 id="删除文件夹下的所有-git-文件"><a href="#删除文件夹下的所有-git-文件" class="headerlink" title="删除文件夹下的所有 .git 文件"></a>删除文件夹下的所有 .git 文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;.git&quot; | xargs rm -Rf</span><br></pre></td></tr></table></figure><h3 id="brew-command-not-found"><a href="#brew-command-not-found" class="headerlink" title="brew: command not found"></a>brew: command not found</h3><p>安装brew:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -e &quot;$(curl --insecure -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure></p><p>error: could not lock config file .git/config， 权限不够，解决方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chgrp -R admin /usr/local</span><br><span class="line">sudo chmod -R g+w /usr/local</span><br></pre></td></tr></table></figure></p><p>安装node：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install node</span><br></pre></td></tr></table></figure></p><p>安装git：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install git</span><br></pre></td></tr></table></figure></p><p>安装hexo：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>180501天津游</title>
      <link href="/2018/05/05/180501%E5%A4%A9%E6%B4%A5%E6%B8%B8/"/>
      <url>/2018/05/05/180501%E5%A4%A9%E6%B4%A5%E6%B8%B8/</url>
      
        <content type="html"><![CDATA[<p>180430：南开，水上公园，五月天演唱会<br>180501：西开教堂，五大道，瓷房子，意式风情街，滨江道，天津之眼，古文化，世纪钟，解放桥，海河，津湾广场<br>美食：十八街麻花，耳朵眼炸糕，锅巴菜、面茶，糖油饼，叉排，桂花糕，牛皮糖，豆根糖，素卷圈</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>iOS修改searchBar右侧cancel按钮属性</title>
      <link href="/2018/05/03/iOS%E4%BF%AE%E6%94%B9searchBar%E5%8F%B3%E4%BE%A7cancel%E6%8C%89%E9%92%AE%E5%B1%9E%E6%80%A7/"/>
      <url>/2018/05/03/iOS%E4%BF%AE%E6%94%B9searchBar%E5%8F%B3%E4%BE%A7cancel%E6%8C%89%E9%92%AE%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>1.遍历searchBar子视图<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)searchBarTextDidBeginEditing:(UISearchBar *)searchBar &#123;</span><br><span class="line">searchBar.showsCancelButton = YES;</span><br><span class="line">for (UIView *view in [_searchBar.subviews[0] subviews]) &#123;</span><br><span class="line">if ([view isKindOfClass:[UIButton class]]) &#123;</span><br><span class="line">UIButton *cancel = (UIButton *)view;</span><br><span class="line">[cancel setTitle:@&quot;确定&quot; forState:UIControlStateNormal];</span><br><span class="line">[cancel setTitleColor:WYContentColor forState:UIControlStateNormal];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">- (void)searchBarTextDidEndEditing:(UISearchBar *)searchBar</span><br><span class="line">&#123;</span><br><span class="line">searchBar.showsCancelButton = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.setValue: forkey:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UIButton *cancelBtn = [_searchBar valueForKeyPath:@&quot;cancelButton&quot;]; //取出cancelBtn</span><br><span class="line">cancelBtn.enabled = YES;</span><br><span class="line">[cancelBtn setTitle:@&quot;取消&quot; forState:UIControlStateNormal];</span><br><span class="line">[cancelBtn setTitleColor:WYContentColor forState:UIControlStateNormal];</span><br><span class="line">cancelBtn.titleLabel.font = [UIFont systemFontOfSize:15];</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//这种写法解决了上面那种写法在弹出取消按钮时不自然的问题。</span><br><span class="line">        [_searchBar setValue:@&quot;确定&quot; forKey: @&quot;_cancelButtonText&quot;];</span><br><span class="line">        [_searchBar setValue:@&quot;确定&quot; forKey: @&quot;_cancelButtonText&quot;];</span><br></pre></td></tr></table></figure><p>3.iOS8也可以这样写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[UIBarButtonItem appearanceWhenContainedIn:[UISearchBar class], nil] setTitle:@&quot;确定&quot;];</span><br><span class="line">[[UIBarButtonItem appearanceWhenContainedIn:[UISearchBar class], nil] setTintColor:WYContentColor];</span><br></pre></td></tr></table></figure></p><p>4.iOS9以后可以这样写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[UIBarButtonItem appearanceWhenContainedInInstancesOfClasses:@[[UISearchBar class]]].title = @&quot;确定&quot;;</span><br><span class="line">[UIBarButtonItem appearanceWhenContainedInInstancesOfClasses:@[[UISearchBar class]]].tintColor = WYContentColor;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>iOS中UICollectionView的使用</title>
      <link href="/2018/03/27/iOS%E4%B8%ADUICollectionView%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/03/27/iOS%E4%B8%ADUICollectionView%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="UICollectionView的使用"><a href="#UICollectionView的使用" class="headerlink" title="UICollectionView的使用"></a>UICollectionView的使用</h1><h2 id="UICollectionViewDataSource"><a href="#UICollectionViewDataSource" class="headerlink" title="UICollectionViewDataSource"></a>UICollectionViewDataSource</h2><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//设置分区数</span><br><span class="line">- (NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView</span><br><span class="line">&#123;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">//设置每个分区的item个数</span><br><span class="line">- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section</span><br><span class="line">&#123;</span><br><span class="line">return self.data.count;</span><br><span class="line">&#125;</span><br><span class="line">//设置返回每个item的属性</span><br><span class="line">- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">RACollectionViewCell *cell = [self.collectionView dequeueReusableCellWithReuseIdentifier:cellID forIndexPath:indexPath];</span><br><span class="line">[cell.imageView removeFromSuperview];</span><br><span class="line">cell.imageView.frame = cell.bounds;</span><br><span class="line">cell.img = self.data[indexPath.row];</span><br><span class="line">//    cell.imageView.image = self.data[indexPath.row];</span><br><span class="line">[cell.contentView addSubview:cell.imageView];</span><br><span class="line"></span><br><span class="line">return cell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//对头视图或者尾视图进行设置</span><br><span class="line">// The view that is returned must be retrieved from a call to -dequeueReusableSupplementaryViewOfKind:withReuseIdentifier:forIndexPath:</span><br><span class="line">//- (UICollectionReusableView *)collectionView:(UICollectionView *)collectionView viewForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath&#123;</span><br><span class="line">//</span><br><span class="line">//&#125;</span><br></pre></td></tr></table></figure><h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//设置某个item是否可以被移动，返回NO则不能移动</span><br><span class="line">- (BOOL)collectionView:(UICollectionView *)collectionView canMoveItemAtIndexPath:(NSIndexPath *)indexPath&#123;</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line">//移动item的时候，会调用这个方法</span><br><span class="line">- (void)collectionView:(UICollectionView *)collectionView moveItemAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath*)destinationIndexPath&#123;</span><br><span class="line"></span><br><span class="line">UIImage *img = self.data[sourceIndexPath.row];</span><br><span class="line">[self.data removeObjectAtIndex:sourceIndexPath.row];</span><br><span class="line">[self.data insertObject:img atIndex:destinationIndexPath.row];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UICollectionViewDelegate"><a href="#UICollectionViewDelegate" class="headerlink" title="UICollectionViewDelegate"></a>UICollectionViewDelegate</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">//是否允许某个Item的高亮，返回NO，则不能进入高亮状态</span><br><span class="line">- (BOOL)collectionView:(UICollectionView *)collectionView shouldHighlightItemAtIndexPath:(NSIndexPath *)indexPath;</span><br><span class="line"></span><br><span class="line">//当item高亮时触发的方法</span><br><span class="line">- (void)collectionView:(UICollectionView *)collectionView didHighlightItemAtIndexPath:(NSIndexPath *)indexPath;</span><br><span class="line"></span><br><span class="line">//结束高亮状态时触发的方法</span><br><span class="line">- (void)collectionView:(UICollectionView *)collectionView didUnhighlightItemAtIndexPath:(NSIndexPath *)indexPath;</span><br><span class="line"></span><br><span class="line">//是否可以选中某个Item，返回NO，则不能选中</span><br><span class="line">- (BOOL)collectionView:(UICollectionView *)collectionView shouldSelectItemAtIndexPath:(NSIndexPath *)indexPath;</span><br><span class="line"></span><br><span class="line">//是否可以取消选中某个Item</span><br><span class="line">- (BOOL)collectionView:(UICollectionView *)collectionView shouldDeselectItemAtIndexPath:(NSIndexPath *)indexPath;</span><br><span class="line"></span><br><span class="line">//已经选中某个item时触发的方法</span><br><span class="line">- (void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath;</span><br><span class="line"></span><br><span class="line">//取消选中某个Item时触发的方法</span><br><span class="line">- (void)collectionView:(UICollectionView *)collectionView didDeselectItemAtIndexPath:(NSIndexPath *)indexPath;</span><br><span class="line"></span><br><span class="line">//将要加载某个Item时调用的方法</span><br><span class="line">- (void)collectionView:(UICollectionView *)collectionView willDisplayCell:(UICollectionViewCell *)cell forItemAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(8_0);</span><br><span class="line"></span><br><span class="line">//将要加载头尾视图时调用的方法</span><br><span class="line">- (void)collectionView:(UICollectionView *)collectionView willDisplaySupplementaryView:(UICollectionReusableView *)view forElementKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(8_0);</span><br><span class="line"></span><br><span class="line">//已经展示某个Item时触发的方法</span><br><span class="line">- (void)collectionView:(UICollectionView *)collectionView didEndDisplayingCell:(UICollectionViewCell *)cell forItemAtIndexPath:(NSIndexPath *)indexPath;</span><br><span class="line"></span><br><span class="line">//已经展示某个头尾视图时触发的方法</span><br><span class="line">- (void)collectionView:(UICollectionView *)collectionView didEndDisplayingSupplementaryView:(UICollectionReusableView *)view forElementOfKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)indexPath;</span><br><span class="line"></span><br><span class="line">//设置是否展示长按菜单</span><br><span class="line">- (BOOL)collectionView:(UICollectionView *)collectionView shouldShowMenuForItemAtIndexPath:(NSIndexPath *)indexPath;</span><br><span class="line"></span><br><span class="line">//设置要展示的菜单选项</span><br><span class="line">- (BOOL)collectionView:(UICollectionView *)collectionView canPerformAction:(SEL)action forItemAtIndexPath:(NSIndexPath *)indexPath withSender:(nullable id)sender;</span><br><span class="line"></span><br><span class="line">//实现点击菜单按钮后的触发方法,通过测试，只有copy，cut和paste三个方法可以使用</span><br><span class="line">- (void)collectionView:(UICollectionView *)collectionView performAction:(SEL)action forItemAtIndexPath:(NSIndexPath *)indexPath withSender:(nullable id)sender;</span><br><span class="line"></span><br><span class="line">//collectionView进行重新布局时调用的方法</span><br><span class="line">- (nonnull UICollectionViewTransitionLayout *)collectionView:(UICollectionView *)collectionView transitionLayoutForOldLayout:(UICollectionViewLayout *)fromLayout newLayout:(UICollectionViewLayout *)toLayout;</span><br></pre></td></tr></table></figure><h2 id="UICollectionViewDelegateFlowLayout"><a href="#UICollectionViewDelegateFlowLayout" class="headerlink" title="UICollectionViewDelegateFlowLayout"></a>UICollectionViewDelegateFlowLayout<uicollectionviewdelegate></uicollectionviewdelegate></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//设置item的大小</span><br><span class="line">- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath&#123;</span><br><span class="line">CGFloat itemW = (self.view.frame.size.width-(ItemNumber-1)*Margin-Inset*2-1)/(CGFloat)ItemNumber;</span><br><span class="line">return CGSizeMake(itemW, itemW);</span><br><span class="line">&#125;</span><br><span class="line">//四周的边距</span><br><span class="line">- (UIEdgeInsets)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout insetForSectionAtIndex:(NSInteger)section&#123;</span><br><span class="line">return UIEdgeInsetsMake(Inset, Inset, Inset, Inset);</span><br><span class="line">&#125;</span><br><span class="line">//设置垂直间距,默认的垂直和水平间距都是10</span><br><span class="line">- (CGFloat)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout minimumLineSpacingForSectionAtIndex:(NSInteger)section&#123;</span><br><span class="line">return Margin;</span><br><span class="line">&#125;</span><br><span class="line">- (CGFloat)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout minimumInteritemSpacingForSectionAtIndex:(NSInteger)section&#123;</span><br><span class="line">return Margin;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">//设置header的大小</span><br><span class="line">- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout referenceSizeForHeaderInSection:(NSInteger)section&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//设置footer的大小</span><br><span class="line">- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout referenceSizeForFooterInSection:(NSInteger)section&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h1 id="自定义UICollectionViewFlowLayout"><a href="#自定义UICollectionViewFlowLayout" class="headerlink" title="自定义UICollectionViewFlowLayout"></a>自定义UICollectionViewFlowLayout</h1><h2 id="在UICollectionViewFlowLayout类中完成四步："><a href="#在UICollectionViewFlowLayout类中完成四步：" class="headerlink" title="在UICollectionViewFlowLayout类中完成四步："></a>在UICollectionViewFlowLayout类中完成四步：</h2><p>（1）重写prepareLayout方法</p><ul><li>作用：在这个方法中做一些初始化操作，进行基本的布局，不能在init中布局，因为设置collectionView尺寸是在viewDidLoad中，而init在它之前调用，获得的collectionView的尺寸是空的</li><li>注意：一定要调用[super prepareLayout]</li></ul><p>（2）重写layoutAttributesForElementsInRect:方法</p><ul><li>作用：当collectionView的显示范围发生改变的时候，让其内部重新布局</li><li>这个方法的返回值是个数组</li><li>这个数组中存放的都是UICollectionViewLayoutAttributes对象</li><li>UICollectionViewLayoutAttributes对象决定了cell的排布方式（frame等）</li></ul><p>（3）重写shouldInvalidateLayoutForBoundsChange:方法</p><ul><li>作用：如果返回YES，那么collectionView显示的范围发生改变时，就会重新刷新布局</li><li>一旦重新刷新布局，就会按顺序调用下面的方法：</li><li>prepareLayout</li><li>layoutAttributesForElementsInRect:</li></ul><p>（4）重写targetContentOffsetForProposedContentOffset:withScrollingVelocity:方法</p><ul><li>作用：返回值决定了collectionView停止滚动时最终的偏移量（contentOffset）</li><li>参数：</li><li>proposedContentOffset：原本情况下，collectionView停止滚动时最终的偏移量</li><li>velocity：滚动速率，通过这个参数可以了解滚动的方向</li></ul><h2 id="例如实现一个相册效果，照片滚动到中间放大："><a href="#例如实现一个相册效果，照片滚动到中间放大：" class="headerlink" title="例如实现一个相册效果，照片滚动到中间放大："></a>例如实现一个相册效果，照片滚动到中间放大：</h2><p>（1）prepareLayout：cell在最左面的时候是在正中间<br>（2）layoutAttributesForElementsInRect：让cell滚动起来<br>（3）shouldInvalidateLayoutForBoundsChange：让cell在左右滑动的时候，尺寸放大或缩小<br>（4）targetContentOffsetForProposedContentOffset:withScrollingVelocity：让最接近中心的cell在停在正中央<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">6  * 用来做布局的初始化操作（不建议在init方法中进行布局的初始化操作）</span><br><span class="line">7  */</span><br><span class="line">8 - (void)prepareLayout</span><br><span class="line">9 &#123;</span><br><span class="line">10     [super prepareLayout];</span><br><span class="line">11     //水平滚动</span><br><span class="line">12     self.scrollDirection = UICollectionViewScrollDirectionHorizontal;</span><br><span class="line">13</span><br><span class="line">14     //</span><br><span class="line">15     CGFloat margin = (self.collectionView.frame.size.width - self.itemSize.width) / 2;</span><br><span class="line">16     self.collectionView.contentInset = UIEdgeInsetsMake(0, margin, 0, margin);</span><br><span class="line">17 &#125;</span><br><span class="line">18</span><br><span class="line">19 /**</span><br><span class="line">20  * 当collectionView的显示范围发生改变的时候，是否需要重新刷新布局</span><br><span class="line">21  * 一旦重新刷新布局，就会重新调用下面的方法：</span><br><span class="line">22  * 1.prepareLayout</span><br><span class="line">23  * 2.layoutAttributesForElementsInRect:方法</span><br><span class="line">24  */</span><br><span class="line">25 - (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds</span><br><span class="line">26 &#123;</span><br><span class="line">27     return YES;</span><br><span class="line">28 &#125;</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31 /**</span><br><span class="line">32  * 这个方法的返回值是一个数组（数组里面存放着rect范围内所有元素的布局属性）</span><br><span class="line">33  * 这个方法的返回值决定了rect范围内所有元素的排布（frame）</span><br><span class="line">34  */</span><br><span class="line">35 //需要在viewController中使用上ZWLineLayout这个类后才能重写这个方法！！</span><br><span class="line">36 - (NSArray&lt;UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect</span><br><span class="line">37 &#123;</span><br><span class="line">38     //让父类布局好样式</span><br><span class="line">39     NSArray *arr = [super layoutAttributesForElementsInRect:rect];</span><br><span class="line">40     //计算出collectionView的中心的位置</span><br><span class="line">41     CGFloat ceterX = self.collectionView.contentOffset.x + self.collectionView.frame.size.width * 0.5;</span><br><span class="line">42     /**</span><br><span class="line">43      * 1.一个cell对应一个UICollectionViewLayoutAttributes对象</span><br><span class="line">44      * 2.UICollectionViewLayoutAttributes对象决定了cell的frame</span><br><span class="line">45      */</span><br><span class="line">46     for (UICollectionViewLayoutAttributes *attributes in arr) &#123;</span><br><span class="line">47         //cell的中心点距离collectionView的中心点的距离，注意ABS()表示绝对值</span><br><span class="line">48         CGFloat delta = ABS(attributes.center.x - ceterX);</span><br><span class="line">49         //设置缩放比例</span><br><span class="line">50         CGFloat scale = 1.1 - delta / self.collectionView.frame.size.width;</span><br><span class="line">51         //设置cell滚动时候缩放的比例</span><br><span class="line">52         attributes.transform = CGAffineTransformMakeScale(scale, scale);</span><br><span class="line">53     &#125;</span><br><span class="line">54</span><br><span class="line">55     return arr;</span><br><span class="line">56 &#125;</span><br><span class="line">57</span><br><span class="line">58 /**</span><br><span class="line">59  * 这个方法的返回值，就决定了collectionView停止滚动时的偏移量</span><br><span class="line">60  */</span><br><span class="line">61 - (CGPoint)targetContentOffsetForProposedContentOffset:(CGPoint)proposedContentOffset withScrollingVelocity:(CGPoint)velocity</span><br><span class="line">62 &#123;</span><br><span class="line">63     // 计算出最终显示的矩形框</span><br><span class="line">64     CGRect rect;</span><br><span class="line">65     rect.origin.y = 0;</span><br><span class="line">66     rect.origin.x = proposedContentOffset.x;</span><br><span class="line">67     rect.size = self.collectionView.frame.size;</span><br><span class="line">68</span><br><span class="line">69     //获得super已经计算好的布局的属性</span><br><span class="line">70     NSArray *arr = [super layoutAttributesForElementsInRect:rect];</span><br><span class="line">71</span><br><span class="line">72     //计算collectionView最中心点的x值</span><br><span class="line">73     CGFloat centerX = proposedContentOffset.x + self.collectionView.frame.size.width * 0.5;</span><br><span class="line">74</span><br><span class="line">75     CGFloat minDelta = MAXFLOAT;</span><br><span class="line">76     for (UICollectionViewLayoutAttributes *attrs in arr) &#123;</span><br><span class="line">77         if (ABS(minDelta) &gt; ABS(attrs.center.x - centerX)) &#123;</span><br><span class="line">78             minDelta = attrs.center.x - centerX;</span><br><span class="line">79         &#125;</span><br><span class="line">80     &#125;</span><br><span class="line">81     proposedContentOffset.x += minDelta;</span><br><span class="line">82     return proposedContentOffset;</span><br><span class="line">83 &#125;</span><br></pre></td></tr></table></figure></p><h2 id="使用collectionView实现拖拽重排"><a href="#使用collectionView实现拖拽重排" class="headerlink" title="使用collectionView实现拖拽重排"></a>使用collectionView实现拖拽重排</h2><h3 id="第一种方法（从iOS9开始支持）"><a href="#第一种方法（从iOS9开始支持）" class="headerlink" title="第一种方法（从iOS9开始支持）"></a>第一种方法（从iOS9开始支持）</h3><p>1.给collectionView添加长按手势<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UILongPressGestureRecognizer *longPressGesture = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(longPressAction:)];</span><br><span class="line">[_collectionView addGestureRecognizer:longPressGesture];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.实现长按手势的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (void)longPressAction:(UILongPressGestureRecognizer *)longPress &#123;</span><br><span class="line">//获取此次点击的坐标，根据坐标获取cell对应的indexPath</span><br><span class="line">CGPoint point = [longPress locationInView:_collectionView];</span><br><span class="line">NSIndexPath *indexPath = [self.collectionView indexPathForItemAtPoint:point];</span><br><span class="line">//根据长按手势的状态进行处理。</span><br><span class="line">switch (longPress.state) &#123;</span><br><span class="line">case UIGestureRecognizerStateBegan:</span><br><span class="line">//当没有点击到cell的时候不进行处理</span><br><span class="line">if (!indexPath) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">//开始移动</span><br><span class="line">[_collectionView beginInteractiveMovementForItemAtIndexPath:indexPath];</span><br><span class="line">break;</span><br><span class="line">case UIGestureRecognizerStateChanged:</span><br><span class="line">//移动过程中更新位置坐标</span><br><span class="line">[_collectionView updateInteractiveMovementTargetPosition:point];</span><br><span class="line">break;</span><br><span class="line">case UIGestureRecognizerStateEnded:</span><br><span class="line">//停止移动调用此方法</span><br><span class="line">[_collectionView endInteractiveMovement];</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">//取消移动</span><br><span class="line">[_collectionView cancelInteractiveMovement];</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.实现移动的数据源方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 移动</span><br><span class="line">//设置某个item是否可以被移动，返回NO则不能移动</span><br><span class="line">- (BOOL)collectionView:(UICollectionView *)collectionView canMoveItemAtIndexPath:(NSIndexPath *)indexPath&#123;</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line">//移动item的时候，会调用这个方法</span><br><span class="line">- (void)collectionView:(UICollectionView *)collectionView moveItemAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath*)destinationIndexPath&#123;</span><br><span class="line"></span><br><span class="line">UIImage *img = self.data[sourceIndexPath.row];</span><br><span class="line">[self.data removeObjectAtIndex:sourceIndexPath.row];</span><br><span class="line">[self.data insertObject:img atIndex:destinationIndexPath.row];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="第二种方法（从iOS8开始支持）"><a href="#第二种方法（从iOS8开始支持）" class="headerlink" title="第二种方法（从iOS8开始支持）"></a>第二种方法（从iOS8开始支持）</h3><p>1.给collectionViewCell添加长按手势<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//为每个cell 添加长按手势</span><br><span class="line">UILongPressGestureRecognizer *longPress = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(longPressCellAction:)];</span><br><span class="line">[cell addGestureRecognizer:longPress];</span><br></pre></td></tr></table></figure></p><p>2.实现长按手势的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">- (void)longPressCellAction:(UILongPressGestureRecognizer *)longPress &#123;</span><br><span class="line"></span><br><span class="line">RACollectionViewCell *cell = (RACollectionViewCell *)longPress.view;</span><br><span class="line">NSIndexPath *cellIndexpath = [_collectionView indexPathForCell:cell];</span><br><span class="line"></span><br><span class="line">[_collectionView bringSubviewToFront:cell];</span><br><span class="line"></span><br><span class="line">_isChange = NO;</span><br><span class="line"></span><br><span class="line">switch (longPress.state) &#123;</span><br><span class="line">case UIGestureRecognizerStateBegan: &#123;</span><br><span class="line">[self.cellAttributesArray removeAllObjects];</span><br><span class="line">for (int i = 0; i &lt; self.data.count; i++) &#123;</span><br><span class="line">[self.cellAttributesArray addObject:[_collectionView layoutAttributesForItemAtIndexPath:[NSIndexPath indexPathForRow:i inSection:0]]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case UIGestureRecognizerStateChanged: &#123;</span><br><span class="line"></span><br><span class="line">cell.center = [longPress locationInView:_collectionView];</span><br><span class="line"></span><br><span class="line">for (UICollectionViewLayoutAttributes *attributes in self.cellAttributesArray) &#123;</span><br><span class="line">if (CGRectContainsPoint(attributes.frame, cell.center) &amp;&amp; cellIndexpath != attributes.indexPath) &#123;</span><br><span class="line">_isChange = YES;</span><br><span class="line">UIImage *img = self.data[cellIndexpath.row];</span><br><span class="line">[self.data removeObjectAtIndex:cellIndexpath.row];</span><br><span class="line">[self.data insertObject:img atIndex:attributes.indexPath.row];</span><br><span class="line">[self.collectionView moveItemAtIndexPath:cellIndexpath toIndexPath:attributes.indexPath];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case UIGestureRecognizerStateEnded: &#123;</span><br><span class="line"></span><br><span class="line">if (!_isChange) &#123;</span><br><span class="line">cell.center = [_collectionView layoutAttributesForItemAtIndexPath:cellIndexpath].center;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>完整demo：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;BaseViewController.h&quot;</span><br><span class="line">#import &quot;RACollectionViewCell.h&quot;</span><br><span class="line">#import &quot;WYAlertController.h&quot;</span><br><span class="line">#define ItemNumber  3</span><br><span class="line">#define Margin  5.f</span><br><span class="line">#define Inset   15.f</span><br><span class="line"></span><br><span class="line">@interface BaseViewController ()&lt;UICollectionViewDelegateFlowLayout,UICollectionViewDataSource&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) UICollectionView *collectionView;</span><br><span class="line">@property (nonatomic, strong) NSMutableArray *data;</span><br><span class="line">//使用数组将collectionView每个cell的 UICollectionViewLayoutAttributes 存储起来</span><br><span class="line">@property (nonatomic, strong) NSMutableArray *cellAttributesArray;</span><br><span class="line">@property (nonatomic, assign) BOOL isChange;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation BaseViewController</span><br><span class="line"></span><br><span class="line">static NSString *cellID = @&quot;cellID&quot;;</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line"></span><br><span class="line">[self.view addSubview:self.collectionView];</span><br><span class="line">[self setupPhotosArray];</span><br><span class="line">[self.collectionView reloadData];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setupPhotosArray</span><br><span class="line">&#123;</span><br><span class="line">for (int i = 1; i &lt;= 20; i++) &#123;</span><br><span class="line">UIImage *photo = [UIImage imageNamed:[NSString stringWithFormat:@&quot;%d.jpg&quot;,i]];</span><br><span class="line">[self.data addObject:photo];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSMutableArray *)data &#123;</span><br><span class="line">if(_data == nil) &#123;</span><br><span class="line">_data = [[NSMutableArray alloc] init];</span><br><span class="line">&#125;</span><br><span class="line">return _data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(NSMutableArray *)cellAttributesArray&#123;</span><br><span class="line">if (!_cellAttributesArray) &#123;</span><br><span class="line">_cellAttributesArray = [NSMutableArray arrayWithCapacity:3];</span><br><span class="line">&#125;</span><br><span class="line">return _cellAttributesArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UICollectionView *)collectionView &#123;</span><br><span class="line">if (_collectionView == nil) &#123;</span><br><span class="line">//设置布局属性</span><br><span class="line">UICollectionViewFlowLayout *flow = [[UICollectionViewFlowLayout alloc] init];</span><br><span class="line">//添加collectionView</span><br><span class="line">_collectionView = [[UICollectionView alloc] initWithFrame:CGRectMake(0, 20, self.view.frame.size.width, self.view.frame.size.height-20) collectionViewLayout:flow];</span><br><span class="line">_collectionView.backgroundColor = [UIColor whiteColor];</span><br><span class="line">//设置代理</span><br><span class="line">_collectionView.dataSource = self;</span><br><span class="line">_collectionView.delegate = self;</span><br><span class="line">//注册</span><br><span class="line">[_collectionView registerClass:[RACollectionViewCell class] forCellWithReuseIdentifier:cellID];</span><br><span class="line"></span><br><span class="line">//        UILongPressGestureRecognizer *longPressGesture = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(longPressAction:)];</span><br><span class="line">//        [_collectionView addGestureRecognizer:longPressGesture];</span><br><span class="line">&#125;</span><br><span class="line">return _collectionView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)longPressAction:(UILongPressGestureRecognizer *)longPress &#123;</span><br><span class="line">//获取此次点击的坐标，根据坐标获取cell对应的indexPath</span><br><span class="line">CGPoint point = [longPress locationInView:_collectionView];</span><br><span class="line">NSIndexPath *indexPath = [self.collectionView indexPathForItemAtPoint:point];</span><br><span class="line">//根据长按手势的状态进行处理。</span><br><span class="line">switch (longPress.state) &#123;</span><br><span class="line">case UIGestureRecognizerStateBegan:</span><br><span class="line">//当没有点击到cell的时候不进行处理</span><br><span class="line">if (!indexPath) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">//开始移动</span><br><span class="line">[_collectionView beginInteractiveMovementForItemAtIndexPath:indexPath];</span><br><span class="line">break;</span><br><span class="line">case UIGestureRecognizerStateChanged:</span><br><span class="line">//移动过程中更新位置坐标</span><br><span class="line">[_collectionView updateInteractiveMovementTargetPosition:point];</span><br><span class="line">break;</span><br><span class="line">case UIGestureRecognizerStateEnded:</span><br><span class="line">//停止移动调用此方法</span><br><span class="line">[_collectionView endInteractiveMovement];</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">//取消移动</span><br><span class="line">[_collectionView cancelInteractiveMovement];</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - UICollectionViewDataSource</span><br><span class="line">//设置分区数</span><br><span class="line">//- (NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView</span><br><span class="line">//&#123;</span><br><span class="line">//    return ItemNumber;</span><br><span class="line">//&#125;</span><br><span class="line">//设置每个分区的item个数</span><br><span class="line">- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section</span><br><span class="line">&#123;</span><br><span class="line">return self.data.count;</span><br><span class="line">&#125;</span><br><span class="line">//设置返回每个item的属性</span><br><span class="line">- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">RACollectionViewCell *cell = [self.collectionView dequeueReusableCellWithReuseIdentifier:cellID forIndexPath:indexPath];</span><br><span class="line">[cell.imageView removeFromSuperview];</span><br><span class="line">cell.imageView.frame = cell.bounds;</span><br><span class="line">cell.img = self.data[indexPath.row];</span><br><span class="line">//    cell.imageView.image = self.data[indexPath.row];</span><br><span class="line">[cell.contentView addSubview:cell.imageView];</span><br><span class="line"></span><br><span class="line">//为每个cell 添加长按手势</span><br><span class="line">UILongPressGestureRecognizer *longPress = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(longPressCellAction:)];</span><br><span class="line">[cell addGestureRecognizer:longPress];</span><br><span class="line"></span><br><span class="line">return cell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)longPressCellAction:(UILongPressGestureRecognizer *)longPress &#123;</span><br><span class="line"></span><br><span class="line">RACollectionViewCell *cell = (RACollectionViewCell *)longPress.view;</span><br><span class="line">NSIndexPath *cellIndexpath = [_collectionView indexPathForCell:cell];</span><br><span class="line"></span><br><span class="line">[_collectionView bringSubviewToFront:cell];</span><br><span class="line"></span><br><span class="line">_isChange = NO;</span><br><span class="line"></span><br><span class="line">switch (longPress.state) &#123;</span><br><span class="line">case UIGestureRecognizerStateBegan: &#123;</span><br><span class="line">[self.cellAttributesArray removeAllObjects];</span><br><span class="line">for (int i = 0; i &lt; self.data.count; i++) &#123;</span><br><span class="line">[self.cellAttributesArray addObject:[_collectionView layoutAttributesForItemAtIndexPath:[NSIndexPath indexPathForRow:i inSection:0]]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case UIGestureRecognizerStateChanged: &#123;</span><br><span class="line"></span><br><span class="line">cell.center = [longPress locationInView:_collectionView];</span><br><span class="line"></span><br><span class="line">for (UICollectionViewLayoutAttributes *attributes in self.cellAttributesArray) &#123;</span><br><span class="line">if (CGRectContainsPoint(attributes.frame, cell.center) &amp;&amp; cellIndexpath != attributes.indexPath) &#123;</span><br><span class="line">_isChange = YES;</span><br><span class="line">UIImage *img = self.data[cellIndexpath.row];</span><br><span class="line">[self.data removeObjectAtIndex:cellIndexpath.row];</span><br><span class="line">[self.data insertObject:img atIndex:attributes.indexPath.row];</span><br><span class="line">[self.collectionView moveItemAtIndexPath:cellIndexpath toIndexPath:attributes.indexPath];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case UIGestureRecognizerStateEnded: &#123;</span><br><span class="line"></span><br><span class="line">if (!_isChange) &#123;</span><br><span class="line">cell.center = [_collectionView layoutAttributesForItemAtIndexPath:cellIndexpath].center;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//对头视图或者尾视图进行设置</span><br><span class="line">// The view that is returned must be retrieved from a call to -dequeueReusableSupplementaryViewOfKind:withReuseIdentifier:forIndexPath:</span><br><span class="line">//- (UICollectionReusableView *)collectionView:(UICollectionView *)collectionView viewForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath&#123;</span><br><span class="line">//</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 移动</span><br><span class="line">//设置某个item是否可以被移动，返回NO则不能移动</span><br><span class="line">//- (BOOL)collectionView:(UICollectionView *)collectionView canMoveItemAtIndexPath:(NSIndexPath *)indexPath&#123;</span><br><span class="line">//    return YES;</span><br><span class="line">//&#125;</span><br><span class="line">////移动item的时候，会调用这个方法</span><br><span class="line">//- (void)collectionView:(UICollectionView *)collectionView moveItemAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath*)destinationIndexPath&#123;</span><br><span class="line">//</span><br><span class="line">//    UIImage *img = self.data[sourceIndexPath.row];</span><br><span class="line">//    [self.data removeObjectAtIndex:sourceIndexPath.row];</span><br><span class="line">//    [self.data insertObject:img atIndex:destinationIndexPath.row];</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">/// Returns a list of index titles to display in the index view (e.g. [&quot;A&quot;, &quot;B&quot;, &quot;C&quot; ... &quot;Z&quot;, &quot;#&quot;])</span><br><span class="line">- (nullable NSArray&lt;NSString *&gt; *)indexTitlesForCollectionView:(UICollectionView *)collectionView API_AVAILABLE(tvos(10.2));</span><br><span class="line"></span><br><span class="line">/// Returns the index path that corresponds to the given title / index. (e.g. &quot;B&quot;,1)</span><br><span class="line">/// Return an index path with a single index to indicate an entire section, instead of a specific item.</span><br><span class="line">- (NSIndexPath *)collectionView:(UICollectionView *)collectionView indexPathForIndexTitle:(NSString *)title atIndex:(NSInteger)index API_AVAILABLE(tvos(10.2));</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#pragma mark - UICollectionViewDelegate</span><br><span class="line">/*</span><br><span class="line">//是否允许某个Item的高亮，返回NO，则不能进入高亮状态</span><br><span class="line">- (BOOL)collectionView:(UICollectionView *)collectionView shouldHighlightItemAtIndexPath:(NSIndexPath *)indexPath;</span><br><span class="line"></span><br><span class="line">//当item高亮时触发的方法</span><br><span class="line">- (void)collectionView:(UICollectionView *)collectionView didHighlightItemAtIndexPath:(NSIndexPath *)indexPath;</span><br><span class="line"></span><br><span class="line">//结束高亮状态时触发的方法</span><br><span class="line">- (void)collectionView:(UICollectionView *)collectionView didUnhighlightItemAtIndexPath:(NSIndexPath *)indexPath;</span><br><span class="line"></span><br><span class="line">//是否可以选中某个Item，返回NO，则不能选中</span><br><span class="line">- (BOOL)collectionView:(UICollectionView *)collectionView shouldSelectItemAtIndexPath:(NSIndexPath *)indexPath;</span><br><span class="line"></span><br><span class="line">//是否可以取消选中某个Item</span><br><span class="line">- (BOOL)collectionView:(UICollectionView *)collectionView shouldDeselectItemAtIndexPath:(NSIndexPath *)indexPath;</span><br><span class="line"></span><br><span class="line">//已经选中某个item时触发的方法</span><br><span class="line">- (void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath;</span><br><span class="line"></span><br><span class="line">//取消选中某个Item时触发的方法</span><br><span class="line">- (void)collectionView:(UICollectionView *)collectionView didDeselectItemAtIndexPath:(NSIndexPath *)indexPath;</span><br><span class="line"></span><br><span class="line">//将要加载某个Item时调用的方法</span><br><span class="line">- (void)collectionView:(UICollectionView *)collectionView willDisplayCell:(UICollectionViewCell *)cell forItemAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(8_0);</span><br><span class="line"></span><br><span class="line">//将要加载头尾视图时调用的方法</span><br><span class="line">- (void)collectionView:(UICollectionView *)collectionView willDisplaySupplementaryView:(UICollectionReusableView *)view forElementKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(8_0);</span><br><span class="line"></span><br><span class="line">//已经展示某个Item时触发的方法</span><br><span class="line">- (void)collectionView:(UICollectionView *)collectionView didEndDisplayingCell:(UICollectionViewCell *)cell forItemAtIndexPath:(NSIndexPath *)indexPath;</span><br><span class="line"></span><br><span class="line">//已经展示某个头尾视图时触发的方法</span><br><span class="line">- (void)collectionView:(UICollectionView *)collectionView didEndDisplayingSupplementaryView:(UICollectionReusableView *)view forElementOfKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)indexPath;</span><br><span class="line"></span><br><span class="line">//设置是否展示长按菜单</span><br><span class="line">- (BOOL)collectionView:(UICollectionView *)collectionView shouldShowMenuForItemAtIndexPath:(NSIndexPath *)indexPath;</span><br><span class="line"></span><br><span class="line">//设置要展示的菜单选项</span><br><span class="line">- (BOOL)collectionView:(UICollectionView *)collectionView canPerformAction:(SEL)action forItemAtIndexPath:(NSIndexPath *)indexPath withSender:(nullable id)sender;</span><br><span class="line"></span><br><span class="line">//实现点击菜单按钮后的触发方法,通过测试，只有copy，cut和paste三个方法可以使用</span><br><span class="line">- (void)collectionView:(UICollectionView *)collectionView performAction:(SEL)action forItemAtIndexPath:(NSIndexPath *)indexPath withSender:(nullable id)sender;</span><br><span class="line"></span><br><span class="line">//collectionView进行重新布局时调用的方法</span><br><span class="line">- (nonnull UICollectionViewTransitionLayout *)collectionView:(UICollectionView *)collectionView transitionLayoutForOldLayout:(UICollectionViewLayout *)fromLayout newLayout:(UICollectionViewLayout *)toLayout;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//设置选中</span><br><span class="line">//点击移除图片</span><br><span class="line">- (void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">WYAlertController *alert = [WYAlertController initWYAlertControlWithTitle:nil message:@&quot;移除图片&quot; Style:UIAlertControllerStyleActionSheet titleArr:@[@&quot;移除图片&quot;,@&quot;取消&quot;] alerAction:^(NSInteger index) &#123;</span><br><span class="line">if (index == 0) &#123;</span><br><span class="line">[self removeCellWithIndexPath:indexPath];</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line">[alert showWYAler];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)removeCellWithIndexPath:(NSIndexPath *)indexPath&#123;</span><br><span class="line"></span><br><span class="line">//在执行完performBatchUpdates操作之后，collection view会自动reloadData</span><br><span class="line">//    [self.collectionView performBatchUpdates:^&#123;</span><br><span class="line">//        [self.collectionView deleteItemsAtIndexPaths:@[indexPath]];</span><br><span class="line">[self.data removeObjectAtIndex:indexPath.item];</span><br><span class="line">//    &#125; completion:^(BOOL finished) &#123;</span><br><span class="line">[self.collectionView reloadData];</span><br><span class="line">//    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - UICollectionViewDelegateFlowLayout&lt;UICollectionViewDelegate&gt;</span><br><span class="line">//设置item的大小</span><br><span class="line">- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath&#123;</span><br><span class="line">CGFloat itemW = (self.view.frame.size.width-(ItemNumber-1)*Margin)/(CGFloat)ItemNumber;</span><br><span class="line">return CGSizeMake(itemW, itemW);</span><br><span class="line">&#125;</span><br><span class="line">//四周的边距</span><br><span class="line">- (UIEdgeInsets)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout insetForSectionAtIndex:(NSInteger)section&#123;</span><br><span class="line">return UIEdgeInsetsMake(Inset, Inset, Inset, Inset);</span><br><span class="line">&#125;</span><br><span class="line">//设置垂直间距,默认的垂直和水平间距都是10</span><br><span class="line">- (CGFloat)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout minimumLineSpacingForSectionAtIndex:(NSInteger)section&#123;</span><br><span class="line">return Margin;</span><br><span class="line">&#125;</span><br><span class="line">- (CGFloat)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout minimumInteritemSpacingForSectionAtIndex:(NSInteger)section&#123;</span><br><span class="line">return Margin;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">//设置header的大小</span><br><span class="line">- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout referenceSizeForHeaderInSection:(NSInteger)section&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//设置footer的大小</span><br><span class="line">- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout referenceSizeForFooterInSection:(NSInteger)section&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p><p>自定义cell：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">@interface RACollectionViewCell : UICollectionViewCell</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) UIImageView *imageView;</span><br><span class="line"></span><br><span class="line">@property (nonatomic,strong)UIImage *img;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#import &quot;RACollectionViewCell.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation RACollectionViewCell</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithFrame:(CGRect)frame</span><br><span class="line">&#123;</span><br><span class="line">self = [super initWithFrame:frame];</span><br><span class="line">if (self) &#123;</span><br><span class="line">self.backgroundColor = [UIColor orangeColor];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(UIImageView *)imageView&#123;</span><br><span class="line">if (!_imageView) &#123;</span><br><span class="line">_imageView = [[UIImageView alloc] init];</span><br><span class="line">//        _imageView.contentMode = UIViewContentModeScaleAspectFill;</span><br><span class="line">_imageView.autoresizingMask = UIViewAutoresizingFlexibleHeight | UIViewAutoresizingFlexibleWidth;</span><br><span class="line">&#125;</span><br><span class="line">return _imageView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setImg:(UIImage *)img &#123;</span><br><span class="line">_img  = img;</span><br><span class="line"></span><br><span class="line">self.imageView.image = img;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setHighlighted:(BOOL)highlighted</span><br><span class="line">&#123;</span><br><span class="line">[super setHighlighted:highlighted];</span><br><span class="line">if (highlighted) &#123;</span><br><span class="line">_imageView.alpha = .7f;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">_imageView.alpha = 1.f;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h2 id="瀑布流实现"><a href="#瀑布流实现" class="headerlink" title="瀑布流实现"></a>瀑布流实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">@interface TestLayout : UICollectionViewFlowLayout</span><br><span class="line"></span><br><span class="line">@property(nonatomic,assign)NSInteger itemCount;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface TestLayout ()</span><br><span class="line">&#123;</span><br><span class="line">NSMutableArray * _attributeArray;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation TestLayout</span><br><span class="line"></span><br><span class="line">-(void)prepareLayout&#123;</span><br><span class="line"></span><br><span class="line">_attributeArray = [NSMutableArray array];</span><br><span class="line">[super prepareLayout];</span><br><span class="line"></span><br><span class="line">_itemCount = (int)[self.collectionView numberOfItemsInSection:0];</span><br><span class="line"></span><br><span class="line">float WIDTH = ([UIScreen mainScreen].bounds.size.width-self.sectionInset.left-self.sectionInset.right-self.minimumInteritemSpacing)/2;</span><br><span class="line">CGFloat colHight[2] = &#123;self.sectionInset.top,self.sectionInset.bottom&#125;;</span><br><span class="line">for (int i=0; i&lt;_itemCount; i++) &#123;</span><br><span class="line"></span><br><span class="line">NSIndexPath * index = [NSIndexPath indexPathForItem:i inSection:0];</span><br><span class="line">UICollectionViewLayoutAttributes * attribute =  [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:index];</span><br><span class="line">CGFloat height = arc4random()%150+40;</span><br><span class="line">int row = 0;</span><br><span class="line">if (colHight[0]&lt;colHight[1]) &#123;</span><br><span class="line">colHight[0] = colHight[0]+height+self.minimumLineSpacing;</span><br><span class="line">row = 0;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">colHight[1] = colHight[1]+height+self.minimumLineSpacing;</span><br><span class="line">row = 1;</span><br><span class="line">&#125;</span><br><span class="line">attribute.frame = CGRectMake(self.sectionInset.left+(self.minimumInteritemSpacing+WIDTH)*row, colHight[row]-height-self.minimumLineSpacing, WIDTH, height);</span><br><span class="line">[_attributeArray addObject:attribute];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">if (colHight[0]&gt;colHight[1]) &#123;</span><br><span class="line">self.itemSize = CGSizeMake(WIDTH, (colHight[0]-self.sectionInset.top)*2/_itemCount-self.minimumLineSpacing);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">self.itemSize = CGSizeMake(WIDTH, (colHight[1]-self.sectionInset.top)*2/_itemCount-self.minimumLineSpacing);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">-(NSArray&lt;UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect&#123;</span><br><span class="line">return _attributeArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="collectionCell根据内容自动适应宽度"><a href="#collectionCell根据内容自动适应宽度" class="headerlink" title="collectionCell根据内容自动适应宽度"></a>collectionCell根据内容自动适应宽度</h2><p>1.设置layout.estimatedItemSize<br>2.在自定义cell中实现preferredLayoutAttributesFittingAttributes<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark — 实现自适应文字宽度的关键步骤:item的layoutAttributes</span><br><span class="line">-(UICollectionViewLayoutAttributes *)preferredLayoutAttributesFittingAttributes:(UICollectionViewLayoutAttributes *)layoutAttributes&#123;</span><br><span class="line"></span><br><span class="line">    UICollectionViewLayoutAttributes *attributes = [super preferredLayoutAttributesFittingAttributes:layoutAttributes];</span><br><span class="line">    //    CGRect maxBounds= CGRectMake(0, 0, CGFLOAT_MAX, self.textLabel.frame.size.height);</span><br><span class="line">    //    attributes.frame = [self.textLabel textRectForBounds:maxBounds limitedToNumberOfLines:self.textLabel.numberOfLines];</span><br><span class="line">    attributes.frame = [self.textLabel.text boundingRectWithSize:CGSizeMake(CGFLOAT_MAX, self.textLabel.frame.size.height) options:NSStringDrawingUsesLineFragmentOrigin attributes:@&#123;NSFontAttributeName:self.textLabel.font&#125; context:nil];</span><br><span class="line">    return attributes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="UITableView自动调整"><a href="#UITableView自动调整" class="headerlink" title="UITableView自动调整"></a>UITableView自动调整</h1><p>UITableViewDelegate新增了三个方法来满足用户设定Cell、Header和Footer预计高度的方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- tableView:estimatedHeightForRowAtIndexPath:</span><br><span class="line">- tableView:estimatedHeightForHeaderInSection:</span><br><span class="line">- tableView:estimatedHeightForFooterInSection:</span><br></pre></td></tr></table></figure></p><p>当然对应这三个方法UITableView也有estimatedRowHeight、estimatedSectionHeaderHeight和estimatedSectionFooterHeight三个属性，局限性在于只能统一定义所有行和节的高度。</p><p>参考：<a href="https://github.com/Flying-Einstein/CollectionViewTest" target="_blank" rel="noopener">两列瀑布流</a><br><a href="https://github.com/codingZero/XRWaterfallLayout" target="_blank" rel="noopener">三列瀑布流</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>iOS图片/视频生成GIF图</title>
      <link href="/2018/03/15/iOS%E5%9B%BE%E7%89%87-%E8%A7%86%E9%A2%91%E7%94%9F%E6%88%90GIF%E5%9B%BE/"/>
      <url>/2018/03/15/iOS%E5%9B%BE%E7%89%87-%E8%A7%86%E9%A2%91%E7%94%9F%E6%88%90GIF%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="1-图片生成GIF图"><a href="#1-图片生成GIF图" class="headerlink" title="1.图片生成GIF图"></a>1.图片生成GIF图</h2><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//1.图片生成GIF图</span><br><span class="line">//    NSMutableArray *imgArray = [NSMutableArray array];</span><br><span class="line">//    for (int i=1; i&lt;7; i++) &#123;</span><br><span class="line">//        UIImage *image = [UIImage imageNamed:[NSString stringWithFormat:@&quot;clock%02d.png&quot;,i]];</span><br><span class="line">//        [imgArray addObject:image];</span><br><span class="line">//    &#125;</span><br><span class="line">//    [self creatGifWithImages:imgArray];</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p>核心方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 图片生成gif，需要依赖MobileCoreServices.framework</span><br><span class="line">-(void)creatGifWithImages:(NSMutableArray *)images&#123;</span><br><span class="line"></span><br><span class="line">//图像目标</span><br><span class="line">CGImageDestinationRef destination;</span><br><span class="line"></span><br><span class="line">//创建输出路径</span><br><span class="line">NSArray *document = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);</span><br><span class="line">NSString *documentStr = [document objectAtIndex:0];</span><br><span class="line">NSFileManager *fileManager = [NSFileManager defaultManager];</span><br><span class="line">NSString *textDirectory = [documentStr stringByAppendingPathComponent:@&quot;gif&quot;];</span><br><span class="line">[fileManager createDirectoryAtPath:textDirectory withIntermediateDirectories:YES attributes:nil error:nil];</span><br><span class="line">NSString *path = [textDirectory stringByAppendingPathComponent:@&quot;example.gif&quot;];</span><br><span class="line">NSLog(@&quot;path:%@&quot;,path);</span><br><span class="line">NSLog(@&quot;%@&quot;,images);</span><br><span class="line"></span><br><span class="line">//创建CFURL对象</span><br><span class="line">CFURLRef url = CFURLCreateWithFileSystemPath (</span><br><span class="line"></span><br><span class="line">kCFAllocatorDefault,</span><br><span class="line"></span><br><span class="line">(CFStringRef)path,</span><br><span class="line"></span><br><span class="line">kCFURLPOSIXPathStyle,</span><br><span class="line"></span><br><span class="line">false);</span><br><span class="line"></span><br><span class="line">//通过一个url返回图像目标</span><br><span class="line">destination = CGImageDestinationCreateWithURL(url, kUTTypeGIF, images.count, NULL);</span><br><span class="line"></span><br><span class="line">//设置gif的信息,播放间隔时间,基本数据,和delay时间</span><br><span class="line">NSDictionary *frameProperties = [NSDictionary</span><br><span class="line"></span><br><span class="line">dictionaryWithObject:[NSMutableDictionary dictionaryWithObjectsAndKeys:[NSNumber numberWithFloat:6*0.15], (NSString *)kCGImagePropertyGIFDelayTime, nil]</span><br><span class="line"></span><br><span class="line">forKey:(NSString *)kCGImagePropertyGIFDictionary];</span><br><span class="line"></span><br><span class="line">//设置gif信息</span><br><span class="line">NSMutableDictionary *dict = [NSMutableDictionary dictionaryWithCapacity:2];</span><br><span class="line">[dict setObject:[NSNumber numberWithBool:YES] forKey:(NSString*)kCGImagePropertyGIFHasGlobalColorMap];</span><br><span class="line">[dict setObject:(NSString *)kCGImagePropertyColorModelRGB forKey:(NSString *)kCGImagePropertyColorModel];</span><br><span class="line">[dict setObject:[NSNumber numberWithInt:8] forKey:(NSString*)kCGImagePropertyDepth];</span><br><span class="line">[dict setObject:[NSNumber numberWithInt:0] forKey:(NSString *)kCGImagePropertyGIFLoopCount];</span><br><span class="line"></span><br><span class="line">NSDictionary *gifProperties = [NSDictionary dictionaryWithObject:dict</span><br><span class="line"></span><br><span class="line">forKey:(NSString *)kCGImagePropertyGIFDictionary];</span><br><span class="line"></span><br><span class="line">//合成gif</span><br><span class="line">for (UIImage* dImg in images)</span><br><span class="line">&#123;</span><br><span class="line">CGImageDestinationAddImage(destination, dImg.CGImage, (__bridge CFDictionaryRef)frameProperties);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CGImageDestinationSetProperties(destination, (__bridge CFDictionaryRef)gifProperties);</span><br><span class="line">CGImageDestinationFinalize(destination);</span><br><span class="line">CFRelease(destination);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-视频生成GIF图"><a href="#2-视频生成GIF图" class="headerlink" title="2.视频生成GIF图"></a>2.视频生成GIF图</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">//2.视频生成GIF图</span><br><span class="line">//创建mp4输出路径</span><br><span class="line">NSArray *document = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);</span><br><span class="line">NSString *documentStr = [document objectAtIndex:0];</span><br><span class="line">NSFileManager *fileManager = [NSFileManager defaultManager];</span><br><span class="line">NSString *textDirectory = [documentStr stringByAppendingPathComponent:@&quot;mp4&quot;];</span><br><span class="line">[fileManager createDirectoryAtPath:textDirectory withIntermediateDirectories:YES attributes:nil error:nil];</span><br><span class="line">NSString *path = [textDirectory stringByAppendingPathComponent:@&quot;example.mp4&quot;];</span><br><span class="line"></span><br><span class="line">//创建gif输出路径</span><br><span class="line">NSString *gifDirectory = [documentStr stringByAppendingPathComponent:@&quot;gif&quot;];</span><br><span class="line">[fileManager createDirectoryAtPath:gifDirectory withIntermediateDirectories:YES attributes:nil error:nil];</span><br><span class="line">NSString *gifPath = [textDirectory stringByAppendingPathComponent:@&quot;example.gif&quot;];</span><br><span class="line"></span><br><span class="line">//从2秒开始，截取8秒</span><br><span class="line">NSRange range = NSMakeRange(2, 8);</span><br><span class="line"></span><br><span class="line">//    NSURL *fileURL = [NSURL URLWithString:@&quot;http://o8cfktdb3.bkt.clouddn.com/4.mp4&quot;];</span><br><span class="line">NSURL *fileURL = [NSURL fileURLWithPath:[[NSBundle mainBundle]pathForResource:@&quot;4.mp4&quot; ofType:nil]];</span><br><span class="line"></span><br><span class="line">[self interceptVideoAndVideoUrl:fileURL withOutPath:path outputFileType:AVFileTypeMPEG4 range:range intercept:^(NSError *error, NSURL *outPutURL) &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;1.%@&quot;,error);</span><br><span class="line">NSLog(@&quot;2.%@&quot;,outPutURL);</span><br><span class="line"></span><br><span class="line">//        AVURLAsset *asset = [AVURLAsset assetWithURL:outPutURL];</span><br><span class="line">//        [self AnimatedGIFFromMovieAsset:asset timeIncrement:8.f completion:^(NSData *imageData, NSError *error) &#123;</span><br><span class="line">//</span><br><span class="line">//            NSLog(@&quot;1.%@&quot;,error);</span><br><span class="line">////            UIImage *img = [UIImage imageWithData:imageData];</span><br><span class="line">////            NSLog(@&quot;%@&quot;,img);</span><br><span class="line">//            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">//                [self showGifImageWithWebViewWithData:imageData];</span><br><span class="line">////                self.desView.image = [UIImage sd_animatedGIFWithData:imageData];</span><br><span class="line">//            &#125;);</span><br><span class="line">//        &#125;];</span><br><span class="line"></span><br><span class="line">[self createGIFfromURL:outPutURL loopCount:0 delayTime:0.1 gifImagePath:gifPath complete:^(NSError *error, NSURL *gifURL) &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;1.%@&quot;,error);</span><br><span class="line">NSLog(@&quot;2.%@&quot;,gifURL.absoluteString);</span><br><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">//                [self showGifImageWithWebViewWithPath:gifPath];</span><br><span class="line">self.desView.image = [UIImage sd_animatedGIFWithData:[NSData dataWithContentsOfURL:gifURL]];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>核心方法：<br>1.截取视频<br>2.本地视频生成GIF图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 视频生成GIF图</span><br><span class="line">#pragma mark - 1.截取视频</span><br><span class="line">/**</span><br><span class="line">@param videoUrl 视频的URL</span><br><span class="line">@param outPath 输出路径</span><br><span class="line">@param outputFileType 输出视频格式</span><br><span class="line">@param videoRange 截取视频的范围</span><br><span class="line">@param interceptBlock 视频截取的回调</span><br><span class="line">*/</span><br><span class="line">- (void)interceptVideoAndVideoUrl:(NSURL *)videoUrl withOutPath:(NSString *)outPath outputFileType:(NSString *)outputFileType range:(NSRange)videoRange intercept:(InterceptBlock)interceptBlock &#123;</span><br><span class="line"></span><br><span class="line">_interceptBlock =interceptBlock;</span><br><span class="line"></span><br><span class="line">//不添加背景音乐</span><br><span class="line">NSURL *audioUrl =nil;</span><br><span class="line">//AVURLAsset此类主要用于获取媒体信息，包括视频、声音等</span><br><span class="line">AVURLAsset* audioAsset = [[AVURLAsset alloc] initWithURL:audioUrl options:nil];</span><br><span class="line">AVURLAsset* videoAsset = [[AVURLAsset alloc] initWithURL:videoUrl options:nil];</span><br><span class="line"></span><br><span class="line">//创建AVMutableComposition对象来添加视频音频资源的AVMutableCompositionTrack</span><br><span class="line">AVMutableComposition* mixComposition = [AVMutableComposition composition];</span><br><span class="line"></span><br><span class="line">//CMTimeRangeMake(start, duration),start起始时间，duration时长，都是CMTime类型</span><br><span class="line">//CMTimeMake(int64_t value, int32_t timescale)，返回CMTime，value视频的一个总帧数，timescale是指每秒视频播放的帧数，视频播放速率，（value / timescale）才是视频实际的秒数时长，timescale一般情况下不改变，截取视频长度通过改变value的值</span><br><span class="line">//CMTimeMakeWithSeconds(Float64 seconds, int32_t preferredTimeScale)，返回CMTime，seconds截取时长（单位秒），preferredTimeScale每秒帧数</span><br><span class="line"></span><br><span class="line">//开始位置startTime</span><br><span class="line">CMTime startTime = CMTimeMakeWithSeconds(videoRange.location, videoAsset.duration.timescale);</span><br><span class="line">//截取长度videoDuration</span><br><span class="line">CMTime videoDuration = CMTimeMakeWithSeconds(videoRange.length, videoAsset.duration.timescale);</span><br><span class="line"></span><br><span class="line">CMTimeRange videoTimeRange = CMTimeRangeMake(startTime, videoDuration);</span><br><span class="line"></span><br><span class="line">//视频采集compositionVideoTrack</span><br><span class="line">AVMutableCompositionTrack *compositionVideoTrack = [mixComposition addMutableTrackWithMediaType:AVMediaTypeVideo preferredTrackID:kCMPersistentTrackID_Invalid];</span><br><span class="line"></span><br><span class="line">// 避免数组越界 tracksWithMediaType 找不到对应的文件时候返回空数组</span><br><span class="line">//TimeRange截取的范围长度</span><br><span class="line">//ofTrack来源</span><br><span class="line">//atTime插放在视频的时间位置</span><br><span class="line">[compositionVideoTrack insertTimeRange:videoTimeRange ofTrack:([videoAsset tracksWithMediaType:AVMediaTypeVideo].count&gt;0) ? [videoAsset tracksWithMediaType:AVMediaTypeVideo].firstObject : nil atTime:kCMTimeZero error:nil];</span><br><span class="line"></span><br><span class="line">//视频声音采集(也可不执行这段代码不采集视频音轨，合并后的视频文件将没有视频原来的声音)</span><br><span class="line">AVMutableCompositionTrack *compositionVoiceTrack = [mixComposition addMutableTrackWithMediaType:AVMediaTypeAudio preferredTrackID:kCMPersistentTrackID_Invalid];</span><br><span class="line"></span><br><span class="line">[compositionVoiceTrack insertTimeRange:videoTimeRange ofTrack:([videoAsset tracksWithMediaType:AVMediaTypeAudio].count&gt;0)?[videoAsset tracksWithMediaType:AVMediaTypeAudio].firstObject:nil atTime:kCMTimeZero error:nil];</span><br><span class="line"></span><br><span class="line">//声音长度截取范围==视频长度</span><br><span class="line">CMTimeRange audioTimeRange = CMTimeRangeMake(kCMTimeZero, videoDuration);</span><br><span class="line"></span><br><span class="line">//音频采集compositionCommentaryTrack</span><br><span class="line">AVMutableCompositionTrack *compositionAudioTrack = [mixComposition addMutableTrackWithMediaType:AVMediaTypeAudio preferredTrackID:kCMPersistentTrackID_Invalid];</span><br><span class="line"></span><br><span class="line">[compositionAudioTrack insertTimeRange:audioTimeRange ofTrack:([audioAsset tracksWithMediaType:AVMediaTypeAudio].count &gt; 0) ? [audioAsset tracksWithMediaType:AVMediaTypeAudio].firstObject : nil atTime:kCMTimeZero error:nil];</span><br><span class="line"></span><br><span class="line">//AVAssetExportSession用于合并文件，导出合并后文件，presetName文件的输出类型</span><br><span class="line">AVAssetExportSession *assetExportSession = [[AVAssetExportSession alloc] initWithAsset:mixComposition presetName:AVAssetExportPresetPassthrough];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//混合后的视频输出路径</span><br><span class="line">NSURL *outPutURL = [NSURL fileURLWithPath:outPath];</span><br><span class="line"></span><br><span class="line">if ([[NSFileManager defaultManager] fileExistsAtPath:outPath])</span><br><span class="line">&#123;</span><br><span class="line">[[NSFileManager defaultManager] removeItemAtPath:outPath error:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出视频格式 outputFileType:mov或mp4及其它视频格式</span><br><span class="line">assetExportSession.outputFileType = outputFileType;</span><br><span class="line">assetExportSession.outputURL = outPutURL;</span><br><span class="line">//输出文件是否网络优化</span><br><span class="line">assetExportSession.shouldOptimizeForNetworkUse = YES;</span><br><span class="line">[assetExportSession exportAsynchronouslyWithCompletionHandler:^&#123;</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line"></span><br><span class="line">switch (assetExportSession.status) &#123;</span><br><span class="line">case AVAssetExportSessionStatusFailed:</span><br><span class="line"></span><br><span class="line">if (_interceptBlock) &#123;</span><br><span class="line"></span><br><span class="line">_interceptBlock(assetExportSession.error,outPutURL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case AVAssetExportSessionStatusCancelled:&#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;Export Status: Cancell&quot;);</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">case AVAssetExportSessionStatusCompleted: &#123;</span><br><span class="line"></span><br><span class="line">if (_interceptBlock) &#123;</span><br><span class="line"></span><br><span class="line">_interceptBlock(nil,outPutURL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">case AVAssetExportSessionStatusUnknown: &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;Export Status: Unknown&quot;);</span><br><span class="line">&#125;</span><br><span class="line">case AVAssetExportSessionStatusExporting : &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;Export Status: Exporting&quot;);</span><br><span class="line">&#125;</span><br><span class="line">case AVAssetExportSessionStatusWaiting: &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;Export Status: Wating&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark--2.本地视频生成GIF图</span><br><span class="line">/**</span><br><span class="line">@param videoURL 视频的路径URL</span><br><span class="line">@param loopCount 播放次数 0即无限循环</span><br><span class="line">@param time 每帧的时间间隔 默认0.25s</span><br><span class="line">@param imagePath 存放GIF图片的文件路径</span><br><span class="line">@param completeBlock 完成的回调</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">- (void)createGIFfromURL:(NSURL*)videoURL loopCount:(int)loopCount delayTime:(CGFloat )time gifImagePath:(NSString *)imagePath complete:(CompleteBlock)completeBlock &#123;</span><br><span class="line"></span><br><span class="line">_completeBlock =completeBlock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">float delayTime = time?:0.1;</span><br><span class="line"></span><br><span class="line">// Create properties dictionaries</span><br><span class="line">NSDictionary *fileProperties = [self filePropertiesWithLoopCount:loopCount];</span><br><span class="line">NSDictionary *frameProperties = [self framePropertiesWithDelayTime:delayTime];</span><br><span class="line"></span><br><span class="line">AVURLAsset *asset = [AVURLAsset assetWithURL:videoURL];</span><br><span class="line"></span><br><span class="line">float videoWidth = [[[asset tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0] naturalSize].width;</span><br><span class="line">float videoHeight = [[[asset tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0] naturalSize].height;</span><br><span class="line"></span><br><span class="line">GIFSize optimalSize = GIFSizeMedium;</span><br><span class="line">if (videoWidth &gt;= 1200 || videoHeight &gt;= 1200)</span><br><span class="line">optimalSize = GIFSizeVeryLow;</span><br><span class="line">else if (videoWidth &gt;= 800 || videoHeight &gt;= 800)</span><br><span class="line">optimalSize = GIFSizeLow;</span><br><span class="line">else if (videoWidth &gt;= 400 || videoHeight &gt;= 400)</span><br><span class="line">optimalSize = GIFSizeMedium;</span><br><span class="line">else if (videoWidth &lt; 400|| videoHeight &lt; 400)</span><br><span class="line">optimalSize = GIFSizeHigh;</span><br><span class="line"></span><br><span class="line">//根据所给的时间增长量以及视频的总时长计算一下GIF中图片的数量</span><br><span class="line">float videoLength = (float)asset.duration.value/asset.duration.timescale;</span><br><span class="line">int framesPerSecond = 4;</span><br><span class="line">int frameCount = videoLength*framesPerSecond;</span><br><span class="line"></span><br><span class="line">// How far along the video track we want to move, in seconds.</span><br><span class="line">float increment = (float)videoLength/frameCount;</span><br><span class="line"></span><br><span class="line">// Add frames to the buffer</span><br><span class="line">NSMutableArray *timePoints = [NSMutableArray array];</span><br><span class="line">for (int currentFrame = 0; currentFrame&lt;frameCount; ++currentFrame) &#123;</span><br><span class="line">float seconds = (float)increment * currentFrame;</span><br><span class="line">CMTime time = CMTimeMakeWithSeconds(seconds, 600);</span><br><span class="line">[timePoints addObject:[NSValue valueWithCMTime:time]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//completion block</span><br><span class="line">NSURL *gifURL = [self createGIFforTimePoints:timePoints fromURL:videoURL fileProperties:fileProperties frameProperties:frameProperties gifImagePath:imagePath frameCount:frameCount gifSize:_gifSize?:GIFSizeMedium];</span><br><span class="line"></span><br><span class="line">if (_completeBlock) &#123;</span><br><span class="line"></span><br><span class="line">// Return GIF URL</span><br><span class="line">_completeBlock(_error,gifURL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - Base methods</span><br><span class="line">- (NSURL *)createGIFforTimePoints:(NSArray *)timePoints fromURL:(NSURL *)url fileProperties:(NSDictionary *)fileProperties  frameProperties:(NSDictionary *)frameProperties gifImagePath:(NSString *)imagePath frameCount:(int)frameCount gifSize:(GIFSize)gifSize&#123;</span><br><span class="line"></span><br><span class="line">NSURL *fileURL = [NSURL fileURLWithPath:imagePath];</span><br><span class="line">if (fileURL == nil)</span><br><span class="line">return nil;</span><br><span class="line"></span><br><span class="line">CGImageDestinationRef destination = CGImageDestinationCreateWithURL((__bridge CFURLRef)fileURL, kUTTypeGIF , frameCount, NULL);</span><br><span class="line">CGImageDestinationSetProperties(destination, (CFDictionaryRef)fileProperties);</span><br><span class="line"></span><br><span class="line">AVURLAsset *asset = [AVURLAsset URLAssetWithURL:url options:nil];</span><br><span class="line">//为目标视频实例化一个生成器</span><br><span class="line">AVAssetImageGenerator *generator = [AVAssetImageGenerator assetImageGeneratorWithAsset:asset];</span><br><span class="line">generator.appliesPreferredTrackTransform = YES;</span><br><span class="line"></span><br><span class="line">//设置生成器属性以及GIF属性</span><br><span class="line">float tolerance = 0.01f;</span><br><span class="line">CMTime tol = CMTimeMakeWithSeconds(tolerance, 600);</span><br><span class="line">generator.requestedTimeToleranceBefore = tol;</span><br><span class="line">generator.requestedTimeToleranceAfter = tol;</span><br><span class="line"></span><br><span class="line">NSError *error = nil;</span><br><span class="line">CGImageRef previousImageRefCopy = nil;</span><br><span class="line">for (NSValue *time in timePoints) &#123;</span><br><span class="line">CGImageRef imageRef;</span><br><span class="line"></span><br><span class="line">#if TARGET_OS_IPHONE || TARGET_IPHONE_SIMULATOR</span><br><span class="line">imageRef = (float)gifSize/10 != 1 ? createImageWithScale([generator copyCGImageAtTime:[time CMTimeValue] actualTime:nil error:&amp;error], (float)gifSize/10) : [generator copyCGImageAtTime:[time CMTimeValue] actualTime:nil error:&amp;error];</span><br><span class="line">#elif TARGET_OS_MAC</span><br><span class="line">imageRef = [generator copyCGImageAtTime:[time CMTimeValue] actualTime:nil error:&amp;error];</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">if (error) &#123;</span><br><span class="line"></span><br><span class="line">_error =error;</span><br><span class="line">NSLog(@&quot;Error copying image: %@&quot;, error);</span><br><span class="line">return nil;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">if (imageRef) &#123;</span><br><span class="line">CGImageRelease(previousImageRefCopy);</span><br><span class="line">previousImageRefCopy = CGImageCreateCopy(imageRef);</span><br><span class="line">&#125; else if (previousImageRefCopy) &#123;</span><br><span class="line">imageRef = CGImageCreateCopy(previousImageRefCopy);</span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">_error =[NSError errorWithDomain:NSStringFromClass([self class]) code:0 userInfo:@&#123;NSLocalizedDescriptionKey:@&quot;Error copying image and no previous frames to duplicate&quot;&#125;];</span><br><span class="line">NSLog(@&quot;Error copying image and no previous frames to duplicate&quot;);</span><br><span class="line">return nil;</span><br><span class="line">&#125;</span><br><span class="line">CGImageDestinationAddImage(destination, imageRef, (CFDictionaryRef)frameProperties);</span><br><span class="line">CGImageRelease(imageRef);</span><br><span class="line">&#125;</span><br><span class="line">CGImageRelease(previousImageRefCopy);</span><br><span class="line"></span><br><span class="line">// Finalize the GIF</span><br><span class="line">if (!CGImageDestinationFinalize(destination)) &#123;</span><br><span class="line"></span><br><span class="line">_error =error;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;Failed to finalize GIF destination: %@&quot;, error);</span><br><span class="line">if (destination != nil) &#123;</span><br><span class="line">CFRelease(destination);</span><br><span class="line">&#125;</span><br><span class="line">return nil;</span><br><span class="line">&#125;</span><br><span class="line">CFRelease(destination);</span><br><span class="line"></span><br><span class="line">return fileURL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - Helpers</span><br><span class="line">CGImageRef createImageWithScale(CGImageRef imageRef, float scale) &#123;</span><br><span class="line"></span><br><span class="line">#if TARGET_OS_IPHONE || TARGET_IPHONE_SIMULATOR</span><br><span class="line">CGSize newSize = CGSizeMake(CGImageGetWidth(imageRef)*scale, CGImageGetHeight(imageRef)*scale);</span><br><span class="line">CGRect newRect = CGRectIntegral(CGRectMake(0, 0, newSize.width, newSize.height));</span><br><span class="line"></span><br><span class="line">UIGraphicsBeginImageContextWithOptions(newSize, NO, 0);</span><br><span class="line">CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line">if (!context) &#123;</span><br><span class="line">return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Set the quality level to use when rescaling</span><br><span class="line">CGContextSetInterpolationQuality(context, kCGInterpolationHigh);</span><br><span class="line">CGAffineTransform flipVertical = CGAffineTransformMake(1, 0, 0, -1, 0, newSize.height);</span><br><span class="line"></span><br><span class="line">CGContextConcatCTM(context, flipVertical);</span><br><span class="line">// Draw into the context; this scales the image</span><br><span class="line">CGContextDrawImage(context, newRect, imageRef);</span><br><span class="line"></span><br><span class="line">//Release old image</span><br><span class="line">CFRelease(imageRef);</span><br><span class="line">// Get the resized image from the context and a UIImage</span><br><span class="line">imageRef = CGBitmapContextCreateImage(context);</span><br><span class="line"></span><br><span class="line">UIGraphicsEndImageContext();</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">return imageRef;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - Properties</span><br><span class="line"></span><br><span class="line">- (NSDictionary *)filePropertiesWithLoopCount:(int)loopCount &#123;</span><br><span class="line">return @&#123;(NSString *)kCGImagePropertyGIFDictionary:</span><br><span class="line">@&#123;(NSString *)kCGImagePropertyGIFLoopCount: @(loopCount)&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSDictionary *)framePropertiesWithDelayTime:(float)delayTime &#123;</span><br><span class="line"></span><br><span class="line">return @&#123;(NSString *)kCGImagePropertyGIFDictionary:</span><br><span class="line">@&#123;(NSString *)kCGImagePropertyGIFDelayTime: @(delayTime)&#125;,</span><br><span class="line">(NSString *)kCGImagePropertyColorModel:(NSString *)kCGImagePropertyColorModelRGB</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gif </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>masonry使用</title>
      <link href="/2018/03/14/masonry%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/03/14/masonry%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>OC基础</title>
      <link href="/2018/03/01/OC%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/03/01/OC%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><a id="more"></a><table><br><tr><br><td>优先级</td><br><td>运算符</td><br><td>名称或含义</td><br></tr><br><br><tr><br><td rowspan="4">1</td><br><td>[]</td><br><td>数组下标</td><br></tr><br><tr><br><td>()</td><br><td>括号</td><br></tr><br><tr><br><td>.</td><br><td>成员选择（对象）</td><br></tr><br><tr><br><td>-&gt;</td><br><td>成员选择（指针）</td><br></tr><br><br><tr><br><td rowspan="9">2</td><br><td>-</td><br><td>负号运算符</td><br></tr><br><tr><br><td>(类型)</td><br><td>强制类型转换</td><br></tr><br><tr><br><td>++</td><br><td>自增</td><br></tr><br><tr><br><td>–</td><br><td>自减</td><br></tr><br><tr><br><td><code>*</code></td><br><td>取值</td><br></tr><br><tr><br><td>&amp;</td><br><td>取地址</td><br></tr><br><tr><br><td>!</td><br><td>逻辑非</td><br></tr><br><tr><br><td>～</td><br><td>按位取反</td><br></tr><br><tr><br><td>sizeof</td><br><td>长度</td><br></tr><br><br><tr><br><td rowspan="3">3</td><br><td>/</td><br><td>除法</td><br></tr><br><tr><br><td><code>*</code></td><br><td>乘法</td><br></tr><br><tr><br><td>%</td><br><td>余数</td><br></tr><br><br><tr><br><td rowspan="2">4</td><br><td>+</td><br><td>加法</td><br></tr><br><tr><br><td>-</td><br><td>减法</td><br></tr><br><br><tr><br><td rowspan="2">5</td><br><td>&lt;&lt;</td><br><td>左移</td><br></tr><br><tr><br><td>&gt;&gt;</td><br><td>右移</td><br></tr><br><br><tr><br><td rowspan="4">6</td><br><td>&gt;</td><br><td>大于</td><br></tr><br><tr><br><td>&gt;=</td><br><td>大于等于</td><br></tr><br><tr><br><td>&lt;</td><br><td>小于</td><br></tr><br><tr><br><td>&lt;=</td><br><td>小于等于</td><br></tr><br><br><tr><br><td rowspan="2">7</td><br><td>==</td><br><td>等于</td><br></tr><br><tr><br><td>!=</td><br><td>不等于</td><br></tr><br><br><tr><br><td>8</td><br><td>&amp;</td><br><td>按位与</td><br></tr><br><br><tr><br><td>9</td><br><td>^</td><br><td>按位异或</td><br></tr><br><br><tr><br><td>10</td><br><td>|</td><br><td>按位或</td><br></tr><br><br><tr><br><td>11</td><br><td>&amp;&amp;</td><br><td>逻辑与</td><br></tr><br><br><tr><br><td>12</td><br><td>||</td><br><td>逻辑或</td><br></tr><br><br><tr><br><td>13</td><br><td>?:</td><br><td>三目运算符</td><br></tr><br><br><tr><br><td rowspan="10">14</td><br><td>=</td><br><td>赋值</td><br></tr><br><tr><br><td>／=</td><br><td>除后赋值</td><br></tr><br><tr><br><td>*=</td><br><td>乘后赋值</td><br></tr><br><tr><br><td>%=</td><br><td>取余后赋值</td><br></tr><br><tr><br><td>+=</td><br><td>加后赋值</td><br></tr><br><tr><br><td>-=</td><br><td>减后赋值</td><br></tr><br><tr><br><td>&lt;&lt;=</td><br><td>左移后赋值</td><br></tr><br><tr><br><td>&gt;&gt;=</td><br><td>右移后赋值</td><br></tr><br><tr><br><td>&amp;=</td><br><td>按位与后赋值</td><br></tr><br><tr><br><td>^／</td><br><td>按位异或后赋值</td><br></tr><br><br><tr><br><td>15</td><br><td>,</td><br><td>逗号运算符</td><br></tr><br><br></table><h2 id="OC"><a href="#OC" class="headerlink" title="OC"></a>OC</h2><h3 id="动态语言"><a href="#动态语言" class="headerlink" title="动态语言"></a>动态语言</h3><ul><li>动态编程语言（动态语言）：指程序在运行时可以改变其结构。JS、Python、Ruby属于动态语言，C、C++不属于动态语言。</li><li>动态类型语言：类型检查在运行时做。</li><li>静态类型语言：类型检查在运行前判断（如编译期）。方便类型安全，但是与类型安全没有联系。使用继承、接口等势线多态</li></ul><h3 id="OC的三大特性"><a href="#OC的三大特性" class="headerlink" title="OC的三大特性"></a>OC的三大特性</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>访问权限修饰符：@public、@protected、@private、@package，默认的修饰符是@private<br>但是OC是没有修饰符的概念的，如果想让一个方法不被外界访问的话，只需要在.m文件中实现这个方法，不要在头文件中进行定义即可。</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p><code>OC是C语言的子类，所以OC是静态语言，但是OC的多态性让其拥有了动态性运行性</code></p><ul><li>动态类型：id类型，运行时决定接收者，动态类型属于弱类型，静态类型属于强类型。</li><li>动态绑定：运行时判断需要调用什么方法。</li><li><p>动态载入：运行时添加代码模块以及其他资源。<br>对象时运行时类的一个实例。在oc中对象永远是通过指针来引用的。</p></li><li><p>无类型：不做任何检查，甚至不区分指令和数据。</p></li><li>弱类型：仅能区分指令和数据。</li><li>强类型：在编译期进行检查，在没有强制类型转换前，不允许两种不同类型的变量相互操作。</li></ul><p>多态：不同对象以自己的方式响应相同的消息的能力叫做多态。子类指针可以赋值给父类对象。<br>主要是将数据类型的确定由编译时，推迟到了运行时。<br>(1)对于语句NSString*obj = [[NSData alloc] init]; obj在编译时和运行时分别时什么类型的对象?<br>答：编译时是NSString的类型;运行时是NSData类型的对象。<br>(2)id声明的对象具有运行时的特性，即可以指向任意类型的objcetive-c的对象.</p><p><a href="">OC中的内存管理机制与属性相关</a></p><h2 id="多线程（多线程编程指南）"><a href="#多线程（多线程编程指南）" class="headerlink" title="多线程（多线程编程指南）"></a>多线程（多线程编程指南）</h2><h3 id="进程-线程的区别？同步-异步的区别？并行-并发的区别？"><a href="#进程-线程的区别？同步-异步的区别？并行-并发的区别？" class="headerlink" title="进程/线程的区别？同步/异步的区别？并行/并发的区别？"></a>进程/线程的区别？同步/异步的区别？并行/并发的区别？</h3><ul><li>进程：正在运行的应用程序，是CPU调度的最小单位，有独立的地址空间，进程中包含的一个或多个执行单元称为线程。</li><li><p>线程：是进程中的一条执行路径，共享进程的资源，有自己的堆栈和局部变量，一个线程死掉就等于整个进程死掉。<br>每条线程可以并行执行不同的任务。<br>多线程间并发执行，其实是CPU在多条线程间调度（切换）。</p></li><li><p>主线程：<br>number=1<br>作用：显示/刷新UI，处理UI事件（点击、拖拽、滚动）<br>禁止将比较耗时的操作放在主线程，会卡顿</p></li><li><p>pthread：跨平台，C，程序员管理生命周期</p></li><li>NSThread：面向对象，OC，程序员管理生命周期</li><li>GCD：充分利用设备的多核，C，自动管理生命周期</li><li><p>NSOperation：基于GCD，面向对象，OC，自动管理生命周期</p></li><li><p>执行任务，函数：<br>同步和异步的区别：能不能开启新线程<br>同步：只能在当前线程中执行任务，不具备开启新线程的能力。（同步就是必须一件一件事做，等前一件做完了才能做下一件事。）<br>异步：可以在新线程中执行任务，具备开启新线程的能力。<code>延迟加载可以避免内存过高，异步加载可以避免线程堵塞。</code></p></li><li><p>队列：<br>串行和并行的区别：任务的执行方式<br>串行：任务只能一个接一个执行<br>并行：允许任务同时执行，只在异步函数下才有效，不创建新线程无法并行<br>全局并发队列：global，系统给每一个应用程序提供了三个concurrent dispatch queues<br>主队列：主队列中的任务都会在主线程中执行</p></li><li><p>异步函数+并行队列：开启多条（不确定几条）子线程，任务并发执行</p></li><li>异步函数+串行队列：开启一条子线程，任务顺序执行</li><li>同步函数+并发队列：不开启子线程，在主线程执行，任务顺序执行</li><li>同步函数+串行队列：不开启子线程，在主线程执行，任务顺序执行</li><li>异步函数+主队列：不开启子线程，在主线程执行，任务顺序执行</li><li><p>同步函数+主队列：默认主线程中会死锁，子线程中不会死锁。</p></li><li><p>开启新线程条件：1.异步 2.队列不是主队列，并发队列：开多条，串行：开一条子线程</p></li><li><p>并行和并发的区别：<code>是否是『同时』</code><br>并行（同时）:两个或多个事件在同一时刻发生。（<code>你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。</code>）提高效率，资源利用率。<br>关键是你有<code>同时</code>处理多个任务的能力。<br>并发:两个或者多个事件在同一时间间隔发生。（<code>你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。</code>）<br>关键是你有处理多个任务的能力，不一定要同时。</p></li></ul><h4 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h4><ul><li><p>创建线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.initWithTarget</span><br><span class="line">NSThread* myThread = [[NSThread alloc] initWithTarget:self selector:@selector(doSomething:) object:nil];</span><br><span class="line">//设置线程优先级、线程名称等信息</span><br><span class="line">[myThread start];</span><br><span class="line"></span><br><span class="line">2.detachNewThreadSelector</span><br><span class="line">[NSThread detachNewThreadSelector:@selector(doSomething:) toTarget:self withObject:nil];</span><br><span class="line"></span><br><span class="line">3.performSelectorInBackground</span><br><span class="line">[self performSelectorInBackground:@selector(doSomething) withObject:nil];</span><br></pre></td></tr></table></figure></li><li><p>其他用法：延迟/休眠/死亡</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//延迟</span><br><span class="line">[self performSelector:@selector(run) withObject:nil afterDelay:2.0];</span><br><span class="line">//休眠</span><br><span class="line">[NSThread sleepForTimeInterval:2.0];</span><br><span class="line">[NSThread sleepUntilDate:(NSDate*)date];</span><br><span class="line">//死亡</span><br><span class="line">[NSThread exit];</span><br></pre></td></tr></table></figure></li><li><p>线程间通信<br>1.通知主线程更新UI界面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">waitUntilDone参数：</span><br><span class="line">* YES:当前线程要被阻塞，直到主线程将我们制定的代码块执行完，即优先执行updateUI方法</span><br><span class="line">* NO:当前线程不阻塞，会直接向下运行代码，不会立即进入updateUI方法，</span><br><span class="line">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait;</span><br></pre></td></tr></table></figure></li></ul><p>2.通知其他线程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait;</span><br></pre></td></tr></table></figure></p><h4 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h4><ul><li><p>延迟执行实现：1.performSelector  2.timer  3.GCD after</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 3*NSEC_PER_SEC);</span><br><span class="line">dispatch_after(time, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">NSLog(@&quot;3秒后执行&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>onece：整个应用程序中只执行一次，不能在懒加载中使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static SingleClass *instance;</span><br><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">instance = [[SingleClass alloc]init];</span><br><span class="line">&#125;);</span><br><span class="line">return instance;</span><br></pre></td></tr></table></figure></li><li><p>GCD定时器的特点</p><ul><li>GCD的定时器不会受到RunLoop运行模式的影响</li><li>可以控制任务在主线程还是子线程执行</li><li>GCD定时器比NSTimer更加准确是因为单位不同，GCD单位是纳秒</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 3*NSEC_PER_SEC);</span><br><span class="line">dispatch_after(time, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">NSLog(@&quot;3秒后执行&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic,strong)dispatch_source_t timer;    //防止timer被释放</span><br><span class="line"></span><br><span class="line">dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_global_queue(0, 0));</span><br><span class="line">dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 2.0 * NSEC_PER_SEC, 0 * NSEC_PER_SEC);</span><br><span class="line">dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">NSLog(@&quot;run...&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_resume(timer);</span><br><span class="line">self.timer = timer;</span><br></pre></td></tr></table></figure><ul><li><p>dispatch_group_async<br>可以实现监听一组任务是否完成，完成后得到通知执行其他的操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">[NSThread sleepForTimeInterval:1];</span><br><span class="line">NSLog(@&quot;group1&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">[NSThread sleepForTimeInterval:2];</span><br><span class="line">NSLog(@&quot;group2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">[NSThread sleepForTimeInterval:3];</span><br><span class="line">NSLog(@&quot;group3&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">NSLog(@&quot;updateUI&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>dispatch_barrier_async<br>在前面的任务执行结束后它才执行，而且等它执行完成之后后面的任务才会执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;barrier&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">[NSThread sleepForTimeInterval:2];</span><br><span class="line">NSLog(@&quot;dispatch_async1&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">[NSThread sleepForTimeInterval:4];</span><br><span class="line">NSLog(@&quot;dispatch_async2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">NSLog(@&quot;dispatch_barrier_async&quot;);</span><br><span class="line">[NSThread sleepForTimeInterval:4];</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">[NSThread sleepForTimeInterval:1];</span><br><span class="line">NSLog(@&quot;dispatch_async3&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>dispatch_apply：执行某个代码片段N次。<br>注意：这个方法没有办法异步执行（为了不阻塞线程可以使用dispatch_async()包装一下再执行）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_apply(5, queue, ^(size_t index) &#123;</span><br><span class="line">// 执行5次</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>dispatch_suspend(myQueue)： 挂起队列</p></li><li>dispatch_resume(myQueue)：恢复队列<br>注意：调用dispatch_suspend会增加队列挂起的引用计数，而调用dispatch_resume则会减少引用计数，当引用计数大于0时，队列会保持挂起状态。因此，这队列的挂起和恢复中，我们需要小心使用以避免引用计数计算错误的出现。</li></ul><h4 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h4><ul><li><p>NSOperation本身是抽象类，只能只有它的子类，三个子类分别是：NSBlockOperation、NSInvocationOperation以及自定义继承自NSOperation的类</p></li><li><p>队列<br>1.主队列：通过mainQueue获得，凡是放到主队列中的任务都将在主线程执行<br>2.非主队列：直接alloc init出来的队列。非主队列同时具备了并发和串行的功能，通过设置最大并发数属性来控制任务是并发执行还是串行执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//1.创建队列</span><br><span class="line">NSOperationQueue *queue = [[NSOperationQueue alloc]init];</span><br><span class="line">//2.设置最大并发数</span><br><span class="line">//注意点：该属性需要在任务添加到队列中之前进行设置</span><br><span class="line">//该属性控制队列是串行执行还是并发执行</span><br><span class="line">//如果最大并发数等于1，那么该队列是串行的，如果大于1那么是并行的</span><br><span class="line">//系统的最大并发数有个默认的值，为-1，如果该属性设置为0，那么不会执行任何任务</span><br><span class="line">queue.maxConcurrentOperationCount = 2;</span><br></pre></td></tr></table></figure></li><li><p>线程通信：设置依赖关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//操作A依赖于操作B，线程操作队列在启动线程时就会首先执行B操作，然后执行A。</span><br><span class="line">[operationA addDependency:operationB];</span><br></pre></td></tr></table></figure></li></ul><h3 id="多线程下，NSMutableArray需不需要开启线程保护"><a href="#多线程下，NSMutableArray需不需要开启线程保护" class="headerlink" title="多线程下，NSMutableArray需不需要开启线程保护"></a>多线程下，NSMutableArray需不需要开启线程保护</h3><p>待解决</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>1.NSLock<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSLock *theLock = [[NSLock alloc] init];</span><br><span class="line">[theLock lock];</span><br><span class="line">//dosomething</span><br><span class="line">[theLock unlock];</span><br></pre></td></tr></table></figure></p><p>2.NSConditionLock 条件锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//公共部分</span><br><span class="line">id condLock = [[NSConditionLock alloc] initWithCondition:NO_DATA];</span><br><span class="line"></span><br><span class="line">//线程一，生产者</span><br><span class="line">while(true) &#123;</span><br><span class="line">[condLock lockWhenCondition:NO_DATA];</span><br><span class="line">//生产数据</span><br><span class="line">[condLock unlockWithCondition:HAS_DATA];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//线程二，消费者</span><br><span class="line">while (true) &#123;</span><br><span class="line">[condLock lockWhenCondition:HAS_DATA];</span><br><span class="line">//消费</span><br><span class="line">[condLock unlockWithCondition:NO_DATA];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.@synchronized(锁对象){}<br>锁对象必须是全局唯一的<br>加锁的前提条件：抢夺资源<br>作用：线程同步，使多线程按顺序执行<br>注意：加锁的位置，加锁会耗费CPU资源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@synchronized(self)</span><br><span class="line">&#123;</span><br><span class="line">// 这段代码对其他 @synchronized(self) 都是互斥的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4.GCD<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/*初始化信号量</span><br><span class="line">参数是信号量初始值</span><br><span class="line">*/</span><br><span class="line">_semaphore=dispatch_semaphore_create(1);</span><br><span class="line">/*信号等待</span><br><span class="line">第二个参数：等待时间</span><br><span class="line">*/</span><br><span class="line">dispatch_semaphore_wait(_semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">//dosomething</span><br><span class="line">&#125;</span><br><span class="line">//信号通知</span><br><span class="line">dispatch_semaphore_signal(_semaphore);</span><br></pre></td></tr></table></figure></p><ul><li>其他锁<br>递归锁：NSRecursiveLock<br>分布锁：NSDistributedLock，它本身是一个互斥锁，基于文件方式实现锁机制，可以跨进程访问。<br>互斥锁：如果共享数据已经有其他线程加锁了，线程会进入休眠状态等待锁。一旦被访问的资源被解锁，则等待资源的线程会被唤醒。<br>自旋锁：如果共享数据已经有其他线程加锁了，线程会以死循环的方式等待锁，一旦被访问的资源被解锁，则等待资源的线程会立即执行。</li></ul><h2 id="runtime与runloop"><a href="#runtime与runloop" class="headerlink" title="runtime与runloop"></a>runtime与runloop</h2><p><a href="https://guchunli.github.io/2017/03/22/iOS-runtime学习笔记/">iOS runtime与runloop学习笔记</a></p><h2 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h2><h3 id="plist文件（属性列表）"><a href="#plist文件（属性列表）" class="headerlink" title="plist文件（属性列表）"></a>plist文件（属性列表）</h3><h3 id="preference（偏好设置）"><a href="#preference（偏好设置）" class="headerlink" title="preference（偏好设置）"></a>preference（偏好设置）</h3><h3 id="沙盒"><a href="#沙盒" class="headerlink" title="沙盒"></a>沙盒</h3><h3 id="NSKeyedArchiver（归档）"><a href="#NSKeyedArchiver（归档）" class="headerlink" title="NSKeyedArchiver（归档）"></a>NSKeyedArchiver（归档）</h3><h4 id="实现NSCoding的自动归档和解档"><a href="#实现NSCoding的自动归档和解档" class="headerlink" title="实现NSCoding的自动归档和解档"></a>实现NSCoding的自动归档和解档</h4><h3 id="SQLite-3"><a href="#SQLite-3" class="headerlink" title="SQLite 3"></a>SQLite 3</h3><h3 id="CoreData"><a href="#CoreData" class="headerlink" title="CoreData"></a>CoreData</h3><h2 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h2><h3 id="http与https"><a href="#http与https" class="headerlink" title="http与https"></a>http与https</h3><p>https：HTTP下加入SSL层<br>区别：<br>1.https协议需要到ca申请证书。<br>2.http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。<br>3.http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p><h3 id="ATS"><a href="#ATS" class="headerlink" title="ATS"></a>ATS</h3><p>NSAppTransportSecurity：ATS配置的根节点，配置了节点表示告诉系统要走自定义的ATS设置。<br>NSAllowsAritraryLoads：是否禁用ATS特性，设置YES就是禁用ATS功能。</p><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>1.对称加密<br>1）加密/解密使用相同的密钥<br>2）加密和解密的过程是可逆的<br>3）经典算法：AES,DES</p><p>2.非对称加密<br>1）使用公钥加密，使用私钥解密，公钥是公开的，私钥保密<br>2）加密处理安全，但是性能极差<br>3）经典算法：RSA</p><h3 id="原生网络请求类"><a href="#原生网络请求类" class="headerlink" title="原生网络请求类"></a>原生网络请求类</h3><h4 id="NSURL"><a href="#NSURL" class="headerlink" title="NSURL"></a>NSURL</h4><p>作用：对传入的字符串类型采用 ASCII 编码格式<br>URL最重要的三个部分是 (scheme 方案), (host 主机), (path 路径)<br>scheme：协议名，如“http”<br>host：主机域名或 IP 地址。<br>port ：端口号。<br>path等</p><h4 id="请求报文和响应报文"><a href="#请求报文和响应报文" class="headerlink" title="请求报文和响应报文"></a>请求报文和响应报文</h4><ul><li><p>请求首部<br>1.GET /api/J1/getJ1List HTTP/1.1：请求方式，请求路径，http版本号<br>2.Host: localhost：3001，主机名，端口号<br>3.Connection: 连接类型为keep-alive<br>4.Pragma: no-cache，随报文传送指示的方式<br>5.Cache-Control : no-cache，随报文传送缓存指示<br>6.Accept: application/json, text/plain, <em>/</em>，接受的任意媒体类型, 和响应首部的Content-Type信息对照<br>7.Origin:  <a href="http://localhost:3000，当前访问域名" target="_blank" rel="noopener">http://localhost:3000，当前访问域名</a>, 与Access-Control-Allow-Origin信息对照<br>8.User-Agent: Mozilla/5.0，发起请求的应用程序名称<br>9.Referer: <a href="http://localhost:3000/，提供了包含当前请求URI的文档的URL" target="_blank" rel="noopener">http://localhost:3000/，提供了包含当前请求URI的文档的URL</a><br>10.Accept-Encoding: gzip, deflate, br，告诉服务器能够发送哪些编码方式.<br>11.Accept-Language: zh-CN,zh;q=0.8，告诉服务器能够发送哪些语言.</p></li><li><p>响应首部<br>1.http版本号，状态码，原因<br>2.content-Type：如application/json; charset=utf-8，用以区分传输资源<br>3.Content-Length：主体部分字节长度<br>4.Date：响应日期.<br>5.Connection ：连接类型为keep-alive.<br>6.Access-Control-Allow-Origin ：服务器域名<br>7.Access-Control-Allow-Methods：服务器实现的方法，GET,HEAD,PUT,POST,DELETE。</p></li></ul><h4 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h4><p>HTTP要传送一条报文时, 会以流的形式将报文数据的内容通过一条打开的TCP链接按序传输, TCP收到数据流之后, 会将数据流砍成被称作段的小数据块, 并将段封装在IP分组中.</p><h4 id="NSURLConnection"><a href="#NSURLConnection" class="headerlink" title="NSURLConnection"></a>NSURLConnection</h4><ul><li>为什么会废弃NSURLConnection而使用NSURLSession这个网络类呢?<br>NSURLConnection在iOS9以后已经被苹果弃用了<br>1.NSURLSession针对下载/上传等复杂的网络操作提供了专门的解决方案，针对普通、上传和下载分别对应三种不同的网络请求任务<br>2.下载任务方式<br>NSURLConnection下载文件时，先将整个文件下载到内存，然后再写入沙盒，如果文件比较大，就会出现内存暴涨的情况。<br>而使用NSURLSessionUploadTask下载文件，会默认下载到沙盒中的tem文件夹中，不会出现内存暴涨的情况，但在下载完成后会将tem中的临时文件删除，需要在初始化任务方法时，在completionHandler回调中增加保存文件的代码。<br>3.请求方法的控制<br>NSURLConnection实例化对象，实例化开始，默认请求就发送（同步发送），不需要调用start方法。而cancel 可以停止请求的发送，停止后不能继续访问，需要创建新的请求。<br>NSURLSession有三个控制方法，取消（cancel），暂停（suspend），继续（resume），暂停后可以通过继续恢复当前的请求任务。<br>4.断点续传的方式<br>5.配置信息<br>NSURLSessionConfiguration类的参数可以设置配置信息，其决定了cookie，安全和高速缓存策略，最大主机连接数，资源管理，网络超时等配置<br>6.支持app进入后台后的下载等处理。自带多线程，防死锁</li></ul><h4 id="NSURLSession"><a href="#NSURLSession" class="headerlink" title="NSURLSession"></a>NSURLSession</h4><p>1.NSURLSession：会话对象，异步请求, dataTask默认是关闭状态, 需要手动开启dataTask.resume().<br>2.NSURLSessionConfiguration</p><ul><li><p>配置不同的NSURLSession</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">defaultSessionConfiguration //默认配置使用的是持久化的硬盘缓存，存储证书到用户钥匙链。存储cookie到shareCookie。</span><br><span class="line">ephemeralSessionConfiguration //不使用永久持存cookie、证书、缓存的配置，最佳优化数据传输。</span><br><span class="line">backgroundSessionConfigurationWithIdentifier //可以上传下载HTTP和HTTPS的后台任务(程序在后台运行)</span><br></pre></td></tr></table></figure></li><li><p>统一设置超时时间、请求头等信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 构造NSURLSessionConfiguration</span><br><span class="line">NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];</span><br><span class="line">//设置请求超时为10秒钟</span><br><span class="line">configuration.timeoutIntervalForRequest = 10;</span><br><span class="line"></span><br><span class="line">//在蜂窝网络情况下是否继续请求（上传或下载）</span><br><span class="line">configuration.allowsCellularAccess = NO;</span><br><span class="line"></span><br><span class="line">//配置请求头</span><br><span class="line">configuration.HTTPAdditionalHeaders =@&#123;@&quot;Content-Encoding&quot;:@&quot;gzip&quot;&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>3.NSURLSessionTask<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSURLSessionDataTask  //一般的get、post等请求</span><br><span class="line">NSURLSessionUploadTask // 用于上传文件或者数据量比较大的请求</span><br><span class="line">NSURLSessionDownloadTask //用于下载文件或者数据量比较大的请求</span><br><span class="line">NSURLSessionStreamTask //建立一个TCP / IP连接的主机名和端口或一个网络服务对象。</span><br></pre></td></tr></table></figure></p><p>函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)suspend;//暂停</span><br><span class="line">- (void)resume;//开始或者恢复</span><br><span class="line">- (void)cancel;//关闭任务</span><br></pre></td></tr></table></figure></p><h3 id="Bonjour-，WebKit-，BSD-Sockets"><a href="#Bonjour-，WebKit-，BSD-Sockets" class="headerlink" title="Bonjour ，WebKit ，BSD Sockets"></a>Bonjour ，WebKit ，BSD Sockets</h3><!--Bonjour(法语中的你好)--><p>Cocoa 网络框架有三层，最底层的是基于 BSD socket库，然后是 Cocoa 中基于 C 的 CFNetwork，最上面一层是 Cocoa 中Foundation 。</p><h2 id="App启动顺序"><a href="#App启动顺序" class="headerlink" title="App启动顺序"></a>App启动顺序</h2><p>1.加载main函数<br>2.UIApplicationMain，创建application对象，创建application的delegate<br>3.创建主循环，代理对象开始监听<br>4.didFinishLaunch，创建window<br><code>controller的加载过程</code><br>5.设置window的根控制器<br>6.如果有storyboard，根据Info.plist获得最主要storyboard的文件名，加载最主要的storyboard<br>7.显示window<br>8.didBecomeActive：真正到了这里，才是所有东西全部加载完毕</p><ul><li><p>controller的加载过程：<br>1.loadView<br>2.viewDidLoad<br>5.viewWillAppear<br>6.viewWillLayoutSubviews<br>7.viewDidLayoutSubviews<br>8.viewDidAppear</p></li><li><p>view的加载过程：<br>9.-(instancetype)initWithCoder:(NSCoder *)aDecoder：如果没有storyboard就会调用initWithFrame，这里两种方法视为一种）<br>10.- (void)awakeFromNib：在使用IB的时候才会涉及到此方法的使用<br>11.- (void)viewWillLayoutSubviews：布局子视图<br>12.- (void)drawRect:(CGRect)rect：使用setNeedsDisplay来定时多次调用本方法</p></li><li><p>ApplicationDelegate<br>1.didFinishLaunch：应用启动完毕调用<br>2.DidBecomeActive：app程序获取焦点就会调用<br>3.WillResignActive：APP失去焦点<br>4.DidEnterBackground：app进入后台的时候调用， 一般在这里保存应用的数据(游戏数据,比如暂停游戏)<br>5.WillEnterForeground：app程序程序从后台回到前台就会调用<br>6.DidReceiveMemoryWarning：内存警告，可能要终止程序，清除不需要再使用的内存<br>7.WillTerminate：程序即将退出调用</p></li></ul><p>1.应用第一次启动：didFinishLaunch-&gt;didBecomeActive<br>2.前台到后台：WillResignActive-&gt;DidEnterBackground<br>3.后台到前台：WillEnterForeground-&gt;DidBecomeActive</p><h3 id="事件传递-事件响应"><a href="#事件传递-事件响应" class="headerlink" title="事件传递/事件响应"></a>事件传递/事件响应</h3><p>传递：application-&gt;window-&gt;controller-&gt;view<br>响应：view-&gt;controller-&gt;window-&gt;application<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//作用：返回一个view来响应事件</span><br><span class="line">//如果调用了父类的这个方法，那系统就要调用方法pointInside方法，通过这个方法的返回值，来判断当前这个view能不能响应消息。</span><br><span class="line">//如果没有调用父类的方法，那就根据这个方法返回的view，作为响应事件的view。（当然返回nil，就是这个view不响应）</span><br><span class="line">- (nullableUIView *)hitTest:(CGPoint)point withEvent:(nullableUIEvent *)event；</span><br><span class="line"></span><br><span class="line">//作用：返回的值可以用来判断是否继续遍历子视图（返回的根据是触摸的point是否在view的frame范围内）</span><br><span class="line">//如果返回的是no，那就不用再去遍历它的子视图，hitTest方法返回的view就是可以响应事件的view。</span><br><span class="line">//如果返回的是YES，那就去遍历它的子视图</span><br><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(nullableUIEvent *)event；</span><br></pre></td></tr></table></figure></p><h1 id="中级"><a href="#中级" class="headerlink" title="中级"></a>中级</h1><h2 id="category分类与extension"><a href="#category分类与extension" class="headerlink" title="category分类与extension"></a>category分类与extension</h2><p>1.category与extension的区别</p><ul><li>category可以不用继承系统类，直接给系统类添加方法，最大程度的体现了Objective-C的动态语言特性。可以用来定义私有方法。</li><li>extension为一个类增加私有方法,属性或成员变量,并且新添加的方法一定要予以实现。Extension都是放在.m文件中@implementation的上方。<br>区别：Extension可以添加属性，category不可以。另外Extension添加的方法是必须要实现的。<br>2.OC中的私有变量用@private修饰，私有方法用category<br>3.category为什么不能添加属性<br>category 它是在运行期决议的。 因为在运行期即编译完成后，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的。</li></ul><h2 id="xib-storyboard-autolayout"><a href="#xib-storyboard-autolayout" class="headerlink" title="xib,storyboard,autolayout"></a>xib,storyboard,autolayout</h2><p>缺点：<br>1.难以维护<br>2.性能<br>3.错误定位困难</p><h2 id="UITableView"><a href="#UITableView" class="headerlink" title="UITableView"></a>UITableView</h2><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>1.缓存高度：更新界面之前就把每个 cell 的高度算好，缓存到相对应的 model 中<br>2.异步绘制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//异步绘制</span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">CGRect rect = CGRectMake(0, 0, 100, 100);</span><br><span class="line">UIGraphicsBeginImageContextWithOptions(rect.size, YES, 0);</span><br><span class="line">CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line">[[UIColor lightGrayColor] set];</span><br><span class="line">CGContextFillRect(context, rect);</span><br><span class="line"></span><br><span class="line">//将绘制的内容以图片的形式返回，并调主线程显示</span><br><span class="line">UIImage *temp = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">UIGraphicsEndImageContext();</span><br><span class="line"></span><br><span class="line">// 回到主线程</span><br><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">//code</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>3.减少层级：减少SubViews的数量, 在滑动的列表上，多层次的view会导致帧数的下降。<br>4.hide：尽量少用addView给Cell动态添加View，可以初始化时就添加，然后通过hide来控制是否显示<br>5.避免离屏渲染<br>（1）当有图像时，预渲染图像，在bitmap context先将其画一遍，导出成UIImage对象，然后再绘制到屏幕，这会大大提高渲染速度<br>（2）尽量不要使用透明背景，将cell的opaque值设为Yes，背景色不要使用clearColor，尽量不要使用阴影渐变等<br>（3）可以在UIView的drawRect方法中自定义绘制<br>（4）正确地使用UITableViewCell的重用机制<br>（5）避免阻塞主线程<br>（6）尽可能重用开销比较大的对象<br>（7）尽量减少计算的复杂度</p><h4 id="UITableView的滚动加载进行优化，防止卡顿"><a href="#UITableView的滚动加载进行优化，防止卡顿" class="headerlink" title="UITableView的滚动加载进行优化，防止卡顿"></a>UITableView的滚动加载进行优化，防止卡顿</h4><p>1.减少cellForRowAtIndexPath代理中的计算量（cell的内容计算）<br>首先要提前计算每个cell中需要的一些基本数据，代理调用的时候直接取出；<br>图片要异步加载，加载完成后再根据cell内部UIImageView的引用设置图片；<br>图片数量多时，图片的尺寸要跟据需要提前经过transform矩阵变换压缩好（直接设置图片的contentMode让其自行压缩仍然会影响滚动效率），必要的时候要准备好预览图和高清图，需要时再加载高清图。<br>图片的‘懒加载’方法，即延迟加载，当滚动速度很快时避免频繁请求服务器数据。<br>尽量手动Drawing视图提升流畅性，而不是直接子类化UITableViewCell，然后覆盖drawRect方法，因为cell中不是只有一个contentview。绘制cell不建议使用UIView，建议使用CALayer。原因要参考UIView和CALayer的区别和联系。</p><p>2.减少heightForRowAtIndexPath代理中的计算量（cell的高度计算）<br>由于每次TableView进行update更新都会对每一个cell调用heightForRowAtIndexPath代理取得最新的height，会大大增加计算时间。如果表格的所有cell高度都是固定的，那么去掉heightForRowAtIndexPath代理，直接设置TableView的rowHeight属性为固定的高度；<br>如果高度不固定，应尽量将cell的高度数据计算好并储存起来，代理调用的时候直接取，即将height的计算时间复杂度降到O(1)。例如：在异步请求服务器数据时，提前将cell高度计算好并作为dataSource的一个数据存到数据库供随时取用。</p><h3 id="重用机制"><a href="#重用机制" class="headerlink" title="重用机制"></a>重用机制</h3><ul><li><p>可变数组，用来保存当前显示的cell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *visiableCells</span><br></pre></td></tr></table></figure></li><li><p>可变字典，用来保存可复用的cell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSMutableDictionary *reusableTableCells</span><br></pre></td></tr></table></figure></li></ul><p>可复用的cell使用字典是因为可复用的cell可能不只有一种样式，这里需要字典指定key(也就是reuseIdentifier)来查找是否有可重用样式</p><h4 id="重用原理"><a href="#重用原理" class="headerlink" title="重用原理"></a>重用原理</h4><ul><li>底端出现的cell：reusableTableCells（取出）-&gt; visiableCells（放入）</li><li>顶端消失的cell：visiableCells（取出）-&gt; reusableTableCells（放入）</li><li>visiableCells当中如果没有该标识符，alloc即可</li></ul><p>在这里先假设iPhone屏幕最多能显示10个cell<br>1.创建11（最多能显示的次数+1）个单元格<br>用[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier]创建11次cell，并给cell指定相同的重用标识(当然，能够为不同显示类型的cell指定不同的标识)。而且11个cell所有都增加到visiableCells数组，<code>此时的reusableTableCells为空</code>。<br>2.向下拖动tableView，当cell1全然移出屏幕，而且cell11(它也是alloc出来的，原因同上)全然显示出来的时候。cell11增加到visiableCells，cell1移出visiableCells，增加到reusableTableCells。<br>3.接下来的拖动当中显示新的cell，cellForRowAtIndexPath会调用，这个时候就执行重用API：传入一个CellIdentifier<br>接着向下拖动tableView，由于reusableTableCells中已经有值，所以，当须要显示新的cell，cellForRowAtIndexPath再次被调用的时候，tableView dequeueReusableCellWithIdentifier:CellIdentifier，返回cell1。cell1增加到visiableCells，cell1移出reusableTableCells；cell2移出visiableCells，增加到reusableTableCells。之后Cell就能够正常重用了。</p><ul><li>并不是只有超过屏幕的时候才更新reusableTableCells数组，reloadData方法 和 reloadRowsAtIndex(可能) 对数组进行更新</li></ul><ol><li>reloadData，这样的情况比较特殊。通常是部分数据发生变化，须要又一次刷新cell显示的内容时调用。在cellForRowAtIndexPath调用中，全部cell都是重用的。我预计reloadData调用后，把visiableCells中全部cell移入reusableTableCells，visiableCells清空。cellForRowAtIndexPath调用后，再把reuse的cell从reusableTableCells取出来，放入到visiableCells。</li><li>reloadRowsAtIndex，刷新指定的IndexPath。假设调用时reusableTableCells为空，那么cellForRowAtIndexPath调用后，是新创建cell，新的cell增加到visiableCells。老的cell移出visiableCells，增加到reusableTableCells。于是，之后的刷新就有cell做reuse了。</li></ol><h2 id="UICollectionView"><a href="#UICollectionView" class="headerlink" title="UICollectionView"></a>UICollectionView</h2><h3 id="UICollectionViewLayout"><a href="#UICollectionViewLayout" class="headerlink" title="UICollectionViewLayout"></a>UICollectionViewLayout</h3><ul><li>UICollectionView如何显示内容完全由layout(布局对象)决定<br>UICollectionViewLayout：是一个抽象类，一般情况使用UICollectionViewLayout的子类即可, 只有需要自定义cell显示样式时才需要定义一个类继承于UICollectionViewLayout来自己实现<br>UICollectionViewFlowLayout(流水布局): 该类是UICollectionViewLayout的子类, 系统已经提供了默认的实现<!--调用顺序：--><!--1.prepareLayout--><!--2.-(CGSize) collectionViewContentSize--><!--3.-(NSArray *)layoutAttributesForElementsInRect:(CGRect)rect--></li></ul><h1 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h1><h2 id="UIView-与-CALayer"><a href="#UIView-与-CALayer" class="headerlink" title="UIView 与 CALayer"></a>UIView 与 CALayer</h2><p>UIView 的绘制是建立在 CoreGraphic 上的，使用的是 CPU。<br>CALayer 使用的是 Core Animation，CPU，GPU 通吃，由系统决定使用哪个。</p><ul><li><p>绘制<br>View：自下向上的一层一层的绘制，然后渲染。<br>Layer处理的是 Texure，利用 GPU 的 Texture Cache 和独立的浮点数计算单元加速 纹理 的处理。</p></li><li><p>从事件的响应来说：<br>UIView是 CALayer 的代理，layer本身并不能响应事件，因为layer是直接继承自NSObject，不具备处理事件的能力。而 UIView 是继承了UIResponder 的，这也是事件转发的角度上说明，view要比单纯的layer复杂的多。多层次的view再加上各种手势的处理势必导致帧数的下降。</p></li></ul><h2 id="iOS各版本差异"><a href="#iOS各版本差异" class="headerlink" title="iOS各版本差异"></a>iOS各版本差异</h2><h3 id="iOS9"><a href="#iOS9" class="headerlink" title="iOS9"></a>iOS9</h3><p>1.UIStackView<br>2.ATS</p><h3 id="iOS11"><a href="#iOS11" class="headerlink" title="iOS11"></a>iOS11</h3><h2 id="性能优化，内存泄漏"><a href="#性能优化，内存泄漏" class="headerlink" title="性能优化，内存泄漏"></a>性能优化，内存泄漏</h2><p>内存泄漏（memory leak）： 是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。<br>内存溢出（out of memory）：程序要求的内存，超出了系统所能分配的范围。如：我们用一个int型4字节的数据来装一个float型8字节的数据，就会产生内存溢出。不过我们在编程是可以强制类型转换int XX = (int)float;只取float 4字节数据给int.</p><p><a href="https://guchunli.github.io/2017/06/05/iOS调试与性能优化学习笔记/">iOS调试与性能优化学习笔记</a><br><a href="https://www.jianshu.com/p/9c450e512020" target="_blank" rel="noopener">iOS最全性能优化</a><br><a href="https://guchunli.github.io/2017/12/19/iOS提高界面流畅度的技巧/">iOS提高界面流畅度的技巧</a></p><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p><a href="https://guchunli.github.io/2017/03/03/git学习笔记/">git学习笔记</a></p><h2 id="原生与js交互"><a href="#原生与js交互" class="headerlink" title="原生与js交互"></a>原生与js交互</h2><p><a href="https://guchunli.github.io/2017/07/04/OC与JS交互的几种方法/">OC与JS交互的几种方法</a></p><h2 id="RAC-函数式，响应式编程"><a href="#RAC-函数式，响应式编程" class="headerlink" title="RAC 函数式，响应式编程"></a>RAC 函数式，响应式编程</h2><p><a href="https://guchunli.github.io/2017/05/20/ReactiveCocoa学习笔记/">ReactiveCocoa学习笔记</a></p><h2 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h2><p><a href="iOS动画学习笔记">iOS动画学习笔记</a><br><a href="https://guchunli.github.io/2017/04/23/RAC与Target-Action、通知、代理、KVO/">RAC与Target-Action、通知、代理、KVO</a></p><h2 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h2><h3 id="SDWebImage"><a href="#SDWebImage" class="headerlink" title="SDWebImage"></a>SDWebImage</h3><ul><li>缓存路径<br>默认情况下，图片是被存储到<code>内存</code>缓存和<code>磁盘</code>缓存中的。如果仅仅是想缓存到内存中，可以用方法：storeImage:forKey:toDisk: 第三个参数传NO即可。</li><li>查找显示图片<br>sd加载一张图片的时候，会先在内存里面查找是否有这张图片，如果没有会根据图片的md5(url)后的名称去沙盒里面去寻找，是否有这张图片，如果没有会开辟线程去下载，下载完毕后加载到imageview上面，并md(url)为名称缓存到沙盒里面。</li><li>SDWebImage缓存到本地沙盒的哪个路径<br><code>NSCachesDirectory</code>，SDImageCache 在初始化的时候会注册一些消息通知，在内存警告或退到后台的时 候清理内存图片缓存，应用结束的时候清理过期图片</li><li>SDWebImage加载图片的流程<br>思路：placeholderImage-&gt;内存中查找-&gt;硬盘中查找（如有，缓存到内存）-&gt;如没有，下载-&gt;解码-&gt;保存到内存和硬盘<br>详细流程：<br>1.入口 setImageWithURL:placeholderImage:options:会先把 placeholderImage显示，然后 SDWebImageManager根据 URL 开始处理图片。<br>2.进入SDWebImageManager 类中downloadWithURL:delegate:options:userInfo:，交给<br>SDImageCache从缓存查找图片是否已经下载<br>queryDiskCacheForKey:delegate:userInfo:.<br>3.先从内存图片缓存查找是否有图片，如果内存中已经有图片缓存，SDImageCacheDelegate回调 imageCache:didFindImage:forKey:userInfo:到<br>SDWebImageManager。<br>4.SDWebImageManagerDelegate 回调<br>webImageManager:didFinishWithImage: 到 UIImageView+WebCache,等前端展示图片。<br>5.如果内存缓存中没有，生成 ｀NSOperation ｀<br>添加到队列，开始从硬盘查找图片是否已经缓存。<br>6.根据 URL的MD5值Key在硬盘缓存目录下尝试读取图片文件。这一步是在 NSOperation 进行的操作，所以回主线程进行结果回调 notifyDelegate:。<br>7.如果上一操作从硬盘读取到了图片，将图片添加到内存缓存中（如果空闲内存过小， 会先清空内存缓存）。SDImageCacheDelegate’回调 imageCache:didFindImage:forKey:userInfo:。进而回调展示图片。<br>8.如果从硬盘缓存目录读取不到图片，说明所有缓存都不存在该图片，需要下载图片， 回调 imageCache:didNotFindImageForKey:userInfo:。<br>9.共享或重新生成一个下载器 SDWebImageDownloader开始下载图片。<br>10.图片下载由 NSURLSession 来做，实现相关 delegate<br>来判断图片下载中、下载完成和下载失败。<br>11.connection:didReceiveData: 中利用 ImageIO做了按图片下载进度加载效果。<br>12.connectionDidFinishLoading: 数据下载完成后交给 SDWebImageDecoder做图片解码处理。<br>13.图片解码处理在一个 NSOperationQueue完成，不会拖慢主线程 UI.如果有需要 对下载的图片进行二次处理，最好也在这里完成，效率会好很多。<br>14.在主线程 notifyDelegateOnMainThreadWithInfo:<br>宣告解码完成 imageDecoder:didFinishDecodingImage:userInfo: 回调给 SDWebImageDownloader`。<br>15.imageDownloader:didFinishWithImage:回调给 SDWebImageManager告知图片 下载完成。</li></ul><ol start="16"><li>通知所有的 downloadDelegates下载完成，回调给需要的地方展示图片。<br>17.将图片保存到 SDImageCache中，内存缓存和硬盘缓存同时保存。写文件到硬盘 也在以单独 NSOperation 完成，避免拖慢主线程。<br>18.SDImageCache 在初始化的时候会注册一些消息通知，在内存警告或退到后台的时 候清理内存图片缓存，应用结束的时候清理过期图片。<br>19.SDWebImage 也提供了 UIButton+WebCache 和 MKAnnotationView+WebCache，方便使用。<br>20.SDWebImagePrefetcher 可以预先下载图片。</li></ol><h4 id="NSCache优于NSDictionary的地方"><a href="#NSCache优于NSDictionary的地方" class="headerlink" title="NSCache优于NSDictionary的地方"></a>NSCache优于NSDictionary的地方</h4><p>1.当系统资源将要耗尽时，NSCache可以自动删减缓存<br>2.NSCache是线程安全的，而NSDictionary则绝对不具备此优势</p><h3 id="cocoapods"><a href="#cocoapods" class="headerlink" title="cocoapods"></a>cocoapods</h3><h4 id="私有库"><a href="#私有库" class="headerlink" title="私有库"></a>私有库</h4><p>远程私有库可以将你的代码传到第三方托管平台进行公司内部开发人员共享,从而实现组件化开发模式</p><h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><h3 id="MJRefresh"><a href="#MJRefresh" class="headerlink" title="MJRefresh"></a>MJRefresh</h3><ul><li><p>基类-&gt;基础的下拉/上拉-&gt;带有状态文字-&gt;(上拉：会回弹到底部/会自动刷新)-&gt;能用的子类<br>MJRefreshComponent-&gt;MJRefreshHeader-&gt;MJRefreshStateHeader-&gt;MJRefreshNormalHeader/MJRefreshGifHeader</p><pre><code>-&gt;MJRefreshFooter-&gt;MJRefreshBackFooter-&gt;MJRefreshBackNormalFooter/MJRefreshBackGifFooter                               -&gt;MJRefreshAutoFooter-&gt;MJRefreshAutoNormalFooter/MJRefreshAutoGifFooter</code></pre></li><li><p>创建<br>block/target-action</p></li><li><p>刷新控件的状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, MJRefreshState) &#123;</span><br><span class="line">/** 普通闲置状态 */</span><br><span class="line">MJRefreshStateIdle = 1,</span><br><span class="line">/** 松开就可以进行刷新的状态 */</span><br><span class="line">MJRefreshStatePulling,</span><br><span class="line">/** 正在刷新中的状态 */</span><br><span class="line">MJRefreshStateRefreshing,</span><br><span class="line">/** 即将刷新的状态 */</span><br><span class="line">MJRefreshStateWillRefresh,</span><br><span class="line">/** 所有数据加载完毕，没有更多的数据了 */</span><br><span class="line">MJRefreshStateNoMoreData</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>隐藏</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 隐藏时间</span><br><span class="line">header.lastUpdatedTimeLabel.hidden = YES;</span><br><span class="line">// 隐藏状态</span><br><span class="line">header.stateLabel.hidden = YES;</span><br></pre></td></tr></table></figure></li></ul><h3 id="fmmpeg框架"><a href="#fmmpeg框架" class="headerlink" title="fmmpeg框架"></a>fmmpeg框架</h3><p>音视频编解码框架，内部使用UDP协议针对流媒体开发，内部开辟了六个端口来接受流媒体数据，完成快速接受之目的。</p><h3 id="图形和动画-：Core-Animation-，OpenGL-ES-，Quartz-2D"><a href="#图形和动画-：Core-Animation-，OpenGL-ES-，Quartz-2D" class="headerlink" title="图形和动画 ：Core Animation ，OpenGL ES ，Quartz 2D"></a>图形和动画 ：Core Animation ，OpenGL ES ，Quartz 2D</h3><h2 id="swift"><a href="#swift" class="headerlink" title="swift"></a>swift</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//swift中的let是线程安全的</span><br><span class="line">static let instance: NetworkTools = NetworkTools()</span><br><span class="line">class func shareNetworkTools() -&gt; NetworkTools&#123;</span><br><span class="line">return instance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private let sharedInstance = Singleton()</span><br><span class="line">class Singleton: NSObject &#123;</span><br><span class="line">class var sharedManager: Singleton &#123;</span><br><span class="line">return sharedInstance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://guchunli.github.io/2017/07/14/Swift学习笔记/">Swift学习笔记</a></p><h2 id="react-native"><a href="#react-native" class="headerlink" title="react native"></a>react native</h2><p><a href="https://guchunli.github.io/2017/07/06/ReactNative基础知识学习笔记/">ReactNative基础知识学习笔记</a><br><a href="https://guchunli.github.io/2017/06/21/ReactNative使用学习笔记/">ReactNative使用学习笔记</a></p><p>参考文章：<a href="https://www.jianshu.com/p/7d486b24dc21" target="_blank" rel="noopener">2017年5月iOS招人心得答案总结</a><br><a href="http://blog.csdn.net/kongdeqin/article/details/53171189" target="_blank" rel="noopener">关于NSMutableArray线程安全的思考和实现</a><br><a href="https://www.jianshu.com/p/48665652e4e4" target="_blank" rel="noopener">OC知识–彻底理解内存管理(MRC、ARC)</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> OC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何让你的简历脱颖而出（转）</title>
      <link href="/2018/03/01/%E5%A6%82%E4%BD%95%E8%AE%A9%E4%BD%A0%E7%9A%84%E7%AE%80%E5%8E%86%E8%84%B1%E9%A2%96%E8%80%8C%E5%87%BA%EF%BC%88%E8%BD%AC%EF%BC%89/"/>
      <url>/2018/03/01/%E5%A6%82%E4%BD%95%E8%AE%A9%E4%BD%A0%E7%9A%84%E7%AE%80%E5%8E%86%E8%84%B1%E9%A2%96%E8%80%8C%E5%87%BA%EF%BC%88%E8%BD%AC%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<pre><code>年后的2、3月份是每年换工作的高峰期。可能很多人在过年以前早都萌生了换工作的想法。过年时在亲朋好友的刺激下，更坚定了这个想法。年终奖既已到手，对前公司的最后一丝留恋也随之逝去。在各大招聘网上更新自己的简历，主动和猎头联系让其帮忙物色，新一轮大潮已经开始。IT行业的招聘是个怪圈。企业缺人，很难招到合适的人才；程序员想要工作，找到理想的工作却不易。企业的要求应聘者达不到，应聘者的期望企业却无法满足。好工作职位不多，应聘者却于过江之鲫。如果你是个大牛，那么恭喜你，不是你找工作，而是工作找你。如果你自认为是一个屌丝，那么在找工作的时候只能自求多福。如果你自认为自己是个小牛，只是苦于没有伯乐发现你，那就要看看你准备了那些东西来博得眼球。在当今在是个阿猫阿狗都敢在简历上写上精通XX，熟悉XX的时代，如何让自己的简历能够第一时间博得HR的芳心，顺利进行面试的环节，甚至通过面试最终环节，升职加薪，当上总经理，出任CEO，赢取白富美，走上人生巅峰那？笔者在IT行业已经呆了5年多，时间不算长也不算短。期间有很多面试和被面试的经历。随着工作年限的增加，如何能够让自己的简历更加出色，是我一直在思考的问题。结合自己最近的面试经验和从HR那里得到的情报，我发现如果能在简历上列下以下东西，绝对会让你的简历立马脱颖而出。1.在简历中列出自己的博客地址。IT行业是个很特别的行业，似乎没有其他行业能够像IT行业这样能够从网络中学到几乎所有专业所需的知识。如何能展示出自己学习到的知识，证明自己肚里有货，博客无疑是一个既用不了多少成本，却能给自己带来丰厚回报的手段。关于写博客的好处我已不想累述。在简历中列出你的博客地址，会让HR直观的感受到你的积极主动、热爱学习的态度，无疑会给你加分不少。2.给出自己在GitHub上的链接。当2008年GitHub横空出世时，用户轻而易举就超过了10万人。现在就连我那学校里的研究生师弟、师妹都开始使用GitHub，Social coding势不可挡。饭店应聘厨子都要试菜，公司招聘程序员当然希望能够看到应征者的程序作品。到底应征者能不能满足要求，在他的Github上随便查阅几次check in历史便可快速判定。你的项目有没有自动构建脚本?有没有单元测试?有没有自动化功能测试？你的代码是否clean？命名是否合理？应用了那些设计模式？使用了那些语言的特性？如果你真的有货，那么就不用和招聘方多费口舌，直接看以前写过的代码吧，那上面啥都有。3.列出自己的豆瓣读书记录。网络虽然是IT行业萃取知识的最大途径，但是我们仍不能忽略书籍的力量。读一本好书远远胜过你在网上读100篇文章。网络资源的特点是碎片化、细节化。这样的知识大而全，没有脉络，读者往往捡了芝麻，丢了西瓜。而一本好书能够有效的将你学到的知识串联起来，形成体系。去年自己计划全年读30本书，后来读了将近20本，感觉收获巨大。应征者的读书记录也能在一定程度上反映出应征者的能力水平。如果能够再花时间写一些读书笔记那更再好不过了。4.列出自己的翻译的文章、书籍，甚至出版自己的技术书籍。如果身为一个IT工程师，英文不行，那么你注定成为不了一个牛逼的工程师。练好英文，会给自己打开一扇大门，就像一条鱼从湖里游到了海里。自己在学习到第一手知识之余，将其翻译为中文，造福国内其他的程序员，百利而无一害。这也能让你的简历增色不少。翻译的文章多了，会有编辑找你翻译书籍，甚至自己出书也不无可能。以上四点足以让你在众多千篇一律的”精通XX,熟悉XX”的简历中脱颖而出。但是以上四点有个共同的特点，就是需要积累，需要坚持，这样才有实质的内容。这需要你好好的经营，短则一年，长则整个职业生涯。1.从现在开始，坚持每周至少写一篇技术文章，一年就有50多篇。2.给自己定一个目标，一个月读2本书，那么一年就有24本。3.注册一个GitHub账号，将自己平时做练习的代码、做的小项目放上去，争取一年有超过200次提交。4.英文不行的开始学习英文，至少达到阅读技术文章无压力，一年的时间也够了吧，每个月翻译一篇自己喜欢的技术文章，一年也有12篇。这样子坚持一年，就算一年前是个屌丝，现在你一定有底气说自己这一年来绝非一事无成。相信你应聘工作的时候会多份从容，少分自卑。如果一年时间你都坚持不下来，那么你就就要扪心自问究竟你比别人强在哪里？凭什么要求面试者多给你机会？贫者愈贫，富者愈富，是马太效应在经济界的直白阐述。其实在IT届也可以应用马太效应，即知识丰富的人随着时间推移会越来越出色，得到机会更多，而平庸的人会越来越平庸，最后泯然众人。我毕业2年后才开始如饥似渴的学习知识，现在毕业不到5年，已经感受到了马太效应的力量。现在是今年的招聘高峰期，还未找到理想工作的同仁不要气馁，厚积薄发一年，绝对会有惊喜。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>http网络请求过程</title>
      <link href="/2018/02/26/http%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/"/>
      <url>/2018/02/26/http%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>Http是属于应用层的协议，配合TCP/IP使用。<br>请求与响应：客户端发送请求，服务器端响应数据。<br><a id="more"></a></p><h2 id="完整的HTTP请求过程"><a href="#完整的HTTP请求过程" class="headerlink" title="完整的HTTP请求过程"></a>完整的HTTP请求过程</h2><p>HTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤：</p><h3 id="1-建立TCP连接："><a href="#1-建立TCP连接：" class="headerlink" title="1. 建立TCP连接："></a>1. 建立TCP连接：</h3><p>在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能进行更高层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。</p><h3 id="2-Web浏览器向Web服务器发送请求命令："><a href="#2-Web浏览器向Web服务器发送请求命令：" class="headerlink" title="2. Web浏览器向Web服务器发送请求命令："></a>2. Web浏览器向Web服务器发送请求命令：</h3><p>一旦建立了TCP连接，Web浏览器就会向Web服务器发送get/post请求命令。例如：GET/sample/hello.jsp HTTP/1.1。</p><h3 id="3-Web浏览器发送请求头信息-："><a href="#3-Web浏览器发送请求头信息-：" class="headerlink" title="3. Web浏览器发送请求头信息 ："></a>3. Web浏览器发送请求头信息 ：</h3><p>浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。</p><h3 id="4-Web服务器应答-："><a href="#4-Web服务器应答-：" class="headerlink" title="4. Web服务器应答 ："></a>4. Web服务器应答 ：</h3><p>客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。</p><h3 id="5-Web服务器发送应答头信息："><a href="#5-Web服务器发送应答头信息：" class="headerlink" title="5. Web服务器发送应答头信息："></a>5. Web服务器发送应答头信息：</h3><p>正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。</p><h3 id="6-Web服务器向浏览器发送数据："><a href="#6-Web服务器向浏览器发送数据：" class="headerlink" title="6. Web服务器向浏览器发送数据："></a>6. Web服务器向浏览器发送数据：</h3><p>Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。</p><h3 id="7-Web服务器关闭TCP连接-："><a href="#7-Web服务器关闭TCP连接-：" class="headerlink" title="7. Web服务器关闭TCP连接 ："></a>7. Web服务器关闭TCP连接 ：</h3><p>一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：Connection:keep-alive；</p><p>TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p><h2 id="建立TCP连接"><a href="#建立TCP连接" class="headerlink" title="建立TCP连接"></a>建立TCP连接</h2><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；</p><p>第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</p><p>第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</p><ul><li>为什么要三次握手<br>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</li></ul><h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><p>第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</p><p>第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；</p><p>第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</p><p>第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</p><ul><li>为什么要四次分手</li></ul><p>TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p><p>参考链接：<a href="http://blog.csdn.net/yezitoo/article/details/78193794" target="_blank" rel="noopener">一次完整的HTTP请求过程</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Carthage的安装与使用</title>
      <link href="/2018/02/26/Carthage%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/02/26/Carthage%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Carthage的安装与使用"><a href="#Carthage的安装与使用" class="headerlink" title="Carthage的安装与使用"></a>Carthage的安装与使用</h2><h3 id="Carthage的安装"><a href="#Carthage的安装" class="headerlink" title="Carthage的安装"></a>Carthage的安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ brew update</span><br><span class="line">Error: /usr/local is not writable. You should change the</span><br><span class="line">ownership and permissions of /usr/local back to your</span><br><span class="line">user account:</span><br><span class="line">sudo chown -R $(whoami) /usr/local</span><br><span class="line">$ sudo chown -R $(whoami) /usr/local</span><br><span class="line">$ brew install carthage</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="创建Cartfile文件"><a href="#创建Cartfile文件" class="headerlink" title="创建Cartfile文件"></a>创建Cartfile文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim Cartfile</span><br></pre></td></tr></table></figure><h3 id="在Cartfile文件中引入一个第三方库"><a href="#在Cartfile文件中引入一个第三方库" class="headerlink" title="在Cartfile文件中引入一个第三方库"></a>在Cartfile文件中引入一个第三方库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//比如引入SwiftyJSON</span><br><span class="line">github &quot;SwiftyJSON/SwiftyJSON&quot;</span><br></pre></td></tr></table></figure><h3 id="安装第三方库"><a href="#安装第三方库" class="headerlink" title="安装第三方库"></a>安装第三方库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">carthage update</span><br></pre></td></tr></table></figure><p>构建完成后，在项目的根目录中自动生成一个Carthage目录。这个目录中又包含了两个目录Build和Checkout。 <code>Build</code>中存放的是构建好的framework包，<code>Checkouts</code>中存放的是签出的第三方库项目源文件。</p><h3 id="添加framework"><a href="#添加framework" class="headerlink" title="添加framework"></a>添加framework</h3><p>Carthage 只支持动态框架，它仅负责将项目 clone 到本地并将对应的 Cocoa Framework target 进行构建，之后你需要自行将构建好的 framework 添加到项目中，所有的引入库的源和版本需要自己管理。<br>添加framework：<br>general-&gt;Linked Frameworks and Libraries-&gt;add-&gt;add other-&gt;Carthage-&gt;Build-&gt;iOS-&gt;xxx.framework</p><h2 id="Carthage文件夹下各个文件的用途"><a href="#Carthage文件夹下各个文件的用途" class="headerlink" title="Carthage文件夹下各个文件的用途"></a>Carthage文件夹下各个文件的用途</h2><ul><li>Cartfile文件：用来标注需要哪些依赖库，对应版本或者 Git 分支,当然前提必须提交到Git。</li><li>Cartfile.resolved文件：用来跟踪项目当前所用的依赖版本号，主要为了保持多端开发一致。</li><li>Carthage文件夹：用来存放依赖库的源文件和编译后的文件 (不需要提交到 Git)。</li></ul><h2 id="Carthage与CocoaPods优缺点"><a href="#Carthage与CocoaPods优缺点" class="headerlink" title="Carthage与CocoaPods优缺点"></a>Carthage与CocoaPods优缺点</h2><ul><li>优点：<ul><li>Carthage更加灵活</li><li>很多库不需要声明并改造就直接可以被 Carthage 用</li></ul></li><li>缺点：<ul><li>不如 CocoaPods 丰富</li><li>有大量 CocoaPods 能用的库不支持</li></ul></li></ul><p>参考链接：<a href="https://www.jianshu.com/p/3921289cd3c5" target="_blank" rel="noopener">走向Carthage</a><br><a href="https://swift.org/package-manager/" target="_blank" rel="noopener">Swift Package Manager</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Carthage </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS生成图形验证码</title>
      <link href="/2018/02/07/iOS%E7%94%9F%E6%88%90%E5%9B%BE%E5%BD%A2%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
      <url>/2018/02/07/iOS%E7%94%9F%E6%88%90%E5%9B%BE%E5%BD%A2%E9%AA%8C%E8%AF%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>1.创建一个图形验证码视图<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface CodeView : UIView</span><br><span class="line"></span><br><span class="line">@property (nonatomic,strong) NSArray           *changeArray;</span><br><span class="line">@property (nonatomic,strong) NSMutableString   *changeString;</span><br><span class="line">@property (nonatomic,strong) UILabel           *codeLabel;</span><br><span class="line"></span><br><span class="line">-(void)changeCode;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>具体实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;CodeView.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation CodeView</span><br><span class="line"></span><br><span class="line">- (id)initWithFrame:(CGRect)frame</span><br><span class="line">&#123;</span><br><span class="line">    self = [super initWithFrame:frame];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        // Initialization code</span><br><span class="line"></span><br><span class="line">        float red = arc4random() % 100 / 100.0;</span><br><span class="line">        float green = arc4random() % 100 / 100.0;</span><br><span class="line">        float blue = arc4random() % 100 / 100.0;</span><br><span class="line">        UIColor *color = [UIColor colorWithRed:red green:green blue:blue alpha:0.2];</span><br><span class="line">        self.backgroundColor = color;</span><br><span class="line">        [self change];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)changeCode</span><br><span class="line">&#123;</span><br><span class="line">    [self change];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)change</span><br><span class="line">&#123;</span><br><span class="line">    //实际可以从后台请求数据</span><br><span class="line">    NSInteger arcNum = arc4random_uniform(10000);</span><br><span class="line">    self.changeString = [[NSMutableString alloc]initWithString:[NSString stringWithFormat:@&quot;%ld&quot;,arcNum]];</span><br><span class="line">    NSLog(@&quot;%@&quot;,self.changeString);</span><br><span class="line">    [self setNeedsDisplay];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)drawRect:(CGRect)rect</span><br><span class="line">&#123;</span><br><span class="line">    [super drawRect:rect];</span><br><span class="line"></span><br><span class="line">    if (self.changeString.length &gt; 0) &#123;</span><br><span class="line">        float red = arc4random() % 100 / 100.0;</span><br><span class="line">        float green = arc4random() % 100 / 100.0;</span><br><span class="line">        float blue = arc4random() % 100 / 100.0;</span><br><span class="line"></span><br><span class="line">        UIColor *color = [UIColor colorWithRed:red green:green blue:blue alpha:0.5];</span><br><span class="line">        [self setBackgroundColor:color];</span><br><span class="line"></span><br><span class="line">        NSString *text = [NSString stringWithFormat:@&quot;%@&quot;,self.changeString];</span><br><span class="line">        CGSize cSize = [@&quot;S&quot; sizeWithAttributes:@&#123;NSFontAttributeName:[UIFont systemFontOfSize:20]&#125;];</span><br><span class="line">        int width = rect.size.width / text.length - cSize.width;</span><br><span class="line">        int height = rect.size.height - cSize.height;</span><br><span class="line">        CGPoint point;</span><br><span class="line"></span><br><span class="line">        float pX, pY;</span><br><span class="line">        for (int i = 0; i &lt; text.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            pX = arc4random() % width + rect.size.width / text.length * i;</span><br><span class="line">            pY = arc4random() % height;</span><br><span class="line">            point = CGPointMake(pX, pY);</span><br><span class="line">            unichar c = [text characterAtIndex:i];</span><br><span class="line">            NSString *textC = [NSString stringWithFormat:@&quot;%C&quot;, c];</span><br><span class="line">            [textC drawAtPoint:point withAttributes:@&#123;NSFontAttributeName:[UIFont systemFontOfSize:20]&#125;];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line">        CGContextSetLineWidth(context, 1.0);</span><br><span class="line">        for(int cout = 0; cout &lt; 10; cout++)</span><br><span class="line">        &#123;</span><br><span class="line">            red = arc4random() % 100 / 100.0;</span><br><span class="line">            green = arc4random() % 100 / 100.0;</span><br><span class="line">            blue = arc4random() % 100 / 100.0;</span><br><span class="line">            color = [UIColor colorWithRed:red green:green blue:blue alpha:0.2];</span><br><span class="line">            CGContextSetStrokeColorWithColor(context, [color CGColor]);</span><br><span class="line">            pX = arc4random() % (int)rect.size.width;</span><br><span class="line">            pY = arc4random() % (int)rect.size.height;</span><br><span class="line">            CGContextMoveToPoint(context, pX, pY);</span><br><span class="line">            pX = arc4random() % (int)rect.size.width;</span><br><span class="line">            pY = arc4random() % (int)rect.size.height;</span><br><span class="line">            CGContextAddLineToPoint(context, pX, pY);</span><br><span class="line">            CGContextStrokePath(context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//验证码view</span><br><span class="line">self.codeView = [[TGCodeView alloc]init];</span><br><span class="line">UITapGestureRecognizer *codeTapGes = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(codeViewTapEvent)];</span><br><span class="line">[self.codeView addGestureRecognizer:codeTapGes];</span><br><span class="line">self.codeView.frame = CGRectMake(70, 100, 70, 30);</span><br><span class="line">[self.view addSubview:self.codeView];</span><br></pre></td></tr></table></figure></p><p>验证码视图的点击事件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)codeViewTapEvent &#123;</span><br><span class="line">    [self.codeView changeCode];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>喜欢的句子</title>
      <link href="/2018/02/02/%E5%96%9C%E6%AC%A2%E7%9A%84%E5%8F%A5%E5%AD%90/"/>
      <url>/2018/02/02/%E5%96%9C%E6%AC%A2%E7%9A%84%E5%8F%A5%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<center><img src="/assets/imgs/shoucang1.jpg" alt="收藏"></center><br><a id="more"></a><br><br>## 那些很文艺的句子<br>———————-<br><em> 人间烟火，山河远阔。 无一是你，无一不是你。</em> 我已亭亭，无忧亦无惧。<br><em> 永远年轻，永远热泪盈眶，永远在路上。</em> 不乱于心，不困于情，不惧未来，不念过往。<br><em> 生命来来往往，来日并不方长。</em> 生命中的全部偶然，其实都是命中注定。<br><em> 愿你余生遇良人，爱得不慌不忙，坦坦荡荡。</em> 愿你一生纯良，不舍爱与自由。<br>* 天涯太远，一生太长，花期荼迷，也抵不住荏苒时光。<br><center><br>摊开双手<br>我空无一物<br>天空有云<br>舒卷于胸<br></center><center><br>我希望有个如你一般的人<br>如山间清爽的风<br>如古城温暖的光<br>从清晨到夜晚<br>由山野到书房<br>只要最后是你<br></center><h2 id="那些很喜欢的句子"><a href="#那些很喜欢的句子" class="headerlink" title="那些很喜欢的句子"></a>那些很喜欢的句子</h2><hr><ul><li>我们毕生所求，不过是真爱和自由！</li><li>life sucks but you will love it.</li><li>该经历的都经历过，该放下的都放下了，余下的，便是举重若轻，从容淡定。</li><li>生活最厉害的招数是用心，其次就是仪式感</li><li>其实我们每个人都是胆小鬼，有这样那样畏首畏尾的时刻。希望每一个心有想法的人，都能打破舒适圈，去追求不可想象的漂泊生活，勇敢又智慧，自由又有钱。</li><li>我们每个人，都有属于自己的生活方式，我欣赏你生活的浪漫热烈，你也无需质疑我的岁月静好。</li></ul><h2 id="那些应该牢记的道理"><a href="#那些应该牢记的道理" class="headerlink" title="那些应该牢记的道理"></a>那些应该牢记的道理</h2><hr><ul><li>什么都不在乎，就无所畏惧。</li><li>不为其困，方为自在</li><li>没有什么对错，也没有什么谁比谁幸福。幸福这种东西，从来都是只有自己才知道。</li><li>人生苦短三万天，为了面子骗骗别人没关系，别骗自己。</li><li>1.人际交往中的期望值管理能力；2.阈值自控意识；3.应对主观时空扭曲的能力</li><li>死亡并不是生命的终点，遗忘才是。</li><li>有些事情，如果你现在不去做，那么也许你一辈子都没有机会了。</li><li>放纵的灵魂就只配活成一摊松垮臃肿的肉。</li><li>每个人都是困于人世的西西弗斯，也许我们无法逃脱，勇于选择并且终于选择就好。</li><li>美丽是实实在在的。是劳累之后立即洗净的那张脸；是走出厨房之后擦满护肤霜的那双手；是临出门前涂上口红的那瓣唇；是走路时傲然挺起的那片腰身；是面对各种诱惑的那份节制；是人群里永远恰当的那抹微笑；是面对荣辱永远镇定的那副神情……</li><li>最痛苦的事，不是失败，是我本可以。</li><li>不要羡慕别人比你过的好，他们假装的。</li><li>没有真正幸福的人，只有比较想得开的人。</li></ul><h3 id="自身提升"><a href="#自身提升" class="headerlink" title="自身提升"></a>自身提升</h3><ul><li>事不拖，话不多，人不作</li><li>干净的圈子，规律的生活，中意的人</li><li>温柔，持家，自信，睿智，气质，情趣，大度，漂亮，幽默，情调</li><li>不要：抱怨，炫耀，数落，搬弄是非</li><li>美丽包括你全方位的肤质，气色，容貌，身材，体态，甚至包括你说法的语气方式，你的谈吐，见识，又细碎到你的生活习惯。</li><li>自律即自由。</li><li>自律一段时间被打回原形，你忽略了重要的一点：自身非常强烈想要实现一个目标，并把一系列有些挑战性的行动固化成自然的习惯。</li><li>今天不想跑，所以才去跑。这才是长距离跑者的思维方式。</li><li>人的堕落是从身体开始的，好好锻炼吧。你的身材里藏着你的自律。</li><li>要变成那个存在于你渴望里的身材窈窕、文艺洒脱、生活精致美好的你。</li><li><p>保持理智的最佳方法就是彻底掌握悲观主义，愤怒和失望就是源于乐观主义的预期。</p></li><li><p>1.早睡早起身体好</p></li><li>2.微笑是一种思维</li><li>3.管住嘴是一种本事</li><li>4.做一个清清爽爽的人</li><li>5.给自己找一个能常年坚持的运动项目</li><li>6.尽量出去走走看看</li></ul><h3 id="沟通注意："><a href="#沟通注意：" class="headerlink" title="沟通注意："></a>沟通注意：</h3><ul><li>听别人把话说完</li><li>否定之前，先给出肯定</li><li>任何评价都要对事不对人，并给出具体的解释</li></ul><center><img src="/assets/20180202_shoucang/shoucang.jpeg" alt="收藏"></center><h2 id="丧、丧、丧"><a href="#丧、丧、丧" class="headerlink" title="丧、丧、丧"></a>丧、丧、丧</h2><hr><ul><li>这个世界疯狂，没人性，腐败。你却一直清醒，温柔，一尘不染。</li><li>当你什么都不再期待，不再奢望的时候，或许一切都会如期而至。</li><li>多一些不需要理由的开心。</li><li>日子熬我，我熬粥（日子熬人，随便活吧）。</li><li>我们都是熬不过世俗的普通人。</li><li>委屈受多了，给我再多糖也会扔。</li><li>别在最好的年龄，辜负了最好的自己。</li><li>一直都在辜负生活，所以生活也不曾善待我们</li><li>在最难过的那天夜里，我是一个人过的</li><li>究竟什么样的终点，才配得上这一路颠沛流离</li><li>要长大 要乖 要努力 要不负众望</li><li>喜欢有阳光的早上 好像什么都可以重新开始</li><li>你说的很对，不过我不听。</li><li>好坏都收下，然后一声不响继续生活。</li><li>人生本来就没有相欠，情出自愿，事过无悔。</li><li>推开自己喜欢的东西是成长。</li><li>现在的生活，并不是我想要的，但确实是我自找的，所以活该也认了。</li><li>不后悔遇见了谁，只是后悔，为何成了现在的模样。</li><li>不想说这个世界什么坏话了，都是我不好</li><li>如果每个人都是一颗小星球，逝去的亲友就是身边的暗物质。我愿能再见你，我知我再见不到你。但你的引力仍在。我感激我们的光锥曾彼此重叠，而你永远改变了我的星轨。纵使再不能相见，你仍是我所在的星系未曾分崩离析的原因，是我宇宙之网的永恒组成。</li><li>有缘无份的时候好聚好散是最好的尊重。</li><li>从不认识到不认识，这就是我们之间所有的故事。</li></ul><h2 id="鸡汤-amp-毒鸡汤"><a href="#鸡汤-amp-毒鸡汤" class="headerlink" title="鸡汤&amp;毒鸡汤"></a>鸡汤&amp;毒鸡汤</h2><hr><ul><li>爱情是有浓度的。</li><li>始于颜值，陷于才华，忠于人品。</li><li>先要彼此都有爱，彼此欣赏和尊重；彼此的世界观、三观不能相差太远，能聊得来、在某个领域能玩到一块；然后是彼此都能有一定的自制力，内心坚定了彼此，能拒绝外来异性诱惑；最后是共同经营，共同进步，不急不躁，在平淡的生活里能偶尔用心为对方制造惊喜和浪漫，在彼此的生活里都留下难以磨灭的深刻回忆。</li><li>如果有幸遇到能凑合忍得了的人，就用尽全力抓紧，无论如何都不要放手。</li><li>幸福就是找个温暖的人过一辈子。</li><li>爱一个人最好的方式，是经营好自己，给对方一个优质的爱人。不是拼命对一个人好，那人就会拼命爱你。俗世的爱情难免有现实的一面：你有价值，你的付出才有人重视。</li><li>我很清楚的知道，这条路走下去会很艰难，但不走好像又会后悔一辈子。</li><li>你看世人多奇怪。喜欢的人得不到，得到了不珍惜，在一起时怀疑，失去了怀念，怀念的想相见，相见的又恨晚。终其一生，满是遗憾。</li><li>荷尔蒙只负责一见钟情，柏拉图负责白头到老。</li></ul><center><br>最好的爱情就是<br>两个人都是独立的个体<br>都可以不用掩饰的做自己<br>都有自己的追求和梦想<br>但是在我们独自打拼的时光里<br>都会把彼此放在心上<br>都会知道我们的每一份努力都是为了<br>两个人的支流最终能汇聚成爱情的长河<br>往时光的尽头永无止境的流淌<br></center><center><br>一生只谈一次恋爱是最好的<br>经历的太多了，会麻木<br>分离的多了，会习惯<br>换恋人多了，会比较<br>到最后，你不会再相信爱情<br>其实对于爱情，越单纯越幸福<br></center><ul><li>时间真的是这个世界上最好的跨度，让惨痛变得苍白，让执着的人选择离开，然后经历沧桑，人来人往；你会明白，万般皆是命，半点不由人。</li><li>爱的时候不辜负人，玩的时候不辜负风景，睡觉时不辜负床，一个人时不辜负自己。</li><li>你来人间一趟，不是来刷任务的，你该好好享受阳光、雨露和爱。</li><li>生活是场清醒的梦，梦到醒不来的梦。</li><li>偏要在这薄情的世界，深情地活。</li><li>就这一生，可以快乐就别难过。</li><li>希望日子，和我都不难过，干净脱俗温柔上进。</li><li>一生只需一人，知我冷暖懂我悲欢。</li><li>梦里出现的人，醒来时就该去见他。The people in your dreams,you should call them when you’re awake.</li><li>只有不曾被爱过的人，才知道爱的珍贵。</li><li>幸福其实很简单：有人爱，有事做，有期待。</li><li>自爱，沉稳，而后爱人。</li><li>其实你的孤独，就是你内心的黑暗。</li><li>他们都说，爱一个人是劫，有人劫后余生，有人在劫难逃。</li><li>尽人事，听天命。情出自愿，事过无悔。</li><li>这么多年，你一个人在走，走过了人性的背后和白云苍狗。</li><li>承担该承担的，面对该面对的。相信自己，接纳自己，并好好爱自己。</li><li>终会有人把你捧在心尖上，喜欢你喜欢的像个傻子，终会有人保护好你的少女心，让你再次相信爱情。</li><li>无论你遇到谁，都是你生命中该遇到的人。</li><li>愿有人懂你低头不语，知你心酸委屈。</li><li>哪有什么坚强，全靠死撑。</li><li>如果你都没有努力去争取就说你得不到，你遗憾吗，难道不会觉得可惜吗，要么一生，要么陌生。</li><li>凭什么说一个爱你入骨的姑娘不懂事，又凭什么说一个爱你到卑微的男孩不成熟，都各有各的故事。</li><li>原来所有的煎熬和孤独都成了我走向你的路。</li><li>那时候天总是很蓝，日子总是过得很慢。</li><li>面朝大海春暖花开时海子的选择，人不是生来被打败的是海明威的选择。</li><li>人生有六个字，前面三个是不害怕，后面三个是不后悔。</li><li>熬过这段灰暗的时光，希望一切都可以苦尽甘来。</li><li>日益努力，而后风生水起。众生皆苦，你也不能认输啊。</li><li>书要好好读，喜欢的人要好好争取。</li><li>如果有人陪你一起疯，是不是就不怕江湖路远了。</li><li>成长就是：渐渐温柔，克制，朴素，不怨不问不记，安静中渐渐体会生命的盛大。</li><li>你不喜欢这个世界，不喜欢你的生活，其实就是不喜欢现在的你，一切自爱必会带来热爱生活，一切厌恶追根溯源必是自我厌倦。</li><li>别说什么来日方长，这世上回首之间的都是人走茶凉。</li><li>我不想说，却又想说些什么，我要怎么说，该说些什么。。。</li><li>前路漫漫，当克己，当慎独。</li><li>你之所以觉得时间一年比一年过得快，是因为时间对你一年比一年重要。</li><li>能治愈你的从来都不是时间，是明白。</li><li>心里有很多苦的人，要多少甜才填的满。心里有很多苦的人，只要一点点甜就能填满。</li><li>要努力呀，为了想要的生活，为了人间的烟火气，为了今天的风和月。</li><li>晚点遇见吧，你刚好成熟，我刚好温柔。</li><li>如果做不到对别人狠，那就对自己狠一点。</li><li>在自己心智还没完全成熟稳重时候，我愿意拒绝所有的暧昧和放下想爱的人。</li><li>我所理解的生活，就是和自己喜欢的一切在一起。</li><li>不辜负时间的馈赠，努力活成自己喜欢的模样。</li><li>要酷，要优秀，要成为别人的可望不可及。</li><li>少吃真的会瘦，瘦了真的好看，好看真的有用。</li><li>狠人的三大表现：说减肥就减肥，说不玩手机就不玩手机，说睡觉就睡觉。</li><li>懂得自制，方能掌控人生。也许阻碍你变好的敌人，自始至终，就只是懒惰的自己而已。</li><li>自律，生长，爱美食，也爱其他。</li><li>世界上最遥远的距离不是远方，而是你不敢迈出去的那一步</li><li>精神状态的好，完完全全体现在肉体上。</li><li>谈恋爱时，作死的程度不要超过漂亮的程度，人际交往中，耿直的程度不要超过能力的限度</li><li>遇见强势的人要示弱，遇见自卑的人要尊重，遇见有趣的人要勾搭</li><li>爱没有别的愿望，只要成全自己。</li><li>多少有些遗憾提起来满是心酸，不说又怕自己会忘记。好像有的往事，久了，也只是故事了。</li><li>有时候有些人有些事，我们除了说再见，别无选择。</li><li>最近日子和我都有些难过，什么都不说就好。</li><li>喜欢一个人事藏不住的，就想日出日落，海涨潮退。</li><li>人生最了不起的四种心境：痛而不言，笑而不语，迷而不失，惊而不乱。</li><li>愿你以梦为马，不负韶华，愿你拼尽全力，无畏前行。</li><li>胖，其实是你的不思进取，不努力，不作为，得过且过的直观表现。</li><li>知足且上进，温柔而坚定。</li><li>无论怎样，路是自己走的，抬起头，不能怂。</li><li>做人要懂事有趣，保持理智。</li><li>一定要自己做决定啊，就算是后悔也要自己来。</li><li>要替自己着想，但为自己而活。</li><li>遇见你不容易，错过了会很可惜。</li><li>其实道理谁都懂，只是有时候选择自欺欺人。</li><li>在寻找真爱的路上匍匐前进，不管南北东西，直觉会给我们指引。</li><li>所有人都在努力，并不是只有你，满腹委屈。</li><li>我得收拾自己的烂摊子。</li><li>好好生活，别总跟自己过不去。</li><li>可不可以跟世界请个假，我想暂时离开下。&amp; 我心情不好，想死两天。（I feel bad and wanna die for about two days.）</li><li>世间什么最难得？徒手摘星，爱而不得，世人万千，再难遇我。</li><li>我有一壶酒，足以慰风尘。</li><li>你会遇到很多让你心动的人，却再难遇到一个让你心安的人。</li><li>我不喜欢我自己，这种感觉真的糟糕透了。</li><li>看不懂就不要妄自揣测别人的无心，你注定辛苦。</li><li>跟生活玩，别太认真了，反正最终没谁能活着离开这场游戏。</li><li>凡事都有它自己的节奏，他们有他们的节奏，你有你自己的，耐心一点。</li><li>当生活不会再有什么惊喜和感动，你会发现，孤独其实是最大的自由。</li><li>如果最后是你，晚点真的没关系。</li><li>你总会遇到一个人恰如其分的适合你，不用刻意迁就，可以任性撒娇，想爱并且默契，所以你要等。</li><li>我希望有人读懂你的难过，明白你焦虑背后的所有小心翼翼，我希望有人把你捧在手心里，渴望慰藉你所有孤独的情绪，你不要对自己失望迷茫，你再等等。</li><li>成熟的人，都有一种默契，你不联系我，我也不联系你，自制能力超级好，内心折磨到死也不妥协。</li><li>去经历，然后去后悔。去做你想做的，去选你爱的，而不是别人眼里正确的，你的一辈子应该为自己而活。</li><li>我们明明离得那么近，可却又那么远。</li><li>以后跟我过余生的那个人请听好，我可以跟你受十分的苦，但是，请不要让我受半分的委屈。</li><li>这一瞬间，像被全世界抛弃了。</li><li>总是这样，很难过又很难说……</li><li>原来顺其自然 是因为无能为力</li><li>在最黑暗的那段人生，是我自己把自己拉出深渊。没有那个人，我就做那个人。</li><li>我知道这个世界什么都善变，可是说真的，眼前这个人，他让我相信永远。</li><li>一个人的生活，没牵挂，没感动，没惊喜，也没失望。</li><li>所谓节日，就是让快乐的人更快乐，孤单的人更孤单的日子。</li><li>我现在，除了别人觉得不好，再没什么不好。</li><li>难熬的日子里，什么也没说，所以以后，也不必说。</li><li>生活真是糟透了，烂透了，没得救。</li><li>要总结任何一个人一生的经历，你并不需要太多的字，有人已经用十二个字概括了：他生了下来，他受了苦，他死了。如何在短暂的一生，幸福而充实地活着，是我们都在追寻的答案。</li><li>大多数人的生活，就是一种水滴石穿的单调和宁静。</li><li>好多事情我真的接受不了，但我也无力抗拒。这辈子从来就没坚强过，大小坎都是死撑。</li><li>这个世界已经有很多人和事让你失望了，而最不应该的就是自己还令自己失望。</li><li>万般皆苦，只能自渡。</li><li>凡事开心就好，反正我们谁也别想活着离开这世界。</li><li>爱的时候不辜负人，玩的时候不辜负风景，睡觉时不辜负床，一个人时不辜负自己。</li><li>人没活明白的第一个特征就是喜欢骗自己。</li><li>除非互相喜欢，否则所有的喜欢，全都是心酸。</li><li>生活有一点我不是太喜欢，就是…它总让更懂事的人来承担糟糕的感受和结果。</li><li>接受分道扬镳，接受世事无常，接受孤独挫折，接受突如其来的无力感，接受自己的缺点，然后发自内心地去改变，找到一个平衡点，跟世界相处，首先是和自己相处，天黑开盏灯，落雨拿把伞，难过先难过，但也不作死，天亮以后，满血复活。<!--* 我未来的那个他呀，一定不爱我吧，不然怎么让我承受着这漫长的煎熬和等待......你欠我的深情，打算什么时候还--></li><li>冬渐去，春已近，愿心中无霾，轻扬眉，颔首笑</li><li>抓不住的东西，伸手都是错的</li><li>听说风吹过经幡一次，就是诵经一遍。</li><li>当你心中满是荒凉，人间便似绝望刑场。</li><li>一开始我以为人是慢慢长大的，后来才发现人都是突然间长大的</li><li>关于等待的故事总是让人很动容，可它能感动到的，也不过是读者和主人公自己。</li><li>但愿在这个拼的你死我活的世界里，我能有一份不用努力的，刚刚好的爱情。</li><li>那是种没人读懂的倔强，骨子里是铮铮的傲……</li><li>每一次跑步的背后都是苦行僧一样的坚持，过去觉得人生苦短应该及时行乐，今朝有酒今朝醉，人不风流枉少年，但是随着时间的推移，慢慢明白每一次不自律行为的背后只会给你带来更大的伤害，所谓的自由不是说你能为所欲为，而是自律之后你知道有所为有所不为。<!--* 我还是这个不成器的样子，没有给他们什么，反而成为他们最放心不下的牵挂。--></li><li>真不想乖乖的和这个世界握手言和呢</li><li>总不能还没努力就向生活妥协吧</li><li>你真的得碰到那个你能降得住又能降得住你的人，才算合适，彼此爱慕又互相嫌弃，要不然这一辈子，该是多么无趣又无欲。</li><li>我们最终都要远行，最终都要与稚嫩的自己告别，告别是通向成长的苦行之路。</li><li>长大后才发现，生活还是需要一点演技。</li><li>难过怎能讲的清楚，失落怎能感同身受。</li><li>我会记住生命中不期而遇的温暖，我也记得大雨滂沱没有伞的日子。</li><li>若干年后，你也经历了一些人事，也有了一些只能在失眠的夜里独自咀嚼的故事。你青涩褪尽，渐渐懂了生之可忧死之可怖。你终于也明白并且心平气和的接受了他不过是个平凡的人，与其他甲乙丙丁并没有什么本质的不同。可是 说不清楚为什么，你还是有所眷恋，像是一种迷信，庙宇塌毁了，神还是神。</li><li>成年人的世界 就是应该果断又干脆 不耽误任何人 不消耗任何人 不浪费任何人 这是一种善良</li><li>他若喜欢你，你脾气再大都叫个性，他若不喜欢你，就算你温顺的像只猫，他都嫌你掉毛。</li><li>总要有些随风，有些入梦，有些长留在心中。</li><li>愿你一生温暖纯良，不舍爱与自由。</li><li>记住了 自己喜欢的东西 就不要问别人好不好看 喜欢胜过所有道理 原则抵不过我乐意</li><li>你要学着无论遇到什么事情 欣喜 悲伤或是濒临崩溃 都能够不动声色自己处理事情 自己辨别对错 好好成长</li><li>我们终其一生的努力 真正能够把握的也不过是自己的喜怒哀乐</li><li>人生最重要的时刻就是你突然发现自己是错的那一刻，是你转变观念的那一刻。人的意识太深了，为了维护自己的意识人类可以做出很多可怕的事情，如果你能从根本发现自己原来没有那么对，整个人生进程都会有质的改变。——李诞</li><li>人生来最爱什么？自由和自我。违背人类本性的关系都很难快乐，也很难持久。<!--* 2019是给幸福的人过的，幸福的人会更加幸福，悲惨的人只会更加悲惨。--><!--* 北京的一天太短了，短到还没开始就结束了。--><!--* 你真的缺席了太多我需要你的时刻--><!--* 西藏是一种病，没来想尝试，来了无药可治--></li><li>很多事 我能想通 也能接受 但我很难受</li><li>我根本无法在这世间任何人身上得到所谓的情感来慰藉心灵，我全部的爱 皆来自于我的臆想</li><li>这个世界 看你笑话的人 永远比在乎你的多 </li><li>笑给你讨厌的人看 要多嚣张有多嚣张</li><li>习惯了 是个很强大的词 可以代替所有的一言难尽</li><li>放弃不难 但坚持很酷 你的负担将变成礼物 你受的苦将照亮你的路</li><li>想结婚就去结婚，想单身的就继续单身 反正到最后也一样会后悔的 何必在意</li><li>一万小时定律：人们眼中的天才之所以卓越非凡，并非天资超人一等，而是付出了持续不断的努力。一万小时的锤炼是任何人从平凡变成超凡的必要条件。</li><li>精于审美的人，往往有独立的人格——她能看轻一般人所看重的，也能看重一般人所看轻的。</li><li>嫉妒是一种变相的赞美 嫉妒也是一种变相的自卑</li><li>不是不能吃苦，不是不能放下一切，可总是要有那么个值得的人。</li><li>愿你三冬暖，愿你春不寒，愿你天黑有灯，下雨有伞，愿你一路上，有良人相伴。愿你所有快乐，无需假装。愿你此生尽兴，赤诚善良。愿时光能缓，愿故人不散；愿有人陪你颠沛流离，愿你惦念的人能和你道早安，愿你独闯的日子里不觉得孤单。愿你人间走一遭，圆满了三界六道，看透了是非善恶；从此福来心至，皆是逍遥。</li><li>很多事介于不说委屈说了矫情之间。</li><li>不如就利用孤单一人的时间，使自己变得更优秀，如刀劈斧凿一样雕刻自己，给别人一个惊喜，也给自己一个好的交代。</li><li>阿德勒手帐中写道：幸福婚姻是这样的：你是我见过最好的人，你是最契合我的人，你是我眼里最优秀的人，你是我的灵魂伴侣，你是能给我保护的人，你是我的知心朋友，你是能分享我一切的人。  我们共同成长、相互照应，在最无助和软弱时候，你能托起我的下巴，扳指我的脊梁，令我坚强，并陪伴我左右，共同承受命运。  我们之间除了爱，还有肝胆相照的义气，不离不弃的默契，共同孕育的成长，以及铭心刻骨的恩情。</li><li>每个人都以为自己所做的是对的，但每个人却不知道，自己也可能做着一件错事，错到需要别人的原谅。</li><li>许多年里，我们原谅一个人，或是宽容一个人，不是与别人和解，而是与自己的一场和解。</li><li>我很难过 怎么翻译？ I’m fine.</li><li>所有渴望别人理解的行为都是弱者的行为，人的强大，第一步要学会孤独，第二步要学会不理解，第三步就是用结果去碾压。</li><li>镜花水月，终是虚幻，你羡慕我的恬淡，我好奇你的纷扰。</li><li>专情，孤傲，只暖喜欢的人，只把感情用在对的人身上。</li><li>人性这种东西，不可言，不可研，不可验。</li><li>喜欢有什么用，你连我今天高兴还是难过都不知道。</li><li>勇敢的接纳爱，承担责任，却不在爱与责任终沉迷。</li><li>有些事不去经历永远都觉得是美好的，走进去了才发现，你以为的美好不过是隔着一层纱。（但我还是希望由我自己去揭开那层纱）</li><li>女孩子就是要狠狠美一回，再狠狠失望一回，才能转身扑通一个猛子，扎进生活。</li><li>你快乐过生活，我拼命去生存。</li><li>喜欢就争取，得到就珍惜，错过就忘记。</li><li>做一个寡言的人，却心里有一片海的人，不伤人伤己，于淡泊中，平和自在</li><li>留住一个人的从来不是卑微，而是活得出色和独立。</li><li>连哭都怕失礼</li><li><p>最惬意的幸福是在柴米油盐酱醋茶下也能安然自得，也能浪漫随心，也能充盈生活，也能陪伴如初</p></li><li><p>人生的路，有时候走着走着才开阔起来的</p></li><li>你要做一个不动声色的大人，自己去过另外的生活，不是所有的鱼，都生活在同一片海里。</li><li>我不希望这场旅行太过于轻松和容易，我觉得经历苦难和遭遇挫折坎坷，是人生一大财富，无人能懂，也无需人懂，做自己就好。</li><li>当我们不能改变的时候，唯有改变自己，所有的不快乐来自于自己的欲望</li><li>如果你不喜欢某件事，就改变它，如果你不能改变它，就改变你的态度，不要抱怨</li><li>以前我特别喜欢下雪天，因为可以打雪仗，但现在我很怕下雪，因为我怕上班迟到，是我变了，还是雪不一样了</li><li>以年轻的名义，奢侈地干几桩坏事，然后在三十岁之前及时回头、改正，从此褪下幼稚的外衣，将智慧带走 然后，要做一个合格的人，开始担负，开始顽强地爱着生活——张爱玲</li><li>这座城市叫北京，挤不完的地铁，吃不完的外卖，还有交不完的房租和熬不完的夜。</li><li>抛硬币，并不是因为它总能给出对的答案，而是在你把它抛在空中的那一秒里，你自己心里就会告诉你真正想选的是什么</li><li>任何关系，只要你想淡，我绝对成全。</li><li>如果每件事情都自愿的，那么事情就简单多了</li><li>这世界上没有人可以伤害你，除非你同意</li><li>生活的最佳状态 是冷冷清清得风风火火。</li><li>所有的旅行，见天地，见众生，不过是为了见自己</li><li>人们去远方只是为了紧紧地搂住自己 我只喜欢在笛声中闻着野草的清香</li><li>大自然本就充满细节，是人类自己选择忽略</li><li>风能吹起一张白纸，却无法吹走一只蝴蝶，因为生命的力量在于不顺从</li><li>人生总要勇敢一次，去做你真正想做的事</li><li>在喜怒哀乐间走走停停，不知道在下一秒会遇见谁，会发生什么，只知道，阳光这么好，不要辜负了今天</li><li>去做你想做的事，趁阳光正好，微风不燥，你还未老</li></ul><ul><li>睡前原谅一切，醒后不问过往</li><li>很多时候我们不幸福，就是对外界寄予太多的渴望，一旦落空，就会剩下满满的失落。</li><li>在这个城市中行走，总要带着一丝二百五的脾气，加上阿Q的自我精神战胜法，才能活得好、活得快乐，这世界从不缺怨妇，也不缺灰色，缺的是女神外表、爷们儿心的女人，你不努力，谁也给不了你想要的生活</li><li>Do what you love,not what you think you’re supposed to do.</li><li>当你思考什么是对什么是错，你就注定得不到你想要的结果</li><li>我原谅所有，I forgive all。</li><li>此去经年，天涯路远。</li><li>不是假装沉默，只是无力诉说</li><li>没有一个冬天不可逾越，没有一个春天不会来临</li><li>我抓不住这世间的美好 只能装作万事顺遂的模样</li><li>因为无能为力 所以顺其自然</li><li>没人会记得你的苦，你要活得宽阔一些。</li><li>希望来生，我没有梦想。</li><li>不用掩饰生命的狼狈，因为这是真实的。</li><li>酷的像风野的像狗，不招人爱倒也自由</li><li>这世界是块冰，就让它是块冰。</li><li>心若静，风奈何。</li><li>就好像是，人这一辈子，总有得不到的东西。</li><li>每个人眼中更好的自己并不只有一种可能。不是这杯美式不好喝，只是它并不适合我。</li><li>岁月不饶人，我亦未曾饶过岁月。</li><li>执着于快乐，便不快乐</li><li>三公里专治各种不爽，五公里专治各种内伤，十公里跑完百毒不侵，满是坦然。</li><li>音乐只是给人一种美好，而现实总是让人唏嘘。</li><li>生活和电影不一样，生活难多了。</li><li>一个人出来会遇到一群人，一群人也会感染一个人</li><li>恋爱是一种选择，独身也是</li><li>熬夜，是因为没有勇气结束这一天 赖床，是因为没有激情开始这一天 好好睡一觉 把心里的垃圾倒一倒</li><li>孤独是给你思考自己的时间，在一个人的日子里，你要做的只有一件事，把自己变得更优秀。</li><li>荷尔蒙决定一见钟情，多巴胺决定天长地久，肾上腺决定出不出手，自尊心决定谁先开口，最后寿命和现实，决定谁先离开谁先走。</li><li>人一旦习惯了孤独，才是比悲伤更悲伤的事</li><li>上天借由各种途径使人变得孤独，好让我们可以走向自己。</li><li>爱情和陪伴是小孩子的，面包和生活才是成年人的。</li><li>不管你承不承认，人确实是经历了一些事以后，就悄悄换了一种性格。</li><li>时间并不会帮我们解决什么问题，它只是把原来怎么也想不通的问题，变得不再重要了。</li><li>有人说，当你不再对某个东西或某件事过分期待的时候，也许它就来了像个惊喜一样</li><li>改变，永远都不会太晚</li><li>人生中无数错过就是错过，从来都只有今生、此时、此刻。</li><li>将就不止存在于婚姻，还存在于单身，因为你没得选择。</li><li>植根于内心的修养；无需提醒的自觉；以约束为前提的自由；为别人着想的善良。</li><li>每个人都有自己的生活方式，这是一种选择，无可厚非。</li><li>在别人的故事里，到最后都会有一个超级英雄来终结一切拯救世界，而我们的世界里，只有自己能拯救自己。</li><li>遗憾的不是红绿灯，是那些数不清的犹豫。</li><li>既然都是凡夫俗子，就要好好沉溺于生活。你总得把断浆划起来。</li><li>其实这世上本没有什么启程，都是过程。时间把一切串起，不可分割。</li><li>喜欢旅行不是因为有钱，而是不想老了以后后悔。风景确实会一直都在，但那颗年少轻狂的心终会消失</li><li>人最大的痛苦，来自无法接受命运的无常，以及生而为人的脆弱。</li><li>你要不顾一切，让自己变得优秀，即使是在那些糟糕的日子里。</li><li>人活这一辈子，最好的状态就是，轻装上阵，去感受这个世界的美好。</li><li>此身不向今生渡，更待何生渡此生</li><li>承受越多明白越多</li><li>无论你正经历着什么，过得是否开心，世界不会因为你的疲惫，而停下它的脚步，那些你不能释怀的人和事，总有一天会在你念念不忘之时早已遗忘，无论黑夜多么漫长不堪，黎明始终会如期而至，能力配不上野心是所有烦恼的根源，这个世界是公平的，你想要得到就得学会付出和坚持，每个人都可以通过自己的努力，去决定生活的样子。</li><li>最喜欢书后记里的一句话：一个人改变自己内心的最佳捷径是什么？改变自己的外在。</li><li>“跑超级马拉松不可能对你有什么好处，我想不出那种运动怎么会对身体有好处。”“对身体有好处？不，的确对身体没好处。可就算是你受伤了，也能痊愈。就算累着了，也能休息回来。关键是，当你跑完了50千米或者是160千米，当你跑过终点线的一刹那，你就不再是起跑线上的那个你了。”</li><li>不自律会满满摧毁一个人的心智、外貌、甚至是人生。自律，是解决人生问题的首要工具，也是消除人生痛苦的重要手段。</li><li>赤裸裸的想赢，不掩饰自己做强者的野心，是一件很酷的事。落入平庸，是从丢失胜负欲开始的。</li><li>“自己”这个东西是看不见的，撞上一些别的什么，反弹回来，才会看见”自己”。所以，去和更强大、更广阔的食物对撞，在一次次的对撞中，你才能验证自己的内心。最终，你的行动会告诉你，你是谁，你真正想要做的事情是什么。</li><li>人一切的痛苦，本质上都是对自己无能的愤怒。而自律，恰恰是解决人生痛苦的根本途径。</li><li>人一旦开始发现自己变得更好了，就会变得更加贪心，还想要变得更好。变好不应该有上限，这才是一个人趋于完美的最佳动力源泉。</li><li>实现自律的三大秘诀：1.学会给目标清单减负 2.学会对目标进行量化 3.学会张弛有度</li><li>真正废掉一个人的是安于现状的心。</li><li>人生苦短，余生很贵，不要做一个令人喜欢的人，而做一个自己喜欢的人。</li><li>独行，是一种唯美的力量，它能让你获得真正的自由，相信我，排除万难也要走进孤独，终将不负此生。</li><li>这个世界，看似周遭嘈杂，各色人等，本质上，还是你一个人的世界，你若澄澈，世界就干净，你若简单，世界就并不复杂。</li><li>人年轻的标志，就是不论在什么年纪，依旧葆有对这个世界的好奇之心。</li><li>饮食、男女、懒惰、推脱责任，是本能，是低级别的人性，是娘胎里带的，基因里有的。勤奋、自律、担当，是能力，是高级别的人性，是后天学习和训练出来的。人分三六九等，贤愚有别，不是别人给分的，都是自己求来的。生而为人，为什么只躺在低级别的人性上。</li><li>你不必逞强，不必说谎，懂你的人自然知道你原来的模样，不要像猫一样在风雨中长大，遇到点爱就以为是家。一定要加倍努力，等到遇到对的人，才不会显得狼狈不堪毫无准备。世界不曾偏爱一个不劳而获的人，也不会辜负一个努力的人。打磨自己的过程很疼，到最终能塑造一个更好的自己。</li><li>梦中一世忆，尽惘然…</li><li><p>气质在肩，年龄在背，活力在腹，性感在臀，自信在腿，健康在颈椎。追求在个人，女人这一生，唯有美，不可妥协，唯有自己，不可辜负，因为全世界，你最珍贵。</p></li><li><p>但也还是无法讨厌上海，尽管这个又冷又湿的冬天那么准确的描绘了我和身边的朋友们正在经历的这一段人生，很难，甚至有些丑陋，每一滴雨都真实可感，所有问题都是散布在裤腿上的泥渍，等我们用一把细毛刷，一点一点刷掉。</p></li><li><p>酒足饭饱，你再身边，这就是我能想到的美好生活。我身边有个姑娘结婚之后，就把微信个人签名改成了：”终于不再需要食物给我安全感。”当时看得我还挺感动，然后顺手又往嘴里塞了块曲奇饼干，特别喜欢吃东西，很多时候是因为觉得无聊。</p></li><li><p>你看这字里行间，年复一年，春光不必趁早，冬霜不会迟到，相聚别离，都是刚刚好。 ​​​​</p></li><li>自律是一个人最美的修行</li><li>余生无畏，只像自由妥协</li><li>放自己一马，哪怕只有今天<br>What makes me really happy?</li><li>旅行是一场豪赌，赌前路美好，赌如你所料。但生活哪有剧本给你挑，那些不期而会的遇到，才是无招胜有招。</li><li>天赐食于鸟，但绝不投食于巢。</li><li>无缘某个人，错失某件事，本是人生常态，无需太多纠缠。</li><li>不是这个世界对你要求越来越高，是你对自己要求不够高。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">突然有一天，他不联系你了。</span><br><span class="line">为什么不承认，他没你想象中那么爱你呢，或者，你刚好赶上了他一段时间空档，你也有一时兴起去吃个炭火烤肉的时候，那鸡胸，那小排，那雪花肉，火上走一遭，滋滋冒油，香气扑鼻而来，你没必要一次就吃撑，辜负了肉也辜负了胃，留个念想不好吗？你年轻轻轻早该懂，爱恨和吃饱，都要有分寸。</span><br><span class="line">你是灵魂有肉香的女子，他是尘世吃素的修行人，各有各的路，干嘛非要挤在一个独木桥上渡劫呢。别拿暧昧当爱情来处，谁的爱情也不能一直藏在你来我往的试探里，你进一步，他退一步，多明显，承认他不爱你，你才有机会去碰见真爱。</span><br><span class="line">仔细想想，你也没有一生，可以慷慨的送给别人。</span><br><span class="line">没在一起就没在一起吧，反正时间很长，它会把另外一个人推进你的世界，你会尝试接受新的选择，你最爱吃的章鱼小丸子没有了，多往前走几步吧，仍有糖炒栗子、榴莲酥、糖葫芦、烤地瓜，我知道你空着肚子留给小丸子，但是，以后的路还要走，总要填饱肚子。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">一个姑娘强大的标志是什么？</span><br><span class="line">有脾气，但不乱发脾气。</span><br><span class="line">有情绪，但不情绪化工作。</span><br><span class="line">会聆听，不反驳别人的过错。</span><br><span class="line">会管理时间，不浪费在无效社交聚会上。</span><br><span class="line">会妥协，但懂得为人处事之道，不露锋芒。</span><br><span class="line">会挣钱，会花钱，也会扔东西。</span><br><span class="line">有情趣爱好，也有专业能力爱好。</span><br><span class="line">不拖延，不熬夜，不抱怨。</span><br><span class="line">会享受孤独，但也不拒绝婚姻。</span><br><span class="line">有一大堆的标志，预示这个姑娘，独立、自由、成熟，但这一切，可以归结为3个字：会生活。</span><br><span class="line">用自己喜欢的方式，过一生。</span><br><span class="line">结不结婚，只是选择生活方式的一种，目的都是选择一种让自己舒服活着的方式，千金难买人家乐意，可是，结婚的鄙视没结婚的说人家是剩女，单身的笑话女的结了婚公主变保姆，这就过分了，没有谁，有资格指责和指导别人的人生，嘴碎，是一种病，被人家扇几耳光就好了。</span><br><span class="line">结不结婚，两种生活，没有对错，各有各的福，互相尊重对方的选择，就好了。</span><br><span class="line">希望你新的一年像毛血一样旺，敢于手撕包菜、干煸菜花、剁椒鱼头，活的蒸汽腾腾不好惹。</span><br><span class="line">希望有人疼你像糖醋入排骨，有人宠你像鸡翅百事可乐，有人陪你哭诉脆皮肠，就算生活时常很苦偶尔很甜，也要活的酸爽麻辣。</span><br><span class="line">希望你好好吃饭，好好恋爱，好好工作，好好学习，天天向上。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> list </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>各种学习资源</title>
      <link href="/2018/02/02/%E5%90%84%E7%A7%8D%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/"/>
      <url>/2018/02/02/%E5%90%84%E7%A7%8D%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<h2 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h2><ul><li>github</li><li>code4app<a id="more"></a></li><li>cocoachina</li><li>简书</li><li>CSDN</li></ul><h2 id="牛人技术博客"><a href="#牛人技术博客" class="headerlink" title="牛人技术博客"></a>牛人技术博客</h2><ul><li>MJ</li><li>YY</li><li><a href="http://southpeak.github.io" target="_blank" rel="noopener">南峰子</a></li><li>唐巧</li><li><a href="https://onevcat.com" target="_blank" rel="noopener">王巍</a></li><li>阮一峰</li><li>东方耀：react native，python</li></ul><h2 id="自学平台"><a href="#自学平台" class="headerlink" title="自学平台"></a>自学平台</h2><ul><li>慕课网</li><li>网易云课堂</li><li>扣丁</li><li>麦子学院</li><li>极客学院</li><li>菜鸟教程</li><li>W3CSchool</li><li>51cto</li><li>脚本之家</li></ul><h2 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h2><ul><li>Leetcode</li><li>Lintcode</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资源 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS显示图片原色</title>
      <link href="/2018/01/31/iOS%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E5%8E%9F%E8%89%B2/"/>
      <url>/2018/01/31/iOS%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E5%8E%9F%E8%89%B2/</url>
      
        <content type="html"><![CDATA[<ul><li>在设置导航栏的右图标时，可能会被系统设置为默认蓝等其他颜色，而不是图片本身的颜色。想要显示原来图片颜色使用以下：<a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIImage *image = [[UIImage imageNamed:@”arrow”]imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal];</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>iOS实现导航栏渐变</title>
      <link href="/2018/01/15/iOS%E5%AE%9E%E7%8E%B0%E5%AF%BC%E8%88%AA%E6%A0%8F%E6%B8%90%E5%8F%98/"/>
      <url>/2018/01/15/iOS%E5%AE%9E%E7%8E%B0%E5%AF%BC%E8%88%AA%E6%A0%8F%E6%B8%90%E5%8F%98/</url>
      
        <content type="html"><![CDATA[<h2 id="设置导航栏的barTintColor"><a href="#设置导航栏的barTintColor" class="headerlink" title="设置导航栏的barTintColor"></a>设置导航栏的barTintColor</h2><p>1.获取状态栏加导航栏的总高度<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//状态条高度</span><br><span class="line">#define TG_TANGO_STATUSBAR_HEIGHT [[UIApplication sharedApplication] statusBarFrame].size.height</span><br><span class="line">//导航条高度</span><br><span class="line">#define TG_TANGO_NAVBAR_HEIGHT 44.0</span><br><span class="line">//导航条+状态条高度</span><br><span class="line">#define TG_TANGO_SYSTEMTOP_HEIGHT (TG_TANGO_STATUSBAR_HEIGHT + TG_TANGO_NAVBAR_HEIGHT)</span><br></pre></td></tr></table></figure></p><p>2.设置导航栏颜色<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.navigationController.navigationBar.barTintColor = [UIColor orangeColor];</span><br></pre></td></tr></table></figure></p><p>3.滚动时修改导航栏透明度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)scrollViewDidScroll:(UIScrollView *)scrollView&#123;</span><br><span class="line"></span><br><span class="line">    CGFloat offsetY = scrollView.contentOffset.y;</span><br><span class="line"></span><br><span class="line">    if (offsetY &lt;= 0) &#123;</span><br><span class="line">        CGFloat alpha = -offsetY / SYSTEMTOP_HEIGHT;</span><br><span class="line">        [self setNavAlpha:alpha];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [self setNavAlpha:0.0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setNavAlpha:(CGFloat)alpha &#123;</span><br><span class="line">    //修改barTintColor的alpha</span><br><span class="line">    self.navigationController.navigationBar.alpha = alpha;</span><br><span class="line">    //修改navigationBar的第一层subview的alpha也可以</span><br><span class="line">    //self.navigationController.navigationBar.subviews.firstObject.alpha = alpha;</span><br><span class="line">    //不起作用</span><br><span class="line">    //self.navigationController.navigationBar.barTintColor = [UIColor colorWithRed:1.0 green:0.5 blue:0.0 alpha:alpha];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Xcode报错总结</title>
      <link href="/2018/01/11/Xcode%E6%8A%A5%E9%94%99%E6%80%BB%E7%BB%93/"/>
      <url>/2018/01/11/Xcode%E6%8A%A5%E9%94%99%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="Library-not-found-for-xxx"><a href="#Library-not-found-for-xxx" class="headerlink" title="Library not found for -xxx"></a>Library not found for -xxx</h2><p>Library Search Paths：没有配置或没有正确配置 .a静态库 导致报错</p><h2 id="xxx-h-file-not-found"><a href="#xxx-h-file-not-found" class="headerlink" title="xxx.h file not found"></a>xxx.h file not found</h2><p>framework search paths ：项目中的framework静态库的路径配置错误或者没有配置<br><a id="more"></a></p><h2 id="library-not-found-for-lPods"><a href="#library-not-found-for-lPods" class="headerlink" title="library not found for -lPods"></a>library not found for -lPods</h2><!--原来Apple不允许build包含swift静态库了。而cocoapods使用了frameworks方式来集成swift库，就是use_frameworks!这句话了--><h2 id="Multiple-commands-produce"><a href="#Multiple-commands-produce" class="headerlink" title="Multiple commands produce"></a>Multiple commands produce</h2><p>1.Info.plist<br>在 target -&gt; Build phase &gt; Copy Bundle Resource 中找到info.plist<br>2.Copy Pods Resources<br>在 target -&gt; Build phase &gt; Copy Pods Resources -&gt; Output Files，移除${TARGET_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}</p><h2 id="Xcode突然没有智能提示"><a href="#Xcode突然没有智能提示" class="headerlink" title="Xcode突然没有智能提示"></a>Xcode突然没有智能提示</h2><p>1.preferences-&gt;location-&gt;DerivedData 点击箭头定位到DerivedData 目录下，删除DerivedData文件夹<br>2.执行command + shift + k 和 command + option + shift + k，重启xcode</p><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>iOS动态更改icon图标</title>
      <link href="/2018/01/05/iOS%E5%8A%A8%E6%80%81%E6%9B%B4%E6%94%B9icon%E5%9B%BE%E6%A0%87/"/>
      <url>/2018/01/05/iOS%E5%8A%A8%E6%80%81%E6%9B%B4%E6%94%B9icon%E5%9B%BE%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<p>1.将所有@2x，@3x图标放到项目中</p><p>2.配置info.plist<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;CFBundleIcons&lt;/key&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">    &lt;key&gt;CFBundlePrimaryIcon&lt;/key&gt;</span><br><span class="line">    &lt;dict&gt;</span><br><span class="line">        &lt;key&gt;CFBundleIconFiles&lt;/key&gt;</span><br><span class="line">        &lt;array&gt;</span><br><span class="line">            &lt;string&gt;appIcon1&lt;/string&gt;</span><br><span class="line">        &lt;/array&gt;</span><br><span class="line">    &lt;/dict&gt;</span><br><span class="line">    &lt;key&gt;CFBundleAlternateIcons&lt;/key&gt;</span><br><span class="line">    &lt;dict&gt;</span><br><span class="line">        &lt;key&gt;appIcon1&lt;/key&gt;</span><br><span class="line">        &lt;dict&gt;</span><br><span class="line">            &lt;key&gt;CFBundleIconFiles&lt;/key&gt;</span><br><span class="line">            &lt;array&gt;</span><br><span class="line">                &lt;string&gt;appIcon1&lt;/string&gt;</span><br><span class="line">            &lt;/array&gt;</span><br><span class="line">            &lt;key&gt;UIPrerenderedIcon&lt;/key&gt;</span><br><span class="line">            &lt;string&gt;NO&lt;/string&gt;</span><br><span class="line">        &lt;/dict&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;key&gt;appIcon2&lt;/key&gt;</span><br><span class="line">        &lt;dict&gt;</span><br><span class="line">            &lt;key&gt;CFBundleIconFiles&lt;/key&gt;</span><br><span class="line">            &lt;array&gt;</span><br><span class="line">                &lt;string&gt;appIcon2&lt;/string&gt;</span><br><span class="line">            &lt;/array&gt;</span><br><span class="line">            &lt;key&gt;UIPrerenderedIcon&lt;/key&gt;</span><br><span class="line">        &lt;string&gt;NO&lt;/string&gt;</span><br><span class="line">        &lt;/dict&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;key&gt;appIcon3&lt;/key&gt;</span><br><span class="line">        &lt;dict&gt;</span><br><span class="line">            &lt;key&gt;CFBundleIconFiles&lt;/key&gt;</span><br><span class="line">            &lt;array&gt;</span><br><span class="line">                &lt;string&gt;appIcon3&lt;/string&gt;</span><br><span class="line">            &lt;/array&gt;</span><br><span class="line">            &lt;key&gt;UIPrerenderedIcon&lt;/key&gt;</span><br><span class="line">            &lt;string&gt;NO&lt;/string&gt;</span><br><span class="line">        &lt;/dict&gt;</span><br><span class="line">    &lt;/dict&gt;</span><br><span class="line">&lt;/dict&gt;</span><br></pre></td></tr></table></figure></p><p>3.更换图标(仅限于iOS版本10.3以上)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (void)changeIcon&#123;</span><br><span class="line"></span><br><span class="line">    if ([UIApplication sharedApplication].supportsAlternateIcons) &#123;</span><br><span class="line">        NSLog(@&quot;you can change this app&apos;s icon&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        NSLog(@&quot;you can not change this app&apos;s icon&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NSString *iconName = [[UIApplication sharedApplication] alternateIconName];</span><br><span class="line">    NSLog(@&quot;%@&quot;,iconName);</span><br><span class="line">    if (iconName) &#123;</span><br><span class="line">        // change to primary icon</span><br><span class="line">        [[UIApplication sharedApplication] setAlternateIconName:@&quot;appIcon1&quot; completionHandler:^(NSError * _Nullable error) &#123;</span><br><span class="line">            if (error) &#123;</span><br><span class="line">            NSLog(@&quot;set icon error: %@&quot;,error);</span><br><span class="line">            &#125;</span><br><span class="line">            NSLog(@&quot;The alternate icon&apos;s name is %@&quot;,iconName);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        // change to alterante icon</span><br><span class="line">        [[UIApplication sharedApplication] setAlternateIconName:@&quot;appIcon2&quot; completionHandler:^(NSError * _Nullable error) &#123;</span><br><span class="line">            if (error) &#123;</span><br><span class="line">            NSLog(@&quot;set icon error: %@&quot;,error);</span><br><span class="line">            &#125;</span><br><span class="line">            NSLog(@&quot;The alternate icon&apos;s name is %@&quot;,iconName);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Lintcode笔记</title>
      <link href="/2018/01/04/Lintcode%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/01/04/Lintcode%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>参考代码：<a href="https://github.com/awangdev/LintCode" target="_blank" rel="noopener">https://github.com/awangdev/LintCode</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode笔记</title>
      <link href="/2018/01/04/Leetcode%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/01/04/Leetcode%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="算法的复杂度"><a href="#算法的复杂度" class="headerlink" title="算法的复杂度"></a>算法的复杂度</h2><p>n 为问题的规模</p><ul><li>时间复杂度T(n)：总运算次数表达式中受n的变化影响最大的那一项（不含系数）。一个算法花费的时间与算法中语句的执行次数成正比。</li><li>空间复杂度S(n)：运行完一个程序所需内存的大小。</li><li>常数阶O(1),  对数阶O(log2n),  线性阶O(n),  线性对数阶O(nlog2n),  平方阶O(n^2)， 立方阶O(n^3),…， k次方阶O(n^k), 指数阶O(2^n)<a id="more"></a></li></ul><h2 id="461-Hamming-Distance"><a href="#461-Hamming-Distance" class="headerlink" title="461.Hamming Distance"></a>461.Hamming Distance</h2><p>左移&lt;&lt;：丢弃最高位，0补最低位<br>右移&gt;&gt;：向右挪动若干位</p><p>##</p><p>参考代码：<a href="https://github.com/gzwl/leetcode" target="_blank" rel="noopener">https://github.com/gzwl/leetcode</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS提高界面流畅度的技巧</title>
      <link href="/2017/12/19/iOS%E6%8F%90%E9%AB%98%E7%95%8C%E9%9D%A2%E6%B5%81%E7%95%85%E5%BA%A6%E7%9A%84%E6%8A%80%E5%B7%A7/"/>
      <url>/2017/12/19/iOS%E6%8F%90%E9%AB%98%E7%95%8C%E9%9D%A2%E6%B5%81%E7%95%85%E5%BA%A6%E7%9A%84%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="屏幕显示图像原理"><a href="#屏幕显示图像原理" class="headerlink" title="屏幕显示图像原理"></a>屏幕显示图像原理</h2><p>App 主线程在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待信号到来时显示到屏幕上。<br><a id="more"></a></p><h2 id="CPU资源消耗原因和解决方案"><a href="#CPU资源消耗原因和解决方案" class="headerlink" title="CPU资源消耗原因和解决方案"></a>CPU资源消耗原因和解决方案</h2><h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><p>对象的创建会分配内存、调整属性、甚至还有读取文件等操作。</p><ul><li>尽量用轻量的对象代替重量的对象</li><li>使用storyboard创建对象比通过代码消耗资源多</li><li>尽量推迟对象创建的时间，并把对象的创建分散到多个任务中去</li><li>能复用的对象尽量使用复用</li></ul><h3 id="对象调整"><a href="#对象调整" class="headerlink" title="对象调整"></a>对象调整</h3><ul><li>尽量减少不必要的属性修改，UIView 的关于显示相关的属性（比如 frame/bounds/transform）等实际上都是 CALayer 属性映射来的</li><li>尽量避免调整视图层次，添加或移除视图</li></ul><h3 id="对象销毁"><a href="#对象销毁" class="headerlink" title="对象销毁"></a>对象销毁</h3><ul><li>如果对象可以放到后台线程去释放，那就挪到后台线程去。<code>把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译器警告，就可以让对象在后台线程销毁了。</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSArray *tmp = self.array;</span><br><span class="line">self.array = nil;</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">[tmp class];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="布局计算"><a href="#布局计算" class="headerlink" title="布局计算"></a>布局计算</h3><ul><li>视图布局的计算是APP中最常见消耗CPU的地方，尽量在<code>后台线程</code>计算好视图布局并对视图布局进行<code>缓存</code>，尽量<code>提前</code>算好布局，在需要时一次性调整好对应属性，而不要多次，频繁的计算、调整这些属性</li></ul><h3 id="autolayout"><a href="#autolayout" class="headerlink" title="autolayout"></a>autolayout</h3><ul><li>autolayout对于复杂视图来说常常会产生严重的性能问题，尽量手动调整 frame 等属性，可以使用category来快捷地获取视图的width,height等属性。</li></ul><h3 id="文本计算"><a href="#文本计算" class="headerlink" title="文本计算"></a>文本计算</h3><ul><li>可以参考UILabel 内部的实现方式：用 [NSAttributedString boundingRectWithSize:options:context:] 来计算文本宽高，用 -[NSAttributedString drawWithRect:options:context:] 来绘制文本，注意需要放到后台线程进行以避免阻塞主线程。</li></ul><h3 id="文本渲染"><a href="#文本渲染" class="headerlink" title="文本渲染"></a>文本渲染</h3><ul><li>用 TextKit 或最底层的 CoreText 对文本异步绘制。CoreText 对象占用内存较少，可以缓存下来以备稍后多次渲染。屏幕上能看到的所有文本内容控件，在底层都是通过 CoreText 排版、绘制为 Bitmap 显示的。</li></ul><h3 id="图片解码"><a href="#图片解码" class="headerlink" title="图片解码"></a>图片解码</h3><p>当你用 UIImage 或 CGImageSource 的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。如果想要绕开这个机制，常见的做法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。</p><h3 id="图片绘制"><a href="#图片绘制" class="headerlink" title="图片绘制"></a>图片绘制</h3><p>图像的绘制通常是指用那些以 CG 开头的方法把图像绘制到画布中，然后从画布创建图片并显示这样一个过程。这个最常见的地方就是 [UIView drawRect:] 里面了。由于 CoreGraphic 方法通常都是线程安全的，所以图像的绘制可以很容易的放到后台线程进行。一个简单异步绘制的过程大致如下（实际情况会比这个复杂得多，但原理基本一致）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)display &#123;</span><br><span class="line">    dispatch_async(backgroundQueue, ^&#123;</span><br><span class="line">        CGContextRef ctx = CGBitmapContextCreate(...);</span><br><span class="line">        // draw in context...</span><br><span class="line">        CGImageRef img = CGBitmapContextCreateImage(ctx);</span><br><span class="line">        CFRelease(ctx);</span><br><span class="line">        dispatch_async(mainQueue, ^&#123;</span><br><span class="line">            layer.contents = img;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="GPU资源消耗原因和解决方案"><a href="#GPU资源消耗原因和解决方案" class="headerlink" title="GPU资源消耗原因和解决方案"></a>GPU资源消耗原因和解决方案</h2><ul><li>GPU的作用：接收提交的纹理和顶点描绘，应用变换，混合和渲染，并且输出到屏幕上。</li></ul><h3 id="纹理的渲染"><a href="#纹理的渲染" class="headerlink" title="纹理的渲染"></a>纹理的渲染</h3><ul><li>尽量减少在短时间内大量图片的显示，尽可能多张图片合成为一张进行显示。</li><li>尽量不要让图片和视图的大小超过4096*4096</li></ul><h3 id="视图的混合"><a href="#视图的混合" class="headerlink" title="视图的混合"></a>视图的混合</h3><ul><li>尽量减少视图数量和层次，并在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成</li></ul><h3 id="图形的生成"><a href="#图形的生成" class="headerlink" title="图形的生成"></a>图形的生成</h3><ul><li>CALayer 的 border、圆角、阴影、遮罩（mask），CASharpLayer 的矢量图形显示，通常会触发离屏渲染，离屏渲染通常发生在 GPU 中，可以尝试开启 CALayer.shouldRasterize 属性，但这会把原本离屏渲染的操作转嫁到 CPU 上去，也可以用一张已经绘制好的圆角图片覆盖到原本视图上面来模拟相同的视觉效果。最彻底的解决办法，就是把需要显示的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性。</li></ul><h2 id="AsyncDisplayKit-ASDK"><a href="#AsyncDisplayKit-ASDK" class="headerlink" title="AsyncDisplayKit(ASDK)"></a>AsyncDisplayKit(ASDK)</h2><p>ASDK 认为，阻塞主线程的任务，主要分为三大类：<br>1.文本宽高计算，视图布局计算<br>2.文本渲染，图片解码，图形绘制<br>3.对象创建，对象调整，对象销毁</p><p>与 UIView 和 CALayer 不同，ASDisplayNode 是线程安全的，它可以在后台线程创建和修改。</p><ul><li>ASDK 的图层预合成：那些并不需要响应触摸事件，也不需要进行动画和位置调整的 sub-layer，可以合成渲染为一张图片</li><li>ASDK 异步并发操作：利用 GCD 异步并发执行</li><li>Runloop 任务分发</li></ul><h2 id="预排版"><a href="#预排版" class="headerlink" title="预排版"></a>预排版</h2><ul><li>当获取到 API JSON 数据后，把每条 Cell 需要的数据都在后台线程计算并封装为一个布局对象 CellLayout。</li><li>FDTemplateLayoutCell</li></ul><h2 id="product-gt-profile"><a href="#product-gt-profile" class="headerlink" title="product-&gt;profile"></a>product-&gt;profile</h2><h1 id="提高列表滚动流畅度"><a href="#提高列表滚动流畅度" class="headerlink" title="提高列表滚动流畅度"></a>提高列表滚动流畅度</h1><h2 id="避免重复多次计算-cell-行高"><a href="#避免重复多次计算-cell-行高" class="headerlink" title="避免重复多次计算 cell 行高"></a>避免重复多次计算 cell 行高</h2><ul><li><p>获取数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (InfoModel *model in data) &#123;</span><br><span class="line">    FrameModel *frameModel = [FrameModel new];</span><br><span class="line">    frameModel.model = model;</span><br><span class="line">    [self.data addObject:frameModel];</span><br><span class="line">&#125;</span><br><span class="line">[self.tabView reloadData];</span><br></pre></td></tr></table></figure></li><li><p>计算 frame 、cell 行高</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@interface FrameModel : NSObject</span><br><span class="line"></span><br><span class="line">@property (assign, nonatomic, readonly) CGRect titleFrame;</span><br><span class="line">@property (assign, nonatomic, readonly) CGFloat cellHeight;</span><br><span class="line">@property (strong, nonatomic) InfoModel *model;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation FrameModel</span><br><span class="line"></span><br><span class="line">- (void)setModel:(InfoModel *)model &#123;</span><br><span class="line">if (!model) return;</span><br><span class="line"></span><br><span class="line">_model = model;</span><br><span class="line"></span><br><span class="line">CGFloat maxLayout = ([UIScreen mainScreen].bounds.size.width - 20.f);</span><br><span class="line">CGFloat bottom = 4.f;</span><br><span class="line"></span><br><span class="line">//title</span><br><span class="line">CGFloat titleX = 10.f;</span><br><span class="line">CGFloat titleY = 10.f;</span><br><span class="line">CGSize titleSize = [model.title boundingRectWithSize:CGSizeMake(maxLayout, CGFLOAT_MAX) options:NSStringDrawingUsesLineFragmentOrigin|NSStringDrawingUsesFontLeading attributes:@&#123;NSFontAttributeName : Font(16.f)&#125; context:nil].size;</span><br><span class="line">_titleFrame = CGRectMake(titleX, titleY, titleSize.width, titleSize.height);</span><br><span class="line"></span><br><span class="line">//cell Height</span><br><span class="line">_cellHeight = (CGRectGetMaxY(_titleFrame) + bottom);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li><li><p>行高取值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">    TableCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;identifier&quot; forIndexPath:indexPath];</span><br><span class="line">    FrameModel *frameModel = self.data[indexPath.row];</span><br><span class="line">    cell.frameModel = frameModel;</span><br><span class="line">    return cell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">    FrameModel *frameModel = self.data[indexPath.row];</span><br><span class="line">    return frameModel.cellHeight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>控件赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)setFrameModel:(FrameModel *)frameModel &#123;</span><br><span class="line">    if (!frameModel) return;</span><br><span class="line"></span><br><span class="line">    _frameModel = frameModel;</span><br><span class="line"></span><br><span class="line">    InfoModel *model = frameModel.model;</span><br><span class="line"></span><br><span class="line">    self.titleLabel.frame = frameModel.titleFrame;</span><br><span class="line">    self.titleLabel.text = model.title;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="文本异步渲染"><a href="#文本异步渲染" class="headerlink" title="文本异步渲染"></a>文本异步渲染</h2><p>用 TextKit 或最底层的 CoreText 对文本异步绘制，支持文本异步渲染也有现成的库 YYText 。* 计算 frame 、cell 行高<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@interface FrameModel : NSObject</span><br><span class="line"></span><br><span class="line">@property (assign, nonatomic, readonly) CGRect titleFrame;</span><br><span class="line">@property (strong, nonatomic, readonly) YYTextLayout *titleLayout;</span><br><span class="line">@property (assign, nonatomic, readonly) CGFloat cellHeight;</span><br><span class="line">@property (strong, nonatomic) InfoModel *model;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation FrameModel</span><br><span class="line"></span><br><span class="line">- (void)setModel:(InfoModel *)model &#123;</span><br><span class="line">if (!model) return;</span><br><span class="line"></span><br><span class="line">_model = model;</span><br><span class="line"></span><br><span class="line">CGFloat maxLayout = ([UIScreen mainScreen].bounds.size.width - 20.f);</span><br><span class="line">CGFloat bottom = 4.f;</span><br><span class="line"></span><br><span class="line">//title</span><br><span class="line">NSMutableAttributedString *title = [[NSMutableAttributedString alloc] initWithString:entity.title];</span><br><span class="line">title.yy_font = Font(16.f);</span><br><span class="line">title.yy_color = [UIColor blackColor];</span><br><span class="line"></span><br><span class="line">YYTextContainer *titleContainer = [YYTextContainer containerWithSize:CGSizeMake(maxLayout, CGFLOAT_MAX)];</span><br><span class="line">_titleLayout = [YYTextLayout layoutWithContainer:titleContainer text:title];</span><br><span class="line"></span><br><span class="line">CGFloat titleX = 10.f;</span><br><span class="line">CGFloat titleY = 10.f;</span><br><span class="line">CGSize titleSize = _titleLayout.textBoundingSize;</span><br><span class="line">//CGSize titleSize = [model.title boundingRectWithSize:CGSizeMake(maxLayout, CGFLOAT_MAX) options:NSStringDrawingUsesLineFragmentOrigin|NSStringDrawingUsesFontLeading attributes:@&#123;NSFontAttributeName : Font(16.f)&#125; context:nil].size;</span><br><span class="line">_titleFrame = (CGRect)&#123;titleX,titleY,CGSizeMake(titleSize.width, titleSize.height)&#125;;</span><br><span class="line"></span><br><span class="line">//cell Height</span><br><span class="line">_cellHeight = (CGRectGetMaxY(_titleFrame) + bottom);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><ul><li><p>UITableViewCell 处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier &#123;</span><br><span class="line">    self = [super initWithStyle:style reuseIdentifier:reuseIdentifier];</span><br><span class="line">    if (!self) return nil;</span><br><span class="line"></span><br><span class="line">    YYLabel *title = [YYLabel new];</span><br><span class="line">    title.displaysAsynchronously = YES; //开启异步渲染</span><br><span class="line">    title.ignoreCommonProperties = YES; //忽略属性</span><br><span class="line">    title.layer.borderColor = [UIColor brownColor].CGColor;</span><br><span class="line">    title.layer.cornerRadius = 1.f;</span><br><span class="line">    title.layer.borderWidth = 1.f;</span><br><span class="line">    [self.contentView addSubview:_titleLabel = title];</span><br><span class="line"></span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>控件赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)setFrameModel:(FrameModel *)frameModel &#123;</span><br><span class="line">if (!frameModel) return;</span><br><span class="line"></span><br><span class="line">_frameModel = frameModel;</span><br><span class="line"></span><br><span class="line">self.titleLabel.frame = frameModel.titleFrame;</span><br><span class="line">self.titleLabel.textLayout = model.titleLayout; //直接取 YYTextLayout</span><br><span class="line">//InfoModel *model = frameModel.model;</span><br><span class="line">//self.titleLabel.text = model.title;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="离屏渲染"><a href="#离屏渲染" class="headerlink" title="离屏渲染"></a>离屏渲染</h2><ul><li><p>On-Screen Rendering<br>当前屏幕渲染，指的是在当前用于显示的屏幕缓冲区中进行渲染操作。</p></li><li><p>Off-Screen Rendering<br>离屏渲染，指的是 GPU 或 CPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。过程中需要切换 contexts (上下文环境),先从当前屏幕切换到离屏的contexts，渲染结束后，又要将 contexts 切换回来，而切换过程十分耗费性能。</p></li></ul><p>GPU 产生的离屏渲染主要是当 CALayer 使用圆角，阴影，遮罩等属性的的时候，图层属性的混合体被指定为在未预合成之前不能直接在屏幕中渲染，则过程中需要进行离屏渲染。<br>实际项目中 CPU 产生的离屏渲染主要由Core Graphics API(核心绘图)的使用导致。</p><h3 id="离屏渲染的检测手段"><a href="#离屏渲染的检测手段" class="headerlink" title="离屏渲染的检测手段"></a>离屏渲染的检测手段</h3><p>模拟器的 debug -&gt; 选取 color Offscreen-Rendered.</p><h3 id="离屏渲染的优化手段"><a href="#离屏渲染的优化手段" class="headerlink" title="离屏渲染的优化手段"></a>离屏渲染的优化手段</h3><h4 id="shadows（阴影）"><a href="#shadows（阴影）" class="headerlink" title="shadows（阴影）"></a>shadows（阴影）</h4><p>解决方案:设置阴影后，设置CALayer的 shadowPath<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view.layer.shadowPath = [UIBezierPath pathWithCGRect:view.bounds].CGPath;</span><br></pre></td></tr></table></figure></p><h4 id="masksToBounds-true-cornerRadius-gt-0"><a href="#masksToBounds-true-cornerRadius-gt-0" class="headerlink" title="masksToBounds = true +  cornerRadius &gt; 0"></a>masksToBounds = true +  cornerRadius &gt; 0</h4><p>解决方案:后台绘制圆角图片，前台进行设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (void)setCircleImage</span><br><span class="line">&#123;</span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">UIImage * circleImage = [image imageWithCircle];</span><br><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">imageView.image = circleImage;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#import &quot;UIImage+Addtions.h&quot;</span><br><span class="line">@implementation UIImage (Addtions)</span><br><span class="line">//返回一张圆形图片</span><br><span class="line">- (instancetype)imageWithCircle</span><br><span class="line">&#123;</span><br><span class="line">UIGraphicsBeginImageContextWithOptions(self.size, NO, 0);</span><br><span class="line">UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(0, 0, self.size.width, self.size.height)];</span><br><span class="line">[path addClip];</span><br><span class="line">[self drawAtPoint:CGPointZero];</span><br><span class="line">UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">UIGraphicsEndImageContext();</span><br><span class="line">return image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于 contents 无内容或者内容的背景透明(无涉及到圆角以外的区域)的layer，直接设置layer的 backgroundColor 和 cornerRadius 属性来绘制圆角。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//不要直接设置控件的 backgroundColor</span><br><span class="line">//部分控件(如 UILabel )设置背景色是对CALayer的 contents 设置颜色而不是 backgroundColor </span><br><span class="line">label.layer.backgroundColor = aColor</span><br><span class="line">label.layer.cornerRadius = 5</span><br></pre></td></tr></table></figure></p><p>使用混合图层，在layer上方叠加相应mask形状的半透明layer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sublayer.contents = (id)[UIImage imageNamed:@&quot;xxx&quot;].CGImage;</span><br><span class="line">[view.layer addSublayer:sublayer];</span><br></pre></td></tr></table></figure></p><h4 id="mask（遮罩）"><a href="#mask（遮罩）" class="headerlink" title="mask（遮罩）"></a>mask（遮罩）</h4><p>解决方案:</p><ul><li>不使用mask</li><li>使用混合图层，具体同上方圆角第二解决方案</li></ul><h4 id="allowsGroupOpacity（组不透明）"><a href="#allowsGroupOpacity（组不透明）" class="headerlink" title="allowsGroupOpacity（组不透明）"></a>allowsGroupOpacity（组不透明）</h4><p>开启CALayer的 allowsGroupOpacity 属性后，子 layer 在视觉上的透明度的上限是其父 layer 的 opacity (对应UIView的 alpha )，并且从 iOS 7 以后默认全局开启了这个功能，这样做是为了让子视图与其容器视图保持同样的透明度。<br>解决方案:关闭 allowsGroupOpacity 属性，按产品需求自己控制layer透明度。</p><h4 id="edge-antialiasing（抗锯齿）"><a href="#edge-antialiasing（抗锯齿）" class="headerlink" title="edge antialiasing（抗锯齿）"></a>edge antialiasing（抗锯齿）</h4><p>解决方案:不设置 allowsEdgeAntialiasing 属性为YES(默认为NO)</p><h4 id="CALayer离屏渲染终极解决方案"><a href="#CALayer离屏渲染终极解决方案" class="headerlink" title="CALayer离屏渲染终极解决方案"></a>CALayer离屏渲染终极解决方案</h4><p>当视图内容是静态不变时，设置 shouldRasterize(光栅化)为YES，此方案最为实用方便。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">view.layer.shouldRasterize = true;</span><br><span class="line">view.layer.rasterizationScale = view.layer.contentsScale;</span><br></pre></td></tr></table></figure></p><p>但当视图内容是动态变化(如后台下载图片完毕后切换到主线程设置)时，使用此方案反而为增加系统负荷。</p><h4 id="CPU离屏渲染的优化手段"><a href="#CPU离屏渲染的优化手段" class="headerlink" title="CPU离屏渲染的优化手段"></a>CPU离屏渲染的优化手段</h4><p>将Core Graphics API(核心绘图)的绘制操作放到后台线程中进行。</p><h1 id="解决界面卡顿"><a href="#解决界面卡顿" class="headerlink" title="解决界面卡顿"></a>解决界面卡顿</h1><h2 id="离屏渲染-1"><a href="#离屏渲染-1" class="headerlink" title="离屏渲染"></a>离屏渲染</h2><h3 id="界面显示的原理"><a href="#界面显示的原理" class="headerlink" title="界面显示的原理"></a>界面显示的原理</h3><p>iOS设备通常是60fps(每秒60帧)，也就是说两帧相隔的时间是1/60秒，大概16.7ms。在这16.7ms中，为了显示一帧，需要如下工作：</p><ul><li>CPU计算好各个视图的位置，大小，对图片进行解码等，绘制成纹理交给GPU</li><li>GPU对收到的纹理进行混合，顶点变换，渲染到帧缓冲区</li><li>每16.7ms,一个时钟信号到达，帧缓冲区取出一帧，显示到屏幕。<br>也就是说，CPU或者GPU被大量占用的时候，都有可能在16.7ms中没办法完成一帧的绘制，导致时钟信号到来的时候，取得还是上一帧的内容，也就都有可能导致界面卡顿</li></ul><h3 id="渲染-amp-离屏渲染"><a href="#渲染-amp-离屏渲染" class="headerlink" title="渲染 &amp; 离屏渲染"></a>渲染 &amp; 离屏渲染</h3><p>在iOS中，渲染通常分为CPU和GPU渲染两种，而GPU渲染又分为在GPU缓冲区和非GPU缓冲区两种</p><ul><li>CPU渲染（软件渲染）,CPU绘制成bitmap，交给GPU</li><li>GPU渲染（硬件渲染） <ul><li>GPU缓冲区渲染</li><li>非GPU缓冲区渲染（额外开辟缓冲区）<br>通常，CPU渲染，和GPU非帧缓冲区内渲染统称为离屏渲染。因为，CPU和帧缓冲区是为图形图像显示做了高度优化的，速度较快。</li></ul></li></ul><p>什么情况下会触发离屏幕渲染？</p><p>用CoreGraphics的CGContext绘制的<br>在drawRect中绘制的，即使drawRect是空的<br>Layer具有Mask（比如圆角）或者Shadow<br>Layer的隔栅化shouldRasterize为True<br>文本(UILabel,UITextfield,UITextView,CoreText,UITextLayer等)</p><h3 id="CoreGraphics-VS-CALayer"><a href="#CoreGraphics-VS-CALayer" class="headerlink" title="CoreGraphics VS CALayer"></a>CoreGraphics VS CALayer</h3><p>上文提到了，CoreGraphics通常是CPU渲染成bitmap交给GPU，假如频繁的大量的绘制出现，往往会导致界面卡顿。而CALayer是对GPU做过优化的，能够硬件加速。所以，对于性能要求较高的绘制，尝试用CALayer替代CoreGraphics</p><h2 id="Core-Animation-获取图形绘制情况，FPS，离屏渲染等"><a href="#Core-Animation-获取图形绘制情况，FPS，离屏渲染等" class="headerlink" title="Core Animation(获取图形绘制情况，FPS，离屏渲染等)"></a>Core Animation(获取图形绘制情况，FPS，离屏渲染等)</h2><ul><li>Color Blended Layers：图层混合情况，没有混合的部分会是绿色，混合最严重的部分会是红色</li><li>Color Hits Green and Misses Red：隔栅化情况，当使用shouldRasterize属性的时候，耗时的图层绘制会被缓存，然后当做一个简单的扁平图片呈现。当缓存无法使用必须重建的时候，会被高亮为红色。</li><li>Color Copied Images：拷贝图片情况，有时候寄宿图片的生成意味着Core Animation被强制生成一些图片，然后发送到渲染服务器，而不是简单的指向原始指针。这个选项把这些图片渲染成蓝色。复制图片对内存和CPU使用来说都是一项非常昂贵的操作，所以应该尽可能的避免。</li><li>Color Misaligned Images：图片如果有像素不对齐，拉伸和缩放情况，会被高亮成黄色</li><li>Color Offscreen-Rendered Yellow：离屏渲染的部分会被高亮成黄色</li><li>Color Immediately：设置每帧都更新，通常Core Animation Instruments以每毫秒10次的频率更新图层调试颜色。</li><li>Color OpenGL Fast Path Blue ：对任何直接使用OpenGL绘制的图层进行高亮</li><li>Flash Updated Region ：对重绘的内容高亮成黄色</li></ul><h2 id="界面卡顿原因"><a href="#界面卡顿原因" class="headerlink" title="界面卡顿原因"></a>界面卡顿原因</h2><h3 id="CPU限制"><a href="#CPU限制" class="headerlink" title="CPU限制"></a>CPU限制</h3><ul><li>对象的创建，释放，属性调整。这里尤其要提一下属性调整，CALayer的属性调整的时候是会创建隐式动画的，是比较损耗性能的。</li><li>视图和文本的布局计算，AutoLayout的布局计算都是在主线程上的，所以占用CPU时间也很多 。</li><li>文本渲染，诸如UILabel和UITextview都是在主线程渲染的</li><li>图片的解码，这里要提到的是，通常UIImage只有在交给GPU之前的一瞬间，CPU才会对其解码。<h3 id="GPU限制"><a href="#GPU限制" class="headerlink" title="GPU限制"></a>GPU限制</h3></li><li>视图的混合。比如一个界面十几层的视图叠加到一起，GPU不得不计算每个像素点药显示的像素</li><li>离屏渲染。视图的Mask，圆角，阴影。</li><li>半透明，GPU不得不进行数学计算，如果是不透明的，CPU只需要取上层的就可以了</li><li>浮点数像素</li></ul><h2 id="界面卡顿优化"><a href="#界面卡顿优化" class="headerlink" title="界面卡顿优化"></a>界面卡顿优化</h2><h3 id="AsyncDisplayKit"><a href="#AsyncDisplayKit" class="headerlink" title="AsyncDisplayKit"></a>AsyncDisplayKit</h3><h3 id="图文混排引擎"><a href="#图文混排引擎" class="headerlink" title="图文混排引擎"></a>图文混排引擎</h3><ul><li>YYKit</li><li>DTCoreText</li></ul><h3 id="异步绘制"><a href="#异步绘制" class="headerlink" title="异步绘制"></a>异步绘制</h3><p>把复杂的界面，放到后台线程里绘制成一个bitmap，然后再显示。虽然有些延迟，不过换来的却是平滑的界面。</p><h3 id="图片的解码"><a href="#图片的解码" class="headerlink" title="图片的解码"></a>图片的解码</h3><p>建议使用成熟的库，比如SDWebImage等，能够在后台进行图片解码，减少CPU的使用。</p><h3 id="预加载与缓存"><a href="#预加载与缓存" class="headerlink" title="预加载与缓存"></a>预加载与缓存</h3><p>对于复杂的TableView，可以对Cell视图的各个控件的大小，位置后台进行预计算，并且缓存起来。这样保证在heightForRow和cellForRow中不进行大量的计算。</p><h3 id="尽量使用CALayer"><a href="#尽量使用CALayer" class="headerlink" title="尽量使用CALayer"></a>尽量使用CALayer</h3><p>因为Layer是一个轻量级的视图结构，它不接受通知，不接受触摸，不在响应链。所以，相对于UIView来说，它的性能较好。并且CALayer及其子类是可以使用GPU渲染的，能够硬件加速。</p><h3 id="图层预合成"><a href="#图层预合成" class="headerlink" title="图层预合成"></a>图层预合成</h3><p>将两个CALayer的内容合成到一个Bitmap里，然后显示。能够减轻GPU的压力</p><h1 id="Texture-AsyncDisplayKit"><a href="#Texture-AsyncDisplayKit" class="headerlink" title="Texture(AsyncDisplayKit)"></a>Texture(AsyncDisplayKit)</h1><p>一些影响流畅性的关键点：</p><ul><li>网络请求，大部分网络请求都应该使用后台线程完成，如果你使用的是 AFNetworking、 SDWebImage 这些开源缓存库，那么切换到后台去请求网络资源的操作都已经默认完成。</li><li>本地数据读写和计算，当你需要从闪存中读取文件的时候，这些操作都应该使用GCD或者NSThread切换至后台线程中完成。</li><li>图像的处理，尽量使用合适的UIImage给予UIImageView使用</li><li>Layer 属性的谨慎选择，不合理的 Layer 特效（阴影、圆角）都会使流畅的滑动变成卡顿（非常重要）。</li><li>少用 UIView.backgroundColor = UIColor.clearColor()，透明的背景会加剧卡顿。</li><li>文字的渲染，你可能不知道，文字的渲染也是需要开销的。一般来说，文字渲染的开销非常小，甚至不能察觉到。但是，当一个UILabel被赋予大段富文本文字后，开销就会非常大。</li><li>图像的渲染，一个任何开发者、几乎所有库（包括SDWebImage）都无法解决的问题，图像在UIImageView中的渲染开销，并且图像的渲染只能在主线程中执行。</li></ul><p>控件对应关系：<br>UIKit —— AsyncDisplayKit<br>UIView —— ASDisplayNode<br>UILabel —— ASTextNode ：在TextKit上支持所有的富文本特性<br>UIImageView —— ASImageNode：异步的图像解码<br>UIButton —— ASButtonNode<br>UITableView —— ASTableView<br>UICollectionView —— ASCollectionView<br>UITableViewCell —— ASCellNode<br>UICollectionViewCell —— ASCellNode</p><h2 id="Layout-Specs（布局规则）"><a href="#Layout-Specs（布局规则）" class="headerlink" title="Layout Specs（布局规则）"></a>Layout Specs（布局规则）</h2><p>ASInsetLayoutSpec（插入布局规则）<br>ASOverlayLayoutSpec（覆盖布局规则）<br>ASBackgroundLayoutSpec（背景布局规则）<br>ASCenterLayoutSpec（中心布局规则）<br>ASRatioLayoutSpec（比例布局规则）<br>ASRelativeLayoutSpec（相对布局规则）<br>ASStackLayoutSpec（堆叠布局规则）<br>ASAbsoluteLayoutSpec（绝对布局约束)<br>ASLayoutSpec（布局规则）<br>Layout Element Properties（布局元素属性）<br>ASStackLayoutElement Properties（堆叠布局元素属性）<br>ASAbsoluteLayoutElement Properties（绝对布局元素属性）<br>ASLayoutElement Properties（布局元素属性）</p><p><a href="https://www.jianshu.com/p/afc69cd9e824" target="_blank" rel="noopener">AsyncDisplaykit2.0(Texture)使用「复杂界面流畅性」</a></p><p>参考文章：<a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">iOS 保持界面流畅的技巧</a><br><a href="https://www.jianshu.com/p/ca51c9d3575b" target="_blank" rel="noopener">离屏渲染优化详解：实例示范+性能测试</a><br><a href="https://blog.csdn.net/shaobo8910/article/details/66975785" target="_blank" rel="noopener">iOS性能优化：Instrument 调试界面卡顿</a><br><a href="https://zsisme.gitbooks.io/ios-/content/chapter12/instruments.html" target="_blank" rel="noopener">ios核心动画高级技巧</a><br><a href="https://didee.cn/2018/01/29/iOS-ASDK/" target="_blank" rel="noopener">iOS 开发一定要尝试的 Texture(ASDK)</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS富文本的使用</title>
      <link href="/2017/12/18/iOS%E5%AF%8C%E6%96%87%E6%9C%AC%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/12/18/iOS%E5%AF%8C%E6%96%87%E6%9C%AC%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>给文本添加富文本</p><ul><li>设置富文本富文本：addAttributes</li><li>富文本拼接：appendAttributedString<a id="more"></a>1.阴影<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NSMutableAttributedString *text = [NSMutableAttributedString new];</span><br><span class="line">NSMutableAttributedString *one = [[NSMutableAttributedString alloc] initWithString:@&quot;Shadow&quot;];</span><br><span class="line">NSShadow *shadow = [[NSShadow alloc]init];</span><br><span class="line">shadow.shadowBlurRadius = 5;</span><br><span class="line">shadow.shadowOffset = CGSizeMake(0, 1);</span><br><span class="line">shadow.shadowColor = [UIColor colorWithWhite:0.000 alpha:0.490];</span><br><span class="line">[one addAttributes:@&#123;NSShadowAttributeName:shadow,NSForegroundColorAttributeName:[UIColor whiteColor],NSFontAttributeName:[UIFont boldSystemFontOfSize:30]&#125; range:NSMakeRange(0, 6)];</span><br><span class="line">[text appendAttributedString:one];</span><br><span class="line">label.attributedText = text;</span><br></pre></td></tr></table></figure></li></ul><p>2.空心字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[one addAttributes:@&#123;NSStrokeColorAttributeName:[UIColor redColor],NSStrokeWidthAttributeName:@1.5&#125; range:NSMakeRange(0, 6)];</span><br></pre></td></tr></table></figure></p><p>3.特殊效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[one addAttributes:@&#123;NSTextEffectAttributeName:NSTextEffectLetterpressStyle,&#125; range:NSMakeRange(0, 6)];</span><br></pre></td></tr></table></figure></p><p>4.下划线、中划线</p><ul><li><p>下划线：NSUnderlineColorAttributeName</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[one addAttributes:@&#123;NSUnderlineStyleAttributeName:@(NSUnderlineStyleSingle),NSUnderlineColorAttributeName:[UIColor redColor]];</span><br></pre></td></tr></table></figure></li><li><p>中划线</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[one addAttributes:@&#123;NSStrikethroughStyleAttributeName:@(NSUnderlinePatternSolid|NSUnderlineStyleSingle),NSStrikethroughColorAttributeName:[UIColor greenColor]&#125; range:NSMakeRange(0, 6)];</span><br></pre></td></tr></table></figure></li></ul><p>线样式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, NSUnderlineStyle) &#123;</span><br><span class="line">NSUnderlineStyleNone                                    = 0x00,</span><br><span class="line">NSUnderlineStyleSingle                                  = 0x01,</span><br><span class="line">NSUnderlineStyleThick NS_ENUM_AVAILABLE(10_0, 7_0)      = 0x02,</span><br><span class="line">NSUnderlineStyleDouble NS_ENUM_AVAILABLE(10_0, 7_0)     = 0x09,</span><br><span class="line"></span><br><span class="line">NSUnderlinePatternSolid NS_ENUM_AVAILABLE(10_0, 7_0)      = 0x0000,</span><br><span class="line">NSUnderlinePatternDot NS_ENUM_AVAILABLE(10_0, 7_0)        = 0x0100,</span><br><span class="line">NSUnderlinePatternDash NS_ENUM_AVAILABLE(10_0, 7_0)       = 0x0200,</span><br><span class="line">NSUnderlinePatternDashDot NS_ENUM_AVAILABLE(10_0, 7_0)    = 0x0300,</span><br><span class="line">NSUnderlinePatternDashDotDot NS_ENUM_AVAILABLE(10_0, 7_0) = 0x0400,</span><br><span class="line"></span><br><span class="line">NSUnderlineByWord NS_ENUM_AVAILABLE(10_0, 7_0)            = 0x8000</span><br><span class="line">&#125; NS_ENUM_AVAILABLE(10_0, 6_0);</span><br></pre></td></tr></table></figure></p><p>5.链接</p><ul><li>label上的链接点击不了，textView可以，回调函数<code>shouldInteractWithURL</code>中可以响应。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[one addAttributes:@&#123;NSLinkAttributeName:@&quot;https://www.baidu.com&quot;&#125; range:NSMakeRange(0, 6)];</span><br></pre></td></tr></table></figure></li></ul><p>6.段落<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSMutableParagraphStyle *paragraph = [[NSMutableParagraphStyle alloc]init];</span><br><span class="line">paragraph.lineSpacing = 10.f;     //行间距</span><br><span class="line">paragraph.firstLineHeadIndent = 30.f;   //段落首行缩进</span><br><span class="line">paragraph.paragraphSpacing = 30.f;    //段落间距</span><br><span class="line">paragraph.headIndent = 15.f;    //整体缩进</span><br><span class="line">[one addAttributes:@&#123;NSParagraphStyleAttributeName:paragraph&#125;</span><br></pre></td></tr></table></figure></p><p>7.图文混排<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSMutableAttributedString *one = [[NSMutableAttributedString alloc] initWithString:@&quot;红红火火恍恍惚惚&quot;];</span><br><span class="line">NSTextAttachment *attachment = [[NSTextAttachment alloc]init];</span><br><span class="line">attachment.image = [UIImage imageNamed:@&quot;star_selected&quot;];</span><br><span class="line">NSAttributedString *imgAttr = [NSAttributedString attributedStringWithAttachment:attachment];</span><br><span class="line">[one insertAttributedString:imgAttr atIndex:4];</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 富文本 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Xcode开发技巧总结</title>
      <link href="/2017/12/15/Xcode%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"/>
      <url>/2017/12/15/Xcode%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="无线连接真机调试"><a href="#无线连接真机调试" class="headerlink" title="无线连接真机调试"></a>无线连接真机调试</h2><p>1.用数据线将手机连到Xcode，<code>请确保手机和电脑连到同一个wifi</code>。<br><a id="more"></a><br>2.Xcode：Window-&gt;Device and Simulators，找到连接的设备，将<code>Connect via network</code>打勾。<br>3.等待连接成功后，连接成功后设备那一列右边有一个地球标识，拔掉数据线，设备连接列表中选择真机即可进行无线调试。<br>4.还可以查看设备日志：Window-&gt;Device and Simulators-&gt;View Device Logs</p><ul><li>Passcode Required (“The device musthave a passcode set in order to allow this operation.”)<br>错误原因：可能手机未设置开机/锁屏密码导致，或者是开发工具Xcode的缓存所致。<br>解决方法：设置手机密码,然后再次点击Connect via network,可以正常连接,之后关掉手机密码后也可正常连接。</li></ul><h2 id="Xcode控制台打印中文"><a href="#Xcode控制台打印中文" class="headerlink" title="Xcode控制台打印中文"></a>Xcode控制台打印中文</h2><h3 id="1-宏定义"><a href="#1-宏定义" class="headerlink" title="1.宏定义"></a>1.宏定义</h3><!--more--><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define NSLog(FORMAT, ...) fprintf(stderr,&quot;\n %s:%d   %s\n&quot;,[[[NSString stringWithUTF8String:__FILE__] lastPathComponent] UTF8String],__LINE__, [[NSString stringWithFormat:FORMAT, ##__VA_ARGS__] UTF8String]);</span><br></pre></td></tr></table></figure><h3 id="2-添加类目，重写description方法：拼接"><a href="#2-添加类目，重写description方法：拼接" class="headerlink" title="2.添加类目，重写description方法：拼接"></a>2.添加类目，重写description方法：拼接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@implementation NSDictionary (Log)</span><br><span class="line">- (NSString *)description</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableString *string = [NSMutableString string];</span><br><span class="line"></span><br><span class="line">    // 开头有个&#123;</span><br><span class="line">    [string appendString:@&quot;&#123;\n&quot;];</span><br><span class="line"></span><br><span class="line">    // 遍历所有的键值对</span><br><span class="line">    [self enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123;</span><br><span class="line">        [string appendFormat:@&quot;\t%@&quot;, key];</span><br><span class="line">        [string appendString:@&quot; : &quot;];</span><br><span class="line">        [string appendFormat:@&quot;%@,\n&quot;, obj];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 结尾有个&#125;</span><br><span class="line">    [string appendString:@&quot;&#125;&quot;];</span><br><span class="line"></span><br><span class="line">    // 查找最后一个逗号</span><br><span class="line">    NSRange range = [string rangeOfString:@&quot;,&quot; options:NSBackwardsSearch];</span><br><span class="line">    if (range.location != NSNotFound)</span><br><span class="line">    [string deleteCharactersInRange:range];</span><br><span class="line"></span><br><span class="line">    return string;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation NSArray (Log)</span><br><span class="line"></span><br><span class="line">- (NSString *)description</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableString *string = [NSMutableString string];</span><br><span class="line"></span><br><span class="line">    // 开头有个[</span><br><span class="line">    [string appendString:@&quot;[\n&quot;];</span><br><span class="line"></span><br><span class="line">    // 遍历所有的元素</span><br><span class="line">    [self enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123;</span><br><span class="line">        [string appendFormat:@&quot;\t%@,\n&quot;, obj];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 结尾有个]</span><br><span class="line">    [string appendString:@&quot;]&quot;];</span><br><span class="line"></span><br><span class="line">    // 查找最后一个逗号</span><br><span class="line">    NSRange range = [string rangeOfString:@&quot;,&quot; options:NSBackwardsSearch];</span><br><span class="line">    if (range.location != NSNotFound)</span><br><span class="line">    [string deleteCharactersInRange:range];</span><br><span class="line"></span><br><span class="line">    return string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="3-添加类目，重写description方法：转换成json格式字符串"><a href="#3-添加类目，重写description方法：转换成json格式字符串" class="headerlink" title="3.添加类目，重写description方法：转换成json格式字符串"></a>3.添加类目，重写description方法：转换成json格式字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@implementation NSDictionary (Log)</span><br><span class="line">- (NSString *)description</span><br><span class="line">&#123;</span><br><span class="line">    NSData *jsonData = [NSJSONSerialization dataWithJSONObject:self options:NSJSONWritingPrettyPrinted error:nil];</span><br><span class="line">    NSString *jsonStr = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];</span><br><span class="line"></span><br><span class="line">    return jsonStr;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation NSArray (Log)</span><br><span class="line"></span><br><span class="line">- (NSString *)description</span><br><span class="line">&#123;</span><br><span class="line">    NSData *jsonData = [NSJSONSerialization dataWithJSONObject:self options:NSJSONWritingPrettyPrinted error:nil];</span><br><span class="line">    NSString *jsonStr = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];</span><br><span class="line">    </span><br><span class="line">    return jsonStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Xcode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>P3图片导致iOS9.3以下崩溃的解决</title>
      <link href="/2017/12/12/P3%E5%9B%BE%E7%89%87%E5%AF%BC%E8%87%B4iOS9-3%E4%BB%A5%E4%B8%8B%E5%B4%A9%E6%BA%83%E7%9A%84%E8%A7%A3%E5%86%B3/"/>
      <url>/2017/12/12/P3%E5%9B%BE%E7%89%87%E5%AF%BC%E8%87%B4iOS9-3%E4%BB%A5%E4%B8%8B%E5%B4%A9%E6%BA%83%E7%9A%84%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<ul><li>这种问题一般在Xcode上运行正常，真机测试运行正常，打包上传到蒲公英下载安装运行正常，只有上传到AppStore下载安装才会崩溃。<a id="more"></a></li><li>导致这种问题的原因是：在 Xcode 8 中，当你资源文件中[含有16位图]或者[图片显示模式γ值为’P3’]且iOS targets设定为iOS 9.3以下就会出现这个问题. 如果你的app需要支持广色域显示的话，那你必须得把target设置成iOS 9.3+，相反，如果你的app不需要支持广色域且你想兼容 iOS 9.3 之前的项目，你就得把所有的16位的或者显示模式为’P3’图片全都替换成8位模式的SRGB颜色的图片。</li></ul><h3 id="解决方案如下："><a href="#解决方案如下：" class="headerlink" title="解决方案如下："></a>解决方案如下：</h3><p>1.导出项目的ipa文件<br>2.修改.ipa后缀为.zip<br>3.解压.zip文件，会生成一个Payload文件夹，文件夹下包含项目的app bundle文件<br>4.打开终端，切换到app bundle文佳夹，定位到Assets.car文件，使用assetutil命令找到包含16-bit或P3的资源文件，将分析结果导出到json文件中，命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd /path/Payload/XXX.app/</span><br><span class="line">$ find . -name &apos;Assets.car&apos;</span><br><span class="line">./Assets.car</span><br><span class="line">$ sudo xcrun --sdk iphoneos assetutil --info ./Assets.car &gt; /tmp/Assets.json    //./Assets.ca为上一步查找的结果  /tmp/Assets.json为导出的json文件路径</span><br><span class="line">$ open /tmp/Assets.json</span><br></pre></td></tr></table></figure></p><p>5.在json文件中查找包含<code>&quot;DisplayGamut&quot; : &quot;P3&quot;</code>的相关内容，<code>&quot;Name&quot; : &quot;picBroken&quot;</code>为对应图片名称，修改替换对应图片文件。json文件格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;Opaque&quot; : false,</span><br><span class="line">&quot;Compression&quot; : &quot;lzfse&quot;,</span><br><span class="line">&quot;SizeOnDisk&quot; : 5968,</span><br><span class="line">&quot;PixelHeight&quot; : 192,</span><br><span class="line">&quot;Name&quot; : &quot;picBroken&quot;,</span><br><span class="line">&quot;RenditionName&quot; : &quot;picBroken@3x.png&quot;,</span><br><span class="line">&quot;ColorModel&quot; : &quot;Monochrome&quot;,</span><br><span class="line">&quot;Scale&quot; : 3,</span><br><span class="line">&quot;Idiom&quot; : &quot;universal&quot;,</span><br><span class="line">&quot;DisplayGamut&quot; : &quot;P3&quot;,</span><br><span class="line">&quot;Encoding&quot; : &quot;GRAY-16&quot;,</span><br><span class="line">&quot;BitsPerComponent&quot; : 16,</span><br><span class="line">&quot;Image Type&quot; : &quot;kCoreThemeOnePartScale&quot;,</span><br><span class="line">&quot;Colorspace&quot; : &quot;extended gray&quot;,</span><br><span class="line">&quot;AssetType&quot; : &quot;Image&quot;,</span><br><span class="line">&quot;PixelWidth&quot; : 192</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>补充：</p><ul><li>iOS Console：可以脱离xcode打印log，以及打印ios系统收集的crash 日志。</li><li>BashShell：命令行打包</li></ul><p>参考文章：<a href="http://www.sohu.com/a/145632913_487493" target="_blank" rel="noopener">P3图片导致iOS9.3以下崩溃问题</a><br><a href="http://www.jianshu.com/p/6492779cb89e" target="_blank" rel="noopener">iOS线上版本图片资源格式的问题导致的闪退</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>项目中的实用技巧</title>
      <link href="/2017/12/07/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/2017/12/07/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="setExclusiveTouch"><a href="#setExclusiveTouch" class="headerlink" title="setExclusiveTouch"></a>setExclusiveTouch</h3><ul><li>避免在一个界面上同时点击多个UIButton导致同时响应多个方法，在AppDelegate启动应用时添加：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[UIButton appearance] setExclusiveTouch:YES];</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><h3 id="给AppDelegate添加类目"><a href="#给AppDelegate添加类目" class="headerlink" title="给AppDelegate添加类目"></a>给AppDelegate添加类目</h3><h3 id="AppDelegate中微信、支付宝支付接收到的回调可以分别添加helper处理"><a href="#AppDelegate中微信、支付宝支付接收到的回调可以分别添加helper处理" class="headerlink" title="AppDelegate中微信、支付宝支付接收到的回调可以分别添加helper处理"></a>AppDelegate中微信、支付宝支付接收到的回调可以分别添加helper处理</h3><h3 id="判断程序是否是从杀死状态进入-接受远程推送"><a href="#判断程序是否是从杀死状态进入-接受远程推送" class="headerlink" title="判断程序是否是从杀死状态进入(接受远程推送)"></a>判断程序是否是从杀死状态进入(接受远程推送)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary * userInfo = [launchOptions objectForKey:UIApplicationLaunchOptionsRemoteNotificationKey];</span><br></pre></td></tr></table></figure><h3 id="实例方法调用类方法-self-class"><a href="#实例方法调用类方法-self-class" class="headerlink" title="实例方法调用类方法 [self class]"></a>实例方法调用类方法 [self class]</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[self class] funA];</span><br><span class="line"></span><br><span class="line">+ (void)funA &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="修改类文件名"><a href="#修改类文件名" class="headerlink" title="修改类文件名"></a>修改类文件名</h3><ul><li>在类的.h文件中右击<code>@interface AppDelegate</code>选中类名，选择Refactor-&gt;Rename，修改完成保存即可。</li></ul><h3 id="字典拼接"><a href="#字典拼接" class="headerlink" title="字典拼接"></a>字典拼接</h3><p>addEntriesFromDictionary是NSMutableDictionary的一个方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[dic1 addEntriesFromDictionary:dic2];</span><br></pre></td></tr></table></figure></p><h3 id="用枚举表示状态、选项、状态码"><a href="#用枚举表示状态、选项、状态码" class="headerlink" title="用枚举表示状态、选项、状态码"></a>用枚举表示状态、选项、状态码</h3><p>typedef NS_ENUM(NSInteger, UITableViewStyle) {<br>UITableViewStylePlain,      // regular table view<br>UITableViewStyleGrouped     // preferences style table view<br>};</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技巧 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用TestFlight构建APP版本测试</title>
      <link href="/2017/12/06/%E4%BD%BF%E7%94%A8TestFlight%E6%9E%84%E5%BB%BAAPP%E7%89%88%E6%9C%AC%E6%B5%8B%E8%AF%95/"/>
      <url>/2017/12/06/%E4%BD%BF%E7%94%A8TestFlight%E6%9E%84%E5%BB%BAAPP%E7%89%88%E6%9C%AC%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-两种测试"><a href="#1-两种测试" class="headerlink" title="1.两种测试"></a>1.两种测试</h2><ul><li>内部测试：测试人员上限25个        无需审核</li><li>外部测试：测试人员上限2000个    需要审核，一天左右<a id="more"></a></li><li>一个版本有效期是60天，如果要继续使用，在过期前提交新版本。</li></ul><h2 id="2-构建内部beta测试"><a href="#2-构建内部beta测试" class="headerlink" title="2.构建内部beta测试"></a>2.构建内部beta测试</h2><p>iTunes Connect-&gt;Users and Roles-&gt;add user</p><ul><li>角色权限</li></ul><table><thead><tr><th></th><th style="text-align:center">Admin</th><th style="text-align:center">App Manager</th><th style="text-align:center">Developer</th><th style="text-align:center">Marketer</th><th style="text-align:center">Sales</th></tr></thead><tbody><tr><td>Can be an internal tester</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">N</td></tr><tr><td>can upload a build</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">N</td><td style="text-align:center">N</td></tr><tr><td>can submit a build for external testing</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">N</td><td style="text-align:center">N</td><td style="text-align:center">N</td></tr></tbody></table><p>My Apps-&gt;Activity-&gt;TestFlight-&gt;Select Version to Test-&gt;Start Testing</p><h2 id="3-构建外部beta测试"><a href="#3-构建外部beta测试" class="headerlink" title="3.构建外部beta测试"></a>3.构建外部beta测试</h2><p>My Apps-&gt;Activity-&gt;Test Information-&gt;填写信息-&gt;External Testing-&gt;Add New Testers-&gt;Add Build To Test-&gt;submit<br>通过审核后，External Testing-&gt;build and hit-&gt;Start Testing</p><h2 id="4-开始测试"><a href="#4-开始测试" class="headerlink" title="4.开始测试"></a>4.开始测试</h2><p>内部测试： Apple ID 连接到iTunes Connect，新版本上传到iTunes Connect，收到邮件。<br>外部测试：版本审核通过，Admin或App Manager在iTunes Connect推送给外部测试，收到邮件。</p><p>App Store下载TestFlight，打开邮件，点击Start Testing，安装下载。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iPhoneX适配笔记</title>
      <link href="/2017/12/05/iPhoneX%E9%80%82%E9%85%8D%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/12/05/iPhoneX%E9%80%82%E9%85%8D%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-设置iPhoneX启动图片"><a href="#1-设置iPhoneX启动图片" class="headerlink" title="1.设置iPhoneX启动图片"></a>1.设置iPhoneX启动图片</h2><a id="more"></a><ul><li>屏幕尺寸：5.8 英寸</li><li>屏幕密度：458 ppi</li><li>开发尺寸：375*812 pt</li><li>像素尺寸：1125*2436 px</li><li>倍图：@3x</li></ul><h2 id="2-safeArea"><a href="#2-safeArea" class="headerlink" title="2.safeArea"></a>2.safeArea</h2><ul><li>顶部有刘海： 状态栏44+导航栏44</li><li>底部有手势区域：bottom 34</li><li>四周有圆角</li></ul><h3 id="控制器生命周期"><a href="#控制器生命周期" class="headerlink" title="控制器生命周期"></a>控制器生命周期</h3><ul><li>viewDidLoad</li><li>viewWillAppear</li><li>viewSafeAreaInsetsDidChange（NEW）</li><li>viewWillLayoutSubviews</li><li>viewDidAppear</li></ul><p>可以在viewSafeAreaInsetsDidChange后，设置safe area：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if #available(iOS 11.0, *) &#123;</span><br><span class="line">self.additionalSafeAreaInsets = UIEdgeInsetsMake(10, 0, 0, 34)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="宏定义高度"><a href="#宏定义高度" class="headerlink" title="宏定义高度"></a>宏定义高度</h3><ul><li><p>适配iPhone x 导航栏高度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define STATUSBAR_HEIGHT [[UIApplication sharedApplication] statusBarFrame].size.height</span><br><span class="line">#define NAV_HEIGHT (STATUSBAR_HEIGHT + 44)</span><br></pre></td></tr></table></figure></li><li><p>适配iPhone x 底栏高度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define TabbarHeight     ([[UIApplication sharedApplication] statusBarFrame].size.height&gt;20?83:49)</span><br></pre></td></tr></table></figure></li></ul><h2 id="待补充"><a href="#待补充" class="headerlink" title="待补充"></a>待补充</h2>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 适配 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS分析友盟的错误报告定位错误代码位置</title>
      <link href="/2017/11/06/iOS%E5%88%86%E6%9E%90%E5%8F%8B%E7%9B%9F%E7%9A%84%E9%94%99%E8%AF%AF%E6%8A%A5%E5%91%8A%E5%AE%9A%E4%BD%8D%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%81%E4%BD%8D%E7%BD%AE/"/>
      <url>/2017/11/06/iOS%E5%88%86%E6%9E%90%E5%8F%8B%E7%9B%9F%E7%9A%84%E9%94%99%E8%AF%AF%E6%8A%A5%E5%91%8A%E5%AE%9A%E4%BD%8D%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%81%E4%BD%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="命令行方式"><a href="#命令行方式" class="headerlink" title="命令行方式"></a>命令行方式</h2><h3 id="1-在Xcode的Windows-gt-Orgnizer-gt-Archives可以看到每次的打包，找到要查看的错误报告所在的版本。"><a href="#1-在Xcode的Windows-gt-Orgnizer-gt-Archives可以看到每次的打包，找到要查看的错误报告所在的版本。" class="headerlink" title="1.在Xcode的Windows-&gt;Orgnizer-&gt;Archives可以看到每次的打包，找到要查看的错误报告所在的版本。"></a>1.在Xcode的Windows-&gt;Orgnizer-&gt;Archives可以看到每次的打包，找到要查看的错误报告所在的版本。</h3><ul><li>/Users/&lt;用户名&gt;/Library/Developer/Xcode/Archives 路径下是所有打包文件</li></ul><a id="more"></a><h3 id="2-show-in-Finder，查看包内容，将-dSYM文件和-app复制保存到一个新的文件夹crash。"><a href="#2-show-in-Finder，查看包内容，将-dSYM文件和-app复制保存到一个新的文件夹crash。" class="headerlink" title="2.show in Finder，查看包内容，将.dSYM文件和.app复制保存到一个新的文件夹crash。"></a>2.show in Finder，查看包内容，将<code>.dSYM</code>文件和<code>.app</code>复制保存到一个新的文件夹crash。</h3><h3 id="3-使用终端"><a href="#3-使用终端" class="headerlink" title="3.使用终端"></a>3.使用终端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd crash</span><br><span class="line">xcrun atos -arch arm64 -o XXX.app/XXX 0x1000e7068</span><br></pre></td></tr></table></figure><ul><li><code>arm64</code>为CPU Type</li><li><code>XXX</code>为项目名称</li><li><code>0x1000e7068</code>为错误代码的地址</li></ul><p>使用以上命令即可得到错误代码所在的文件以及出错代码的具体行数。</p><h2 id="使用工具软件"><a href="#使用工具软件" class="headerlink" title="使用工具软件"></a>使用工具软件</h2><p>下载地址：<a href="https://github.com/answer-huang/dSYMTools" target="_blank" rel="noopener">dSYMTools</a></p><ul><li>如何将文件一一对应：xxx.app 、 xxx.app.dSYM 和crash 文件都有自己的 UUID，只要这三个文件的 UUID 一致，就可以解析出正确的错误函数信息。</li></ul><p>1.查看 xx.app 文件的 UUID：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dwarfdump --uuid xxx.app/xxx (xxx代表项目名)</span><br></pre></td></tr></table></figure></p><p>2.查看 xx.app.dSYM 文件的 UUID：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dwarfdump --uuid xxx.app.dSYM</span><br></pre></td></tr></table></figure></p><p>3.crash 文件内第一行 Incident Identifier 就是 crash 文件的 UUID。</p><h2 id="使用xcode自带的工具symbolicatecrash"><a href="#使用xcode自带的工具symbolicatecrash" class="headerlink" title="使用xcode自带的工具symbolicatecrash"></a>使用xcode自带的工具symbolicatecrash</h2><p>参考文章：<a href="http://www.jianshu.com/p/17fd659df460?open_source=weibo_search" target="_blank" rel="noopener">如何通过友盟的错误分析报告，定位到错误代码的位置</a></p><p><a href="http://www.cocoachina.com/ios/20141219/10694.html" target="_blank" rel="noopener">dSYM 文件分析工具</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>iOS报错信息详解</title>
      <link href="/2017/11/06/iOS%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF%E8%AF%A6%E8%A7%A3/"/>
      <url>/2017/11/06/iOS%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="duplicate-symbols-for-architecture-x86-64"><a href="#duplicate-symbols-for-architecture-x86-64" class="headerlink" title="duplicate symbols for architecture x86_64"></a>duplicate symbols for architecture x86_64</h2><ul><li><p>原因：1.在工程中不同路径下重复导入了某个类或文件；  2.引用了.m文件，#import “XXX.m”； 3.多个文件中重复定义了相同的枚举等</p></li><li><p>解决：1.查找，删除； 2.查找，修改； 3.查找，删除。 如果还是不能解决，试着删除该文件，重新添加。</p></li></ul><a id="more"></a><h2 id="invalid-mode-‘kCFRunLoopCommonModes’-provided-to-CFRunLoopRunSpecific-break-on-CFRunLoopError-RunCalledWithInvalidMode-to-debug-This-message-will-only-appear-once-per-execution"><a href="#invalid-mode-‘kCFRunLoopCommonModes’-provided-to-CFRunLoopRunSpecific-break-on-CFRunLoopError-RunCalledWithInvalidMode-to-debug-This-message-will-only-appear-once-per-execution" class="headerlink" title="invalid mode ‘kCFRunLoopCommonModes’ provided to CFRunLoopRunSpecific - break on _CFRunLoopError_RunCalledWithInvalidMode to debug. This message will only appear once per execution."></a>invalid mode ‘kCFRunLoopCommonModes’ provided to CFRunLoopRunSpecific - break on _CFRunLoopError_RunCalledWithInvalidMode to debug. This message will only appear once per execution.</h2><ul><li><p>原因：数组未初始化</p></li><li><p>解决：初始化数组</p></li></ul><h2 id="“-OBJC-CLASS-XXX”-referenced-from"><a href="#“-OBJC-CLASS-XXX”-referenced-from" class="headerlink" title="“_OBJC_CLASS_$_XXX”, referenced from"></a>“_OBJC_CLASS_$_XXX”, referenced from</h2><ul><li><p>原因：缺少文件，或文件未参与编译，framework 没导入，真机和测试也要注意，.m文件为参与编译</p></li><li><p>解决：在build Phases-&gt;Compile Sources 中添加相应的类文件</p></li></ul><h2 id="index-0-beyond-bounds-for-empty-array"><a href="#index-0-beyond-bounds-for-empty-array" class="headerlink" title="index 0 beyond bounds for empty array"></a>index 0 beyond bounds for empty array</h2><ul><li><p>原因：数组越界，index 0 在空数组中也是越界，不存在。取到的值是NSNull  对象。 它表示空值，只有一个方法。调用NSArray的属性方法，程序会dump。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface NSNull : NSObject &lt;NSCopying,NSSecureCoding&gt;</span><br><span class="line"></span><br><span class="line">+ (NSNull *)null;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li><li><p>解决：判断array 不为空</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (array != nil &amp;&amp; ![array isKindOfClass:[NSNull class]] &amp;&amp; array.count != 0)</span><br></pre></td></tr></table></figure></li></ul><h2 id="待补充"><a href="#待补充" class="headerlink" title="待补充"></a>待补充</h2>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Xcode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS-让代码更规范</title>
      <link href="/2017/10/26/iOS-%E8%AE%A9%E4%BB%A3%E7%A0%81%E6%9B%B4%E8%A7%84%E8%8C%83/"/>
      <url>/2017/10/26/iOS-%E8%AE%A9%E4%BB%A3%E7%A0%81%E6%9B%B4%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h2 id="使用字面量语法"><a href="#使用字面量语法" class="headerlink" title="使用字面量语法"></a>使用字面量语法</h2><h2 id="换行，空格"><a href="#换行，空格" class="headerlink" title="换行，空格"></a>换行，空格</h2><h2 id="使用枚举表示状态"><a href="#使用枚举表示状态" class="headerlink" title="使用枚举表示状态"></a>使用枚举表示状态</h2><a id="more"></a><h2 id="使用分类简化代码"><a href="#使用分类简化代码" class="headerlink" title="使用分类简化代码"></a>使用分类简化代码</h2><h2 id="使用description方法查看日志"><a href="#使用description方法查看日志" class="headerlink" title="使用description方法查看日志"></a>使用description方法查看日志</h2><h2 id="使用多target区分正式环境和开发环境"><a href="#使用多target区分正式环境和开发环境" class="headerlink" title="使用多target区分正式环境和开发环境"></a>使用多target区分正式环境和开发环境</h2><h2 id="解耦MVC"><a href="#解耦MVC" class="headerlink" title="解耦MVC"></a>解耦MVC</h2>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 规范 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS11适配注意点</title>
      <link href="/2017/10/16/iOS11%E9%80%82%E9%85%8D%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
      <url>/2017/10/16/iOS11%E9%80%82%E9%85%8D%E6%B3%A8%E6%84%8F%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="1-UIBarItem"><a href="#1-UIBarItem" class="headerlink" title="1.UIBarItem"></a>1.UIBarItem</h2><h3 id="landscapeImagePhone：横屏时，长按item，item放大显示在hud上"><a href="#landscapeImagePhone：横屏时，长按item，item放大显示在hud上" class="headerlink" title="landscapeImagePhone：横屏时，长按item，item放大显示在hud上"></a>landscapeImagePhone：横屏时，长按item，item放大显示在hud上</h3><a id="more"></a><h2 id="2-navigationItem"><a href="#2-navigationItem" class="headerlink" title="2.navigationItem"></a>2.navigationItem</h2><h3 id="largeTitleDisplayMode：控制大标题的显示"><a href="#largeTitleDisplayMode：控制大标题的显示" class="headerlink" title="largeTitleDisplayMode：控制大标题的显示"></a>largeTitleDisplayMode：控制大标题的显示</h3><h2 id="3-UISearchController"><a href="#3-UISearchController" class="headerlink" title="3.UISearchController"></a>3.UISearchController</h2><h3 id="navigationItem-searchController-将UISearchController集成到Navigation"><a href="#navigationItem-searchController-将UISearchController集成到Navigation" class="headerlink" title="navigationItem.searchController  //将UISearchController集成到Navigation"></a>navigationItem.searchController  //将UISearchController集成到Navigation</h3><h3 id="navigationItem-hidesSearchBarWhenScrolling-决定滑动的时候是否隐藏搜索框；iOS-11-新增属性"><a href="#navigationItem-hidesSearchBarWhenScrolling-决定滑动的时候是否隐藏搜索框；iOS-11-新增属性" class="headerlink" title="navigationItem.hidesSearchBarWhenScrolling //决定滑动的时候是否隐藏搜索框；iOS 11 新增属性"></a>navigationItem.hidesSearchBarWhenScrolling //决定滑动的时候是否隐藏搜索框；iOS 11 新增属性</h3><h2 id="4-automaticallyAdjustsScrollViewInsets"><a href="#4-automaticallyAdjustsScrollViewInsets" class="headerlink" title="4.automaticallyAdjustsScrollViewInsets"></a>4.automaticallyAdjustsScrollViewInsets</h2><p>在iOS11之前，如果想要scrollView不偏移64p，则需设置automaticallyAdjustsScrollViewInsets=NO，但是这个属性在iOS11直接被遗弃了，解决方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (@available(iOS 11.0, *)) &#123;</span><br><span class="line">self.tableView.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">self.automaticallyAdjustsScrollViewInsets = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="5-UIScrollView-amp-UITableVIew-iOS11开启了Self-Sizing行高估算机制"><a href="#5-UIScrollView-amp-UITableVIew-iOS11开启了Self-Sizing行高估算机制" class="headerlink" title="5.UIScrollView &amp; UITableVIew iOS11开启了Self-Sizing行高估算机制"></a>5.UIScrollView &amp; UITableVIew iOS11开启了Self-Sizing行高估算机制</h2><ul><li><p>解决方法一 ：添加实现View的代理方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (UIView *)tableView:(UITableView *)tableView viewForFooterInSection:(NSInteger)section &#123;</span><br><span class="line">return nil;</span><br><span class="line">&#125;</span><br><span class="line">- (UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section &#123;</span><br><span class="line">return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解决方法二：添加以下代码关闭估算行高：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.tableView.estimatedRowHeight = 0;</span><br><span class="line">self.tableView.estimatedSectionHeaderHeight = 0;</span><br><span class="line">self.tableView.estimatedSectionFooterHeight = 0;</span><br></pre></td></tr></table></figure></li></ul><h3 id="如果使用了Masonry-进行布局，需要适配safeArea"><a href="#如果使用了Masonry-进行布局，需要适配safeArea" class="headerlink" title="如果使用了Masonry 进行布局，需要适配safeArea"></a>如果使用了Masonry 进行布局，需要适配safeArea</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if ([UIDevice currentDevice].systemVersion.floatValue &gt;= 11.0) &#123;</span><br><span class="line">make.edges.equalTo(self.view.safeAreaInsets);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">make.edges.equalTo(self.view);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="待补充"><a href="#待补充" class="headerlink" title="待补充"></a>待补充</h2>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 适配 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cocoapods安装与使用</title>
      <link href="/2017/08/14/cocoapods%E5%AE%89%E8%A3%85/"/>
      <url>/2017/08/14/cocoapods%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="cocoapods的安装"><a href="#cocoapods的安装" class="headerlink" title="cocoapods的安装"></a>cocoapods的安装</h2><p>1.安装过程中如果出现以下错误提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR:  While executing gem ... (OpenSSL::SSL::SSLError)</span><br><span class="line">    hostname &quot;rubygems-china.oss.aliyuncs.com&quot; does not match the server certificate</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>移除镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem sources --remove https://rubygems.org/</span><br></pre></td></tr></table></figure></p><p>使用<code>https://gems.ruby-china.com/</code>镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem sources -a https://gems.ruby-china.com/</span><br></pre></td></tr></table></figure></p><p>2.查看镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem sources -l</span><br></pre></td></tr></table></figure></p><p>3.安装cocoapods：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install -n /usr/local/bin cocoapods</span><br></pre></td></tr></table></figure></p><h3 id="安装Homebrew"><a href="#安装Homebrew" class="headerlink" title="安装Homebrew"></a>安装Homebrew</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br><span class="line">$ curl -LsSf http://github.com/mxcl/homebrew/tarball/master | sudo tar xvz -C/usr/local --strip 1</span><br><span class="line">Error: /usr/local must be writable!</span><br><span class="line">$ sudo chown -R $(whoami) /usr/local</span><br><span class="line">$ brew update     //更新版本</span><br><span class="line">$ brew doctor     //检查是否安装成功</span><br><span class="line">Your system is ready to brew.</span><br></pre></td></tr></table></figure><h3 id="安装npm和node"><a href="#安装npm和node" class="headerlink" title="安装npm和node"></a>安装npm和node</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew install node</span><br><span class="line">npm -v      //查看npm是否安装成功</span><br><span class="line">node -v     //查看node是否安装成功</span><br></pre></td></tr></table></figure><h2 id="cocoapods的使用"><a href="#cocoapods的使用" class="headerlink" title="cocoapods的使用"></a>cocoapods的使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//拉取最新pod库时间较长</span><br><span class="line">pod setup</span><br><span class="line">vim Podfile</span><br><span class="line">pod install</span><br><span class="line">//配置完成后在 Podfile 所在目录执行更新</span><br><span class="line">pod update</span><br></pre></td></tr></table></figure><p>Podfile：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, ’9.0’</span><br><span class="line">target &apos;xxx&apos; do</span><br><span class="line">use_frameworks!</span><br><span class="line">pod &apos;AFNetworking&apos;</span><br><span class="line">pod &apos;SDWebImage&apos;</span><br><span class="line">pod &apos;MJExtension&apos;</span><br><span class="line">pod &apos;MJRefresh&apos;</span><br><span class="line">pod &apos;MBProgressHUD&apos;</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>在swift中配置Podfile文件时要加上 <code>use_frameworks!</code> ，作用是把三方库打包成静态库。</p><h3 id="Project-Document-Project-Format"><a href="#Project-Document-Project-Format" class="headerlink" title="Project Document-Project Format"></a>Project Document-Project Format</h3>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cocoapods </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SVN使用</title>
      <link href="/2017/08/04/SVN%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/08/04/SVN%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="命令帮助"><a href="#命令帮助" class="headerlink" title="命令帮助"></a>命令帮助</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ svn help  //svn命令帮助</span><br><span class="line">$ svn htlp add  //svn具体功能帮助</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="创建svn版本库"><a href="#创建svn版本库" class="headerlink" title="创建svn版本库"></a>创建svn版本库</h2><p>(1)创建仓库路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ svnadmin create svnrepo</span><br><span class="line">$ cd svnrepo</span><br></pre></td></tr></table></figure></p><p>(2)导入项目源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ svn import [本地路径][目标版本库路径] -m [description]</span><br></pre></td></tr></table></figure></p><p>(3)修改配置文件 passwd</p><ul><li><p>添加用户名和密码，格式：<code>用户名 = 密码</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd conf/</span><br><span class="line">$ vi passwd</span><br></pre></td></tr></table></figure></li><li><p>修改启动项参数 svnserve.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vi svnserve.conf</span><br></pre></td></tr></table></figure></li></ul><p>将下面几行代码打开，将前面的注释<code>#</code>删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">anon-access = read</span><br><span class="line">auth-access = write</span><br><span class="line">...</span><br><span class="line">password-db = passwd</span><br><span class="line">...</span><br><span class="line">authz-db = authz</span><br></pre></td></tr></table></figure></p><ul><li>配置用户权限 authz<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[groups]</span><br><span class="line"># harry_and_sally = harry,sally</span><br><span class="line"># harry_sally_and_joe = harry,sally,&amp;joe</span><br><span class="line">admin = admin   //配置admin</span><br><span class="line"># [/foo/bar]</span><br><span class="line"># harry = rw</span><br><span class="line"># &amp;joe = r</span><br><span class="line"># * =</span><br><span class="line">[/]</span><br><span class="line">@admin=rw       //配置admin读写权限</span><br><span class="line">* = r</span><br><span class="line"># [repository:/baz/fuz]</span><br><span class="line"># @harry_and_sally = rw</span><br><span class="line"># * = r</span><br></pre></td></tr></table></figure></li></ul><p>(4)启动svn服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svnserve -d -r svnrepo</span><br></pre></td></tr></table></figure></p><h2 id="导入项目"><a href="#导入项目" class="headerlink" title="导入项目"></a>导入项目</h2><ul><li>svn import<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd svndemo</span><br><span class="line">$ svn import svndemo http://... --message &quot;start&quot;</span><br></pre></td></tr></table></figure></li></ul><h2 id="导出项目"><a href="#导出项目" class="headerlink" title="导出项目"></a>导出项目</h2><ul><li><p>svn checkout 导出的代码在版本控制下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ svn checkout https://... --username zhangsan</span><br><span class="line">$ svn checkout svn://... --username zhangsan</span><br></pre></td></tr></table></figure></li><li><p>svn export 导出的代码不在版本控制下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ svn export [-r version] https://... --username zhangsan</span><br></pre></td></tr></table></figure></li></ul><h2 id="添加新文件"><a href="#添加新文件" class="headerlink" title="添加新文件"></a>添加新文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp; svn add test.txt</span><br></pre></td></tr></table></figure><h2 id="提交修改"><a href="#提交修改" class="headerlink" title="提交修改"></a>提交修改</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp; svn commit -m &quot;description&quot;</span><br></pre></td></tr></table></figure><h2 id="更新文件"><a href="#更新文件" class="headerlink" title="更新文件"></a>更新文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ svn update [-r version] filename</span><br></pre></td></tr></table></figure><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ svn delete svn://... -m &quot;description&quot;</span><br></pre></td></tr></table></figure><h2 id="比较差异"><a href="#比较差异" class="headerlink" title="比较差异"></a>比较差异</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ svn diff [-r version] filename</span><br><span class="line">$ svn diff &gt; file   //输出diff信息到文件</span><br></pre></td></tr></table></figure><h2 id="加锁-解锁"><a href="#加锁-解锁" class="headerlink" title="加锁/解锁"></a>加锁/解锁</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ svn lock -m &quot;description&quot; [--force] filename</span><br><span class="line">$ svn unlock filename</span><br></pre></td></tr></table></figure><h2 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ svn status</span><br></pre></td></tr></table></figure><h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><ul><li><p>可以查看文件的所有修改记录和版本号变化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ svn log filename</span><br></pre></td></tr></table></figure></li><li><p>查看文件详细信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ svn info filename</span><br></pre></td></tr></table></figure></li></ul><h2 id="查看SVN版本库下的文件和目录列表"><a href="#查看SVN版本库下的文件和目录列表" class="headerlink" title="查看SVN版本库下的文件和目录列表"></a>查看SVN版本库下的文件和目录列表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ svn list svn://...</span><br></pre></td></tr></table></figure><h2 id="创建新目录，加入版本控制"><a href="#创建新目录，加入版本控制" class="headerlink" title="创建新目录，加入版本控制"></a>创建新目录，加入版本控制</h2><ul><li>可以查看文件的所有修改记录和版本号变化<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ svn mkdir [-m &quot;description&quot;] svn://...</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>添加完子目录后，一定要回到根目录下更新一下，否则在该目录下提交文件会提示“提交失败”</p></blockquote><h2 id="丢弃本地修改"><a href="#丢弃本地修改" class="headerlink" title="丢弃本地修改"></a>丢弃本地修改</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ svn revert [--recursive] filename</span><br><span class="line">$ svn revert --recursive .  //丢弃整个目录的本地修改</span><br></pre></td></tr></table></figure><h2 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h2><ul><li><p>发生冲突时会生成与冲突文件同名的三个文件：.mine, .rOLDREV, .rNEWREV，例如a.txt发生冲突：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a.txt</span><br><span class="line">a.txt.mine</span><br><span class="line">a.txt.r1</span><br><span class="line">a.txt.r2</span><br></pre></td></tr></table></figure></li><li><p>解决冲突的三种方式<br>(1)修改冲突，然后执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ svn resolved</span><br></pre></td></tr></table></figure></li></ul><p>(2)使用库里的新版本代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cp a.txt.r2 a.txt</span><br><span class="line">$ svn resolved a.txt</span><br></pre></td></tr></table></figure></p><p>(3)撤销修改，使用旧版本代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ svn revert a.txt</span><br></pre></td></tr></table></figure></p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><ul><li>一般项目创建三个分支：<br>(1)trunk是主分支，是日常开发进行的地方,一般包含： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0-Src                       源码</span><br><span class="line">1-DevelopDoc         开发文档</span><br><span class="line">2-ProductDoc           产品文档</span><br><span class="line">3-ThirdPartyTools     第三方工具（插件）</span><br><span class="line">4-Testing                   测试</span><br><span class="line">5-DeployDoc             部署文档</span><br></pre></td></tr></table></figure></li></ul><p>(2)branches，开发分支。阶段性的release版本。</p><p>(3)tags，标签分支。一般是只读的，存储阶段性的发布版本。</p><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ svn copy branchA branchB -m &quot;make B banch&quot;</span><br><span class="line">* 使用分支的两种分支</span><br></pre></td></tr></table></figure><p>(1)先拷贝本地分支然后提交：checkout-&gt;copy-&gt;commit<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ svn checkout serverBranchA</span><br><span class="line">$ svn copy localBranchA localBranchB</span><br><span class="line">$ svn commit -m &quot;make B banch&quot;</span><br></pre></td></tr></table></figure></p><p>(2)直接远程拷贝分支：copy-&gt;checkout<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ svn copy serverBranchA serverBranchB -m &quot;make B banch&quot;</span><br><span class="line">$ svn checkout serverBranchB</span><br></pre></td></tr></table></figure></p><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ svn info | grep URL   //branchA</span><br><span class="line">$ svn switch serverBranchB</span><br><span class="line">$ svn info | grep URL   //branchB</span><br><span class="line">``</span><br><span class="line"></span><br><span class="line">### 合并分支</span><br></pre></td></tr></table></figure><p>$ svn merge branchA branchB  // 把对branchA的修改合并到分支branchB<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 删除分支</span><br></pre></td></tr></table></figure></p><p>$ svn delete serverBranchB -m “delete branch B”<br><code>`</code></p><h2 id="svn-cleanup"><a href="#svn-cleanup" class="headerlink" title="svn cleanup"></a>svn cleanup</h2>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SVN </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift项目中的注意点</title>
      <link href="/2017/08/03/Swift%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
      <url>/2017/08/03/Swift%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="swift与OC的区别"><a href="#swift与OC的区别" class="headerlink" title="swift与OC的区别"></a>swift与OC的区别</h2><ul><li>注意: Swift开发中定义变量时候先用let(常量), 只有真正需要修改时才用var</li><li>由于编译器可以通过赋值的类型自动推导出数据的真实类型, 所以在Swift开发中, 能不写数据类型就不写数据类型<a id="more"></a></li><li>Swift 对类型校验更加严格，不同类型的变量不允许直接计算</li><li>Swift语法允许我们直接修改一个对象的结构体属性的成员</li><li><p>一般情况下只有需要区分两个变量, 或者在闭包中访问外界属性才需要加上self，可以提醒程序员主动思考当前self会不会形成循环引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">titleLabel?.frame.origin.x = 0</span><br></pre></td></tr></table></figure></li><li><p>一般在本类中的扩展中实现代理方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extension QRCodeViewController: UINavigationControllerDelegate, UIImagePickerControllerDelegate</span><br></pre></td></tr></table></figure></li></ul><h1 id="day-1"><a href="#day-1" class="headerlink" title="day 1"></a>day 1</h1><h2 id="创建项目准备工作"><a href="#创建项目准备工作" class="headerlink" title="创建项目准备工作"></a>创建项目准备工作</h2><h3 id="删除模板文件"><a href="#删除模板文件" class="headerlink" title="删除模板文件"></a>删除模板文件</h3><ul><li>ViewController.swift</li><li>Main.storyboard</li><li>LaunchScreen.xib</li></ul><h3 id="创建项目结构"><a href="#创建项目结构" class="headerlink" title="创建项目结构"></a>创建项目结构</h3><h4 id="主目录-Classes"><a href="#主目录-Classes" class="headerlink" title="主目录 Classes"></a>主目录 <code>Classes</code></h4><h4 id="二级目录"><a href="#二级目录" class="headerlink" title="二级目录"></a>二级目录</h4><table><thead><tr><th>目录名</th><th>说明</th></tr></thead><tbody><tr><td>Main</td><td>主要</td></tr><tr><td>Home</td><td>首页</td></tr><tr><td>Message</td><td>消息</td></tr><tr><td>Discover</td><td>发现</td></tr><tr><td>Profile</td><td>我</td></tr><tr><td>Tools</td><td>工具类</td></tr></tbody></table><h3 id="创建项目文件"><a href="#创建项目文件" class="headerlink" title="创建项目文件"></a>创建项目文件</h3><h4 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h4><p>BaseTabbar/BaseNavigation/BaseViewController</p><h4 id="功能模块"><a href="#功能模块" class="headerlink" title="功能模块"></a>功能模块</h4><table><thead><tr><th>目录</th><th>Controller</th></tr></thead><tbody><tr><td>Home</td><td>HomeTableViewController.swift</td></tr><tr><td>Message</td><td>MessageTableViewController.swift</td></tr><tr><td>Discover</td><td>DiscoverTableViewController.swift</td></tr><tr><td>Profile</td><td>ProfileTableViewController.swift</td></tr></tbody></table><h3 id="设置程序入口"><a href="#设置程序入口" class="headerlink" title="设置程序入口"></a>设置程序入口</h3><ul><li>修改 <code>AppDelegate</code> 中的 <code>didFinishLaunchingWithOptions</code> 函数，设置启动控制器</li></ul><h3 id="iOS-Images-Extractor"><a href="#iOS-Images-Extractor" class="headerlink" title="iOS Images Extractor"></a>iOS Images Extractor</h3><p>可以获取APP中的所有图片</p><h2 id="架构-设计"><a href="#架构-设计" class="headerlink" title="架构/设计"></a>架构/设计</h2><ul><li>单一职责原则</li><li>这是经常被违背的原则。一个类只能干一个事情，一个方法最好也只干一件事情。比较常见的违背是<code>一个类既干UI的事情，又干逻辑的事情</code>，这个在低质量的客户端代码里很常见</li><li>行为是否统一，例如：</li><li>缓存是否统一</li><li>错误处理是否统一</li><li>错误提示是否统一</li><li>弹出框是否统一</li><li>……</li><li>代码污染</li><li>代码有没有对其他模块强耦合</li><li>重复代码</li><li>开闭原则</li><li>面向接口编程</li><li>健壮性</li><li>是否考虑线程安全</li><li>数据访问是否一致性</li><li>边界处理是否完整</li><li>逻辑是否健壮</li><li>是否有内存泄漏</li><li>有没有循环依赖</li><li>有没有野指针</li><li>……</li><li>错误处理</li><li>改动是不是对代码的提升</li><li>新的改动是打补丁，让代码质量继续恶化，还是对代码质量做了修复</li><li>效率/性能</li><li>关键算法的时间复杂度多少？有没有可能有潜在的性能瓶颈</li><li>客户端程序对频繁消息和较大数据等耗时操作是否处理得当</li></ul><h2 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h2><ul><li>可读性</li><li>衡量可读性的可以有很好实践的标准，就是 Reviewer 能否非常容易的理解这个代码。如果不是，那意味着代码的可读性要进行改进</li><li>命名对可读性非常重要</li><li>英语用词尽量准确一点，必要时可以查字典</li><li>函数长度/类长度</li><li>函数太长的不好阅读</li><li>类太长了，检查是否违反的 <code>单一职责</code> 原则</li><li>恰到好处的注释</li><li>参数不要太多，一般不要超过 3 个</li></ul><h2 id="log"><a href="#log" class="headerlink" title="log"></a>log</h2><ul><li><p>QorumLogs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">QorumLogs.enabled = true // 启用QorumLogs</span><br><span class="line">QorumLogs.test() // 测试QorumLogs</span><br><span class="line"></span><br><span class="line">// 设置需要显示的等级</span><br><span class="line">QorumLogs.minimumLogLevelShown = 3</span><br><span class="line"></span><br><span class="line">// 测试的时候，可以限定输出文件</span><br><span class="line">QorumLogs.onlyShowThisFile(BaseTabbarController.self)</span><br><span class="line"></span><br><span class="line">QL1(&quot;mylog&quot;) // debug</span><br><span class="line">QL2(&quot;mylog&quot;)  // info</span><br><span class="line">QL3(&quot;mylog&quot;) // warning</span><br><span class="line">QL4(&quot;mylog&quot;) // error</span><br><span class="line">QLPlusLine() // 打印加号作为分割线</span><br><span class="line">QLShortLine() // 打印等号作为分割线</span><br></pre></td></tr></table></figure></li><li><p>自定义LOG<br>print(#function)  // 打印所在的方法<br>print(#line)     // 打印所在的行<br>print(#file)     // 打印所在文件的路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">泛型</span><br><span class="line">如果想在函数中使用泛型, 那么必须告诉系统者是一个泛型函数</span><br><span class="line">func 函数名称&lt;T&gt;(形参列表) -&gt; 返回值类型</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">message : T</span><br><span class="line">T具体是什么类型由调用者来确定, 调用者传递的是什么类型, T就是什么类型</span><br><span class="line">*/</span><br><span class="line">func XXLog&lt;T&gt;(_ message: T, method: String = #function, line: Int = #line)</span><br><span class="line">&#123;</span><br><span class="line">#if DEBUG</span><br><span class="line">print(&quot;\(method)[\(line)]: \(message)&quot;)</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h2><p>do catch的作用: 一旦方法抛出异常, 那么就会执行catch后面{}中的内容, 如果没有抛出异常, 那么catch后面{}中的内容不执行<br>try : 正常处理异常, 一旦有异常就执行catch<br>try!: 强制处理异常(忽略异常),也就是说告诉系统一定不会发生异常, 如果真的发生了异常, 那么程序会崩溃<br>try?: 忽略异常, 告诉系统可能有异常也可能没有异常, 如果发生异常返回值就是nil, 如果没有发生异常, 会将返回值包装为一个可选类型的值<br>开发中推举使用try? 和 try , 不推荐使用try!<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//序列化JSON</span><br><span class="line">guard let dictArray = try? NSJSONSerialization.JSONObjectWithData(jsonData!, options: NSJSONReadingOptions.MutableContainers) else&#123;&#125;</span><br></pre></td></tr></table></figure></p><h2 id="动态加载控制器"><a href="#动态加载控制器" class="headerlink" title="动态加载控制器"></a>动态加载控制器</h2><ul><li><p>命名空间<br>作用: 避免重复<br>不用项目中的命名空间是不一样的, 默认情况下命名空间的名称就是当前项目的名称<br>正是因为Swift可以通过命名空间来解决重名的问题, 所以在做Swift开发时尽量使用cocoapods来集成三方框架, 这样可以有效的避免类名重复<br>正是因为Swift中有命名空间, 所以通过一个字符串来创建一个类和OC中也不太一样了, OC中可以直接通过类名创建一个类, 而Swift中如果想通过类名来创建一个类必须加上命名空间</p></li><li><p>guard可以有效的解决可选绑定容易形成{}嵌套问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">guard 条件表达式 else &#123;</span><br><span class="line">//            需要执行的语句</span><br><span class="line">//            只有条件为假才会执行&#123;&#125;中的内容</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>动态加载控制器</p><ul><li>在 swift 中，类名是包含命名空间的,类名的组成格式是 <code>namespace.类名</code></li><li>命名空间默认是项目名称，同一个命名空间全局共享</li><li>从 <code>mainBundle</code> 的 <code>infoDictionary</code> 获取命名空间名称,namespace 对应的是 <code>CFBundleExecutable</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">childControllerName = &quot;HomeTableViewController&quot;</span><br><span class="line"></span><br><span class="line">// 1.动态获取命名空间</span><br><span class="line">// 由于字典/数组中只能存储对象, 所以通过一个key从字典中获取值取出来是一个AnyObject类型, 并且如果key写错或者没有对应的值, 那么就取不到值, 所以返回值可能有值也可能没值, 所以最终的类型是AnyObject?</span><br><span class="line">guard let name =  NSBundle.mainBundle().infoDictionary![&quot;CFBundleExecutable&quot;] as? String else</span><br><span class="line">&#123;</span><br><span class="line">NJLog(&quot;获取命名空间失败&quot;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2.根据字符串获取Class</span><br><span class="line">let cls: AnyClass? = NSClassFromString(name + &quot;.&quot; + childControllerName)</span><br><span class="line"></span><br><span class="line">// 3.告诉编译器真实类型是UITableViewController</span><br><span class="line">// Swift中如果想通过一个Class来创建一个对象, 必须告诉系统这个Class的确切类型</span><br><span class="line">guard let typeCls = cls as? UITableViewController.Type else</span><br><span class="line">&#123;</span><br><span class="line">NJLog(&quot;cls不能当做UITableViewController&quot;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 4.实例化控制器</span><br><span class="line">// 通过Class创建对象</span><br><span class="line">let childController = typeCls.init()</span><br><span class="line">NJLog(childController)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="as"><a href="#as" class="headerlink" title="as"></a>as</h2><ul><li><p>如果某些方法返回的数据类型是 <code>AnyObject</code>/<code>AnyClass</code>，则需要在右侧使用 <code>as 类型</code> 表明类型，并且根据返回值<code>是否是可选项</code>，添加 <code>!</code> 或者 <code>?</code>，例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ns = <span class="type">NSBundle</span>.mainBundle().infoDictionary![<span class="string">"CFBundleExecutable"</span>] <span class="keyword">as</span>! <span class="type">String</span></span><br></pre></td></tr></table></figure></li><li><p>如果某些方法返回类型是 <code>AnyObject</code>/<code>AnyClass</code>，但是对象类型是动态生成的，也就是说，编码时同样无法确定改对象的准确类型，可以在左侧使用 <code>: AnyObject</code> 或者 <code>: AnyClass</code> 告诉编译器暂不处理</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cls: <span class="type">AnyClass</span> = <span class="type">NSClassFromString</span>(ns + <span class="string">"."</span> + vcName)!</span><br></pre></td></tr></table></figure></li></ul><h2 id="storyboard-refrence"><a href="#storyboard-refrence" class="headerlink" title="storyboard refrence"></a>storyboard refrence</h2><h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><p>懒加载的代码是一个闭包，因此在代码内部需要使用 <code>self.</code><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> centerBtn: <span class="type">UIButton</span> = &#123;</span><br><span class="line">    () -&gt; <span class="type">UIButton</span></span><br><span class="line">    <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> btn = <span class="type">UIButton</span>()</span><br><span class="line">    <span class="keyword">return</span> btn</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></p><h2 id="objc"><a href="#objc" class="headerlink" title="@objc"></a>@objc</h2><ul><li>类<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@objc class MyHelper:NSObject &#123;  </span><br><span class="line">// class code  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>使用@objc修饰后的类型，可以直接供 Objective-C 调用<br>使用@objc修饰的类，必须继承自NSObject。</p><ul><li>方法<br><code>@objc private func</code><br>作用：在swift 中 如果一个按钮添加点击方法 如果定义为Private  或者 定义为 FilePrivate 那么会在Addtaget方法中找不到私有方法<br>但是又不想把方法暴露出来，避免外界访问 ，那么可以在私有方法前加 @objc 修饰 那么它就能找到那个方法了, 允许这个函数在“运行时”通过oc的消息机制调用</li></ul><h2 id="private-fileprivate"><a href="#private-fileprivate" class="headerlink" title="private/fileprivate"></a>private/fileprivate</h2><ul><li>private<br>能在同一个类 或者 同一个文件（extension）中访问这个方法</li><li>不希望暴露的方法，应该使用 <code>private</code> 修饰符</li><li><p>按钮点击事件的调用是由 <code>运行循环</code> 监听并且以<code>消息机制</code>传递的，因此，按钮监听函数不能设置为 <code>private</code></p></li><li><p>fileprivate<br>只能在一个类中访问 不能在类扩展中访问</p></li></ul><h2 id="通知-代理-block"><a href="#通知-代理-block" class="headerlink" title="通知/代理/block"></a>通知/代理/block</h2><p>通知 : 层级结构较深<br>代理 : 父子 , 方法较多时候使用<br>block: 父子, 方法较少时使用(一般情况一个方法)</p><blockquote><p>和OC不一样, Swift中如果简单的调用代理方法, 不用判断代理能否响应</p></blockquote><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><ul><li>定义协议</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 访客视图协议</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">VisitorViewDelegate</span>: <span class="title">NSObjectProtocol</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="comment">/// 将要登录</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">visitorViewLogin</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">/// 将要注册</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">visitorViewRegister</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>定义协议时，需要继承自 <code>NSObjectProtocol</code>，否则无法设置代理的类型</p></blockquote><ul><li>定义代理</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 定义代理 - 一定要用 weak</span></span><br><span class="line"><span class="keyword">weak</span> <span class="keyword">var</span> delegate: <span class="type">VisitorViewDelegate</span>?</span><br></pre></td></tr></table></figure><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>如果构造方法前面没有convenience单词, 代表着是一个初始化构造方法(指定构造方法)<br>如果构造方法前面有convenience单词, 代表着是一个便利构造方法</p><p>指定构造方法和便利构造方法的区别<br>1.指定构造方法中必须对所有的属性进行初始化<br>2.便利构造方法中不用对所有的属性进行初始, “因为便利构造方法依赖于指定构造方法”<br>一般情况下如果想给系统的类提供一个快速创建的方法, 就自定义一个便利构造方法</p><p>##<br>// 一般情况下设置全局性的属性, 最好放在AppDelegate中设置, 这样可以保证后续所有的操作都是设置之后的操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 设置全局外观</span><br><span class="line">private func setupAppearance() &#123;</span><br><span class="line">    UINavigationBar.appearance().tintColor = UIColor.orange</span><br><span class="line">    UITabBar.appearance().tintColor = UIColor.orange</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="tabbarItem"><a href="#tabbarItem" class="headerlink" title="tabbarItem"></a>tabbarItem</h2><p>tabBar 的 items 是在 <code>视图将要出现之前</code> 才被创建的</p><ul><li>viewDidLoad 方法调用是实例化控制器方法触发的<br>此时只是创建子控制器，而由于界面还没有显示，按照 iOS 开发的延迟创建原则，tabBar 中的 items 还没有被创建</li><li>viewWillAppear 方法是由 <code>makeKeyAndVisible</code> 方法触发的<br>此时需要开始准备将控制器的子视图添加到界面上，因此 tabBar 中的 items 已经被创建</li></ul><h1 id="day-2"><a href="#day-2" class="headerlink" title="day 2"></a>day 2</h1><h2 id="UIPresentationController"><a href="#UIPresentationController" class="headerlink" title="UIPresentationController"></a>UIPresentationController</h2><p>1.自定义转场modal出来的控制器不会移除原有的控制器<br>2.自定义转场modal出来的控制器的尺寸可以自己在containerViewWillLayoutSubviews方法中控制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">override func containerViewWillLayoutSubviews()</span><br><span class="line">&#123;</span><br><span class="line">// 设置弹出视图的尺寸</span><br><span class="line">presentedView()?.frame = CGRect(x: 100, y: 45, width: 200, height: 200)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.containerView 非常重要, 容器视图, 所有modal出来的视图都是添加到containerView上的<br>4.presentedView() 非常重要, 通过该方法能够拿到弹出的视图</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>github上优秀的iOS开源项目</title>
      <link href="/2017/08/01/github%E4%B8%8A%E4%BC%98%E7%A7%80%E7%9A%84iOS%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
      <url>/2017/08/01/github%E4%B8%8A%E4%BC%98%E7%A7%80%E7%9A%84iOS%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="OC项目"><a href="#OC项目" class="headerlink" title="OC项目"></a>OC项目</h1><h2 id="JKCategories"><a href="#JKCategories" class="headerlink" title="JKCategories"></a>JKCategories</h2><ul><li>对系统各种类的category，很全面，看源码能学到很多东西。<br>链接：<a href="https://github.com/shaojiankui/JKCategories" target="_blank" rel="noopener">JKCategories</a><a id="more"></a><h2 id="MiaoShow"><a href="#MiaoShow" class="headerlink" title="MiaoShow"></a>MiaoShow</h2></li><li>高仿&lt;喵播APP&gt;，视频直播相关。<br>链接：<a href="https://github.com/ForIos/MiaoShow/tree/master/MiaowShow" target="_blank" rel="noopener">MiaoShow</a></li></ul><h2 id="SmallHorseLive"><a href="#SmallHorseLive" class="headerlink" title="SmallHorseLive"></a>SmallHorseLive</h2><ul><li>小马直播间 - 环信IM &amp; UCloud<br>链接：<a href="https://github.com/mengmakies/SmallHorseLive" target="_blank" rel="noopener">SmallHorseLive</a></li></ul><h2 id="BeautyHour"><a href="#BeautyHour" class="headerlink" title="BeautyHour"></a>BeautyHour</h2><ul><li>图片美化，类似美图秀秀，支持图片与文字合成。<br>链接：<a href="https://github.com/xujingzhou/BeautyHour" target="_blank" rel="noopener">BeautyHour</a></li></ul><h2 id="JHChart"><a href="#JHChart" class="headerlink" title="JHChart"></a>JHChart</h2><ul><li>绘制图表，条形图，环形图等，根据具体需求选择<br>链接：<a href="https://github.com/China131/JHChart" target="_blank" rel="noopener">JHChart</a></li></ul><h2 id="PNChart"><a href="#PNChart" class="headerlink" title="PNChart"></a>PNChart</h2><ul><li>绘制图表，条形图，环形图等，根据具体需求选择<br>链接：<a href="https://github.com/kevinzhow/PNChart" target="_blank" rel="noopener">PNChart</a></li></ul><h2 id="MVVMReactiveCocoa"><a href="#MVVMReactiveCocoa" class="headerlink" title="MVVMReactiveCocoa"></a>MVVMReactiveCocoa</h2><ul><li>雷纯锋写的关于MVVM，ReactiveCocoa相关。<br><a href="https://github.com/leichunfeng/MVVMReactiveCocoa" target="_blank" rel="noopener">MVVMReactiveCocoa</a></li></ul><h2 id="opencv-for-ios-book-samples"><a href="#opencv-for-ios-book-samples" class="headerlink" title="opencv_for_ios_book_samples"></a>opencv_for_ios_book_samples</h2><ul><li>opencv</li></ul><h2 id="ZRFloodFillDemo"><a href="#ZRFloodFillDemo" class="headerlink" title="ZRFloodFillDemo"></a>ZRFloodFillDemo</h2><ul><li>仿 colorfy demo</li></ul><h2 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h2><ul><li>LPExample</li><li>ZJKitTool</li></ul><h1 id="Swift项目"><a href="#Swift项目" class="headerlink" title="Swift项目"></a>Swift项目</h1><h2 id="TodayNews"><a href="#TodayNews" class="headerlink" title="TodayNews"></a>TodayNews</h2><ul><li>模仿今日头条。<br>链接：<a href="https://github.com/hrscy/TodayNews" target="_blank" rel="noopener">TodayNews</a></li></ul><h2 id="socket-io-client-swift"><a href="#socket-io-client-swift" class="headerlink" title="socket.io-client-swift"></a>socket.io-client-swift</h2><ul><li>Socket.IO-client for iOS/OS X.<br><a href="https://github.com/socketio/socket.io-client-swift" target="_blank" rel="noopener">socket.io-client-swift</a></li></ul><h1 id="ReactNative项目"><a href="#ReactNative项目" class="headerlink" title="ReactNative项目"></a>ReactNative项目</h1><h2 id="react-zhihu"><a href="#react-zhihu" class="headerlink" title="react-zhihu"></a>react-zhihu</h2><ul><li>模仿知乎界面的简单React demo<br><a href="https://github.com/tsrot/react-zhihu" target="_blank" rel="noopener">react-zhihu</a></li></ul><h3 id="未完待续，持续更新中…"><a href="#未完待续，持续更新中…" class="headerlink" title="未完待续，持续更新中…"></a>未完待续，持续更新中…</h3>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> demo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2017张北草原音乐节</title>
      <link href="/2017/07/30/2017%E5%BC%A0%E5%8C%97%E8%8D%89%E5%8E%9F%E9%9F%B3%E4%B9%90%E8%8A%82/"/>
      <url>/2017/07/30/2017%E5%BC%A0%E5%8C%97%E8%8D%89%E5%8E%9F%E9%9F%B3%E4%B9%90%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<h2 id="2017-07-29-张北草原音乐节"><a href="#2017-07-29-张北草原音乐节" class="headerlink" title="2017-07-29 张北草原音乐节"></a>2017-07-29 张北草原音乐节</h2><center><img src="/assets/20170730_music/caoyuan2.jpeg" alt="张北草原"></center><br><a id="more"></a><br><center>张北草原</center><br><center><img src="/assets/20170730_music/caoyuan1.jpeg" alt="张北草原"></center><br><center>张北草原</center><center><img src="/assets/20170730_music/yinyuejie1.jpeg" alt="音乐节现场"></center><br><center>音乐节现场</center><center><img src="/assets/20170730_music/yinyuejie2.jpeg" alt="音乐节现场"></center><br><center>音乐节现场</center><center><img src="/assets/20170730_music/nanzhengbeizhan.jpeg" alt="南征北战"></center><br><center>南征北战–《萨瓦迪卡》《我的天空》</center><center><img src="/assets/20170730_music/haomeimei1.jpeg" alt="好妹妹"></center><br><center>好妹妹–《一个人的北京》《我说今晚月光那么美，你说是的》</center><center><img src="/assets/20170730_music/xuwei1.jpeg" alt="许巍"></center><br><center>许巍</center><center><img src="/assets/20170730_music/xuwei2.jpeg" alt="许巍"></center><br><center>许巍–《曾经的你》</center>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>iOS逆向开发学习笔记</title>
      <link href="/2017/07/27/iOS%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/07/27/iOS%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>待补充<br><a id="more"></a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>iOS可用架构设计</title>
      <link href="/2017/07/21/iOS%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
      <url>/2017/07/21/iOS%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h2><ul><li>AppDelegate：应用入口<ul><li>AppDelegate：生命周期</li><li>AppDelegate+AppService：推送，IM，支付等<a id="more"></a></li></ul></li><li>Base：基类<ul><li>TabbarController</li><li>NavigationController</li><li>WebViewController</li><li>BaseViewController</li><li>NoDataViewController</li></ul></li><li>Modules：功能模块，APP的主要业务逻辑，MVC<ul><li>Home<ul><li>ViewController</li><li>View</li><li>Model</li><li>Logic</li><li>Service</li></ul></li></ul></li><li>Manager：管理模块，用户登录退出，网络状态监听，广告页，应用介绍页等<ul><li>AppManager</li><li>UserManager</li></ul></li><li>Utils：工具类，三方框架的二次封装，自己定义的工具类等<ul><li>Network</li><li>Category</li><li>HUD</li><li>ADPage</li></ul></li><li>Frameworks：第三方框架，支付，IM等</li><li>Define：全局宏定义，屏幕宽高、接口地址、字体颜色、key、secret</li><li>Resource：资源文件，图片，音视频等</li></ul><p>参考链接：<a href="http://www.jianshu.com/p/d553096914ff" target="_blank" rel="noopener">iOS 从0到1搭建高可用App框架</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS常用第三方框架</title>
      <link href="/2017/07/21/iOS%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"/>
      <url>/2017/07/21/iOS%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>1.PPNetworkHelper</p><ul><li>对AFNetworking 3.x 与YYCache的二次封装</li><li>简单易用，包含了缓存机制，控制台可以直接打印json中文字符<a id="more"></a></li></ul><p>2..YTKNetwork</p><ul><li>猿题库研发团队基于AFNetworking封装的iOS网络库</li><li>适合稍微复杂一些的项目，不适合个人的小项目</li></ul><h2 id="基础组件库"><a href="#基础组件库" class="headerlink" title="基础组件库"></a>基础组件库</h2><h3 id="YYKit"><a href="#YYKit" class="headerlink" title="YYKit"></a>YYKit</h3><ul><li>YYModel— 高性能的 iOS JSON 模型框架。</li><li>YYCache— 高性能的 iOS 缓存框架。</li><li>YYImage— 功能强大的 iOS 图像框架。</li><li>YYWebImage— 高性能的 iOS 异步图像加载框架。</li><li>YYText— 功能强大的 iOS 富文本框架。</li><li>YYKeyboardManager— iOS 键盘监听管理工具。</li><li>YYDispatchQueuePool— iOS 全局并发队列管理工具。</li><li>YYAsyncLayer— iOS 异步绘制与显示的工具。</li><li>YYCategories— 功能丰富的 Category 类型工具库。<blockquote><p>图像异步加载使用的NSURLConnection，还是建议使用SDWebImage。</p></blockquote></li></ul><h2 id="等待加载提示"><a href="#等待加载提示" class="headerlink" title="等待加载提示"></a>等待加载提示</h2><ul><li>MBProgressHUD</li><li>SVProgressHUD</li><li>UAProgressView</li></ul><h2 id="空白页面占位图"><a href="#空白页面占位图" class="headerlink" title="空白页面占位图"></a>空白页面占位图</h2><ul><li><a href="https://github.com/yangli-dev/LYEmptyView" target="_blank" rel="noopener">LYEmptyView</a></li></ul><h2 id="状态栏顶部通知"><a href="#状态栏顶部通知" class="headerlink" title="状态栏顶部通知"></a>状态栏顶部通知</h2><ul><li><a href="https://github.com/jaydee3/JDStatusBarNotification" target="_blank" rel="noopener">JDStatusBarNotification</a></li></ul><h2 id="键盘监听管理工具"><a href="#键盘监听管理工具" class="headerlink" title="键盘监听管理工具"></a>键盘监听管理工具</h2><ul><li>IQKayboardManager</li></ul><h2 id="相册选择图片"><a href="#相册选择图片" class="headerlink" title="相册选择图片"></a>相册选择图片</h2><ul><li>KSPhotoBrowser</li></ul><h2 id="Badge"><a href="#Badge" class="headerlink" title="Badge"></a>Badge</h2><ul><li>WZLBadge</li></ul><h2 id="日历"><a href="#日历" class="headerlink" title="日历"></a>日历</h2><ul><li>GFCalendar</li><li>FSCalendar</li></ul><h2 id="状态栏上方显示手机状态"><a href="#状态栏上方显示手机状态" class="headerlink" title="状态栏上方显示手机状态"></a>状态栏上方显示手机状态</h2><ul><li><a href="https://github.com/dani-gavrilov/GDPerformanceView-Swift" target="_blank" rel="noopener">GDPerformanceView-Swift</a></li></ul><h2 id="跑马灯广告无线轮播"><a href="#跑马灯广告无线轮播" class="headerlink" title="跑马灯广告无线轮播"></a>跑马灯广告无线轮播</h2><ul><li><a href="https://github.com/tingxins/TXScrollLabelView" target="_blank" rel="noopener">TXScrollLabelView</a></li><li>CCPScrollView</li></ul><h2 id="FAQ视图"><a href="#FAQ视图" class="headerlink" title="FAQ视图"></a>FAQ视图</h2><ul><li><a href="https://github.com/mukeshthawani/FAQView" target="_blank" rel="noopener">FAQView</a></li></ul><h2 id="卡片界面"><a href="#卡片界面" class="headerlink" title="卡片界面"></a>卡片界面</h2><ul><li><a href="https://github.com/D-32/DMSwipeCards" target="_blank" rel="noopener">DMSwipeCards</a></li></ul><h2 id="模仿Airbnb首页过渡动画"><a href="#模仿Airbnb首页过渡动画" class="headerlink" title="模仿Airbnb首页过渡动画"></a>模仿Airbnb首页过渡动画</h2><ul><li><a href="https://github.com/newyjp/JPAnimation" target="_blank" rel="noopener">JPAnimation</a></li></ul><h2 id="界面转场动画集"><a href="#界面转场动画集" class="headerlink" title="界面转场动画集"></a>界面转场动画集</h2><ul><li><a href="https://github.com/alanwangmodify/WXSTransition" target="_blank" rel="noopener">WXSTransition</a></li></ul><h2 id="iOS的CSS"><a href="#iOS的CSS" class="headerlink" title="iOS的CSS"></a>iOS的CSS</h2><ul><li><a href="https://github.com/146BC/StyleKit" target="_blank" rel="noopener">StyleKit</a></li></ul><h2 id="动画加号按钮"><a href="#动画加号按钮" class="headerlink" title="动画加号按钮"></a>动画加号按钮</h2><ul><li><a href="https://github.com/YGeorge/YGPulseView" target="_blank" rel="noopener">YGPulseView</a></li></ul><h2 id="Swift-3快速异步助手"><a href="#Swift-3快速异步助手" class="headerlink" title="Swift 3快速异步助手"></a>Swift 3快速异步助手</h2><ul><li><a href="https://github.com/BarakRL/Do.this" target="_blank" rel="noopener">Do.this</a></li></ul><h2 id="密码输入切换框"><a href="#密码输入切换框" class="headerlink" title="密码输入切换框"></a>密码输入切换框</h2><ul><li><a href="https://github.com/eddy-lau/UXPasscodeField" target="_blank" rel="noopener">UXPasscodeField</a></li></ul><h2 id="美颜相机（仿faceU）"><a href="#美颜相机（仿faceU）" class="headerlink" title="美颜相机（仿faceU）"></a>美颜相机（仿faceU）</h2><ul><li><a href="https://github.com/Maru-zhang/MARFaceBeauty" target="_blank" rel="noopener">MARFaceBeauty</a></li><li><a href="">XIUSDK–美图，美颜</a></li></ul><h2 id="多功能数据pickerView"><a href="#多功能数据pickerView" class="headerlink" title="多功能数据pickerView"></a>多功能数据pickerView</h2><ul><li><a href="https://github.com/coder-zwz/DLPickerView" target="_blank" rel="noopener">DLPickerView</a></li></ul><h2 id="直播"><a href="#直播" class="headerlink" title="直播"></a>直播</h2><ul><li>LFLiveKit</li><li>IJKMediaFramework</li></ul><h2 id="视频播放"><a href="#视频播放" class="headerlink" title="视频播放"></a>视频播放</h2><ul><li>VIMVideoPlayer</li><li>CLPlayer（tableViewCell、全屏播放）</li><li>JPVideoPlayer（自动播放）</li></ul><h2 id="VR播放器"><a href="#VR播放器" class="headerlink" title="VR播放器"></a>VR播放器</h2><ul><li>MDVRLibrary</li></ul><h2 id="知识整合，学习资源"><a href="#知识整合，学习资源" class="headerlink" title="知识整合，学习资源"></a>知识整合，学习资源</h2><ul><li>AxcUIKit</li><li><a href="https://github.com/BigShow1949/BigShow1949" target="_blank" rel="noopener">BigShow1949</a></li></ul><p>参考资料：<br>(iOS及Mac开源项目和学习资料【超级全面】)[<a href="http://www.open-open.com/lib/view/open1442664670352.html]" target="_blank" rel="noopener">http://www.open-open.com/lib/view/open1442664670352.html]</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 第三方 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift学习笔记</title>
      <link href="/2017/07/14/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/07/14/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>在线swift编辑器：IBM Swift Sandbox</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h2><p>let，var分别声明常量，变量<br><a id="more"></a><br><code>代码中有不需要改变的值，使用 let 关键字将它声明为常量</code></p><blockquote><p>使用 let 修饰 <code>view</code> 并且赋值，表示该常量的内存地址不允许修改，但是可以修改其内部的属性</p></blockquote><h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><ul><li><p>字面量是指像特定的数字，字符串或者是布尔值这样能够直接了当地指出自己的类型并对变量进行赋值的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let aNumber = 3</span><br><span class="line">let astring = &quot;Hello&quot;</span><br><span class="line">let aBool = true</span><br><span class="line"></span><br><span class="line">let anArray = [1,2,3]</span><br><span class="line">let aDictionary = [&quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot;]</span><br></pre></td></tr></table></figure></li><li><p>数值型字面量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let a = 11</span><br><span class="line">let b = 0b11</span><br><span class="line">let c = 0o11</span><br><span class="line">let d = 0x11</span><br><span class="line">let e = 2e2     //200</span><br><span class="line">let f = 2e-2    //0.02</span><br><span class="line">let g = 0xFp2   //60</span><br><span class="line">let h = 0xFp-2  //3.75</span><br><span class="line">let i = 1_000_000</span><br></pre></td></tr></table></figure></li></ul><h2 id="类型标注"><a href="#类型标注" class="headerlink" title="类型标注"></a>类型标注</h2><p>很少需要标注，swift会进行类型推断，根据右边的代码，推导出变量的准确类型</p><blockquote><p>Option + Click 可以查看变量的类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let a:Float = 3.0</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>多行注释可嵌套</p><h2 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h2><p>swift语句，最后分号可写可不写</p><h2 id="打印日志"><a href="#打印日志" class="headerlink" title="打印日志"></a>打印日志</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;item1&quot;,&quot;item2&quot;,&quot;item3&quot;, separator: &quot;,,,&quot;, terminator: &quot;...&quot;)</span><br><span class="line">//item1,,,item2,,,item3...</span><br></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>值永远不会被隐式转换为其他类型，如果要对不同类型的数据进行计算，必须要显式的转换</p><ul><li>与字面量的加减无关<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a = &quot;abc&quot;</span><br><span class="line">let b = 9</span><br><span class="line">let ab = a + String(b)</span><br></pre></td></tr></table></figure></li></ul><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typealias Example = Int</span><br></pre></td></tr></table></figure><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><ul><li>元组可通过变量名或下标访问</li><li>可在定义元组的时候给元素命名</li><li>不需要访问的元素可用<code>_</code>代替</li><li>元组可作为函数返回值返回多个值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let (color,price,_) = (&quot;red&quot;,80,true)</span><br><span class="line">print(color)</span><br><span class="line">let pen = (&quot;red&quot;,80,true)</span><br><span class="line">let (color,price,_) = pen</span><br><span class="line">print(color)</span><br><span class="line">print(pen.0)</span><br><span class="line">let some = (color:&quot;red&quot;,price:80)</span><br><span class="line">print(some.color)</span><br></pre></td></tr></table></figure></li></ul><h2 id="可选类型"><a href="#可选类型" class="headerlink" title="可选类型"></a>可选类型</h2><p>可以是任何类型值的缺失<br>显式类型转换结果是可选类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var s: String = &quot;hello&quot;</span><br><span class="line">//s = nil //错误</span><br><span class="line">var s1: String? = &quot;hello&quot;</span><br><span class="line">s1 = nil</span><br></pre></td></tr></table></figure></p><h2 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h2><p>nil是一个确定的值，表示值缺失，任何类型的可选状态都可以被设置为nil<br>不可用于非可选的常量和变量<br>可选常量或变量不赋值，自动设值为nil</p><ul><li>在OC中nil是指针，在swift中nil是可选类型。</li></ul><h2 id="if-语句以及强制解析"><a href="#if-语句以及强制解析" class="headerlink" title="if 语句以及强制解析"></a>if 语句以及强制解析</h2><p>if语句中的条件必须是一个布尔表达式<br>当一个可选常量或变量确定包含值时，可用<code>!</code>强制解析</p><blockquote><p><code>()</code> 可以省略，但是 <code>{}</code> 不能省略</p><ul><li>当 if 的嵌套层次很深，可用where<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if let u = url where u.host == &quot;www.baidu.com&quot; &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><p>解包：<br>(1)!强行解包,如果 变量 为空，运行时会崩溃<br>(2)判断是否为空<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if str != nil &#123;</span><br><span class="line">print(str!)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(3)<code>if let</code>可选绑定</p><h2 id="可选绑定"><a href="#可选绑定" class="headerlink" title="可选绑定"></a>可选绑定</h2><ul><li>需要改变，用<code>if var</code><br>可以用在if或while语句中<br>可以判断多个可选项是否为空，用<code>,</code>隔开</li><li>一旦进入if分支，变量就不再是可选项<blockquote><p><code>if let</code> 不能与使用 <code>&amp;</code>、<code>|</code> 等条件判断,可以使用 <code>where</code> 子句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if let constantName = someOptional &#123;</span><br><span class="line">//constantName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><h2 id="隐式解析可选类型"><a href="#隐式解析可选类型" class="headerlink" title="隐式解析可选类型"></a>隐式解析可选类型</h2><p>可选类型被第一次赋值之后就可以确定之后一直有值，这种类型的可选状态被定义为隐式解析可选类型，可使用!直接声明，之后不需要使用!取值。<br>隐式解析可选类型就是可以自动解析的可选类型。<br>仍然可以可选绑定。</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>抛出错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func canThrowAnError() throws &#123;</span><br><span class="line">    // 这个函数有可能抛出错误</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>捕获错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    try canThrowAnError()</span><br><span class="line">    // 没有错误消息抛出</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">    // 有一个错误消息抛出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>举个栗子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">enum LoginError : Error &#123;</span><br><span class="line">case UserNotFound, UserPasswordNotMatch</span><br><span class="line">&#125;</span><br><span class="line">func login(user: String, password: String) throws &#123;</span><br><span class="line"></span><br><span class="line">if 2 &gt; 1 &#123;</span><br><span class="line">throw LoginError.UserPasswordNotMatch</span><br><span class="line">&#125;</span><br><span class="line">if 1 &lt; 2 &#123;</span><br><span class="line">throw LoginError.UserNotFound</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;Login successfully.&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line">try login(user: &quot;onevcat&quot;, password: &quot;123&quot;)</span><br><span class="line">&#125; catch LoginError.UserNotFound &#123;</span><br><span class="line">print(&quot;UserNotFound&quot;)</span><br><span class="line">&#125; catch LoginError.UserPasswordNotMatch &#123;</span><br><span class="line">print(&quot;UserPasswordNotMatch&quot;)</span><br><span class="line">&#125; catch&#123;</span><br><span class="line">//加入一个空的catch，用于关闭catch。否则会报错：Errors thrown from here are not handled because the enclosing catch is not exhaustive</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>当前面表达式的结果为false时显示后面的消息，应用终止。后面的断言消息也可省略。<br>release配置时，断言被禁用。在代码发布时，我们也不需要刻意去把这些断言手动清除。</p><ul><li>一般以下情况使用：<ul><li>下标越界</li><li>传递给函数的参数不符合类型</li><li>解析可选类型：一个可选值当前为 nil ，但随后的代码就需要非空的值才能成功执行。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let age = 17</span><br><span class="line">assert(age&gt;=18,&quot;未成年人&quot;)</span><br><span class="line">//Assertion failed: 未成年人</span><br></pre></td></tr></table></figure><h2 id="fatalError"><a href="#fatalError" class="headerlink" title="fatalError"></a>fatalError</h2><ul><li>因为断言只会在 Debug 环境中有效，而在 Release 编译中所以变得断言都将被禁用。所以我们会考虑以产生致命错误(fatalError)的方式来种植程序。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">required init?(coder aDecoder: NSCoder) &#123;</span><br><span class="line">    fatalError(&quot;init(coder:) has not been implemented&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">func methodMustBeImplementedInSubclass() &#123;</span><br><span class="line">fatalError(&quot;这个方法必须在子类中被重写&quot;) &#125;</span><br><span class="line">&#125;</span><br><span class="line">class YourClass: MyClass &#123;</span><br><span class="line">override func methodMustBeImplementedInSubclass() &#123;</span><br><span class="line">print(&quot;YourClass 实现了该方法&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class TheirClass: MyClass &#123;</span><br><span class="line">func someOtherMethod() &#123;</span><br><span class="line">&#125;</span><br><span class="line">//    override func methodMustBeImplementedInSubclass() &#123;</span><br><span class="line">//        print(&quot;TheirClass 实现了该方法&quot;)</span><br><span class="line">//    &#125;</span><br><span class="line">&#125;</span><br><span class="line">YourClass().methodMustBeImplementedInSubclass()</span><br></pre></td></tr></table></figure><h1 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a = 3</span><br><span class="line">let b = 3.3</span><br><span class="line">let c = Double(a)*b //或 let c = a*Int(b)</span><br></pre></td></tr></table></figure><h2 id="不可自增自减"><a href="#不可自增自减" class="headerlink" title="不可自增自减"></a>不可自增自减</h2><h2 id="取余"><a href="#取余" class="headerlink" title="取余"></a>取余</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10 % 6  //4</span><br><span class="line">10 % -6 //4</span><br><span class="line">-10 % 6 //-4</span><br></pre></td></tr></table></figure><h2 id="空值合并-空合-运算符"><a href="#空值合并-空合-运算符" class="headerlink" title="空值合并(空合)运算符??"></a>空值合并(空合)运算符??</h2><p>可对可选类型a进行空判断，如果包含值就解封，否则返回默认值b，此默认值b也为可选类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a = Int(&quot;aaa&quot;)</span><br><span class="line">let b = 2</span><br><span class="line">let c = a ?? b  //等同于 let c = a != nil ? a! : b</span><br></pre></td></tr></table></figure></p><h2 id="区间运算符"><a href="#区间运算符" class="headerlink" title="区间运算符"></a>区间运算符</h2><ul><li>闭区间：… </li><li>半开区间：..&lt;</li></ul><h1 id="字符与字符串"><a href="#字符与字符串" class="headerlink" title="字符与字符串"></a>字符与字符串</h1><h2 id="初始化空字符串"><a href="#初始化空字符串" class="headerlink" title="初始化空字符串"></a>初始化空字符串</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let s1 = &quot;&quot;</span><br><span class="line">let s2 = String()</span><br></pre></td></tr></table></figure><h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><p>str.characters<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let c = &quot;a&quot;</span><br><span class="line"></span><br><span class="line">let chars:[Character] = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br><span class="line">let str = String[chars]</span><br><span class="line">for char in are&#123;</span><br><span class="line">print(char)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="字符串可变性"><a href="#字符串可变性" class="headerlink" title="字符串可变性"></a>字符串可变性</h2><p>变量可变，常量不可变</p><h2 id="连接字符串和字符"><a href="#连接字符串和字符" class="headerlink" title="连接字符串和字符"></a>连接字符串和字符</h2><ul><li>+：只能连接字符串，不能连接字符</li><li>append<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var str1 = &quot;12&quot;</span><br><span class="line">let str2 = &quot;34&quot;</span><br><span class="line">let char1:Character = &quot;5&quot;</span><br><span class="line">str1 += str2</span><br><span class="line">//str1 += char1     //+：只能连接字符串，不能连接字符</span><br><span class="line">str1.append(char1)</span><br><span class="line">str1.append(str2)</span><br><span class="line">//str1.append(contentsOf: char1)    //contentsOf：只能连接字符串，不能连接字符</span><br><span class="line">str1.append(contentsOf: str2)</span><br></pre></td></tr></table></figure></li></ul><h2 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h2><p>以下方法也可使用在Array,Dictionary,Set中。</p><ul><li>str.characters.indices所有索引</li><li>在某个索引值之前插入字符：<code>insert(_:at:)</code>，不能越界</li><li><p>插入字符串：<code>insert(contentsOf:at:)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var hello = &quot;hello&quot;;</span><br><span class="line">hello.insert(contentsOf:&quot; world!&quot;.characters, at: hello(before: welcome.endIndex))</span><br></pre></td></tr></table></figure></li><li><p>删除字符：<code>remove(at:)</code>，越界返回nil</p></li><li>removeFirst(2),removeLast()</li><li>删除字符串<code>removeSubrange(_:)</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var hello = &quot;hello world!&quot;</span><br><span class="line">let range = hello.index(hello.endIndex, offsetBy: -7)..&lt;hello.endIndex</span><br><span class="line">hello.removeSubrange(range)</span><br></pre></td></tr></table></figure></li></ul><h2 id="计算字符数量"><a href="#计算字符数量" class="headerlink" title="计算字符数量"></a>计算字符数量</h2><p>str.characters.count</p><h2 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h2><ul><li><code>startIndex</code>,<code>endIndex</code>,<code>index(before:)</code>,<code>index(after:)</code>,<code>index(_:offsetBy:)</code>,也可以使用在Array,Dictionary,Set中</li><li>str.characters.indices所有索引</li></ul><h2 id="比较字符串"><a href="#比较字符串" class="headerlink" title="比较字符串"></a>比较字符串</h2><ul><li>字符串相等：==</li><li>前缀相等：<code>hasPrefix(_:)</code></li><li>后缀相等：<code>hasSuffix(_:)</code></li></ul><h2 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h2><p>值转换成字符串：()</p><blockquote><p>如果变量是可选项，拼接的结果中会有 <code>Optional</code>，<code>??</code> 操作符用于检测可选项是否为 <code>nil</code>， 如果不是 <code>nil</code>，使用当前值，如果是 <code>nil</code>，使用后面的值替代</p></blockquote><h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><ul><li>在实际开发中，如果需要指定字符串格式，可以使用 <code>String(format:...)</code> 的方式<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> h = <span class="number">8</span></span><br><span class="line"><span class="keyword">let</span> m = <span class="number">23</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="number">9</span></span><br><span class="line"><span class="comment">//后面的参数需要放在一个数组中</span></span><br><span class="line"><span class="keyword">let</span> timeString = <span class="type">String</span>(format: <span class="string">"%02d:%02d:%02d"</span>, arguments: [h, m, s])</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let name = &quot;Tom&quot;</span><br><span class="line">let date = NSDate()</span><br><span class="line">let string = NSString(format: &quot;Hello %@. Date: %@&quot;, name, date)</span><br></pre></td></tr></table></figure><h2 id="swift4新增"><a href="#swift4新增" class="headerlink" title="swift4新增"></a>swift4新增</h2><ul><li><p>多行字符串字面量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let str1 = &quot;&quot;&quot;</span><br><span class="line">12\n34</span><br><span class="line">56</span><br><span class="line">789</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">print(str1)</span><br></pre></td></tr></table></figure></li><li><p>去掉 characters</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//swift3</span><br><span class="line">let values = &quot;one,two,three...&quot;</span><br><span class="line">print(values.characters.count)</span><br><span class="line">var i = values.characters.startIndex</span><br><span class="line"></span><br><span class="line">while let comma = values.characters[i...&lt;values.characters.endIndex].index(of: &quot;,&quot;) &#123;</span><br><span class="line">if values.characters[i..&lt;comma] == &quot;two&quot; &#123;</span><br><span class="line">print(&quot;found it!&quot;)</span><br><span class="line">&#125;</span><br><span class="line">i = values.characters.index(after: comma)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//swift4</span><br><span class="line">let values = &quot;one,two,three...&quot;</span><br><span class="line">print(values.count)</span><br><span class="line">var i = values.startIndex</span><br><span class="line"></span><br><span class="line">while let comma = values[i...&lt;values.endIndex].index(of: &quot;,&quot;) &#123;</span><br><span class="line">if values[i..&lt;comma] == &quot;two&quot; &#123;</span><br><span class="line">print(&quot;found it!&quot;)</span><br><span class="line">&#125;</span><br><span class="line">i = values.index(after: comma)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>String 当做 Collection 来用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let abc: String = &quot;abc&quot;</span><br><span class="line">print(String(abc.reversed()))   // cba</span><br></pre></td></tr></table></figure></li></ul><h1 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h1><h2 id="集合的可变性"><a href="#集合的可变性" class="headerlink" title="集合的可变性"></a>集合的可变性</h2><p>变量可变，常量不可变</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li>数组的类型<ul><li>如果初始化时，所有内容类型一致，择数组中保存的是该类型的内容</li><li>如果初始化时，所有内容类型不一致，择数组中保存的是 <code>NSObject</code></li></ul></li><li>数字可以直接添加到集合，不需要再转换成 <code>NSNumber</code></li><li>如果将结构体对象添加到集合，仍然需要转换成 <code>NSValue</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//var array2 = [&quot;zhangsan&quot;, 18]  //会报错:Heterogeneous collection literal could only be inferred to &apos;[Any]&apos;; add explicit type annotation if this is intentional</span><br><span class="line">let array2 = [&quot;zhangsan&quot;, 18] as [Any]</span><br><span class="line">array2.append(100)</span><br><span class="line">array2.append(NSValue(CGPoint: CGPoint(x: 10, y: 10)))</span><br></pre></td></tr></table></figure></li></ul><p>最后一个元素后面允许有个逗号</p><ul><li><p>定义数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr1:[Int]</span><br><span class="line">let a:Array&lt;Int&gt;</span><br></pre></td></tr></table></figure></li><li><p>创建空数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr2 = [Int]()</span><br><span class="line">//var arr3 = []  //错误</span><br><span class="line">var a2:[String] = Array&lt;String&gt;()</span><br></pre></td></tr></table></figure></li><li><p>给数组赋空值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr1 = []</span><br><span class="line">arr = [Int](repeatElement(3, count: 10))</span><br><span class="line">arr = Array(repeatElement(2, count: 10))</span><br><span class="line">var ints = [Int](repeating: &quot;2&quot;, count: 10)</span><br><span class="line">var ints = Array(repeating: &quot;2&quot;, count: 10)</span><br></pre></td></tr></table></figure></li><li><p>判断是否是空数组：isEmpty</p></li><li><p><code>不可以用下标访问的形式为数组添加新项</code></p></li><li><p>遍历数组<br>可以使用元组返回索引和元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (index, value) in arr.enumerated() &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>必须是相同类型的数组才能够合并</p></li></ul><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ul><li>存储在集合中的数据必须是可哈希化的。<br>可哈希化必须满足三个条件：<ul><li>a == a(自反性)</li><li>a == b意味着b == a(对称性)</li><li>a == b &amp;&amp; b == c意味着a == c(传递性)</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = 1</span><br><span class="line">print(a.hashValue)</span><br></pre></td></tr></table></figure><ul><li><p>创建空集合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var set1 = Set&lt;String&gt;()</span><br></pre></td></tr></table></figure></li><li><p>集合转数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let arr = set1.sorted()</span><br></pre></td></tr></table></figure></li><li><p>集合的交差并补</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let x:Set = [1,2,3]</span><br><span class="line">let y:Set = [3,4,5]</span><br><span class="line">x.intersection(y)</span><br><span class="line">x.subtract(y)</span><br><span class="line">x.union(y)</span><br><span class="line">x.symmetricDifference(y)</span><br></pre></td></tr></table></figure></li><li><p>集合相等：有完全相同的元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let set1:Set = [1,2,3]</span><br><span class="line">let set2:Set = [3,2,1]</span><br><span class="line">set1 == set2</span><br></pre></td></tr></table></figure></li><li><p>子集（可以相等），严格子集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let set1:Set = [1,2,3,4]</span><br><span class="line">let set2:Set = [3,4]</span><br><span class="line">set2.isSuperset(of: set1)</span><br><span class="line">set2.isStrictSuperset(of: set1)</span><br></pre></td></tr></table></figure></li><li><p>父集（可以相等），严格父集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set1.isSubset(of: set2)</span><br><span class="line">set1.isStrictSubset(of: set2)</span><br></pre></td></tr></table></figure></li><li><p>无交集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let set1:Set = [1,2]</span><br><span class="line">let set2:Set = [3,4]</span><br><span class="line">set1.isDisjoint(with: set2)</span><br></pre></td></tr></table></figure></li></ul><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><ul><li>存储在集合中的key必须是可哈希化的。</li><li><p>创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var dict = [&quot;a&quot;:&quot;b&quot;]</span><br><span class="line">var dict1 : Dictionary&lt;String,String&gt;</span><br><span class="line">var dict2 : [String:String]</span><br></pre></td></tr></table></figure></li><li><p><code>updateValue(_:forKey:)</code>:设置或更新值，但是返回更新值之前的原值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let oldValue = dic.updateValue(&quot;lisi&quot;, forKey: &quot;name&quot;)</span><br></pre></td></tr></table></figure></li><li><p><code>dic[&quot;akey&quot;] = nil</code>，<code>dic.removeValue(forKey: &quot;akey&quot;)</code>：移除键值对</p></li><li><p>dic.keys,dic.values</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var keyArr = [String](dict.keys)</span><br><span class="line">var valueArr = Array(dict.values)</span><br></pre></td></tr></table></figure></li><li><p>遍历字典时候需要明确指明数组中的数据类型<br>for dict in dictArray  as! [[String:String]]{}</p></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="生成器（Generator）"><a href="#生成器（Generator）" class="headerlink" title="生成器（Generator）"></a>生成器（Generator）</h3><ul><li>生成器允许遍历所有元素<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protocol GeneratorType &#123;</span><br><span class="line">typealias Element</span><br><span class="line">mutating func next() -&gt; Element?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="序列（Sequence）"><a href="#序列（Sequence）" class="headerlink" title="序列（Sequence）"></a>序列（Sequence）</h3><ul><li>一种可以对其元素进行连续，迭代访问的类型。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protocol SequenceType &#123;</span><br><span class="line">    typealias Generator: GeneratorType</span><br><span class="line">    func generate() -&gt; Generator</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="集合-Collection"><a href="#集合-Collection" class="headerlink" title="集合(Collection)"></a>集合(Collection)</h3><h1 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h1><h2 id="For-In-循环"><a href="#For-In-循环" class="headerlink" title="For-In 循环"></a>For-In 循环</h2><ul><li>index 可直接使用，无序声明，不需要的时候可用<code>_</code>忽略</li><li>省略下标<ul><li><code>_</code> 能够匹配任意类型</li><li><code>_</code> 表示忽略对应位置的值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for index in 1...5 &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="while-repeat-while"><a href="#while-repeat-while" class="headerlink" title="while/repeat-while"></a>while/repeat-while</h2><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><ul><li>switch支持任意类型的数据比较 </li><li>switch不会隐式贯穿，默认有break,不用加</li><li>每一个 case 分支都必须包含至少一条语句,没有可用break；必须有default语句,要保证处理所有可能的情况，不然编译器直接报错</li><li>每一个 <code>case</code> 中定义的变量仅在当前 <code>case</code> 中有效</li><li>复合匹配，可以用逗号隔开匹配多个值</li><li>区间匹配：<code>case 1...10:</code></li><li>元组匹配：<code>case (_,0):</code></li><li>值绑定：<code>case (let x,0):</code></li><li>where添加额外条件：<code>case let(x,y) where x==y:</code></li></ul><h2 id="控制转移语句"><a href="#控制转移语句" class="headerlink" title="控制转移语句"></a>控制转移语句</h2><ul><li>continue</li><li>break：可用于switch语句或循环体中</li><li><p>label</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var i = 1</span><br><span class="line">myLabel: while i&lt;100&#123;</span><br><span class="line">    switch i &#123;</span><br><span class="line">        case 10:</span><br><span class="line">            print(&quot;case-10&quot;)</span><br><span class="line">            break myLabel</span><br><span class="line">        case 20:</span><br><span class="line">            print(&quot;case-20&quot;)</span><br><span class="line">        default:</span><br><span class="line">            print(&quot;default&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    i+=1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>fallthrough：贯穿到下一个case中的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let i = 3</span><br><span class="line">switch i &#123;</span><br><span class="line">    case 1:</span><br><span class="line">        print(&quot;1&quot;)</span><br><span class="line">    case 2:</span><br><span class="line">        print(&quot;2&quot;)</span><br><span class="line">    case 3:</span><br><span class="line">        print(&quot;3&quot;)</span><br><span class="line">        fallthrough</span><br><span class="line">    case 4:</span><br><span class="line">        print(&quot;4&quot;)</span><br><span class="line">        fallthrough</span><br><span class="line">    default:</span><br><span class="line">        print(&quot;default&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>return</p></li><li>throw</li><li><p>guard:提前退出，后面必须有一个else语句，else中必须包含控制转移语句<br><code>防止代码嵌套过多，if满足条件需要return时就可以用guard，相当于if let</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//只有numOfMyFriend &gt;0 的时候，才可以执行下面的程序。否则(else)就抛出一个异常。</span><br><span class="line">guard numOfMyFriend &gt; 0 else &#123;</span><br><span class="line">    throw errorGame.noFriendToGether</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>label标签语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">where labName&#123;</span><br><span class="line">    if()&#123;</span><br><span class="line">        break labName</span><br><span class="line">    &#125;else if()&#123;</span><br><span class="line">        continue labName</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        ///</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="检测API可用性"><a href="#检测API可用性" class="headerlink" title="检测API可用性"></a>检测API可用性</h2><p>*是必须的，用于指定在所有其它平台中，如果版本号高于你的设备指定的最低版本，if语句的代码块将会运行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if #available(iOS 10, macOS 10.12, *) &#123;</span><br><span class="line">// 在 iOS 使用 iOS 10 的 API, 在 macOS 使用 macOS 10.12 的 API</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// 使用先前版本的 iOS 和 macOS 的 API</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ul><li>swift中MARK的使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// MARK: - mark something</span><br></pre></td></tr></table></figure></li></ul><h2 id="函数定义与调用"><a href="#函数定义与调用" class="headerlink" title="函数定义与调用"></a>函数定义与调用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func hello(name:String) -&gt; String&#123;</span><br><span class="line">    let str = &quot;Hello,&quot;+name+&quot;!&quot;;</span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br><span class="line">hello(name:&quot;Anna&quot;);</span><br></pre></td></tr></table></figure><h2 id="指定参数标签"><a href="#指定参数标签" class="headerlink" title="指定参数标签"></a>指定参数标签</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func someFunction(argumentLabel parameterName: Int) &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="忽略参数标签"><a href="#忽略参数标签" class="headerlink" title="忽略参数标签"></a>忽略参数标签</h2><p>如果一个参数有一个标签，那么在调用的额是很好必须使用标签来标记这个参数，如果不希望为某个参数添加标签，可以使用<code>_</code>来代替一个明确的参数标签。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func hello(name:String) -&gt; String&#123;&#125;</span><br><span class="line">//调用 hello(name:&quot;Anna&quot;);</span><br><span class="line">func hello(_ name:String) -&gt; String&#123;&#125;</span><br><span class="line">//调用 hello(&quot;Anna&quot;);</span><br></pre></td></tr></table></figure></p><h2 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func someFunction(parameterWithoutDefault: Int, parameterWithDefault: Int = 12) &#123;</span><br><span class="line">// 如果你在调用时候不传第二个参数，parameterWithDefault 会值为 12 传入到函数体中。</span><br><span class="line">&#125;</span><br><span class="line">someFunction(parameterWithoutDefault: 4) // parameterWithDefault = 12</span><br></pre></td></tr></table></figure><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func getMiddle(_ numbers: Double...) -&gt; Double&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="输入输出参数"><a href="#输入输出参数" class="headerlink" title="输入输出参数"></a>输入输出参数</h2><blockquote><p>函数参数默认是常量。试图在函数体中更改参数值将会导致编译错误</p><ul><li>输入输出参数：可以在函数中修改的参数，并且这些修改在参数调用的时候仍然存在<br>只能传递变量给输入输出参数，不能传入常量或者字面量，并且在传入的时候在参数名前添加<code>&amp;</code>。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T) &#123;</span><br><span class="line">    //可以不使用额外空间而使用多元组特性直接交换 a 和 b 的值</span><br><span class="line">    (a, b) = (b, a)</span><br><span class="line">&#125;</span><br><span class="line">var a = 5, b = 6</span><br><span class="line">swapTwoValues(&amp;a, &amp;b)</span><br><span class="line">print(a, b)</span><br></pre></td></tr></table></figure><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><ul><li>可作为参数类型或返回值类型<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func calculate(x: Int,y: Int,method: (Int,Int)-&gt;Int) -&gt; Int&#123;</span><br><span class="line">return method(x,y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func add(x: Int,y: Int)-&gt;Int&#123;</span><br><span class="line">return x+y</span><br><span class="line">&#125;</span><br><span class="line">func multiply(x: Int,y: Int)-&gt;Int&#123;</span><br><span class="line">return x*y</span><br><span class="line">&#125;</span><br><span class="line">calculate(x: 3, y: 4, method: add)</span><br><span class="line">calculate(x: 3, y: 4, method: multiply)</span><br></pre></td></tr></table></figure></li></ul><h2 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int &#123;</span><br><span class="line">func stepForward(input: Int) -&gt; Int &#123; return input + 1 &#125;</span><br><span class="line">func stepBackward(input: Int) -&gt; Int &#123; return input - 1 &#125;</span><br><span class="line">return backward ? stepBackward : stepForward</span><br><span class="line">&#125;</span><br><span class="line">var currentValue = 4</span><br><span class="line">let moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)</span><br><span class="line">while currentValue != 0 &#123;</span><br><span class="line">print(&quot;\(currentValue)... &quot;)</span><br><span class="line">currentValue = moveNearerToZero(currentValue)</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;zero!&quot;)</span><br></pre></td></tr></table></figure><h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><blockquote><p>把接受多个参数的方法变换成接受第一个参数的方法，并且返回接受余下的参数并且返回结果的新方法。</p></blockquote><!--* 不使用柯里化<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func addTwoNumbers(a: Int, num: Int) -&gt; Int &#123;</span><br><span class="line">return a + num</span><br><span class="line">&#125;</span><br><span class="line">let result = addTwoNumbers(a:4, num: 6)</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">func greaterThan(comparator: Int, input: Int) -&gt; Bool &#123;</span><br><span class="line">return input &gt; comparator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let greaterThan10 = greaterThan(comparator: 10, input: 13)</span><br><span class="line">print(greaterThan10)</span><br><span class="line">let littleThan10 = greaterThan(comparator: 10, input: 9)</span><br><span class="line">print(littleThan10)</span><br></pre></td></tr></table></figure><ul><li>使用柯里化<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">func addTwoNumbers(a: Int)(num: Int) -&gt; Int &#123;</span><br><span class="line">return a + num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//等同于</span><br><span class="line">//func addTwoNumbers(a: Int)-&gt;((Int) -&gt; Int) &#123;</span><br><span class="line">//    func incrementor(num: Int) -&gt; Int &#123;</span><br><span class="line">//        return a + num</span><br><span class="line">//    &#125;</span><br><span class="line">//    return incrementor</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let addToFour = addTwoNumbers(a: 4)</span><br><span class="line">let result = addToFour(num: 6)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func greaterThan(comparator: Int)(input: Int) -&gt; Bool &#123;</span><br><span class="line">return input &gt; comparator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let greaterThan10 = greaterThan(comparator:10)</span><br><span class="line">greaterThan10(input: 13)    //true</span><br><span class="line">greaterThan10(input: 9)     //false</span><br></pre></td></tr></table></figure></li></ul><p>–&gt;</p><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>闭包的三种形式：</p><ul><li>全局函数是一个有名字但不会捕获任何值的闭包</li><li>嵌套函数是一个有名字并可以捕获其封闭函数域内值的闭包</li><li>闭包表达式是一个利用轻量级语法所写的可以捕获其上下文中变量或常量值的匿名闭包<h2 id="闭包表达式"><a href="#闭包表达式" class="headerlink" title="闭包表达式"></a>闭包表达式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; (parameters) -&gt; returnType in</span><br><span class="line">statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>排序闭包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames = names.sorted(by: &#123; (s1: String, s2: String) -&gt; Bool in return s1 &gt; s2 &#125; )</span><br></pre></td></tr></table></figure></p><blockquote><p>排序闭包函数类型需为<code>(String, String) -&gt; Bool</code></p><ul><li>所有的参数和返回值类型都可以被正确推断，则返回箭头（-&gt;）和围绕在参数周围的括号也可以被省略<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames = names.sorted(by: &#123; s1, s2 in return s1 &gt; s2 &#125; )</span><br></pre></td></tr></table></figure></li></ul></blockquote><ul><li><p>单表达式闭包隐式返回,可以省略 return 关键字，把语句的值作为结果返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames = names.sorted(by: &#123; s1, s2 in s1 &gt; s2 &#125; )</span><br></pre></td></tr></table></figure></li><li><p>可以通过参数位置引用参数，通过 $0，$1来顺序调用闭包的参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames = names.sorted(by: &#123; $0 &gt; $1 &#125; )</span><br></pre></td></tr></table></figure></li><li><p>运算符方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames = names.sorted(by: &gt;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="尾随闭包"><a href="#尾随闭包" class="headerlink" title="尾随闭包"></a>尾随闭包</h2><ul><li>当一个闭包作为最后一个参数传给函数的时候，闭包可以直接跟在括号后面，不用写出参数标签</li><li>如果闭包是函数的唯一参数，则当使用尾随闭包时，可以把()省略掉<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames = names.sorted &#123; $0 &gt; $1 &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="值捕获"><a href="#值捕获" class="headerlink" title="值捕获"></a>值捕获</h2><ul><li>闭包可以在其被定义的上下文中捕获常量或变量。即使定义这些常量和变量的原作用域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。</li><li>Swift 中，可以捕获值的闭包的最简单形式是嵌套函数</li><li>如果一个值不会被闭包改变，或者在闭包创建后不会改变，Swift 可能会改为捕获并保存一份对值的拷贝。<blockquote><p>如果你将闭包赋值给一个类实例的属性，并且该闭包通过访问该实例或其成员而捕获了该实例，你将在闭包和该实例间创建一个循环强引用。Swift 使用捕获列表来打破这种循环强引用</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func add(num: Int)-&gt;(()-&gt;())&#123;</span><br><span class="line">    var sum = 0</span><br><span class="line">    func addNum()&#123;</span><br><span class="line">        sum+=num</span><br><span class="line">        print(sum)</span><br><span class="line">    &#125;</span><br><span class="line">    return addNum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = add(num: 10)</span><br><span class="line">a() //10</span><br><span class="line">a() //20</span><br><span class="line"></span><br><span class="line">var b = add(num: 8)</span><br><span class="line">b() //8</span><br><span class="line">b() //16</span><br><span class="line">a() //30</span><br></pre></td></tr></table></figure><h2 id="函数和闭包都是引用类型"><a href="#函数和闭包都是引用类型" class="headerlink" title="函数和闭包都是引用类型"></a>函数和闭包都是引用类型</h2><h2 id="逃逸闭包-escaping"><a href="#逃逸闭包-escaping" class="headerlink" title="逃逸闭包 @escaping"></a>逃逸闭包 @escaping</h2><ul><li>逃逸闭包：当一个闭包作为参数传到一个函数中，但是这个闭包在函数返回之后才被执行</li><li>如何逃逸：将闭包保存在一个函数外部定义的变量中，因为闭包需要在函数返回之后被调用<blockquote><p>将一个闭包标记为 @escaping 意味着必须在闭包中显式地引用 self，非逃逸闭包可以隐式引用self</p></blockquote></li></ul><h2 id="自动闭包-autoclosure"><a href="#自动闭包-autoclosure" class="headerlink" title="自动闭包 @autoclosure"></a>自动闭包 @autoclosure</h2><blockquote><p>自动闭包是一种自动创建的用来把作为实际参数传递给函数的表达式打包的闭包。它不接受任何实际参数，并且当它被调用时，它会返回内部打包的表达式的值。这个语法的好处在于通过写普通表达式代替显式闭包而使你省略包围函数形式参数的括号。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 在不使用autoclosure的情况下</span><br><span class="line">func logIfTrue(predicate: () -&gt; Bool) &#123;</span><br><span class="line">    if predicate() &#123;</span><br><span class="line">        print(&quot;True&quot;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        print(&quot;False&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 第一种调用方式</span><br><span class="line">logIfTrue &#123; () -&gt; Bool in</span><br><span class="line">    return 1 &gt; 2</span><br><span class="line">&#125;</span><br><span class="line">// 第二种调用方式</span><br><span class="line">logIfTrue&#123;return 1 &gt; 2&#125;</span><br><span class="line">// 第三种调用方式</span><br><span class="line">logIfTrue&#123;1 &gt; 2&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 使用autoclosure</span><br><span class="line">func logIfTrue( _ predicate: @autoclosure () -&gt; Bool) &#123;</span><br><span class="line">    if predicate() &#123;</span><br><span class="line">        print(&quot;True&quot;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        print(&quot;False&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 调用方式</span><br><span class="line">logIfTrue(2 &gt; 1)</span><br><span class="line">logIfTrue(1 &gt; 2)</span><br></pre></td></tr></table></figure><h1 id="枚举enum"><a href="#枚举enum" class="headerlink" title="枚举enum"></a>枚举enum</h1><h2 id="枚举语法"><a href="#枚举语法" class="headerlink" title="枚举语法"></a>枚举语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line">    case north</span><br><span class="line">    case south</span><br><span class="line">    case east</span><br><span class="line">    case west</span><br><span class="line">&#125;</span><br><span class="line">var d = Direction.west</span><br><span class="line">d = .west</span><br><span class="line"></span><br><span class="line">enum Direction&#123; case East,West,South,North &#125;</span><br></pre></td></tr></table></figure><h2 id="使用-Switch-语句匹配枚举值，如果变量是枚举值，可省略枚举名，还可以在case中加上元组变量"><a href="#使用-Switch-语句匹配枚举值，如果变量是枚举值，可省略枚举名，还可以在case中加上元组变量" class="headerlink" title="使用 Switch 语句匹配枚举值，如果变量是枚举值，可省略枚举名，还可以在case中加上元组变量"></a>使用 Switch 语句匹配枚举值，如果变量是枚举值，可省略枚举名，还可以在case中加上元组变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">enum Direction&#123; case East,West,South,North &#125;</span><br><span class="line">var d = Direction.North</span><br><span class="line"></span><br><span class="line">switch d&#123;</span><br><span class="line">case Direction.East:</span><br><span class="line">print(&quot;east&quot;)</span><br><span class="line">case .West:</span><br><span class="line">print(&quot;wast&quot;)</span><br><span class="line">case .South:</span><br><span class="line">print(&quot;south&quot;)</span><br><span class="line">case .North:</span><br><span class="line">print(&quot;north&quot;)</span><br><span class="line">//default可省略，非枚举必须加default</span><br><span class="line">//default:</span><br><span class="line">//print(&quot;other&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">enum Direction&#123; case East,West,South,North,Other &#125;</span><br><span class="line">var d = Direction.North</span><br><span class="line"></span><br><span class="line">switch d&#123;</span><br><span class="line">case Direction.East:</span><br><span class="line">print(&quot;east&quot;)</span><br><span class="line">case .West:</span><br><span class="line">print(&quot;wast&quot;)</span><br><span class="line">case .South:</span><br><span class="line">print(&quot;south&quot;)</span><br><span class="line">case .North:</span><br><span class="line">print(&quot;north&quot;)</span><br><span class="line">//default不可省略</span><br><span class="line">default:</span><br><span class="line">print(&quot;other&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原始值-rawValue"><a href="#原始值-rawValue" class="headerlink" title="原始值 rawValue"></a>原始值 rawValue</h2><p>当使用整数作为原始值时，如果第一个枚举成员没有设置原始值，其原始值将为0,隐式赋值的值依次递增1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//赋初始值，必须有类型说明</span><br><span class="line">enum Numbers:Int&#123;case A = 1, B, C&#125;</span><br><span class="line">print(Numbers.A.rawValue)</span><br><span class="line"></span><br><span class="line">enum Direction:String&#123;</span><br><span class="line">    case East = &quot;east&quot;</span><br><span class="line">    case West = &quot;west&quot;</span><br><span class="line">    case South = &quot;south&quot;</span><br><span class="line">    case North = &quot;north&quot;</span><br><span class="line">&#125;</span><br><span class="line">print(Direction.West.rawValue)</span><br></pre></td></tr></table></figure></p><h2 id="关联值：枚举成员可以是不同数据类型"><a href="#关联值：枚举成员可以是不同数据类型" class="headerlink" title="关联值：枚举成员可以是不同数据类型"></a>关联值：枚举成员可以是不同数据类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum State&#123;</span><br><span class="line">case Status1(Int,String)</span><br><span class="line">case Status2(String,String)</span><br><span class="line">&#125;</span><br><span class="line">var s = State.Status1(404,&quot;page not found&quot;)</span><br></pre></td></tr></table></figure><h1 id="类和结构体"><a href="#类和结构体" class="headerlink" title="类和结构体"></a>类和结构体</h1><h2 id="类和结构体对比"><a href="#类和结构体对比" class="headerlink" title="类和结构体对比"></a>类和结构体对比</h2><p>相同点：</p><ul><li>定义属性用于存储值</li><li>定义方法用于提供功能</li><li>定义下标操作使得可以通过下标语法来访问实例所包含的值</li><li>定义构造器用于生成初始化值</li><li>通过扩展以增加默认实现的功能</li><li>实现协议以提供某种标准功能<br>类的不同点：</li><li>继承允许一个类继承另一个类的特征</li><li>类型转换允许在运行时检查和解释一个类实例的类型</li><li>析构器允许一个类实例释放任何其所被分配的资源</li><li><p>引用计数允许对一个类的多次引用</p></li><li><p>定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class SomeClass &#123;</span><br><span class="line">// 在这里定义类</span><br><span class="line">&#125;</span><br><span class="line">struct SomeStructure &#123;</span><br><span class="line">// 在这里定义结构体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>结构体类型的成员逐一构造器，类实例没有默认构造函数，类中的属性必须初始化或设为可选（属性加！或？，或者写init方法）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Dog &#123;</span><br><span class="line"></span><br><span class="line">var name: String!</span><br><span class="line">var age :Int!</span><br><span class="line">init()&#123;</span><br><span class="line">name = &quot;hua hua&quot;</span><br><span class="line">age = 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func show()&#123;</span><br><span class="line">print(&quot;\(name!):\(age!)&quot;)   //解析</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var d1 = Dog()</span><br><span class="line">d1.show()</span><br><span class="line">d1.name = &quot;xiao hei&quot;</span><br><span class="line">d1.age = 3</span><br><span class="line">d1.show()</span><br><span class="line"></span><br><span class="line">print(d1 === d2)    //是否是同一对象:true</span><br><span class="line">var d3 = Dog()</span><br><span class="line">print(d1 === d3)    //是否是同一对象:false</span><br></pre></td></tr></table></figure></li><li><p>结构体和枚举是值类型，函数和闭包是引用类型</p><blockquote><p>值类型：被赋予给一个变量、常量或者被传递给一个函数的时候，其值会被拷贝。<br>引用类型：在被赋予到一个变量、常量或者被传递到一个函数时，其值不会被拷贝。因此，引用的是已存在的实例本身而不是其拷贝。实际是同一个。<br>结构体和枚举类型都是值类型。这意味着它们的实例，以及实例中所包含的任何值类型属性，在代码中传递的时候都会被复制。两者相互独立，是不同的。<br>在 Swift 中，Integer、floating-point、Boolean、string、array、dictionary 都是值类型，并且在底层都是以结构体的形式所实现。</p></blockquote></li><li><p>恒等运算符（===/!==）：判定两个常量或者变量是否引用同一个类实例</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">//结构体</span><br><span class="line">struct Point &#123;</span><br><span class="line">var x: Int</span><br><span class="line">var y: Int</span><br><span class="line">&#125;</span><br><span class="line">var p1 = Point(x: 10, y: 20)</span><br><span class="line">var p2 = p1</span><br><span class="line">print(&quot;\(p1.x):\(p1.y)&quot;)</span><br><span class="line">print(&quot;\(p2.x):\(p2.y)&quot;)</span><br><span class="line">p1.x = 100</span><br><span class="line">p1.y = 200</span><br><span class="line">print(&quot;\(p1.x):\(p1.y)&quot;)</span><br><span class="line">print(&quot;\(p2.x):\(p2.y)&quot;)</span><br><span class="line"></span><br><span class="line">//枚举</span><br><span class="line">enum Direction&#123;case East,West,North,South&#125;</span><br><span class="line">var direction1 = Direction.East</span><br><span class="line">var direction2 = direction1</span><br><span class="line">print(&quot;\(direction1)&quot;)</span><br><span class="line">print(&quot;\(direction2)&quot;)</span><br><span class="line">direction1 = .West</span><br><span class="line">print(&quot;\(direction1)&quot;)</span><br><span class="line">print(&quot;\(direction2)&quot;)</span><br><span class="line"></span><br><span class="line">//类</span><br><span class="line">class Dog &#123;</span><br><span class="line"></span><br><span class="line">var name: String!</span><br><span class="line">var age: Int!</span><br><span class="line">init()&#123;</span><br><span class="line"></span><br><span class="line">name = &quot;hua hua&quot;</span><br><span class="line">age = 2</span><br><span class="line">&#125;</span><br><span class="line">func show()&#123;</span><br><span class="line">print(&quot;\(name):\(age)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var d1 = Dog()</span><br><span class="line">var d2 = d1</span><br><span class="line">d1.show()</span><br><span class="line">d2.show()</span><br><span class="line">d1.name = &quot;xiao hei&quot;</span><br><span class="line">d1.age = 3</span><br><span class="line">d1.show()</span><br><span class="line">d2.show()</span><br></pre></td></tr></table></figure><h2 id="类和结构体的选择"><a href="#类和结构体的选择" class="headerlink" title="类和结构体的选择"></a>类和结构体的选择</h2><p>大部分使用类，以下情形考虑构建结构体：</p><ul><li>目的是用来封装少量相关简单数据值。</li><li>实例在被赋值或传递时，封装的数据将会被拷贝而不是被引用。</li><li>储存的值类型属性，也应该被拷贝，而不是被引用。</li><li>不需要去继承另一个既有类型的属性或者行为。</li></ul><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p><code>存储属性只能用于类和结构体，计算属性可以用于类、结构体和枚举。</code></p><h2 id="存储属性"><a href="#存储属性" class="headerlink" title="存储属性"></a>存储属性</h2><ul><li>定义：存储在特定类或结构体实例里的一个常量或变量，保存单个类型的变量。</li><li><code>所有类的存储属性——包括从它的父类继承的所有属性——都必须在初始化期间分配初始值。</code></li><li>常量结构体的存储属性：如果创建了一个结构体的实例并将其赋值给一个常量，则无法修改该实例的任何属性，即使有属性被声明为变量也不行(由于结构体（struct）属于值类型。<code>当值类型的实例被声明为常量的时候，它的所有属性也就成了常量</code>。属于引用类型的类（class）则不一样，<code>把一个引用类型的实例赋给一个常量后，仍然可以修改该实例的变量属性</code>。)</li><li>延迟存储属性lazy<ul><li>定义：在第一次被访问的时候创建</li><li>一般用于：<ul><li>延迟对象的创建</li><li>当属性的值依赖于其他未知类</li></ul></li><li>必须将延迟存储属性声明成变量（使用 var 关键字），而常量属性在构造过程完成之前必须要有初始值，因此无法声明成延迟属性</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//1)类中的属性必须初始化或设为可选</span><br><span class="line">class Dog &#123;</span><br><span class="line">var name: String!</span><br><span class="line">var age: Int!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//2）常量结构体的存储属性</span><br><span class="line">struct Point &#123;</span><br><span class="line">var x: Int</span><br><span class="line">var y: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p1 = Point(x: 1, y: 2)</span><br><span class="line">//结构体常量对象不可以进行修改</span><br><span class="line">//p1.x = 100</span><br><span class="line">//p1.y = 200</span><br><span class="line"></span><br><span class="line">3）延迟存储属性 lazy：调用时才进行构造</span><br><span class="line">class A &#123;</span><br><span class="line">init()&#123;</span><br><span class="line">print(&quot;A init&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func f1()&#123;</span><br><span class="line">print(&quot;f1...&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">lazy var a: A = A()</span><br><span class="line">init()&#123;</span><br><span class="line">print(&quot;B init&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var b = B()</span><br><span class="line">//调用时A才进行构造</span><br><span class="line">print(b.a.f1())</span><br></pre></td></tr></table></figure><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><ul><li>定义：计算属性不直接存储值，而是提供一个 getter 和一个可选的 setter，来间接获取和设置其他属性或变量的值。</li><li>新值的参数名默认为newValue</li><li>只读计算属性的声明可以去掉get关键字和花括号，直接return<blockquote><p>必须使用var定义计算属性，包括只读计算属性</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">struct Rect &#123;</span><br><span class="line">    var w: Double</span><br><span class="line">    var h: Double</span><br><span class="line"></span><br><span class="line">    var circle: Double&#123;</span><br><span class="line">        get&#123;</span><br><span class="line">            print(&quot;get...&quot;)</span><br><span class="line">            return (w+h)*2</span><br><span class="line">        &#125;</span><br><span class="line">        set&#123;</span><br><span class="line">            //默认newValue，oldValue</span><br><span class="line">            //newValue就是circle</span><br><span class="line">            w = newValue/2</span><br><span class="line">            h = newValue/2</span><br><span class="line">            print(&quot;newValue=\(newValue)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var r = Rect(w: 30, h: 20)</span><br><span class="line">print(r.circle)</span><br><span class="line">r.circle = 200</span><br><span class="line">print(r.circle)</span><br></pre></td></tr></table></figure><h2 id="属性观察器"><a href="#属性观察器" class="headerlink" title="属性观察器"></a>属性观察器</h2><ul><li>属性被设置值的时候会调用属性观察器（即使新值与当前值相同）</li><li>可添加观察器的情况：<ul><li>定义的存储属性（除延迟存储属性之外）</li><li>从父类继承的存储属性或计算属性（通过重写属性的方式），不需要为无法重载的计算属性添加属性观察器，因为可以通过setter直接监控和响应值的变化</li></ul></li><li>willSet：传入新属性值，默认为newValue，常量参数</li><li>didSet：传入旧属性值，默认为oldValue</li><li>willSet和didSet在属性初始化过程中不会被调用</li><li>继承：<ul><li>父类属性在子类的构造器中赋值，会先调用父类观察器，再调用子类观察器。</li><li>在父类初始化方法调用之前，子类给属性赋值时，不会调用观察器方法。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    var age: Int = 1&#123;</span><br><span class="line"></span><br><span class="line">        //可以不加newValue:willSet(newValue)</span><br><span class="line">        willSet&#123;</span><br><span class="line">            print(&quot;newValue:\(newValue)&quot;)</span><br><span class="line">            //保护属性</span><br><span class="line">            if newValue &lt;= 0 &#123;</span><br><span class="line">                print(&quot;非法年龄！&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //必须加newValue</span><br><span class="line">        didSet(newValue)&#123;</span><br><span class="line">            print(&quot;newValue:\(newValue)&quot;)</span><br><span class="line">            print(&quot;didSet&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var a = Animal()</span><br><span class="line">print(a.age)    //1</span><br><span class="line">a.age = -1</span><br><span class="line">print(a.age)    //-1</span><br></pre></td></tr></table></figure><h2 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h2><ul><li>都属于存储型变量，跟存储属性类似。</li><li>都可以定义计算型变量和为存储型变量定义观察器，与计算属性类似。</li><li>全局变量或常量都是延迟计算的，与延迟存储属性相似，不需要声明lazy。局部变量或常量从不延迟计算。</li></ul><h2 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct Structname &#123;</span><br><span class="line">    static var storedTypeProperty = &quot; &quot;</span><br><span class="line">    static var computedTypeProperty: Int &#123;</span><br><span class="line">    // 这里返回一个 Int 值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum Enumname &#123;</span><br><span class="line">    static var storedTypeProperty = &quot; &quot;</span><br><span class="line">    static var computedTypeProperty: Int &#123;</span><br><span class="line">    // 这里返回一个 Int 值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Classname &#123;</span><br><span class="line">    class var computedTypeProperty: Int &#123;</span><br><span class="line">    // 这里返回一个 Int 值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>存储型类型属性可以是变量或常量，计算型类型属性跟实例的计算型属性一样只能定义成变量属性（计算型属性只能声明为变量）。</li><li>在为类定义<code>计算型类型属性</code>时，可以改用关键字 <code>class</code> 来支持子类对父类的实现进行重写。</li></ul><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><ul><li>类、结构体、枚举都可以定义实例方法，也可以定义类型方法。</li><li>self<ul><li>在一个方法中使用一个已知的属性或者方法名称，可省略self。</li><li>实例方法的某个参数名称与实例的某个属性名称相同的时候，参数名称享有优先权，可以使用self属性来区分参数名称和属性名称。</li></ul></li><li>变异mutating<ul><li>结构体和枚举是值类型，值类型属性不能在实例方法中被修改，在实例方法中修改值类型：mutating，修改后的值会一直保留</li><li>赋给隐含属性self一个全新的实例，新实例在方法结束后将替换原来的实例</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">struct Area &#123;</span><br><span class="line">    var length = 1</span><br><span class="line">    var breadth = 1</span><br><span class="line"></span><br><span class="line">    func area() -&gt; Int &#123;</span><br><span class="line">        return length * breadth</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutating func scaleBy(res: Int) &#123;</span><br><span class="line">        self.length *= res</span><br><span class="line">        self.breadth *= res</span><br><span class="line">        print(length)</span><br><span class="line">        print(breadth)</span><br><span class="line"></span><br><span class="line">        //只有在变异方法中才可以给self赋值</span><br><span class="line">        //self = Area(length:self.length*res, breadth:self.breadth*res)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//若实例对象为let,不可修改</span><br><span class="line">var val = Area(length: 3, breadth: 5)</span><br><span class="line">val.scaleBy(res: 13)</span><br><span class="line">print(&quot;\(val.length)---\(val.breadth)&quot;)</span><br></pre></td></tr></table></figure><ul><li>类型方法：类型方法的方法体中，self指向这个类型本身，而不是类型的某个实例<ul><li>静态方法只能访问静态方法和属性</li><li>实例方法可以访问实例方法和属性，通过类型调用静态方法和属性</li><li>用class修饰的方法可以被子类覆盖（重写）</li><li>在方法func关键字之前加上关键字<code>static</code>来指定类型方法，类还可以用关键字<code>class</code>来允许子类重写父类的方法实现</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">    var v1: Int!</span><br><span class="line">    var s1: String!</span><br><span class="line">    static var ss1: String!</span><br><span class="line">    class func f1()&#123;</span><br><span class="line">        print(&quot;static f1&quot;)</span><br><span class="line"></span><br><span class="line">        //***静态方法只能访问静态方法和属性</span><br><span class="line">        ss1 = &quot;hello&quot;</span><br><span class="line">        //        v1 = 1</span><br><span class="line">        //        f2()</span><br><span class="line">    &#125;</span><br><span class="line">    func f2()&#123;</span><br><span class="line">        print(&quot;f2&quot;)</span><br><span class="line"></span><br><span class="line">        //***实例方法可以访问实例方法和属性，通过类型调用静态方法和属性</span><br><span class="line">        MyClass.ss1 = &quot;world&quot;</span><br><span class="line">        MyClass.f1()</span><br><span class="line">    &#125;</span><br><span class="line">    //用class修饰的方法可以被子类覆盖（重写）</span><br><span class="line">    class func f3() &#123;</span><br><span class="line">        print(&quot;class f3&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MySubClass: MyClass &#123;</span><br><span class="line">    //override class：重写   f2不可重写</span><br><span class="line">    override class func f3()&#123;</span><br><span class="line">        print(&quot;override f3...&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass.ss1 = &quot;static ss1&quot;</span><br><span class="line">print(MyClass.ss1)</span><br><span class="line">MyClass.f1()</span><br><span class="line"></span><br><span class="line">MyClass.f3()</span><br><span class="line">MySubClass.f3()</span><br></pre></td></tr></table></figure><h1 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h1><p>可以定义在类，结构体，枚举中，是访问对象、集合、序列的快捷方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">subscript(index: Int) -&gt; Int &#123;</span><br><span class="line">get &#123;</span><br><span class="line">// 返回一个适当的 Int 类型的值</span><br><span class="line">&#125;</span><br><span class="line">set(newValue) &#123;</span><br><span class="line">// 执行适当的赋值操作</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>下标脚本类似于实例方法((Int)-&gt;Int)和计算型属性（set,get）的混合</li><li>可以读写或只读</li><li>newValue的类型和下标的返回类型相同，默认newValue<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">struct Matrix &#123;</span><br><span class="line">    let rows: Int,columns: Int</span><br><span class="line">    var grid: [Double]</span><br><span class="line">    init(rows: Int,columns: Int)&#123;</span><br><span class="line">        self.rows = rows</span><br><span class="line">        self.columns = columns</span><br><span class="line">        grid = Array(repeatElement(5.0, count: rows*columns))</span><br><span class="line">    &#125;</span><br><span class="line">    func indexIsValidForRow(row: Int,column: Int)-&gt;Bool&#123;</span><br><span class="line">        return row &gt;= 0 &amp;&amp; column &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; column &lt; columns</span><br><span class="line">    &#125;</span><br><span class="line">    subscript(row: Int,column: Int)-&gt;Double&#123;</span><br><span class="line">        get&#123;</span><br><span class="line">            print(&quot;get...\((row*columns)+column)&quot;)</span><br><span class="line">            assert(indexIsValidForRow(row: row, column: column), &quot;Index out of range&quot;)</span><br><span class="line">            return grid[(row*columns)+column]</span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            print(&quot;set...\((row*columns)+column)&quot;)</span><br><span class="line">            assert(indexIsValidForRow(row: row, column: column), &quot;Index out of range&quot;)</span><br><span class="line">            grid[(row*columns)+column] = newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var matr = Matrix(rows: 6, columns: 6)</span><br><span class="line">print(matr.grid)</span><br><span class="line">print(matr[5,5])</span><br></pre></td></tr></table></figure></li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="基类"><a href="#基类" class="headerlink" title="基类"></a>基类</h2><ul><li>如果你不为你定义的类指定一个超类的话，这个类就自动成为基类。</li></ul><h2 id="重写override"><a href="#重写override" class="headerlink" title="重写override"></a>重写override</h2><ul><li>可以重写继承来的实例方法、类方法、实例属性、类型属性，自定义getter和setter或添加属性观察器（可重写计算属性，方法，存储属性不可重写，可重写属性观察器）</li><li>重写属性的getter或setter<ul><li>可以为任意继承来的属性（存储属性或计算属性）自定义getter或setter</li><li>可以将继承来的只读属性重写为读写属性，但是不能将继承来的读写属性重写为只读属性。</li><li>如果在重写属性中提供了 setter，那么一定要提供 getter，如果不修改可以调用super方法</li></ul></li><li>重写属性观察器<ul><li>不可以为继承来的常量存储属性或只读计算属性添加属性观察器，因为这些属性的值是不可以修改的</li><li>不可以同时重写setter和属性观察器，因为在setter中就可以观察到任何值的变化</li></ul></li><li>防止重写 final<ul><li>final var,final func,final class fun,final subscript</li><li>final class 声明的类不能被继承</li></ul></li></ul><h1 id="构造过程"><a href="#构造过程" class="headerlink" title="构造过程"></a>构造过程</h1><ul><li>没有返回值</li><li>用于类、结构体或枚举<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init() &#123;</span><br><span class="line">// 在此处执行构造过程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="默认属性值"><a href="#默认属性值" class="headerlink" title="默认属性值"></a>默认属性值</h2><ul><li>如果一个属性总是使用相同的初始值，为其设置默认值比每次在构造器中赋值要好。</li></ul><h2 id="存储属性的初始赋值"><a href="#存储属性的初始赋值" class="headerlink" title="存储属性的初始赋值"></a>存储属性的初始赋值</h2><ul><li>存储属性在构造器中赋值时，它们的值是被直接设置的，不会触发任何属性观察器。</li><li><p>存储属性在构造器中赋值流程</p><ul><li>创建初始值</li><li>在属性定义中指定默认属性值</li><li>初始化实例，并调用init()方法</li></ul></li><li><p>可选属性类型：当存储属性声明为可选时，将自动初始化为空 nil</p></li><li>修改常量属性：<code>在init里可以对let的实例常量进行赋值</code>，可以在构造过程中的任意时间点给常量属性指定一个值，但是它的常量属性只能在定义它的类的构造过程中修改；不能在子类中修改</li><li>外部参数名：Swift 会为每个构造器的参数自动生成一个跟内部名字相同的外部名，如果不想提供外部名称可以使用下划线(_)来显式描述它的外部名</li><li>默认构造器：如果结构体或类的所有属性都有默认值，且它是没有父类的基类，同时没有自定义的构造器，swift会自动提供默认构造器，默认构造器将简单的创建一个所有属性值都设置为默认值的实例</li><li>逐一成员构造器：结构体自动获得一个逐一成员构造器</li><li>构造器代理规则<ul><li>值类型：不支持继承，可以使用self.init在自定义的构造器中引用其它的属于相同值类型的构造器</li><li>类类型：支持集成，类有责任保证其所有继承的存储型属性在构造时也能正确的初始化</li></ul></li></ul><h2 id="类的继承和构造过程"><a href="#类的继承和构造过程" class="headerlink" title="类的继承和构造过程"></a>类的继承和构造过程</h2><ul><li>类里面的所有存储型属性——包括所有继承自父类的属性——都必须在构造过程中设置初始值，可以通过指定构造器或便利构造器实现。<h3 id="指定构造器-designated"><a href="#指定构造器-designated" class="headerlink" title="指定构造器 designated"></a>指定构造器 designated</h3></li><li>初始化类中提供的所有属性，并根据父类链往上调用父类的构造器来实现父类的初始化，每一个类都必须拥有至少一个指定构造器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init(parameters) &#123;</span><br><span class="line">statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="便利构造器-convenience"><a href="#便利构造器-convenience" class="headerlink" title="便利构造器 convenience"></a>便利构造器 convenience</h3><ul><li>便利构造器可以调用同一个类中的指定构造器，并为其参数提供默认值，必要时创建。</li><li><code>convenience 的初始化方法是不能被子类重写或者从子类中以 super 的方式被调用的。</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">convenience init(parameters) &#123;</span><br><span class="line">statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="构造器的继承和重载：当重写一个父类指定构造器时，子类不会默认继承父类的构造器，需要写override，override-convenience"><a href="#构造器的继承和重载：当重写一个父类指定构造器时，子类不会默认继承父类的构造器，需要写override，override-convenience" class="headerlink" title="构造器的继承和重载：当重写一个父类指定构造器时，子类不会默认继承父类的构造器，需要写override，override convenience"></a>构造器的继承和重载：当重写一个父类指定构造器时，子类不会默认继承父类的构造器，需要写override，<code>override convenience</code></h3><h3 id="初始化方法的顺序"><a href="#初始化方法的顺序" class="headerlink" title="初始化方法的顺序"></a>初始化方法的顺序</h3><ul><li>设置子类自己需要初始化的参数</li><li>调用父类相应的初始化方法，<code>super.init()</code></li><li>对父类中需要改变的成员进行设定<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    var name: String?</span><br><span class="line">    init() &#123;</span><br><span class="line">        name = &quot;Animal&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let animal = Animal()</span><br><span class="line">print(animal.name!)</span><br><span class="line"></span><br><span class="line">class Dog: Animal &#123;</span><br><span class="line">    let age: Int</span><br><span class="line">    override init() &#123;</span><br><span class="line">        age = 10</span><br><span class="line">        // 如果不先把子类的成员初始化完成，下面就无法调用父类的初始化方法会报错,Swift 会自动的对父类的对应 init 方法进行调用</span><br><span class="line">        super.init() // Property &apos;self.age&apos; not initialized at super.init call</span><br><span class="line">        name = &quot;a dog&quot;  // 根据实际情况修改，如果不需要改变父类属性的话，可以不写</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">print(Dog().name!)</span><br></pre></td></tr></table></figure></li></ul><h3 id="初始化方法需要遵循的两个原则"><a href="#初始化方法需要遵循的两个原则" class="headerlink" title="初始化方法需要遵循的两个原则"></a>初始化方法需要遵循的两个原则</h3><ul><li>初始化路径必须保证对象<code>完全初始化</code>，这可以通过调用本类型的 designated 初始化方法得到保证。</li><li>子类的 designated 初始化方法<code>必须调用父类的 designated 方法</code>，以保证<code>父类成员也完成初始化</code>。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class ClassAA &#123;</span><br><span class="line">let numA: Int</span><br><span class="line">init(num: Int) &#123;</span><br><span class="line">numA = num</span><br><span class="line">&#125;</span><br><span class="line">convenience init(bigNum: Bool) &#123;</span><br><span class="line">self.init(num: bigNum ? 10000 : 1) // 所有的 convenience 初始化方法都必须调用同一个类中的 designated 初始化完成设置</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ClassBB: ClassAA &#123;</span><br><span class="line">let numB: Int</span><br><span class="line">override init(num: Int) &#123;</span><br><span class="line">numB = num + 1</span><br><span class="line">//只要在子类中实现重写了父类 convenience 方法所需要的 init 方法的话，我们在子类中就可以使用父类的 convenience 初始化方法了</span><br><span class="line">super.init(num: num)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let anObj = ClassBB(bigNum: true)</span><br><span class="line">print(anObj.numA, anObj.numB)</span><br></pre></td></tr></table></figure><h3 id="required"><a href="#required" class="headerlink" title="required"></a>required</h3><ul><li>对于某些我们希望子类中一定实现的 designated 初始化方法，我们可以通过添加<code>required</code>关键字进行限制，强制子类对这个方法重写实现。这样做的最大的好处是可以保证依赖于某个 designated 初始化方法的 convenience 一直可以被使用。</li><li>如果希望初始化方法对于子类一定可用，就将 init(num: Int) 声明为必须。对于 convenience 的初始化方法我们也可以加上 required 以确保子类对其进行实现。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class ClassAAA &#123;</span><br><span class="line">let numA: Int</span><br><span class="line">required init(num: Int) &#123;</span><br><span class="line">numA = num</span><br><span class="line">&#125;</span><br><span class="line">required convenience init(bigNum: Bool) &#123;</span><br><span class="line">self.init(num: bigNum ? 10000 : 1)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class ClassBBB: ClassAAA &#123;</span><br><span class="line">let numB: Int</span><br><span class="line">required init(num: Int) &#123;</span><br><span class="line">numB = num + 1</span><br><span class="line">super.init(num: num)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let sencondObj = ClassBBB(bigNum: true)</span><br><span class="line">print(sencondObj.numA, sencondObj.numB)</span><br></pre></td></tr></table></figure></li></ul><h2 id="可失败构造器（init-init-）"><a href="#可失败构造器（init-init-）" class="headerlink" title="可失败构造器（init?,init!）"></a>可失败构造器（init?,init!）</h2><ul><li>非可失败构造器（init），可失败构造器（init?），隐式解包可失败构造器（init!）</li><li>可失败构造器：可失败构造器会创建一个类型为自身的可选类型的对象，在init关键字后面添加问号(init?)，通过<code>return nil</code>来表明可失败构造器在何种情况下应该失败。</li><li>可失败构造器的参数名和参数类型，<code>不能与其它非可失败构造器的参数名，及其参数类型相同</code>。</li><li>变量初始化失败可能的原因有：<ul><li>传入无效的参数值</li><li>缺少某种所需的外部资源</li><li>没有满足特定条件</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct Animal &#123;</span><br><span class="line">    let species: String</span><br><span class="line">    init?(species: String) &#123;</span><br><span class="line">    if species.isEmpty &#123; return nil &#125;</span><br><span class="line">        self.species = species</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>枚举类型的可失败构造器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">enum TemperatureUnit &#123;</span><br><span class="line">    // 开尔文，摄氏，华氏</span><br><span class="line">    case Kelvin, Celsius, Fahrenheit</span><br><span class="line">    init?(symbol: Character) &#123;</span><br><span class="line">        switch symbol &#123;</span><br><span class="line">            case &quot;K&quot;:</span><br><span class="line">            self = .Kelvin</span><br><span class="line">            case &quot;C&quot;:</span><br><span class="line">            self = .Celsius</span><br><span class="line">            case &quot;F&quot;:</span><br><span class="line">            self = .Fahrenheit</span><br><span class="line">            default:</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>何时触发：值类型的可失败构造器何时触发没有限制，类的可失败构造器只能在所有的类属性被初始化后和所有类之间的代理调用发生完后触发失败行为</p></li><li>覆盖一个可失败构造器：可以用子类的可失败构造器或非失败构造器覆盖基类的可失败构造器</li><li>但一个非失败构造器永远不能代理调用一个可失败构造器</li><li>init!<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct StudRecord &#123;</span><br><span class="line">    let stname: String</span><br><span class="line"></span><br><span class="line">    init!(stname: String) &#123;</span><br><span class="line">    if stname.isEmpty &#123;return nil &#125;</span><br><span class="line">    self.stname = stname</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let stmark = StudRecord(stname: &quot;Runoob&quot;)</span><br><span class="line">if let name = stmark &#123;</span><br><span class="line">    print(&quot;指定了学生名&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let blankname = StudRecord(stname: &quot;&quot;)</span><br><span class="line">if blankname == nil &#123;</span><br><span class="line">    print(&quot;学生名为空&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="类的构造器代理规则"><a href="#类的构造器代理规则" class="headerlink" title="类的构造器代理规则"></a>类的构造器代理规则</h2><ul><li>指定构造器必须调用其直接父类的指定构造器</li><li>便利构造器必须调用其同类定义的其他构造器</li><li>便利构造器必须最终导致一个指定构造器被调用<blockquote><p>指定构造器向上代理，便利构造器横向代理</p></blockquote></li></ul><h2 id="两段式构造过程"><a href="#两段式构造过程" class="headerlink" title="两段式构造过程"></a>两段式构造过程</h2><ul><li>安全检查1<br>指定构造器必须保证它所在类引入的所有属性都必须先初始化完成，之后才能将其它构造任务向上代理给父类中的构造器。</li><li>安全检查2<br>指定构造器必须先向上代理调用父类构造器，然后再为继承的属性设置新值。</li><li>安全检查3<br>便利构造器必须先代理调用同一类中的其它构造器，然后再为任意属性赋新值。</li><li>安全检查4<br>构造器在第一阶段构造完成之前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用self作为一个值。</li></ul><h1 id="析构过程"><a href="#析构过程" class="headerlink" title="析构过程"></a>析构过程</h1><p>*<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deinit &#123;</span><br><span class="line">// 执行析构过程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="自动引用计数"><a href="#自动引用计数" class="headerlink" title="自动引用计数"></a>自动引用计数</h1><blockquote><p>引用计数仅仅应用于类的实例。结构体和枚举类型是值类型。</p></blockquote><h2 id="类实例之间的循环强引用"><a href="#类实例之间的循环强引用" class="headerlink" title="类实例之间的循环强引用"></a>类实例之间的循环强引用</h2><h3 id="弱引用-weak"><a href="#弱引用-weak" class="headerlink" title="弱引用 weak"></a>弱引用 weak</h3><ul><li>当 ARC 设置弱引用为nil时，属性观察不会被触发</li></ul><p>1.与OC类似的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">weak var weakSelf = self</span><br><span class="line">loadData&#123;</span><br><span class="line">print(&quot;\(weakSelf?.view)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.swift推荐的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loadData&#123; [weak self] in</span><br><span class="line">print(&quot;\(self?.view)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="无主引用-unowned"><a href="#无主引用-unowned" class="headerlink" title="无主引用 unowned"></a>无主引用 unowned</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loadData&#123; [unowned self] in</span><br><span class="line">print(&quot;\(self.view)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环引用总结"><a href="#循环引用总结" class="headerlink" title="循环引用总结"></a>循环引用总结</h3><ul><li><code>对于生命周期中会变为nil的实例使用弱引用。相反的，对于初始化赋值后再也不会被赋值为nil的实例，使用无主引用。</code> 当其他的实例有更短的生命周期时，使用弱引用(当其他实例析构在先)，当其他实例有相同的或者更长生命周期时，请使用无主引用</li><li>swift<ul><li><code>[weak self]</code>：self是可选项，如果self已经被释放，则为nil</li><li><code>[unowned self]</code>：self不是可选项，如果self已经被释放，则为野指针访问，使用无主引用，必须确保引用始终指向一个未销毁的实例</li></ul></li><li>Objc<ul><li><code>__weak typeof(self) weakSelf;</code>：如果self已经被释放，则为nil</li><li><code>__unsafe_unretained typeof(self) weakSelf;</code>：如果self已经被释放，则为野指针访问</li></ul></li></ul><h2 id="闭包引起的循环强引用"><a href="#闭包引起的循环强引用" class="headerlink" title="闭包引起的循环强引用"></a>闭包引起的循环强引用</h2><blockquote><p>解决闭包引起的循环强引用:闭包捕获列表，在定义闭包时同时定义捕获列表作为闭包的一部分</p></blockquote><ul><li>当闭包和捕获的实例总是互相引用时并且总是<code>同时销毁</code>时，将闭包内的捕获定义为<code>无主引用</code>。<br>相反的，当捕获引用有时<code>可能会是nil</code>时，将闭包内的捕获定义为<code>弱引用</code>。<br>如果捕获的引用<code>绝对不会置为nil</code>，应该用<code>无主引用</code>，而不是弱引用。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lazy var someClosure: (Int, String) -&gt; String = &#123;</span><br><span class="line">[unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -&gt; String in</span><br><span class="line">// 这里是闭包的函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="可选链"><a href="#可选链" class="headerlink" title="可选链"></a>可选链</h1><blockquote><p>可以应用于任意类型，并且能检查调用是否成功。<br><code>多次请求或调用可以被链接成一个链，如果任意一个节点为nil将导致整条链失效</code></p></blockquote><ul><li>通过可选链访问属性，返回两个值：<ul><li>如果目标有值，调用成功，返回该值</li><li>如果目标为nil，调用返回nil</li></ul></li><li><p>通过可选链调用方法，返回两个值：</p><ul><li>如果调用成功，返回Void</li><li>如果没有称，返回nil</li></ul></li><li><p>可选链可代替强制解析：</p><ul><li>?：当可选为nil，输出预定的错误信息</li><li>! ：当可选为nil，强制展开执行错误</li></ul></li><li><p>连接多层可选链：如果试图通过可选链获得Int值，不论使用了多少层链接返回的总是Int?。</p></li><li>可以通过可选链调用返回为可空值的方法，并且可以继续对可选值进行链接。</li></ul><h1 id="错误处理-1"><a href="#错误处理-1" class="headerlink" title="错误处理"></a>错误处理</h1><h2 id="表示并抛出错误-throw"><a href="#表示并抛出错误-throw" class="headerlink" title="表示并抛出错误(throw)"></a>表示并抛出错误(throw)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//枚举构建一组相关的错误状态，枚举的关联值还可以提供错误状态的额外信息</span><br><span class="line">enum VendingMachineError: Error &#123;</span><br><span class="line">case invalidSelection                    //选择无效</span><br><span class="line">case insufficientFunds(coinsNeeded: Int) //金额不足</span><br><span class="line">case outOfStock                          //缺货</span><br><span class="line">&#125;</span><br><span class="line">//抛出一个错误</span><br><span class="line">throw VendingMachineError. insufficientFunds(coinsNeeded: 5)</span><br></pre></td></tr></table></figure><h2 id="throwing函数"><a href="#throwing函数" class="headerlink" title="throwing函数"></a>throwing函数</h2><ul><li><code>throws</code>写在函数声明的参数列表后，<code>-&gt;</code>前。<blockquote><p>throwing函数可在其内部抛出错误，将错误传递到函数被调用时的作用域，非throwing函数内部抛出的错误只能在函数内部处理。</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func canThrowErrors() throws -&gt; String</span><br></pre></td></tr></table></figure><h2 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h2><ul><li>处理错误的四种方式：<ul><li>把函数抛出的错误传递给调用此函数的代码</li><li>do-catch语句</li><li>将错误作为可选类型：<code>try?</code></li><li>断言此错误根本不会发生</li></ul></li></ul><h3 id="do-catch"><a href="#do-catch" class="headerlink" title="do-catch"></a>do-catch</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    try expression</span><br><span class="line">    statements</span><br><span class="line">&#125; catch pattern 1 &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125; catch pattern 2 where condition &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将错误转换成可选值-try"><a href="#将错误转换成可选值-try" class="headerlink" title="将错误转换成可选值 try?"></a>将错误转换成可选值 try?</h3><ul><li>如果在评估try?表达式时一个错误被抛出，那么表达式的值就是nil。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let y = try? someThrowingFunction()</span><br><span class="line">等价于</span><br><span class="line">let y: Int?</span><br><span class="line">do &#123;</span><br><span class="line">    y = try someThrowingFunction()</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">    y = nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="禁用错误传递-try"><a href="#禁用错误传递-try" class="headerlink" title="禁用错误传递 try!"></a>禁用错误传递 try!</h3><ul><li>会把调用包装在一个不会有错误抛出的运行时断言中，如果真的抛出，则会发生运行时错误。</li></ul><h2 id="指定清理操作-defer"><a href="#指定清理操作-defer" class="headerlink" title="指定清理操作 defer"></a>指定清理操作 defer</h2><ul><li>defer语句在即将离开当前代码块时（throw,return,break等）执行一系列语句。<br>将代码的执行延迟到当前作用域退出之前，延时执行的操作会按照被指定时的顺序的相反顺序执行，即第一条defer语句中的代码会在第二条defer语句中的代码被执行之后才执行，以此类推。</li><li><code>即使没有涉及到错误处理，也可以使用defer语句</code></li></ul><h1 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h1><h2 id="检查值的类型：is"><a href="#检查值的类型：is" class="headerlink" title="检查值的类型：is"></a>检查值的类型：is</h2><ul><li>用类型检查操作符（is）来检查一个实例是否属于特定子类型。</li></ul><h2 id="向下转型：as"><a href="#向下转型：as" class="headerlink" title="向下转型：as"></a>向下转型：as</h2><ul><li>某类型的一个常量或变量可能在幕后实际上属于一个子类，用<code>as</code>向下转到它的子类型。</li><li>转换没有真的改变实例或它的值</li><li>类型转换的条件转换：as? as!<ul><li>可选形式as?：下转成一个可选值</li><li>强制形式as!：向下转型+强制解包</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for item in library&#123;</span><br><span class="line">    //（1）item不确定是什么类型，所以as?</span><br><span class="line">    if let movie = item as? Movie&#123;</span><br><span class="line">        //（2）使用可选绑定类型进行可选解析</span><br><span class="line">        print(&quot;\(movie.name)--\(movie.director)&quot;)</span><br><span class="line">    &#125;else if let song = item as? Song&#123;</span><br><span class="line">        print(&quot;\(song.name)--\(song.artist)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取实例的类型名称"><a href="#获取实例的类型名称" class="headerlink" title="获取实例的类型名称"></a>获取实例的类型名称</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let someStr = &quot;123&quot;</span><br><span class="line">print(type(of: someStr))    //String</span><br></pre></td></tr></table></figure><h2 id="Any-和-AnyObject-的类型转换"><a href="#Any-和-AnyObject-的类型转换" class="headerlink" title="Any 和 AnyObject 的类型转换"></a>Any 和 AnyObject 的类型转换</h2><ul><li>Any 可以表示任何类型，包括函数类型、可选类型。</li><li>AnyObject 可以表示任何类型的实例，AnyObject 也是Optional类型的。<blockquote><p>Any类型可以表示所有类型的值，包括可选类型。Swift 会在你用Any类型来表示一个可选值的时候，给你一个警告。如果你确实想使用Any类型来承载可选值，你可以使用as操作符显式转换为Any。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 可以存储Any类型的数组</span><br><span class="line">var arr1 = [Any]()</span><br><span class="line">// [AnyObject] 类型的数组</span><br><span class="line">var arr2: [AnyObject]</span><br></pre></td></tr></table></figure></blockquote></li></ul><h1 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h1><ul><li>类、枚举、结构体之间可相互嵌套</li></ul><h1 id="扩展-Extensions"><a href="#扩展-Extensions" class="headerlink" title="扩展 Extensions"></a>扩展 Extensions</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">extension SomeType &#123;</span><br><span class="line">// 为 SomeType 添加的新功能写到这里</span><br><span class="line">&#125;</span><br><span class="line">extension SomeType: SomeProtocol, AnotherProctocol &#123;</span><br><span class="line">// 协议实现写到这里</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>与OC中的分类类似，但是swift中的扩展没有名字</li><li>扩展可以添加新的计算属性，但是不可以添加存储属性，也不可以向已有属性添加属观察器</li><li>可用于向已有的类、结构体、枚举或协议添加新功能，但是不能重写已有的功能。</li><li>通过为一个已有类型添加新功能，则<code>新功能对该类型的所有实例都有效</code>，即使它们是在扩展定义之前创建的</li><li><p>可以实现的功能：</p><ul><li>添加计算型属性和计算型类型属性</li><li>定义实例方法和类型方法</li><li>提供新的构造器</li><li>定义下标</li><li>定义和使用新的嵌套类型</li><li>使一个已有类型符合某个协议</li></ul></li><li><p>swift4：extension中可以访问private属性</p></li></ul><h2 id="计算型属性"><a href="#计算型属性" class="headerlink" title="计算型属性"></a>计算型属性</h2><ul><li>扩展可以添加新的计算属性，但是不可以添加<code>存储型属性</code>，也不可以为已有属性添加<code>属性观察器</code>。</li></ul><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><ul><li>扩展可以为类添加新的便利构造器，不可以添加新的指定构造器或析构器。指定构造器和析构器必须由原始类提供。</li></ul><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><p>通过扩展添加的实例方法可以修改该实例本身，结构体和枚举类型中修改self或其属性的方法必须将该实例方法标注为mutating</p><h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><p>类、枚举、结构体都可以实现协议</p><h2 id="协议语法"><a href="#协议语法" class="headerlink" title="协议语法"></a>协议语法</h2><p>定义协议：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol SomeProtocol &#123;</span><br><span class="line">// 协议的定义部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>遵循协议：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct SomeStructure: FirstProtocol, AnotherProtocol &#123;</span><br><span class="line">// 结构体的定义部分</span><br><span class="line">&#125;</span><br><span class="line">class SomeClass: SomeSuperClass, FirstProtocol, AnotherProtocol &#123;</span><br><span class="line">// 类的内容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="属性要求"><a href="#属性要求" class="headerlink" title="属性要求"></a>属性要求</h2><ul><li><p>协议可以要求遵循协议的类型提供的实例属性或类型属性的<code>名称和类型</code>，还可指定<code>读写性</code>，但不用指定是存储型属性或计算型属性。</p><blockquote><p>用<code>var</code>声明变量属性，用<code>{set get}</code>声明属性是可读可写的，<code>{get}</code>表示只读属性。</p></blockquote></li><li><p>类属性要求使用static前缀关键字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol AnotherProtocol &#123;</span><br><span class="line">    static var someTypeProperty: Int &#123; get set &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="方法要求"><a href="#方法要求" class="headerlink" title="方法要求"></a>方法要求</h2><ul><li>方法不需要大括号和方法体</li><li>不支持为协议中的方法的参数提供默认值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protocol classa &#123;</span><br><span class="line">var marks: Int &#123; get set &#125;</span><br><span class="line">var result: Bool &#123; get &#125;</span><br><span class="line"></span><br><span class="line">func attendance() -&gt; String</span><br><span class="line">func markssecured() -&gt; String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Mutating-方法要求"><a href="#Mutating-方法要求" class="headerlink" title="Mutating 方法要求"></a>Mutating 方法要求</h2><ul><li>表示可以在该方法中修改它所属的实例及其实例属性的值</li><li>实现协议中的mutating方法时，若是类类型，则不用写<code>mutating</code>，对于结构体和枚举必须写。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protocol SomeProtocal &#123;</span><br><span class="line">    mutating func show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造器要求"><a href="#构造器要求" class="headerlink" title="构造器要求"></a>构造器要求</h2><ul><li><p>协议构造器在类中的实现：在遵循该协议的类中实现构造器，并指定其为类的指定构造器或便利构造器，这时必须为构造器实现标上<code>required</code>修饰符，可以确保遵循该协议的子类也能提供此构造器的显式实现或继承实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class SomeClass: SomeProtocol &#123;</span><br><span class="line">    required init(someParameter: Int) &#123;</span><br><span class="line">    // 构造器实现</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果一个子类重写了父类的指定构造器，并且该构造器满足了某个协议的要求，则构造器的实现需要标上<code>required</code>和<code>override</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">protocol SomeProtocol &#123;</span><br><span class="line">    init()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SomeSuperClass &#123;</span><br><span class="line">    init() &#123;</span><br><span class="line">    // 这里是构造器的实现部分</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SomeSubClass: SomeSuperClass, SomeProtocol &#123;</span><br><span class="line">    // 因为遵循协议，需要加上 required</span><br><span class="line">    // 因为继承自父类，需要加上 override</span><br><span class="line">    required override init() &#123;</span><br><span class="line">    // 这里是构造器的实现部分</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="协议作为类型"><a href="#协议作为类型" class="headerlink" title="协议作为类型"></a>协议作为类型</h2><ul><li>作为函数、方法或构造器中的参数类型或返回值类型</li><li>作为常量、变量或属性的类型</li><li>作为数组、字典或其他容器中的元素类型</li></ul><h2 id="协议可以继承"><a href="#协议可以继承" class="headerlink" title="协议可以继承"></a>协议可以继承</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol InheritingProtocol: SomeProtocol, AnotherProtocol &#123;</span><br><span class="line">// 协议定义</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类专属协议"><a href="#类专属协议" class="headerlink" title="类专属协议"></a>类专属协议</h2><ul><li>在协议继承列表添加<code>class</code>关键字，可以限制协议只能适配到类类型</li><li><code>该class关键字必须是第一个出现在协议的继承列表中，其后才是其他集继承协议</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol SomeClassOnlyProtocol: class, SomeInheritedProtocol &#123;</span><br><span class="line">// 协议定义</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="协议的合成"><a href="#协议的合成" class="headerlink" title="协议的合成"></a>协议的合成</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">protocol Stname &#123;</span><br><span class="line">var name: String &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol Stage &#123;</span><br><span class="line">var age: Int &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Person: Stname, Stage &#123;</span><br><span class="line">var name: String</span><br><span class="line">var age: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func show(celebrator: Stname &amp; Stage) &#123;</span><br><span class="line">print(&quot;\(celebrator.name) is \(celebrator.age) years old&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let studname = Person(name: &quot;Priya&quot;, age: 21)</span><br><span class="line">print(show(celebrator: studname))   //Priya is 21 years old</span><br></pre></td></tr></table></figure><h2 id="协议的组合使用"><a href="#协议的组合使用" class="headerlink" title="协议的组合使用"></a>协议的组合使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protocol&lt;ProtocolA, ProtocolB, ProtocolC&gt; 等价于</span><br><span class="line">protocol ProtocolD: ProtocolA, ProtocolB, ProtocolC &#123;</span><br><span class="line">//...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="检查协议一致性"><a href="#检查协议一致性" class="headerlink" title="检查协议一致性"></a>检查协议一致性</h2><ul><li>is：检查实例湿度遵循了某个协议</li><li>as?：当实例遵循了协议时，返回该协议类型，否则返回nil</li><li>as! ：强制向下转换类型，如果失败，会引起运行时错误</li></ul><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><ul><li>泛型使用占位类型名（在这里用字母 T 来表示）来代替实际类型名（例如 Int、String 或 Double）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个交换两个变量的函数</span><br><span class="line">func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T) &#123;</span><br><span class="line">    //可以不使用额外空间而使用多元组特性直接交换 a 和 b 的值</span><br><span class="line">    (a, b) = (b, a)</span><br><span class="line">&#125;</span><br><span class="line">var a = 5, b = 6</span><br><span class="line">swapTwoValues(&amp;a, &amp;b)</span><br><span class="line">print(a, b)</span><br><span class="line"></span><br><span class="line">//泛型的栈</span><br><span class="line">struct Stack&lt;Element&gt; &#123;</span><br><span class="line">    var items = [Element]()</span><br><span class="line">    mutating func push(_ item: Element) &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    mutating func pop() -&gt; Element &#123;</span><br><span class="line">        return items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var stackOfStrings = Stack&lt;String&gt;()</span><br></pre></td></tr></table></figure></li></ul><h2 id="扩展泛型类型"><a href="#扩展泛型类型" class="headerlink" title="扩展泛型类型"></a>扩展泛型类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">extension Stack &#123;</span><br><span class="line">    //扩展了一个只读计算型属性</span><br><span class="line">    var topItem: Element? &#123;</span><br><span class="line">        return items.isEmpty ? nil : items[items.count - 1]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//T 必须是 SomeClass 子类的类型约束,要求 U 必须符合 SomeProtocol 协议的类型约束</span><br><span class="line">func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) &#123;</span><br><span class="line">// 这里是泛型函数的函数体部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关联类-associatedtype"><a href="#关联类-associatedtype" class="headerlink" title="关联类 associatedtype"></a>关联类 associatedtype</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// Container 协议</span><br><span class="line">protocol Container &#123;</span><br><span class="line">    associatedtype ItemType</span><br><span class="line">    // 添加一个新元素到容器里</span><br><span class="line">    mutating func append(_ item: ItemType)</span><br><span class="line">    // 获取容器中元素的数</span><br><span class="line">    var count: Int &#123; get &#125;</span><br><span class="line">    // 通过索引值类型为 Int 的下标检索到容器中的每一个元素</span><br><span class="line">subscript(i: Int) -&gt; ItemType &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Stack 结构体遵从 Container 协议</span><br><span class="line">struct Stack&lt;Element&gt;: Container &#123;</span><br><span class="line">// Stack&lt;Element&gt; 的原始实现部分</span><br><span class="line">    var items = [Element]()</span><br><span class="line">    mutating func push(_ item: Element) &#123;</span><br><span class="line">    items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    mutating func pop() -&gt; Element &#123;</span><br><span class="line">    return items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">    // Container 协议的实现部分</span><br><span class="line">    mutating func append(_ item: Element) &#123;</span><br><span class="line">    self.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">    var count: Int &#123;</span><br><span class="line">    return items.count</span><br><span class="line">    &#125;</span><br><span class="line">    subscript(i: Int) -&gt; Element &#123;</span><br><span class="line">    return items[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="where语句"><a href="#where语句" class="headerlink" title="where语句"></a>where语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//用来检查两个Container实例是否包含相同顺序的相同元素</span><br><span class="line">func allItemsMatch&lt;C1: Container, C2: Container&gt;</span><br><span class="line">(_ someContainer: C1, _ anotherContainer: C2) -&gt; Bool</span><br><span class="line">where C1.ItemType == C2.ItemType, C1.ItemType: Equatable &#123;</span><br><span class="line"></span><br><span class="line">    // 检查两个容器含有相同数量的元素</span><br><span class="line">    if someContainer.count != anotherContainer.count &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 检查每一对元素是否相等</span><br><span class="line">    for i in 0..&lt;someContainer.count &#123;</span><br><span class="line">        if someContainer[i] != anotherContainer[i] &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 所有元素都匹配，返回 true</span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h1><ul><li>可以给单个类型（类、结构体、枚举）设置访问级别，也可以给这些类型的属性、函数、初始化方法、基本类型、下标、协议等设置访问级别</li><li>访问控制基于模块与源文件<ul><li>模块：独立单元构建和发布的framework或application</li><li>源文件：通常属于一个模块，源文件可以包含多个类和函数的定义</li></ul></li></ul><h2 id="四种访问级别"><a href="#四种访问级别" class="headerlink" title="四种访问级别"></a>四种访问级别</h2><ul><li>四种访问级别，从高到低，默认为<code>internal</code>：<br>| 访问级别 | 权限  |<br>|:——–:|———-|<br>|   public    | 可以访问自己模块中源文件里的任何实体，别人也可以通过引入该模块来访问源文件里的所有实体   |<br>|   internal   | 可以访问自己模块中源文件里的任何实体，别人不能   |<br>|   fileprivate    | 文件内私有，只能在当前源文件中使用   |<br>|   private    | 只能在类中访问，离开了这个类或者结构体的作用域外面就无法访问   |</li></ul><h2 id="访问级别的原则"><a href="#访问级别的原则" class="headerlink" title="访问级别的原则"></a>访问级别的原则</h2><ul><li><p><code>元组</code>的访问级别与元组中访问级别<code>最低的类型</code>一致（元组 = min（元组中元素））</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">internal class SomeInternalClass &#123;&#125;</span><br><span class="line">private class SomePrivateClass &#123;&#125;</span><br><span class="line">//该函数返回类型的访问级别是 private，必须使用 private 修饰符，明确的声明该函数</span><br><span class="line">func someFunction() -&gt; (SomeInternalClass, SomePrivateClass) &#123;</span><br><span class="line">// 函数实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>枚举中<code>成员</code>的访问级别<code>继承自该枚举</code>，不能为枚举中的成员单独声明不同的访问级别（枚举成员 = 枚举）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public enum Student &#123;</span><br><span class="line">    case Name(String)</span><br><span class="line">    case Mark(Int,Int,Int)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>子类的访问级别<code>不得高于父类</code>的访问级别。（子类 &lt;= 父类）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class SuperClass &#123;</span><br><span class="line">    fileprivate func show() &#123;</span><br><span class="line">    print(&quot;超类&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 访问级别不能低于超类 internal &gt; public</span><br><span class="line">internal class SubClass: SuperClass  &#123;</span><br><span class="line">    override internal func show() &#123;</span><br><span class="line">    print(&quot;子类&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>常量、变量、属性<code>不能拥有比它们的类型更高</code>的访问级别，下标也不能拥有比索引类型或返回类型更高的访问级别（常量、变量、属性、下标 &lt;= 它的类型）</p></li><li><p>常量、变量、属性、下标索引的getter和setter的访问级别<code>继承自他们所属成员</code>的访问级别，setter的访问级别可以低于对应的getter的访问级别，这样可以控制常量、变量、下标的读写权限（getter和setter = 常量、变量、属性、下标索引，getter &gt;= setter）</p></li><li><p>构造器和默认构造器访问级别：</p><ul><li>自定义的初始化方法 &lt;= 它所属类</li><li>必要构造器 = 所属类</li><li>函数中，初始化方法参数 &gt;= 初始化方法</li><li>默认构造器 = 所属类型</li></ul></li><li><p>协议访问级别（请确保该协议只在声明的访问级别作用域中使用）：实现协议的必要函数 = 协议</p></li><li><p>扩展访问级别：扩展成员 = 原始类成员，单独成员所声明的访问级别可以覆盖扩展的默认访问级别。</p></li><li><p>泛型访问级别 = min（泛型类型、函数本身、泛型类型参数）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public struct TOS&lt;T&gt; &#123;</span><br><span class="line">    var items = [T]()</span><br><span class="line">    private mutating func push(item: T) &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutating func pop() -&gt; T &#123;</span><br><span class="line">        return items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类型别名 &lt;= 原类型</p></li></ul><h1 id="高级运算符"><a href="#高级运算符" class="headerlink" title="高级运算符"></a>高级运算符</h1><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><ul><li>按位取反：~</li><li>按位与：&amp;</li><li>按位或：|</li><li>按位异或：^</li><li>按位左移：&lt;&lt;(乘2)</li><li>按位右移：&gt;&gt;(除2)</li><li>有符号整数的移位运算：0代表证书，1代表负数，负数表示用二进制补码</li></ul><h2 id="溢出运算符"><a href="#溢出运算符" class="headerlink" title="溢出运算符"></a>溢出运算符</h2><ul><li>溢出加法：&amp;+</li><li>溢出减法：&amp;-</li><li>溢出乘法：&amp;*</li></ul><h2 id="优先级和结合性"><a href="#优先级和结合性" class="headerlink" title="优先级和结合性"></a>优先级和结合性</h2><ul><li>乘法与取余运算都是左结合</li></ul><h2 id="运算符函数"><a href="#运算符函数" class="headerlink" title="运算符函数"></a>运算符函数</h2><h2 id="重载-自定义运算符"><a href="#重载-自定义运算符" class="headerlink" title="重载/自定义运算符"></a>重载/自定义运算符</h2><ul><li><p>重载运算符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func +(left: Vector2D, right:Vector2D) -&gt; Vector2D &#123;</span><br><span class="line">    return Vector2D(x: left.x + right.x, y: left.y + right.y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let v1 = Vector2D(x: 2, y: 3)</span><br><span class="line">let v2 = Vector2D(x: 1, y: 4)</span><br><span class="line">let v3 = Vector2D(x: v1.x+v2.x, y: v1.y+v2.y)</span><br><span class="line">let v4 = v1 + v2 + v3</span><br></pre></td></tr></table></figure></li><li><p>自定义运算符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func +*(left: Vector2D, right:Vector2D) -&gt; Double &#123;</span><br><span class="line">return left.x * right.x + left.y * right.y</span><br><span class="line">&#125;</span><br><span class="line">let result1 = v1 +* v2</span><br></pre></td></tr></table></figure></li></ul><h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// FirstClass.swift</span><br><span class="line">// 这个文件存在于 MyFramework.framework 中</span><br><span class="line">public class FirstClass &#123;</span><br><span class="line">    public class func hello() &#123;</span><br><span class="line">        print(&quot;hello from first&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// SecondClass.swift</span><br><span class="line">// 这个文件存在于 app 的主 target 中</span><br><span class="line">class SecondClass &#123;</span><br><span class="line">    class func hello() &#123;</span><br><span class="line">        print(&quot;hello from second&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">FirstClass.MyClass.hello()</span><br><span class="line">// hello from firsst</span><br><span class="line">SecondClass.MyClass.hello()</span><br><span class="line">// hello from second</span><br></pre></td></tr></table></figure><h1 id="Swift-UI部分"><a href="#Swift-UI部分" class="headerlink" title="Swift UI部分"></a>Swift UI部分</h1><p>Q:编译错误：<code>The “Swift Language Version” (SWIFT_VERSION) build setting must be set to a supported value for targets which use Swift. This setting can be set in the build settings editor.</code><br>A:解决：Build Settings-&gt;Swift Language Version 选择一个最新的swift版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var myBtn: UIButton?</span><br><span class="line">myBtn = UIButton(type:UIButtonType.system)</span><br><span class="line">myBtn!.frame = CGRect(x: 100, y: 100, width: 100, height: 44)</span><br><span class="line">myBtn!.backgroundColor = UIColor.red</span><br><span class="line">myBtn!.setTitle(&quot;注册&quot;, for: UIControlState.normal)</span><br><span class="line">myBtn!.addTarget(self, action: Selector((&quot;register:&quot;)), for: UIControlEvents.touchUpInside)</span><br><span class="line">self.view.addSubview(myBtn!)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var myBtn: UIButton!</span><br><span class="line">myBtn = UIButton(type:UIButtonType.system)</span><br><span class="line">myBtn!.frame = CGRect(x: 100, y: 100, width: 100, height: 44)</span><br><span class="line">myBtn!.backgroundColor = UIColor.red</span><br><span class="line">myBtn!.setTitle(&quot;注册&quot;, for: .normal)</span><br><span class="line">myBtn!.addTarget(self, action: #selector(register(sender:)), for: .touchUpInside)</span><br><span class="line">view.addSubview(myBtn!)</span><br><span class="line"></span><br><span class="line">@objc func register(sender: UIButton)&#123;</span><br><span class="line">print(&quot;register click&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><ul><li><p>swift中单例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//swift中的let是线程安全的</span><br><span class="line">static let instance: NetworkTools = NetworkTools()</span><br><span class="line">class func shareNetworkTools() -&gt; NetworkTools&#123;</span><br><span class="line">    return instance</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>OC中单例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+(instancetype)shareNetworkTools&#123;</span><br><span class="line">    static id instance;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">        //onceToken默认等于0，如果是0就执行block，如果不是就不执行</span><br><span class="line">        NSLog(@&quot;%ld&quot;,onceToken);</span><br><span class="line">        dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        instance = [[self alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="swift的常用内置函数总结"><a href="#swift的常用内置函数总结" class="headerlink" title="swift的常用内置函数总结"></a>swift的常用内置函数总结</h1><ul><li>abs</li><li>assert</li><li>countElements</li><li>enumerate</li><li>sort</li><li>contains(sequence, element)</li><li>dropFirst(sequence)</li><li>dropLast(sequence)</li><li>dump(object)：打印出某个对象object的所有信息</li><li>equal(sequence1, sequence2)：判断两个序列是否相等</li><li>filter(sequence, includeElementClosure)：对序列sequence中每个元素都执行includeElementClosure闭包，并将所有闭包结果为true的元素合成一个新序列sequence并返回。</li><li>find(sequence, element)：返回序列sequence中某元素element的位置index。如果序列中不存在此元素，则返回nil。</li><li>indices(sequence)：返回序列sequence中所有元素的位置（indices是index的复数）</li><li>join(separator, sequence)：将序列sequence通过分隔符separator连成一个字符串，并返回此字符串。</li><li>map(sequence, transformClosure)：对序列sequence中每个元素都执行includeElementClosure闭包，并将所有闭包的结果合成一个新序列sequence并返回。</li><li>max(comparable1, comparable2, etc.)  min(comparable1, comparable2, etc.)</li><li>maxElement(sequence)：返回序列sequence中的最大值。  minElements(sequence)：返回序列sequence中的最小值。</li><li>reverse(sequence)：返回逆序的序列sequence。</li></ul><p>参考资料：<a href="http://wiki.jikexueyuan.com/project/swift">The Swift Programming Language中文版</a><br><a href="http://blog.csdn.net/banma2008/article/details/46360333">Swift的74个常用内置函数介绍</a><br><a href="http://www.cocoachina.com/ios/20151218/14716.html">深入探究Swift数组背后的协议、方法、拓展</a><br><a href="https://github.com/allenwong/30DaysofSwift">30个swift项目源码</a><br><a href="https://github.com/cjiong/LearnSwift">50个swift项目源码</a><br><a href="https://github.com/yagamis/swift2basic">https://github.com/yagamis/swift2basic</a><br><a href="https://github.com/KeyJohn/Swift">https://github.com/KeyJohn/Swift</a></p><p><a href="http://www.swift51.com/openSource.htm">Swift编程</a><br><a href="http://lib.csdn.net/article/swift/52339">swift 框架大全</a></p>-->]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>podspec学习笔记</title>
      <link href="/2017/07/11/podspec%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/07/11/podspec%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>1.创建spec文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod spec create spec文件名</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>2.创建工程<br>(1)将组件代码放到Classes中<br>(2)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod lib create 组件代码名称</span><br></pre></td></tr></table></figure></p><p>需要重新<code>pod install</code></p><p>3.验证spec文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pod lib lint</span><br><span class="line">pod lib lint --allow-warnings //屏蔽警告</span><br><span class="line">pod lib lint --verbose  //获取错误的更多提示信息</span><br></pre></td></tr></table></figure></p><p>出现<code>XXX passed validation.</code>信息则成功，否则按照提示进行修改。</p><p>4.指定tag<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -m &quot;podspec description&quot; &quot;0.0.1&quot;</span><br><span class="line">$ git push --tags</span><br></pre></td></tr></table></figure></p><p>5.推送到cocoapods官方库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//注册</span><br><span class="line">pod trunk register EMAIL [NAME]</span><br><span class="line">//推送</span><br><span class="line">pod trunk push spec文件名</span><br></pre></td></tr></table></figure></p><p>6.搜索<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod search spec文件名</span><br></pre></td></tr></table></figure></p><p>7.安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &apos;spec文件名&apos;，&apos;~&gt;0.0.1&apos;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cocoapods </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Babel学习笔记</title>
      <link href="/2017/07/11/Babel%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/07/11/Babel%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>Babel：ES6转码器。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install babel@5 --save  //安装ES5</span><br><span class="line">npm install babel-core --save  //安装ES6</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li><p>安装插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-preset-es2015</span><br></pre></td></tr></table></figure></li><li><p>创建.babelrc文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;presets&quot;: [&quot;es2015&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置文件.babelrc：用于配置转码规则和插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;presets&quot;: [&quot;latest&quot;,&quot;react&quot;,&quot;stage-2&quot;],</span><br><span class="line">&quot;plugins&quot;: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 最新转码规则</span><br><span class="line">$ npm install --save-dev babel-preset-latest</span><br><span class="line"># react 转码规则</span><br><span class="line">$ npm install --save-dev babel-preset-react</span><br><span class="line"># 不同阶段语法提案的转码规则（0-3)</span><br><span class="line">$ npm install --save-dev babel-preset-stage-2</span><br></pre></td></tr></table></figure><ul><li>命令行转码babel-cli<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --global babel-cli</span><br></pre></td></tr></table></figure></li></ul><p>将babel-cli安装在项目中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save-dev babel-cli</span><br></pre></td></tr></table></figure></p><p>改写package.json<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">// ...</span><br><span class="line">&quot;devDependencies&quot;: &#123;</span><br><span class="line">&quot;babel-cli&quot;: &quot;^6.0.0&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">&quot;build&quot;: &quot;babel src -d lib&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run build</span><br></pre></td></tr></table></figure></p><p>##<br>待补充</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ES6学习笔记</title>
      <link href="/2017/07/11/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/07/11/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="let-和-const-命令"><a href="#let-和-const-命令" class="headerlink" title="let 和 const 命令"></a>let 和 const 命令</h2><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><ul><li>基本用法<br>用来声明变量。用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。<br><code>for语句设置循环变量部分与循环体是两个作用域。for循环设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</code><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 不存在变量提升</span><br><span class="line">`var声明的变量存在的问题：1.变量提升 2.for语句中的循环变量为全局变量`</span><br><span class="line">var声明的变量在声明前使用已经存在，但没有值；let声明的变量在声明前是不存在的。</span><br><span class="line">var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。</span><br><span class="line">let命令声明的变量一定要在声明后使用，否则报错。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* 暂时性死区</span><br><span class="line">暂时性死区：在代码块内，使用let命令声明变量之前，该变量都是不可用的。let声明的变量在块级作用域内被绑定，不受外部影响。</span><br><span class="line">ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</span><br><span class="line"></span><br><span class="line">* 不允许重复声明</span><br><span class="line">let不允许在相同作用域内，重复声明同一个变量。</span><br></pre></td></tr></table></figure></li></ul><p>function func(arg) {<br>let arg; // 报错<br>}</p><p>function func(arg) {<br>{<br>let arg; // 不报错<br>}<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 块级作用域</span><br><span class="line">* 外层代码块不受内层代码块的影响。外层作用域无法读取内层作用域的变量。</span><br><span class="line">* 内层作用域可以定义外层作用域的同名变量。</span><br><span class="line">* 允许在块级作用域之中声明函数，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。</span><br><span class="line"></span><br><span class="line">浏览器的 ES6 环境中：</span><br><span class="line">允许在块级作用域内声明函数。（只在使用大括号的情况下成立，如果没有使用大括号，就会报错。）</span><br><span class="line">函数声明类似于var，即会提升到全局作用域或函数作用域的头部。</span><br><span class="line">同时，函数声明还会提升到所在的块级作用域的头部。</span><br><span class="line"></span><br><span class="line">应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</span><br><span class="line">// 函数声明语句</span><br><span class="line">&#123;</span><br><span class="line">let a = &apos;secret&apos;;</span><br><span class="line">function f() &#123;</span><br><span class="line">return a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数表达式</span><br><span class="line">&#123;</span><br><span class="line">let a = &apos;secret&apos;;</span><br><span class="line">let f = function () &#123;</span><br><span class="line">return a;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">### const</span><br><span class="line">`引用第三方库时声明的变量用const修饰可以避免重命名导致错误。`</span><br><span class="line">* const声明一个只读的常量。一旦声明变量，就必须立即初始化。</span><br><span class="line">* const的作用域与let命令相同：只在声明所在的块级作用域内有效。不提升，暂时死区。不可重复声明。</span><br><span class="line"></span><br><span class="line">本质：不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。</span><br><span class="line">对于基本数据类型等同于常量。</span><br><span class="line">对于复合类型，变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。</span><br><span class="line">用const声明对象，这个地址指向一个对象，不可变的只是这个地址，即不能把对象指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。如果真的想将对象冻结，应该使用Object.freeze方法。</span><br><span class="line"></span><br><span class="line">### ES6 声明变量的六种方法</span><br><span class="line">ES5 只有两种声明变量的方法：var命令和function命令。</span><br><span class="line">ES6 let和const命令，import和class命令。</span><br><span class="line"></span><br><span class="line">### 顶层对象的属性</span><br><span class="line">顶层对象：在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。</span><br><span class="line">ES6 规定：</span><br><span class="line">* var命令和function命令声明的全局变量，依旧是顶层对象的属性；</span><br><span class="line">* let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。</span><br><span class="line"></span><br><span class="line">### global 对象</span><br><span class="line">* this</span><br><span class="line">全局环境中，this会返回顶层对象。但是，Node 模块和 ES6 模块中，this返回的是当前模块。</span><br><span class="line">函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。</span><br><span class="line"></span><br><span class="line">保证各种环境里面，global对象都是存在的：</span><br></pre></td></tr></table></figure></p><p>// ES6 模块的写法<br>import shim from ‘system.global/shim’; shim();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将顶层对象放入变量global：</span><br></pre></td></tr></table></figure></p><p>// ES6 模块的写法<br>import getGlobal from ‘system.global’;<br>const global = getGlobal();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 变量的解构赋值</span><br><span class="line">### 数组的解构赋值</span><br><span class="line">解构：ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值。</span><br><span class="line">本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。如果解构不成功，变量的值就等于undefined。</span><br></pre></td></tr></table></figure></p><p>let [x, y, …z] = [‘a’];<br>x // “a”<br>y // undefined<br>z // []<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">不完全解构：等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</span><br></pre></td></tr></table></figure></p><p>let [x, y] = [1, 2, 3];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果等号的右边不是数组，不是可遍历的结构，，那么将会报错。因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。</span><br></pre></td></tr></table></figure></p><p>// 报错<br>let [foo] = 1;<br>let [foo] = false;<br>let [foo] = NaN;<br>let [foo] = undefined;<br>let [foo] = null;<br>let [foo] = {};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Set 结构，也可以使用数组的解构赋值。只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。Generator 函数，原生具有 Iterator 接口，解构赋值会依次从这个接口获取值</span><br><span class="line"></span><br><span class="line">#### default默认值</span><br></pre></td></tr></table></figure></p><p>let [x = 1] = [undefined];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。</span><br><span class="line">* 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。</span><br></pre></td></tr></table></figure></p><p>function f() {<br>console.log(‘aaa’);<br>}</p><p>let [x = f()] = [1]; //x能取到值，所以函数f不会执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</span><br></pre></td></tr></table></figure></p><p>let [x = y, y = 1] = [];     // ReferenceError: y is not defined<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 对象的解构赋值</span><br><span class="line">对象的解构与数组有一个重要的不同：数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</span><br><span class="line">* 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。对象的解构赋值是下面形式的简写：</span><br></pre></td></tr></table></figure></p><p>let { a: c, b: d } = { a: “aaa”, b: “bbb” };<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 如果变量名与属性名不一致，可以写成下面这样：</span><br></pre></td></tr></table></figure></p><p>let { a: c } = { a: ‘aaa’, b: ‘bbb’ };<br>c // “aaa”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 与数组一样，解构也可以用于嵌套结构的对象。</span><br><span class="line">let obj = &#123;</span><br><span class="line">p: [</span><br><span class="line">&apos;Hello&apos;,</span><br><span class="line">&#123; y: &apos;World&apos; &#125;</span><br><span class="line">]</span><br><span class="line">&#125;;</span><br><span class="line">// let &#123; p: [x, &#123; y &#125;] &#125; = obj; //这时p是模式，不是变量，因此不会被赋值</span><br><span class="line">let &#123; p, p: [x, &#123; y &#125;] &#125; = obj; //如果p也要作为变量赋值，可以写成这样</span><br><span class="line">x // &quot;Hello&quot;</span><br><span class="line">y // &quot;World&quot;</span><br><span class="line">p // [&quot;Hello&quot;, &#123;y: &quot;World&quot;&#125;]</span><br><span class="line"></span><br><span class="line">* 如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。</span><br></pre></td></tr></table></figure></p><p>// 报错<br>let {foo: {bar}} = {baz: ‘baz’};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 因为 JavaScript 引擎会将&#123;x&#125;理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。</span><br></pre></td></tr></table></figure></p><p>let x;<br>{x} = {x: 1};// SyntaxError: syntax error<br>({x} = {x: 1});// 正确的写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。类似于index取值</span><br><span class="line"></span><br><span class="line">### 字符串的解构赋值</span><br><span class="line">字符串被转换成了一个类似数组的对象。</span><br><span class="line">* 可对length进行解构赋值</span><br></pre></td></tr></table></figure></p><p>let {length : len} = ‘hello’;<br>len // 5<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 数值和布尔值的解构赋值</span><br><span class="line"></span><br><span class="line">### 函数参数的解构赋值</span><br><span class="line">解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</span><br></pre></td></tr></table></figure></p><p>let {toString: s} = 123;<br>s === Number.prototype.toString // true</p><p>let {toString: s} = true;<br>s === Boolean.prototype.toString // true<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。</span><br></pre></td></tr></table></figure></p><p>let { prop: x } = undefined; // TypeError<br>let { prop: y } = null; // TypeError<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 为函数move的参数指定默认值，而不是为变量x和y指定默认值</span><br><span class="line">function move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123;</span><br><span class="line">return [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;x: 3&#125;); // [3, undefined]</span><br><span class="line">move(&#123;&#125;); // [undefined, undefined]</span><br><span class="line">move(); // [0, 0]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 圆括号问题</span><br><span class="line">ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。建议只要有可能，就不要在模式中放置圆括号。</span><br><span class="line">不得使用圆括号的情况：</span><br><span class="line">1.变量声明语句</span><br></pre></td></tr></table></figure></p><p>// 全部报错<br>let [(a)] = [1];</p><p>let {x: (c)} = {};<br>let ({x: c}) = {};<br>let {(x: c)} = {};<br>let {(x): c} = {};</p><p>let { o: ({ p: p }) } = { o: { p: 2 } };<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.函数参数</span><br></pre></td></tr></table></figure></p><p>// 报错<br>function f([(z)]) { return z; }<br>// 报错<br>function f([z,(x)]) { return x; }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.赋值语句的模式</span><br></pre></td></tr></table></figure></p><p>// 将整个模式放在圆括号之中，导致报错<br>({ p: a }) = { p: 42 };<br>([a]) = [5];<br>// 将一部分模式放在圆括号之中，导致报错<br>[({ p: a }), { x: c }] = [{}, {}];//<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以使用圆括号的情况：赋值语句的非模式部分。</span><br><span class="line">满足：1.是赋值语句，而不是声明语句 2.圆括号都不属于模式的一部分</span><br></pre></td></tr></table></figure></p><p>[(b)] = [3]; // 正确<br>({ p: (d) } = {}); // 正确<br>[(parseInt.prop)] = [3]; // 正确<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 使用解构赋值的情况</span><br><span class="line">* 交换变量值</span><br></pre></td></tr></table></figure></p><p>let x = 1;<br>let y = 2;</p><p>[x, y] = [y, x];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 从函数返回多个值</span><br></pre></td></tr></table></figure></p><p>function example() {<br>return [1, 2, 3];<br>}<br>let [a, b, c] = example();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 函数参数的定义</span><br></pre></td></tr></table></figure></p><p>// 参数是一组有次序的值<br>function f([x, y, z]) { … }<br>f([1, 2, 3]);</p><p>// 参数是一组无次序的值<br>function f({x, y, z}) { … }<br>f({z: 3, y: 2, x: 1});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 提取json数据（重要）</span><br></pre></td></tr></table></figure></p><p>let jsonData = {<br>id: 42,<br>status: “OK”,<br>data: [867, 5309]<br>};</p><p>let { id, status, data: number } = jsonData;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 函数参数的默认值</span><br></pre></td></tr></table></figure></p><p>jQuery.ajax = function (url, {<br>async = true,<br>beforeSend = function () {},<br>cache = true,<br>complete = function () {},<br>crossDomain = false,<br>global = true,<br>// … more config<br>} = {}) {<br>// … do stuff<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* for...of遍历Map结构</span><br></pre></td></tr></table></figure></p><p>const map = new Map();<br>map.set(‘first’, ‘hello’);<br>map.set(‘second’, ‘world’);</p><p>for (let [key, value] of map) {<br>console.log(key + “ is “ + value);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果只想获取键名，或者只想获取键值，可以写成下面这样。</span><br></pre></td></tr></table></figure></p><p>// 获取键名<br>for (let [key] of map) {<br>// …<br>}</p><p>// 获取键值<br>for (let [,value] of map) {<br>// …<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 加载模块时输入模块的指定模块</span><br></pre></td></tr></table></figure></p><p>const { SourceMapConsumer, SourceNode } = require(“source-map”);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 字符串的扩展</span><br><span class="line">### codePointAt</span><br><span class="line">codePointAt方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。</span><br></pre></td></tr></table></figure></p><p>function is32Bit(c) {<br>return c.codePointAt(0) &gt; 0xFFFF;<br>}</p><p>is32Bit(“𠮷”) // true<br>is32Bit(“a”) // false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### fromCodePoint</span><br><span class="line">S6 提供了String.fromCodePoint方法，可以识别大于0xFFFF的字符，弥补了String.fromCharCode方法的不足。</span><br></pre></td></tr></table></figure></p><p>String.fromCodePoint(0x20BB7)<br>// “𠮷”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">1·在作用上，fromCodePoint正好与codePointAt方法相反。</span><br><span class="line">2.fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上。</span><br><span class="line"></span><br><span class="line">### 字符串的遍历器接口</span><br></pre></td></tr></table></figure></p><p>for (let codePoint of ‘foo’) {<br>console.log(codePoint)<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### includes(),startsWith(),endsWith()</span><br><span class="line">### repeat()</span><br><span class="line"></span><br><span class="line">### padStart().padEnd()</span><br><span class="line">头部补全，尾部补全。</span><br><span class="line">如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。</span><br><span class="line">如果省略第二个参数，默认使用空格补全长度。</span><br><span class="line">padStart的常见用途是为数值补全指定位数。另一个用途是提示字符串格式。</span><br></pre></td></tr></table></figure></p><p>‘09-12’.padStart(10, ‘YYYY-MM-DD’) // “YYYY-09-12”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">### matchAll()</span><br><span class="line">### 模板字符串</span><br><span class="line">模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</span><br><span class="line">* 模板字符串中嵌入变量，需要将变量名写在$&#123;&#125;之中： `&amp;&#123;变量/表达式/函数&#125;`。如果大括号中是一个对象，将默认调用对象的toString方法。如果模板字符串中的变量没有声明，将报错。</span><br><span class="line">* 模板字符串的空格和换行，都是被保留的，可以使用trim方法消除它。</span><br><span class="line"></span><br><span class="line">String.raw()</span><br><span class="line"></span><br><span class="line">## 数值的扩展</span><br><span class="line">### Number.isFinite(), Number.isNaN()</span><br><span class="line">Number.isFinite()用来检查一个数值是否为有限的（finite），即不是Infinity。</span><br><span class="line">如果参数类型不是数值，Number.isFinite一律返回false。</span><br><span class="line">Number.isNaN()用来检查一个值是否为NaN。</span><br><span class="line">如果参数类型不是NaN，Number.isNaN一律返回false。</span><br><span class="line"></span><br><span class="line">### Number.parseInt(), Number.parseFloat()</span><br><span class="line"></span><br><span class="line">### Number.isInteger()</span><br><span class="line"></span><br><span class="line">### Number.EPSILON</span><br><span class="line">Number.EPSILON可以用来设置“能够接受的误差范围”。</span><br><span class="line"></span><br><span class="line">### Math 对象的扩展</span><br><span class="line">Math.trunc方法用于去除一个数的小数部分，返回整数部分。对于空值和无法截取整数的值，返回NaN。</span><br><span class="line"></span><br><span class="line">## 函数的扩展</span><br><span class="line">### 函数参数的默认值</span><br><span class="line">* ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</span><br><span class="line">* 只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值生成。如果函数foo调用时没提供参数，变量x和y就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。</span><br></pre></td></tr></table></figure></p><p>//function foo({x, y = 5}) {<br>//  console.log(x, y);<br>//}<br>//foo() // TypeError: Cannot read property ‘x’ of undefined</p><p>function foo({x, y = 5} = {}) {<br>console.log(x, y);<br>}<br>foo() // undefined 5<br><code>`</code></p><h3 id="rest-参数"><a href="#rest-参数" class="headerlink" title="rest 参数"></a>rest 参数</h3><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><h3 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h3><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><h3 id="双冒号运算符"><a href="#双冒号运算符" class="headerlink" title="双冒号运算符"></a>双冒号运算符</h3><h3 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h3><h3 id="函数参数的尾逗号"><a href="#函数参数的尾逗号" class="headerlink" title="函数参数的尾逗号"></a>函数参数的尾逗号</h3><h2 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h2><h2 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h2><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h2 id="Iterator-for…of"><a href="#Iterator-for…of" class="headerlink" title="Iterator for…of"></a>Iterator for…of</h2><h2 id="aync"><a href="#aync" class="headerlink" title="aync"></a>aync</h2><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><p>参考文章：<br><a href="http://es6.ruanyifeng.com" target="_blank" rel="noopener">ECMAScript 6 入门</a><br><a href="http://www.jianshu.com/p/ebfeb687eb70" target="_blank" rel="noopener">30分钟掌握ES6/ES2015核心内容</a></p><!--## class--><!--用于定义类：class Person{}--><!----><!--## extends--><!--继承类，constructor内定义的方法和属性是实例对象自己的，外的是所有实力对象共享的--><!----><!--## super--><!--必须先调用父类`super()`,才能修改子类的this--><!----><!--## arrow function--><!--```--><!--function(i){return i+1;}--><!--(i) => i+1 --><!--```--><!----><!--解决函数内this指向全局变量问题：--><!--(1)使用self指代this--><!--(2)bind(this)--><!--(3)=> 使用箭头函数--><!----><!--## template string--><!--\` \` 表示起始，${}引用变量，保留所有空格和缩进--><!----><!--# rest--><!--传递多个参数时：--><!--ES5: arguments--><!--ES6: 参数列表可写成`...types`--><!----><!----><!--## JS中的作用域--><!--### 函数作用域--><!--Javascript没有块级作用域，而是函数作用域--><!--```--><!--var scope="global";  --><!--function t(){  --><!--console.log(scope);  //undefined--><!--var scope="local"  --><!--console.log(scope);  //local--><!--}  --><!--t();   --><!--```--><!----><!--```--><!--var name="global";  --><!--if(true){  --><!--var name="local";  --><!--console.log(name)   //local--><!--}  --><!--console.log(name);  //local--><!--```--><!----><!--```--><!--function t(flag){  --><!--if(flag){  --><!--var s="ifscope";  --><!--for(var i=0;i<2;i++)   --><!--;  --><!--}  --><!--console.log(i);  //2--><!--console.log(s);  //ifscope--><!--}  --><!--t(true); --><!--```--><!----><!--### 变量作用域--><!--JS中没有用var声明的变量都是全局变量，而且是顶层对象的属性。--><!--使用var声明一个变量时，创建的这个属性是不可配置的，也就是说无法通过delete运算符删除。--><!----><!--### 作用域链--><!--```--><!--name="lwy";  --><!--function t(){  --><!--var name="tlwy";  --><!--function s(){  --><!--var name="slwy";  --><!--console.log(name);  --><!--}  --><!--function ss(){  --><!--console.log(name);  --><!--}  --><!--s();  //slwy--><!--ss(); //tlwy--><!--}  --><!--t();  --><!--```--><!----><!--```--><!--var a = [];--><!--for (var i = 0; i < 10; i++) {--><!--a[i] = function () {--><!--console.log(i);--><!--};--><!--}--><!--a[6](); // 10--><!--```--><!----><!--### with语句--><!--with语句主要用来临时扩展作用域链，将语句中的对象添加到当前作用域的头部。--><!--with语句结束后，作用域链恢复正常。--><!--```--><!--person={name:"yhb",age:22,height:175,wife:{name:"lwy",age:21}};  --><!--with(person.wife){  --><!--console.log(name);  //lwy--><!--}  --><!--```--><!----><!--## this--><!--1.全局代码区域：所有函数之外的区域，指全局对象window（node.js中是global）--><!--2.function代码区域：某个函数内的代码，但不包括它所嵌套的函数内的代码--><!--函数中的this的含义在函数声明时无法确定，要到运行期才能确定，而且与调用函数的方式有关--><!--内部函数可以引用外部函数的局部变量，但是不能直接应用外部函数的this--><!--(1)直接调用时，在严格模式下，this会被设为undefined，非严格模式下，this会被设为全局对象window--><!--(2)作为方法调用时，this指方法所属的对象--><!----><!--### do--><!--使块级作用域变为表达式，可以用变量接收do{}的返回值-->]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ReactNative基础知识学习笔记</title>
      <link href="/2017/07/06/ReactNative%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/07/06/ReactNative%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><ul><li>Browser.js:作用是将 JSX 语法转为 JavaScript 语法</li><li>JSX 中不能使用 if else 语句，但可以使用 conditional (三元运算) 表达式来替代</li><li>注释需要写在花括号中:<code>{/*注释...*/}</code><a id="more"></a></li><li>JSX 允许在模板中插入数组，数组会自动展开所有成员</li><li>要渲染 HTML 标签，只需在 JSX 里使用小写字母的标签名,要渲染 React 组件，只需创建一个大写字母开头的本地变量</li><li>class-&gt;className  for-&gt;htmlFor</li><li>使用<code>{}</code>的情况：表达式，变量，对象，字典<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">style=&#123;styles.mainStyle&#125;</span><br><span class="line">var str = &apos;hello&apos;</span><br><span class="line">&lt;Text&gt;&#123;str&#125;&lt;/Text&gt;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//第一重大括号表示这是 JavaScript 语法，第二重大括号表示样式对象</span><br><span class="line">&lt;View style=&#123;&#123;flex:1&#125;&#125;&gt;&lt;/View&gt;</span><br></pre></td></tr></table></figure><ul><li>使用()的情况：返回组件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">return (</span><br><span class="line">&lt;View&gt;</span><br><span class="line">&lt;/View&gt;</span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="判断平台进行不同操作"><a href="#判断平台进行不同操作" class="headerlink" title="判断平台进行不同操作"></a>判断平台进行不同操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const instructions = Platform.select(&#123;</span><br><span class="line">ios: &apos;Press Cmd+R to reload,\n&apos; + &apos;Cmd+D or shake for dev menu&apos;,</span><br><span class="line">android:</span><br><span class="line">&apos;Double tap R on your keyboard to reload,\n&apos; +</span><br><span class="line">&apos;Shake or press menu button for dev menu&apos;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="CSS布局"><a href="#CSS布局" class="headerlink" title="CSS布局"></a>CSS布局</h2><ul><li>使用驼峰命名法</li><li>style属性可以是一个普通的 JavaScript 对象</li><li>建议使用StyleSheet.create来集中定义组件的样式</li><li>后声明的属性会覆盖先声明的同名属性</li></ul><h3 id="创建一个样式表"><a href="#创建一个样式表" class="headerlink" title="创建一个样式表"></a>创建一个样式表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const styles = StyleSheet.create(&#123;</span><br><span class="line">container: &#123;</span><br><span class="line">borderRadius: 4,</span><br><span class="line">borderWidth: 0.5,</span><br><span class="line">borderColor: &apos;#d6d7da&apos;,</span><br><span class="line">&#125;,</span><br><span class="line">title: &#123;</span><br><span class="line">fontSize: 19,</span><br><span class="line">fontWeight: &apos;bold&apos;,</span><br><span class="line">&#125;,</span><br><span class="line">activeTitle: &#123;</span><br><span class="line">color: &apos;red&apos;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="使用一个样式表"><a href="#使用一个样式表" class="headerlink" title="使用一个样式表"></a>使用一个样式表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">&lt;Text style=&#123;[styles.title, this.props.isActive &amp;&amp; styles.activeTitle]&#125; /&gt;</span><br><span class="line">&lt;/View&gt;</span><br></pre></td></tr></table></figure><ul><li>margin：第一个组件比较特殊，参照父组件，与父控件之间的间距。其他组件间距，相对于上一个组件</li><li>padding：设置子控件与当前控件的位置，想设置自己的子控件相对自己的位置的时候使用</li><li>注意marginRight和width冲突，如果设置了width，marginRight无效<br>position</li><li>absolute:绝对定位，相对父组件<blockquote><p>使用：当想把一个已经设置了宽度的控件快速的放在左下角，右下角的时候</p></blockquote></li><li>relative: 相对定位，相对自己的原始位置<blockquote><p>使用：当想相对自己做出一些改变的时候，采用相对定位,比如相对自己，往下移动一点</p></blockquote></li></ul><h2 id="FlexBox布局"><a href="#FlexBox布局" class="headerlink" title="FlexBox布局"></a>FlexBox布局</h2><p>1.flexDirection：row | row-reverse | column | column-reverse<br>决定了子元素在主轴方向的排列方式（此样式设置在父元素上），默认值是column<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;View style=&#123;&#123;flex: 1, flexDirection: &apos;column&apos;&#125;&#125;&gt;</span><br><span class="line">&lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: &apos;powderblue&apos;&#125;&#125; /&gt;</span><br><span class="line">&lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: &apos;skyblue&apos;&#125;&#125; /&gt;</span><br><span class="line">&lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: &apos;steelblue&apos;&#125;&#125; /&gt;</span><br><span class="line">&lt;/View&gt;</span><br></pre></td></tr></table></figure></p><p>2.justifyContent（no flex:1）：flex-start | flex-end | center | space-between | space-around | space-evenly<br>决定了子元素在主轴方向的对齐方式（此样式设置在父元素上），默认值是flex-start<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;View style=&#123;&#123;</span><br><span class="line">flex: 1,</span><br><span class="line">flexDirection: &apos;column&apos;,</span><br><span class="line">justifyContent: &apos;space-between&apos;,</span><br><span class="line">&#125;&#125;&gt;</span><br><span class="line">&lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: &apos;powderblue&apos;&#125;&#125; /&gt;</span><br><span class="line">&lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: &apos;skyblue&apos;&#125;&#125; /&gt;</span><br><span class="line">&lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: &apos;steelblue&apos;&#125;&#125; /&gt;</span><br><span class="line">&lt;/View&gt;</span><br></pre></td></tr></table></figure></p><p>3.alignItems（nowrap,align-self）：flex-start | flex-end | center | stretch<br>决定了子元素在次轴方向的排列方式（此样式设置在父元素上），默认值为 stretch，子组件在侧轴方向被拉伸到与容器相同的高度或宽度<br><code>次轴：与主轴垂直的轴，若主轴方向为row，则次轴方向为column</code><br><code>要使stretch选项生效的话，子元素在次轴方向上不能有固定的尺寸</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;View style=&#123;&#123;</span><br><span class="line">flex: 1,</span><br><span class="line">flexDirection: &apos;column&apos;,</span><br><span class="line">justifyContent: &apos;center&apos;,</span><br><span class="line">alignItems: &apos;stretch&apos;,</span><br><span class="line">&#125;&#125;&gt;</span><br><span class="line">&lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: &apos;powderblue&apos;&#125;&#125; /&gt;</span><br><span class="line">&lt;View style=&#123;&#123;height: 50, backgroundColor: &apos;skyblue&apos;&#125;&#125; /&gt;</span><br><span class="line">&lt;View style=&#123;&#123;height: 100, backgroundColor: &apos;steelblue&apos;&#125;&#125; /&gt;</span><br><span class="line">&lt;/View&gt;</span><br></pre></td></tr></table></figure></p><p>4.alignSelf：auto | flex-start | flex-end | center | stretch<br>决定了元素在父元素的次轴方向的排列方式（此样式设置在子元素上），其值会覆盖父元素的alignItems的值。默认值为 auto，继承它的父容器的alignItems属性。如果没有父容器则为 “stretch”。</p><p>5.aligncontent（wrap）：stretch | flex-start | flex-end | center | space-between | space-around<br>6.flexWrap：wrap | no-wrap<br>决定子控件在父视图内是否允许多行排列，显示不全时是否自动换行。默认为nowrap<br>7.flex:子控件在主轴中占据几等分，任意数字，所有子控件flex相加，自己flex占总共多少，就有多少宽度.</p><h2 id="props-state"><a href="#props-state" class="headerlink" title="props,state"></a>props,state</h2><ul><li>props：一般用于自定义组件，大多数组件在创建时就可以使用各种参数来进行定制，用于定制的这些参数就称为props（属性）。</li><li>在父组件中指定，而且一经指定，在整个组件的生命周期中都不再改变。通过this.props.name访问。</li><li><p>this.props.children表示组件的所有子节点</p></li><li><p>state：以后想修改某个属性，就修改界面，就需要用state。</p></li><li>constructor中声明(ES6)，在setState中修改数据</li></ul><blockquote><p>this.props 表示那些一旦定义，就不再改变的特性，而 this.state 是会随着用户互动而产生变化的特性。<br>通过state 来更新和修改数据，而子组件只能通过 props 来传递数据</p></blockquote><p>定义state:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.state = &#123;</span><br><span class="line">num:1,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>修改state:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.setState(&#123;</span><br><span class="line">num : number</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.setState(&#123;name: e.target.value&#125;, function()&#123;</span><br><span class="line">console.log(this.state.name);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><ul><li>一切界面变化都是状态state变化</li><li>state的修改必须通过setState()方法</li><li>this.state.likes = 100; // 这样的直接赋值修改无效！</li><li>setState 是一个 merge 合并操作，只修改指定属性，不影响其他属性</li><li>setState 是异步操作，修改不会马上生效</li></ul><h2 id="父子组件传值"><a href="#父子组件传值" class="headerlink" title="父子组件传值"></a>父子组件传值</h2><h3 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h3><ul><li>props:this.props.name</li><li>ref:this.refs.son.receiveMsg(“msg”)<h3 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h3></li><li>方法回调<br>父组件：定义一个处理接收到值的方法，把这个方法传递给子组件，并且绑定this<br>子组件：通过this.props拿到这个方法调用<h3 id="无关联组件间传值"><a href="#无关联组件间传值" class="headerlink" title="无关联组件间传值"></a>无关联组件间传值</h3></li><li>通知:组件1传值给组件2<br>组件1：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Text onPress=&#123;()=&gt;&#123;</span><br><span class="line">DeviceEventEmitter.emit(&apos;NotificationName&apos;,123);</span><br><span class="line">&#125;&#125;&gt;&lt;/Text&gt;</span><br></pre></td></tr></table></figure></li></ul><p>组件2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line"></span><br><span class="line">this.age = 10;</span><br><span class="line">this.age = 20;</span><br><span class="line"></span><br><span class="line">console.log(this.age);</span><br><span class="line"></span><br><span class="line">// 定义属性,但是对这个属性的修改不会触发render</span><br><span class="line">this.lister = DeviceEventEmitter.addListener(&apos;NotificationName&apos;,(value)=&gt;&#123;</span><br><span class="line">this.setState(&#123;</span><br><span class="line">value:value</span><br><span class="line">&#125;);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentWillUnmount() &#123;</span><br><span class="line">this.lister.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export default class RNDemo extends Component &#123;</span><br><span class="line">render() &#123;</span><br><span class="line">return (</span><br><span class="line">&lt;View /&gt;</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">AppRegistry.registerComponent(&apos;React&apos;, () =&gt; RNDemo);</span><br></pre></td></tr></table></figure><h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><p>0.defaultProps:给props设置默认值<br>1.constructor:初始化state（只调用一次）<br>2.componentWillMount:即将加载组件调用，render前（只调用一次）<br>3.render:渲染组件<br>4.componentDidMount:组件加载完成调用，render后（只调用一次）</p><ul><li>除了 render ，其他方法只调用一次<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><code>props改变</code><br>5.componentWillReceiveProps:props改变调用<br><code>state改变</code><br>6.shouldComponentUpdate:props/state改变调用，可控制是否刷新界面<br>7.componentWillUpdate:组件即将更新调用（调用this.setState会循环）<br>8.render<br>9.componentDidUpdate:组件更新完成（调用this.setState会循环）</li><li>绝对不要在componentWillUpdate，componentDidUpdate中调用this.setState方法，否则将导致无限循环调用，在componentWillReceiveProps，shouldComponentUpdate可以<h3 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h3>10.componentWillUnmount:组件即将销毁，可移除观察者，清空数据等</li></ul><h2 id="propTypes"><a href="#propTypes" class="headerlink" title="propTypes"></a>propTypes</h2><ul><li>可以实现类型检查，当传入错误的属性值，会报警告，但是不会报错</li><li>用PropTypes定义属性，外界使用的时候，会有提示。</li><li>必须要用static修饰，否则无效</li><li>static：用来定义类方法或者类属性，定义类的方法和属性，生成的对象就自动有这样的属性了。</li><li>只能用于React框架的自定义组件，默认JS是没有的，因为它是React框架中的。<h3 id="类型检查：当传入错误的属性值，会报警告，但是不会报错"><a href="#类型检查：当传入错误的属性值，会报警告，但是不会报错" class="headerlink" title="类型检查：当传入错误的属性值，会报警告，但是不会报错"></a>类型检查：当传入错误的属性值，会报警告，但是不会报错</h3>导入：<code>import React, { Component,PropTypes } from &#39;react&#39;;</code></li><li>定义属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static propTypes = &#123;</span><br><span class="line">name:PropTypes.string,</span><br><span class="line">age:PropTypes.number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">propTypes: &#123;</span><br><span class="line">// 可以声明 prop 为指定的 JS 基本数据类型，默认情况，这些数据是可选的</span><br><span class="line">optionalArray: React.PropTypes.array,</span><br><span class="line">optionalBool: React.PropTypes.bool,</span><br><span class="line">optionalFunc: React.PropTypes.func,</span><br><span class="line">optionalNumber: React.PropTypes.number,</span><br><span class="line">optionalObject: React.PropTypes.object,</span><br><span class="line">optionalString: React.PropTypes.string,</span><br><span class="line"></span><br><span class="line">// 可以被渲染的对象 numbers, strings, elements 或 array</span><br><span class="line">optionalNode: React.PropTypes.node,</span><br><span class="line"></span><br><span class="line">//  React 元素</span><br><span class="line">optionalElement: React.PropTypes.element,</span><br><span class="line"></span><br><span class="line">// 用 JS 的 instanceof 操作符声明 prop 为类的实例。</span><br><span class="line">optionalMessage: React.PropTypes.instanceOf(Message),</span><br><span class="line"></span><br><span class="line">// 用 enum 来限制 prop 只接受指定的值。</span><br><span class="line">optionalEnum: React.PropTypes.oneOf([&apos;News&apos;, &apos;Photos&apos;]),</span><br><span class="line"></span><br><span class="line">// 可以是多个对象类型中的一个</span><br><span class="line">optionalUnion: React.PropTypes.oneOfType([</span><br><span class="line">React.PropTypes.string,</span><br><span class="line">React.PropTypes.number,</span><br><span class="line">React.PropTypes.instanceOf(Message)</span><br><span class="line">]),</span><br><span class="line"></span><br><span class="line">// 指定类型组成的数组</span><br><span class="line">optionalArrayOf: React.PropTypes.arrayOf(React.PropTypes.number),</span><br><span class="line"></span><br><span class="line">// 指定类型的属性构成的对象</span><br><span class="line">optionalObjectOf: React.PropTypes.objectOf(React.PropTypes.number),</span><br><span class="line"></span><br><span class="line">// 特定 shape 参数的对象</span><br><span class="line">optionalObjectWithShape: React.PropTypes.shape(&#123;</span><br><span class="line">color: React.PropTypes.string,</span><br><span class="line">fontSize: React.PropTypes.number</span><br><span class="line">&#125;),</span><br><span class="line"></span><br><span class="line">// 任意类型加上 `isRequired` 来使 prop 不可空。</span><br><span class="line">requiredFunc: React.PropTypes.func.isRequired,</span><br><span class="line"></span><br><span class="line">// 不可空的任意类型</span><br><span class="line">requiredAny: React.PropTypes.any.isRequired,</span><br><span class="line"></span><br><span class="line">// 自定义验证器。如果验证失败需要返回一个 Error 对象。不要直接使用 `console.warn` 或抛异常，因为这样 `oneOfType` 会失效。</span><br><span class="line">customProp: function(props, propName, componentName) &#123;</span><br><span class="line">if (!/matchme/.test(props[propName])) &#123;</span><br><span class="line">return new Error(&apos;Validation failed!&apos;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="设置初始化值"><a href="#设置初始化值" class="headerlink" title="设置初始化值"></a>设置初始化值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static defaultProps = &#123;</span><br><span class="line">name:&apos;xiaoming&apos;,</span><br><span class="line">age:20</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本组件"><a href="#基本组件" class="headerlink" title="基本组件"></a>基本组件</h2><h3 id="View"><a href="#View" class="headerlink" title="View"></a>View</h3><p>###TouchableOpacity：默认点击区域是所有子控件的区域,因为默认一个组件的尺寸由子控件决定</p><ul><li>activeOpacity:0-1 1-不透明</li><li>点击事件：onPress|onLongPress|onPressIn|onPressOut</li><li>disabled:true|false<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;TouchableOpacity activeOpacity=&#123;0.7&#125;&gt;</span><br><span class="line">&lt;View style=&#123;styles.childSytle&#125;&gt;</span><br><span class="line">&lt;/View&gt;</span><br><span class="line">&lt;/TouchableOpacity&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h3><ul><li>numberOfLines</li><li>selectable:true|false 是否允许长按选择文本</li><li>suppressHighlighting:true|false 是否允许按下时有灰色阴影</li><li>onPress:文字点击事件  onPress={()=&gt;{}}</li><li>color/fontSize/fontWeight/lineHeight/textAlign<h3 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h3></li><li>不可设置样式，一般用text自定义</li><li>color/disabled/onPress/title<h3 id="TextInput"><a href="#TextInput" class="headerlink" title="TextInput"></a>TextInput</h3></li><li>默认无边框</li><li>autoFocus/blurOnSubmit/editable/maxLength/multiline/placeholder</li><li>keyboardType/returnKeyType/clearButtonMode</li><li>clearTextOnFocus/enablesReturnKeyAutomatically</li><li>clear()</li><li>事件：onBlur/onFocus/onChange/onChangeText/onEndEditing/onKeyPress/onSubmitEditing<h3 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h3>iOS中的2x,3x图片同样适用，如果存在<a href="mailto:a@2x.png" target="_blank" rel="noopener">a@2x.png</a>与<a href="mailto:a@3x.png" target="_blank" rel="noopener">a@3x.png</a>，写a.png即可。<br>同时兼容iOS和安卓平台的图片，如果存在a.ios.png与a.android.png，同样写a.png即可。</li><li>source/defaultSource<h4 id="本地资源加载"><a href="#本地资源加载" class="headerlink" title="本地资源加载"></a>本地资源加载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Image source=&#123;require(&apos;./images/add.png&apos;)&#125;/&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="通过url的方式加载图片，必须设置图片尺寸，否则不显示，iOS端可以添加缓存策略-default-reload-force-cache-only-if-cached"><a href="#通过url的方式加载图片，必须设置图片尺寸，否则不显示，iOS端可以添加缓存策略-default-reload-force-cache-only-if-cached" class="headerlink" title="通过url的方式加载图片，必须设置图片尺寸，否则不显示，iOS端可以添加缓存策略(default/reload/force-cache/only-if-cached)"></a>通过url的方式加载图片，必须设置图片尺寸，否则不显示，iOS端可以添加缓存策略(default/reload/force-cache/only-if-cached)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Image source=&#123;&#123;uri:&apos;http://xxxxxxxx&apos;&#125;&#125; style=&#123;&#123;width: 90, height: 90&#125;&#125;/&gt;</span><br></pre></td></tr></table></figure><h4 id="本地图片存放路径"><a href="#本地图片存放路径" class="headerlink" title="本地图片存放路径"></a>本地图片存放路径</h4><p>1.放在与index.ios.js同目录下的Img文件夹<br>2.iOS：可以存放到iOS项目中，打开iOS项目，存入到assets文件中<br>Android：可以存放到安卓项目中,必须放入drawable目录</p><ul><li>blurRadius</li><li>resizeMode:cover|contain|stretch|repeat|center</li><li>事件：onLoad/onLoadStart/onLoadEnd/onProgress/onError<h3 id="ScrollView"><a href="#ScrollView" class="headerlink" title="ScrollView"></a>ScrollView</h3></li><li>horizontal/showsHorizontalScrollIndicator/showsVerticalScrollIndicator/alwaysBounceHorizontal/alwaysBounceVertical</li><li>automaticallyAdjustContentInsets</li><li>bounces/bouncesZoom/contentInset</li><li>scrollEventThrottle/stickyHeaderIndices(与horizontal={true}冲突)</li><li>事件：onScrollBeginDrag/End/onMomentumScrollBegin/End/onScrollAnimationEnd/onScroll/scrollEventThrottle</li></ul><h2 id="自定义类"><a href="#自定义类" class="headerlink" title="自定义类"></a>自定义类</h2><p>1.自定义类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export default class Person&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>2.继承extends<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class HomeView extends Component</span><br></pre></td></tr></table></figure></p><p>3.使用：var p = new Person();</p><h2 id="ScrollView-1"><a href="#ScrollView-1" class="headerlink" title="ScrollView"></a>ScrollView</h2><ul><li>不能通过scrollView获取,因为在RN中,滚动的时候,不会给scrollView组件的contentOffset属性赋值,只能通过nativeEvent事件获取<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_onScroll(e) &#123;</span><br><span class="line">// console.log(&apos;滚动的时候调用&apos;);</span><br><span class="line">//  var scrollView = this.refs.scrollView;</span><br><span class="line">//  console.log(scrollView.props.contentOffset);</span><br><span class="line"></span><br><span class="line">var nativeEvent = e.nativeEvent;</span><br><span class="line">console.log(nativeEvent.contentOffset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h2><p>0.ListViewDataSource<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">构造函数可以接受下列四种参数（都是可选）：</span><br><span class="line"></span><br><span class="line">getRowData(dataBlob, sectionID, rowID);</span><br><span class="line">getSectionHeaderData(dataBlob, sectionID);</span><br><span class="line">rowHasChanged(prevRowData, nextRowData);</span><br><span class="line">sectionHeaderHasChanged(prevSectionData, nextSectionData);</span><br></pre></td></tr></table></figure></p><p>1.创建数据源，给数据源设置数据<br>使用state保存数据源</p><h3 id="不分组使用：cloneWithRows"><a href="#不分组使用：cloneWithRows" class="headerlink" title="不分组使用：cloneWithRows"></a>不分组使用：cloneWithRows</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">constructor(props) &#123;</span><br><span class="line">super(props);</span><br><span class="line">var data = new ListView.DataSource(&#123;rowHasChanged: (r1, r2) =&gt; r1 !== r2&#125;);</span><br><span class="line"></span><br><span class="line">this.state = &#123;</span><br><span class="line">// 给数据源设置数据,创建新的数据,不过保存了之前的行改变方法属性</span><br><span class="line">dataSource: data.cloneWithRows([&apos;row 1&apos;, &apos;row 2&apos;]),</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分组使用：cloneWithRowsAndSections"><a href="#分组使用：cloneWithRowsAndSections" class="headerlink" title="分组使用：cloneWithRowsAndSections"></a>分组使用：cloneWithRowsAndSections</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">constructor(props) &#123;</span><br><span class="line">super(props);</span><br><span class="line">var data = new ListView.DataSource(&#123;</span><br><span class="line">rowHasChanged:(r1,r2)=&gt;r1 !== r2,</span><br><span class="line">sectionHeaderHasChanged:(s1,s2)=&gt;s1 !== s2</span><br><span class="line">&#125;);</span><br><span class="line">var sectionData = &#123;&#125;;</span><br><span class="line">this.state = &#123;</span><br><span class="line">dataSource : data.cloneWithRowsAndSections(sectionData)</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.实现数据源方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;ListView dataSource=&#123;this.state.dataSource&#125;</span><br><span class="line">renderRow=&#123;this._renderRow.bind(this)&#125;</span><br><span class="line">renderHeader=&#123;this._renderHeader.bind(this)&#125;</span><br><span class="line">renderFooter=&#123;this._renderFooter.bind(this)&#125;</span><br><span class="line">renderSeparator=&#123;this._renderSeparator.bind(this)&#125;</span><br><span class="line">//renderSectionHeader=&#123;this._renderSectionHeader.bind(this)&#125;</span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line">_renderRow(rowData, sectionID, rowID, highlightRow) &#123;</span><br><span class="line">return (</span><br><span class="line">&lt;View&gt;</span><br><span class="line">&lt;Text&gt;&#123;rowData&#125;&lt;/Text&gt;</span><br><span class="line">&lt;/View&gt;</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_renderHeader() &#123;</span><br><span class="line">return (</span><br><span class="line">&lt;View&gt;</span><br><span class="line">&lt;Text&gt;头部视图&lt;/Text&gt;</span><br><span class="line">&lt;/View&gt;</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_renderFooter() &#123;</span><br><span class="line">return (</span><br><span class="line">&lt;View&gt;</span><br><span class="line">&lt;Text&gt;尾部视图&lt;/Text&gt;</span><br><span class="line">&lt;/View&gt;</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_renderSeparator(sectionID, rowID, adjacentRowHighlighted)  &#123;</span><br><span class="line">console.log(sectionID,rowID,adjacentRowHighlighted);</span><br><span class="line">return (</span><br><span class="line">&lt;View style=&#123;&#123;height:1,backgroundColor:&apos;black&apos;&#125;&#125;&gt;&lt;/View&gt;</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//如果是组视图，设置组数据</span><br><span class="line">_renderSectionHeader(sectionData, sectionID) &#123;</span><br><span class="line">return (</span><br><span class="line">&lt;View&gt;</span><br><span class="line">&lt;Text&gt;&#123;sectionID&#125;&lt;/Text&gt;</span><br><span class="line">&lt;/View&gt;</span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="FlatList"><a href="#FlatList" class="headerlink" title="FlatList"></a>FlatList</h2><h2 id="SectionList"><a href="#SectionList" class="headerlink" title="SectionList"></a>SectionList</h2><p>默认情况下每行都需要提供一个不重复的key属性。你也可以提供一个keyExtractor函数来生成key。<br>把这个属性添加到 <sectionlist> 里面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">keyExtractor = &#123;this._extraUniqueKey&#125;   </span><br><span class="line"></span><br><span class="line">_extraUniqueKey(item ,index)&#123;</span><br><span class="line">return &quot;index&quot;+index+item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></sectionlist></p><h2 id="导航Navigator"><a href="#导航Navigator" class="headerlink" title="导航Navigator"></a>导航Navigator</h2><p>如果找不到Navigator，安装Navigator所在的库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install react-native-deprecated-custom-components --save</span><br><span class="line">//yarn add react-native-deprecated-custom-components</span><br></pre></td></tr></table></figure></p><p>项目导入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Navigator&#125; from &apos;react-native-deprecated-custom-components&apos;</span><br></pre></td></tr></table></figure></p><h2 id="Tabbar"><a href="#Tabbar" class="headerlink" title="Tabbar"></a>Tabbar</h2><h3 id="TabBarIOS"><a href="#TabBarIOS" class="headerlink" title="TabBarIOS"></a>TabBarIOS</h3><ul><li>只可用于iOS平台</li><li>badge可设置未读消息数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;TabBarIOS style=&#123;&#123;flex:1,alignItems:&apos;flex-end&apos;&#125;&#125;&gt;</span><br><span class="line">&lt;TabBarIOS.Item </span><br><span class="line">title=&apos;消息&apos;</span><br><span class="line">icon=&#123;require(&apos;./Img/home.png&apos;)&#125;</span><br><span class="line">badge=&#123;3&#125;</span><br><span class="line">onPress=&#123;()=&gt;&#123;</span><br><span class="line">this.setState(&#123;</span><br><span class="line">selectIndex:0</span><br><span class="line">&#125;)</span><br><span class="line">&#125;&#125;</span><br><span class="line">selected=&#123;0==this.state.selectIndex&#125;</span><br><span class="line">&gt;</span><br><span class="line">&lt;View&gt;</span><br><span class="line">&lt;Text&gt;首页&lt;/Text&gt;</span><br><span class="line">&lt;/View&gt;</span><br><span class="line">&lt;/TabBarIOS.Item&gt;</span><br><span class="line">&lt;/TabBarIOS&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="TabNavigator"><a href="#TabNavigator" class="headerlink" title="TabNavigator"></a>TabNavigator</h3><ul><li>可用于iOS和安卓<br>1.安装<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install react-native-tab-navigator --save</span><br></pre></td></tr></table></figure></li></ul><p>2.导入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import TabNavigator from &apos;react-native-tab-navigator&apos;;</span><br></pre></td></tr></table></figure></p><p>3.使用</p><ul><li>TabBarIOS: <code>icon={require(&#39;./Img/home.png&#39;)}</code></li><li>TabNavigator: renderIcon是传入一个函数，这个函数返回一个Image组件,如果是通过url加载，一定要记得设置尺寸，否则不显示<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">renderIcon=&#123;() =&gt; &lt;Image source=&#123;require(&apos;./Img/indexicon_hone_after@3x.png&apos;)&#125; style=&#123;styles.iconStyle&#125;/&gt;&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;TabNavigator&#125;&gt;</span><br><span class="line">&lt;TabNavigator.Item title=&apos;消息&apos;</span><br><span class="line">renderIcon=&#123;() =&gt; &lt;Image source=&#123;require(&apos;./Img/indexicon_hone_after@3x.png&apos;)&#125; style=&#123;styles.iconStyle&#125;/&gt;&#125;</span><br><span class="line">// renderBadge=&#123;3&#125;</span><br><span class="line">onPress=&#123;()=&gt;&#123;</span><br><span class="line">this.setState(&#123;</span><br><span class="line">selectIndex:0</span><br><span class="line">&#125;)</span><br><span class="line">&#125;&#125;</span><br><span class="line">selected=&#123;0==this.state.selectIndex&#125;</span><br><span class="line">&gt;</span><br><span class="line">&lt;View style=&#123;&#123;flex:1,justifyContent:&apos;center&apos;,alignItems:&apos;center&apos;&#125;&#125;&gt;</span><br><span class="line">&lt;Text&gt;首页&lt;/Text&gt;</span><br><span class="line">&lt;/View&gt;</span><br><span class="line">&lt;/TabNavigator.Item&gt;</span><br><span class="line">&lt;/TabNavigator&gt;</span><br></pre></td></tr></table></figure><h2 id="主流架构搭建"><a href="#主流架构搭建" class="headerlink" title="主流架构搭建"></a>主流架构搭建</h2><h3 id="ReactNavigation"><a href="#ReactNavigation" class="headerlink" title="ReactNavigation"></a>ReactNavigation</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//推荐yarn</span><br><span class="line">yarn add react-navigation</span><br><span class="line"># or with npm</span><br><span class="line"># npm install --save react-navigation</span><br></pre></td></tr></table></figure><p>安装图片组件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save react-native-vector-icons</span><br></pre></td></tr></table></figure></p><p>如果报错 Unrecognized font family ‘Ionicons’：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-native link</span><br></pre></td></tr></table></figure></p><h3 id="createStackNavigator"><a href="#createStackNavigator" class="headerlink" title="createStackNavigator"></a>createStackNavigator</h3><p><code>createStackNavigator(RouteConfigs, StackNavigatorConfig);</code><br>createStackNavigator函数返回一个React组件，我们可以直接从App.js导出它以用作我们App的根组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import &#123;createStackNavigator&#125; from &apos;react-navigation&apos;;</span><br><span class="line">import Tabbar from &apos;./Tabbar&apos;</span><br><span class="line">import LoginPage from &apos;./LoginPage&apos;</span><br><span class="line"></span><br><span class="line">const RootStack = createStackNavigator(&#123;</span><br><span class="line">//底部导航页面</span><br><span class="line">Tabbar: &#123;</span><br><span class="line">screen: Tabbar,</span><br><span class="line">navigationOptions: &#123;</span><br><span class="line">header: null  //顶部导航很多都会自己自定义，这里就为空</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">//登录页面</span><br><span class="line">Login: &#123;</span><br><span class="line">screen: LoginPage,</span><br><span class="line">&#125;,</span><br><span class="line">Details: &#123;</span><br><span class="line">screen: DetailsPage</span><br><span class="line">navigationOptions: &#123;</span><br><span class="line">title: &apos;详情&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default RootStack;</span><br></pre></td></tr></table></figure></p><h4 id="切换路由："><a href="#切换路由：" class="headerlink" title="切换路由："></a>切换路由：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this.props.navigation.navigate(&apos;Details&apos;) 将新路由推送到堆栈导航器（如果它尚未在堆栈中），否则它将跳转到该屏幕</span><br><span class="line">this.props.navigation.push(&apos;Details&apos;) 继续推送新路由</span><br><span class="line">this.props.navigation.goBack() 返回到上层路由</span><br><span class="line">this.props.navigation.popToTop() 返回到堆栈中的第一个屏幕</span><br></pre></td></tr></table></figure><h5 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h5><p>通过将params放入一个对象作为navigation.navigate函数的第二个参数。</p><ul><li>将参数传递给下一个路由：<code>this.props.navigation.navigate（&#39;RouteName&#39;，{/ * params go here * /}）</code></li><li>获取前一个路由传递的参数：<code>this.props.navigation.getParam（paramName，defaultValue）</code>，还可以使用this.props.navigation.state.params直接访问params对象。 </li><li>更新navigationOptions：this.props.navigation.setParams({name: params})<h4 id="配置标题栏"><a href="#配置标题栏" class="headerlink" title="配置标题栏"></a>配置标题栏</h4></li><li><p>设置标题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static navigationOptions = &#123;</span><br><span class="line">title: &apos;Home&apos;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>在标题中使用params</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static navigationOptions = (&#123;navigation,navigationOptions &#125;) =&gt; &#123;</span><br><span class="line">console.log(navigation)</span><br><span class="line">return &#123;</span><br><span class="line">title: navigation.getParam(&apos;name&apos;, &apos;A Nested Details Screen&apos;),</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>调整标题样式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static navigationOptions = &#123;</span><br><span class="line">title: &apos;Home&apos;,</span><br><span class="line">headerStyle: &#123;            //标题栏样式</span><br><span class="line">backgroundColor: &apos;red&apos;,  </span><br><span class="line">&#125;,</span><br><span class="line">headerTintColor: &apos;#fff&apos;,  //标题文字和按钮颜色</span><br><span class="line">headerTitleStyle: &#123;       //标题文字样式</span><br><span class="line">fontWeight: &apos;bold&apos;,</span><br><span class="line">// color:&apos;blue&apos; 如果这里也写了标题文字的颜色，那么会覆盖headerTintColor的颜色，即标题为蓝色</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>跨屏幕共享通用navigationOptions</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">export default class HomeScreen extends React.Component &#123;</span><br><span class="line">static navigationOptions = &#123;</span><br><span class="line">title: &apos;Home&apos;,</span><br><span class="line">/* No more header config here! */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* render function, etc */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------------------分割线-------------------</span><br><span class="line"></span><br><span class="line">const Tabbar = createStackNavigator(&#123;</span><br><span class="line">Home: &#123;</span><br><span class="line">screen: HomePage</span><br><span class="line">&#125;,</span><br><span class="line">Mine: &#123;</span><br><span class="line">screen: MinePage</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">Details: &#123;</span><br><span class="line">screen: DetailsPage</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;, &#123;</span><br><span class="line">/* 主屏幕的标题配置现在在这里 */</span><br><span class="line">navigationOptions: &#123;</span><br><span class="line">headerStyle: &#123;</span><br><span class="line">backgroundColor: &apos;#f4511e&apos;,</span><br><span class="line">&#125;,</span><br><span class="line">headerTintColor: &apos;#fff&apos;,</span><br><span class="line">headerTitleStyle: &#123;</span><br><span class="line">fontWeight: &apos;bold&apos;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>titleView，navigationItem，back</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static navigationOptions = &#123;</span><br><span class="line">//用自定义组件替换标题</span><br><span class="line">headerTitle: &lt;LogoTitle/&gt;,</span><br><span class="line"></span><br><span class="line">//navigationItem</span><br><span class="line">headerRight: (</span><br><span class="line">&lt;Button</span><br><span class="line">onPress=&#123;() =&gt; alert(&apos;This is a button!&apos;)&#125;</span><br><span class="line">title=&quot;Info&quot;</span><br><span class="line">color=&quot;blue&quot;</span><br><span class="line">/&gt;</span><br><span class="line">),</span><br><span class="line"></span><br><span class="line">//back</span><br><span class="line">headerBackImage: &lt;Image</span><br><span class="line">source=&#123;require(&apos;../../image/title.png&apos;)&#125;</span><br><span class="line">style=&#123;&#123;width: 30, height: 30&#125;&#125;</span><br><span class="line">/&gt;</span><br><span class="line">//</span><br><span class="line">//headerBackTitle: &quot;title&quot; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="createBottomTabNavigator"><a href="#createBottomTabNavigator" class="headerlink" title="createBottomTabNavigator"></a>createBottomTabNavigator</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createBottomTabNavigator &#125; from &apos;react-navigation&apos;;</span><br></pre></td></tr></table></figure><h2 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h2><ul><li>fetch: 发送请求</li><li>then: 回调函数</li><li>response: 请求到的json数据</li><li>catch: 捕获异常<br>发送GET请求：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fetch(&apos;http://192.168.1.143:8080&apos;) // 发送GET请求</span><br><span class="line">.then((response)=&gt;response.json()) // 请求成功，把请求数据转换为 JSON</span><br><span class="line">.then((json)=&gt;&#123;                    // 获取JSON数据做事情</span><br><span class="line">console.log(json)</span><br><span class="line">&#125;)</span><br><span class="line">.catch((error)=&gt;&#123;                // 请求失败或者处理JSON数据失败，调用</span><br><span class="line">console.log(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><p>发送POST请求有三种方式：</p><ul><li>application/x-www-form-urlencoded: 参数是普通的参数拼接</li><li>application/json: 参数是json格式</li><li>application/form-data: 文件上传</li></ul><h3 id="request模块"><a href="#request模块" class="headerlink" title="request模块"></a>request模块</h3><h2 id="本地存储-AsyncStorage"><a href="#本地存储-AsyncStorage" class="headerlink" title="本地存储 AsyncStorage"></a>本地存储 AsyncStorage</h2><ul><li>异步的</li><li>只能存储字符串</li><li>把数据保存到沙盒中的Documents中,并生成manifest.json文件</li><li>save/read/delete<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AsyncStorage.setItem(&apos;object&apos;,JSON.stringify(object),(error)=&gt;&#123;&#125;);</span><br><span class="line">AsyncStorage.getItem(&apos;object&apos;,(error,result)=&gt;&#123;&#125;);</span><br><span class="line">AsyncStorage.removeItem(&apos;object&apos;,(error)=&gt;&#123;&#125;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="引导页"><a href="#引导页" class="headerlink" title="引导页"></a>引导页</h2><p>1.第一次进入界面，写个属性，记录下第一次加载。<br>2.每次启动，获取之前是否保存过第一次加载的属性，如果加载过，就显示主页，没加载过，就显示引导页</p><h2 id="模块导出"><a href="#模块导出" class="headerlink" title="模块导出"></a>模块导出</h2><ul><li>自定义组件：继承自Component，必须使用class定义类</li><li>自定义类：可以不使用class定义</li></ul><h3 id="自定义组件导出"><a href="#自定义组件导出" class="headerlink" title="自定义组件导出"></a>自定义组件导出</h3><p>1.ES6/5</p><ul><li>ES6:一般使用默认组件，支持import导出</li><li>ES5:一般使用非默认组件，支持require导出<br>2.默认组件/非默认组件</li><li><p>默认组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//定义</span><br><span class="line">export default class XXX extends Component&#123;&#125;</span><br><span class="line">//外部使用</span><br><span class="line">import XXX from &apos;../Custom/XXX&apos;</span><br></pre></td></tr></table></figure></li><li><p>非默认组件<br>非默认组件：需要加入{}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//定义</span><br><span class="line">export class XXX extends Component</span><br><span class="line">//外部使用</span><br><span class="line">import &#123;XXX&#125; from &apos;../Custom/XXX&apos;</span><br></pre></td></tr></table></figure></li></ul><h3 id="自定义类-1"><a href="#自定义类-1" class="headerlink" title="自定义类"></a>自定义类</h3><h4 id="没有对象属性的自定义类，同组件的定义和导出方式"><a href="#没有对象属性的自定义类，同组件的定义和导出方式" class="headerlink" title="没有对象属性的自定义类，同组件的定义和导出方式"></a>没有对象属性的自定义类，同组件的定义和导出方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//定义</span><br><span class="line">export default class XXX&#123;&#125;</span><br><span class="line">//外部使用</span><br><span class="line">import XXX from &apos;../Custom/XXX&apos;</span><br></pre></td></tr></table></figure><h4 id="有对象属性的自定义类"><a href="#有对象属性的自定义类" class="headerlink" title="有对象属性的自定义类"></a>有对象属性的自定义类</h4><p><code>一般用function定义类，用module.exports(也可以export default)导出</code></p><p>1.定义类的两种方式</p><ul><li><p>class定义类：在类中声明任何属性和方法，都会自动生成对象的属性和方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export default class XXX &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>function定义类：要想定义属性和方法，属性和方法前面必须添加this</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function XXX(data) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">this.func = function () &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>2.导出自定义类的两种方式</p><ul><li><p>module.exports</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module.exports = XXX;</span><br></pre></td></tr></table></figure></li><li><p>export default</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export default function XXX() &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><p>3.外部引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import XXX from &apos;../Custom/XXX&apos;</span><br></pre></td></tr></table></figure></p><h3 id="自定义类的继承–call方法"><a href="#自定义类的继承–call方法" class="headerlink" title="自定义类的继承–call方法"></a>自定义类的继承–call方法</h3><p>call方法<br>1.交换方法调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func1.call(func2);  //调用func1</span><br></pre></td></tr></table></figure></p><p>2.交换方法调用者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c1.log.call(c2);    //c2调用c1的log方法</span><br></pre></td></tr></table></figure></p><p>3.通过function自定义类没有继承功能，需要通过call方法自己实现<br>本质：交换方法调用者</p><h2 id="项目中经常遇到的问题"><a href="#项目中经常遇到的问题" class="headerlink" title="项目中经常遇到的问题"></a>项目中经常遇到的问题</h2><h3 id="主头文件问题"><a href="#主头文件问题" class="headerlink" title="主头文件问题"></a>主头文件问题</h3><p>1.创建主头文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import Common from &apos;../Common/GroupListView&apos;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// 这句话的意思：把当前文件作为一个模块导出，模块里面有这些子组件</span><br><span class="line">// 以后导入这个模块的时候，就能获取了这个模块里面的东西.</span><br><span class="line">module.exports = &#123;</span><br><span class="line">GroupListView,</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>2.使用头文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import Common from &apos;Common&apos;</span><br><span class="line">// 创建行模型</span><br><span class="line">var item0 = new Common.GroupListView();</span><br></pre></td></tr></table></figure></p><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><h3 id="Animated"><a href="#Animated" class="headerlink" title="Animated"></a>Animated</h3><p>Animated封装了四个可以动画的组件：View、Text、Image和ScrollView。</p><ul><li>配置动画</li><li>组合动画<br>parallel<br>sequence<br>stagger<br>delay</li><li>联动多个动画值</li><li>插值：interpolate({inputRange:[0,1],outputRange:[0,100],})</li><li>跟踪动态值:leader,follower,ValueXY</li><li>输入事件：Animated.event</li><li>使用原生动画驱动：<code>useNativeDriver:true</code></li></ul><h3 id="LayoutAnimation"><a href="#LayoutAnimation" class="headerlink" title="LayoutAnimation"></a>LayoutAnimation</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LayoutAnimation.spring();</span><br><span class="line">this.setState(&#123;w: this.state.w + 15, h: this.state.h + 15&#125;)</span><br></pre></td></tr></table></figure><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><ul><li>setTimeout,clearTimeout</li><li>setInterval,clearInterval</li><li>setImmediate,clearImmediate</li><li>requestAnimationFrame,cancelAnimationFrame</li></ul><p>requestAnimationFrame():用来执行在一段时间内控制视图动画的代码<br>setTimeout/setInterval/setImmediate:稍后执行代码，可能会延迟当前正在进行的动画<br>runAfterInteractions():稍后执行代码，不会延迟当前进行的动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InteractionManager.runAfterInteractions(() =&gt; &#123;</span><br><span class="line">// ...需要长时间同步执行的任务...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><blockquote><p>*** 注意：在unmount方法中清除定时器</p></blockquote><h2 id="setNativeProps"><a href="#setNativeProps" class="headerlink" title="setNativeProps"></a>setNativeProps</h2><h2 id="微信登录"><a href="#微信登录" class="headerlink" title="微信登录"></a>微信登录</h2><p><a href="https://github.com/yorkie/react-native-wechat" target="_blank" rel="noopener">文档</a></p><h3 id="安装react-native-wechat"><a href="#安装react-native-wechat" class="headerlink" title="安装react-native-wechat"></a>安装react-native-wechat</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install react-native-wechat --save</span><br></pre></td></tr></table></figure><h3 id="自动关联"><a href="#自动关联" class="headerlink" title="自动关联"></a>自动关联</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">react-native link</span><br><span class="line">//rnpm link react-native-wechat</span><br></pre></td></tr></table></figure><h3 id="配置项目"><a href="#配置项目" class="headerlink" title="配置项目"></a>配置项目</h3><ul><li><p><a href="https://github.com/yorkie/react-native-wechat/blob/master/docs/build-setup-ios.md" target="_blank" rel="noopener">iOS</a></p></li><li><p><a href="https://github.com/yorkie/react-native-wechat/blob/master/docs/build-setup-android.md" target="_blank" rel="noopener">Android</a></p></li></ul><h3 id="导入react-native-wechat"><a href="#导入react-native-wechat" class="headerlink" title="导入react-native-wechat"></a>导入react-native-wechat</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import * as WeChat from &apos;react-native-wechat&apos;;//首先导入react-native-wechat</span><br></pre></td></tr></table></figure><h3 id="从微信开放平台申请"><a href="#从微信开放平台申请" class="headerlink" title="从微信开放平台申请"></a>从微信开放平台申请</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">WeChat.registerApp(&apos;xxxx&apos;);</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">console.error(e);</span><br><span class="line">&#125;</span><br><span class="line">console.log(WeChat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在需要触发登录的时候调用"><a href="#在需要触发登录的时候调用" class="headerlink" title="在需要触发登录的时候调用"></a>在需要触发登录的时候调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeChat.sendAuthRequest(&quot;snsapi_userinfo&quot;);</span><br></pre></td></tr></table></figure><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>iOS模拟器上，<code>cmd+D</code>为摇晃手势<br><!--启动模拟器：--><br><!--<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--react-native run-ios --simulator &quot;iPhone 7&quot;--&gt;</span><br><span class="line">&lt;!--```--&gt;</span><br><span class="line"></span><br><span class="line">* Reload:刷新JS文件</span><br><span class="line">* Debug JS Remotely：在Chrome中调试JS代码</span><br><span class="line">会自动打开`http://localhost:8081/debugger-ui`，打开开发者工具可以查看console输出，以及打断点调试JS脚本。</span><br><span class="line">* Enable Live Reload：自动刷新，实时加载，应用更新时需要刷新当前页面，可以看到明显的全局刷新效果。</span><br><span class="line">* Enable Hot Reloading：热加载，基本上看不出刷新的效果，类似于局部刷新。</span><br><span class="line">* Start Systrace</span><br><span class="line">* Show Inspector</span><br><span class="line">* Show Pert Monitor</span><br><span class="line"></span><br><span class="line">必须重新编译应用才能生效：</span><br><span class="line">* 增加了新的资源，如图片</span><br><span class="line">* 更改了原生代码</span><br><span class="line"></span><br><span class="line">* console.error()可触发红屏报错</span><br><span class="line">* 屏蔽指定警告：ignoreWarnings([&apos;Warning:&apos;]);</span><br><span class="line"></span><br><span class="line">* 访问控制台日志：</span><br></pre></td></tr></table></figure></p><p>react-native log-ios<br>react-native log-android<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">还可以通过Debug-&gt;Open System Log查看日志</span><br><span class="line"></span><br><span class="line">* React Developer Tools</span><br></pre></td></tr></table></figure></p><p>npm install -g react-devtools  //安装<br>react-devtools  //启动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 真机调试</span><br><span class="line">(1)退出所有终端打开的页面</span><br><span class="line">(2)手机与电脑连到同一无线网下</span><br><span class="line">(3)将AppDelegate中jsCodeLocation的URL地址中的`localhost`改成电脑的IP地址，然后打开`Debug JS Remotely`</span><br><span class="line">`设置-&gt;网络`或者终端输入`ifconfig | grep &quot;inet &quot; | grep -v 127.0.0.1`查看电脑的IP地址。</span><br><span class="line">(4)解决https问题</span><br><span class="line">(5)更新node,npm版本到最新</span><br><span class="line">(6)关闭防火墙</span><br><span class="line"></span><br><span class="line">* 解决连接真机报错`No account for team &quot;QMP96B5DPW&quot;. Add a new account in the Accounts preference pane or verify that your accounts have valid credentials.`：build settings中搜索`DEVELOPMENT_TEAM`，修改team。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 自动化测试</span><br></pre></td></tr></table></figure></p><p>$ cd react-native<br>$ npm test<br>$ npm run flow<br>$ ./scripts/objc-test-ios.sh<br>$ ./scripts/test-manual-e2e.sh<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 性能</span><br><span class="line">只在开发环境时打印日志</span><br></pre></td></tr></table></figure></p><p>if (!<strong>DEV</strong>) {<br>global.console = {<br>info: () =&gt; {},<br>log: () =&gt; {},<br>warn: () =&gt; {},<br>debug: () =&gt; {},<br>error: () =&gt; {},<br>};<br>}<br><code>`</code></p><h2 id="发布应用"><a href="#发布应用" class="headerlink" title="发布应用"></a>发布应用</h2><p>1.edit scheme-&gt;Run-&gt;release release版本会自动禁用开发者菜单，同时将JS文件和静态图片打包压缩后放到包中<br>2.热更新：<a href="https://github.com/reactnativecn/react-native-pushy/blob/master/docs/guide.md">pushy</a></p><p>[React Native中文网]<a href="https://reactnative.cn/docs/sample-application-movies/">https://reactnative.cn/docs/sample-application-movies/</a><br><a href="http://www.jianshu.com/p/504a26d094b2">袁峥讲ReactNative-系列</a><br><a href="http://blog.xieliqun.com/2016/11/06/react-study/#more">React学习资源汇总</a><br><a href="http://www.jianshu.com/p/98c8f2a970eb">React Native开发错误警告处理总结（已解决 ！持续更新</a></p>--></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS动画学习笔记</title>
      <link href="/2017/07/05/iOS%E5%8A%A8%E7%94%BB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/07/05/iOS%E5%8A%A8%E7%94%BB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="UIView动画"><a href="#UIView动画" class="headerlink" title="UIView动画"></a>UIView动画</h1><h2 id="UIView的属性"><a href="#UIView的属性" class="headerlink" title="UIView的属性"></a>UIView的属性</h2><ul><li>frame</li><li>bounds</li><li>center</li><li>transform</li><li>alpha<a id="more"></a></li><li>backgroundColor</li><li>contentStretch</li></ul><h3 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h3><ul><li><p>view.transform 和 view.layer.transform的区别：</p><ul><li>view.transform：二维，<code>CGAffineTransform transform</code>。</li><li>view.layer.transform：3D，<code>CATransform3D transform</code>。</li></ul></li><li><p>CGAffineTransform:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//还原</span><br><span class="line">CGAffineTransformIdentity</span><br><span class="line">//位移仿射(CGFloat tx,CGFloat ty)</span><br><span class="line">CGAffineTransformMakeTranslation</span><br><span class="line">CGAffineTransformTranslate</span><br><span class="line">//旋转仿射(CGFloat angle)</span><br><span class="line">CGAffineTransformMakeRotation</span><br><span class="line">CGAffineTransformRotate</span><br><span class="line">//缩放仿射(CGFloat sx, CGFloat sy)</span><br><span class="line">CGAffineTransformMakeScale</span><br><span class="line">CGAffineTransformScale</span><br></pre></td></tr></table></figure></li><li><p>CATransform3D</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//还原</span><br><span class="line">CATransform3DIdentity</span><br><span class="line">//位移3D仿射(CGFloat tx, CGFloat ty, CGFloat tz)</span><br><span class="line">CATransform3DMakeTranslation</span><br><span class="line">CATransform3DTranslation</span><br><span class="line">//旋转3D仿射(CGFloat angle, CGFloat x, CGFloat y, CGFloat z)</span><br><span class="line">CATransform3DMakeRotation</span><br><span class="line">CATransform3DRotation</span><br><span class="line">//缩放3D仿射(CGFloat angle, CGFloat x, CGFloat y, CGFloat z)</span><br><span class="line">CATransform3DMakeScale</span><br><span class="line">CATransform3DScale</span><br><span class="line">//叠加3D仿射效果</span><br><span class="line">CATransform3DConcat(CATransform3D a, CATransform3D b)</span><br><span class="line">//仿射基础3D方法，可以直接做效果叠加</span><br><span class="line">CGAffineTransformMake (sx,shx,shy,sy,tx,ty)</span><br><span class="line">//检查是否有做过仿射3D效果(CATransform3D t)</span><br><span class="line">CATransform3DIsIdentity(transform)</span><br><span class="line">//检查2个3D仿射效果是否相同</span><br><span class="line">CATransform3DEqualToTransform(transform1,transform2)</span><br><span class="line">//3D仿射效果反转（反效果，比如原来扩大，就变成缩小）</span><br><span class="line">CATransform3DInvert(transform)</span><br></pre></td></tr></table></figure></li><li><p>CGAffineTransform与CGTransform3D的转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//将CGAffinrTransform转化为CATransform3D</span><br><span class="line">CATransform3D CATransform3DMakeAffineTransform (CGAffineTransform m);</span><br><span class="line">//将CATransform3D转换为CGAffineTransform</span><br><span class="line">CGAffineTransform CATransform3DGetAffineTransform (CATransform3D t);</span><br><span class="line">//判断一个CATransform3D是否可以转换为CAAffineTransform</span><br><span class="line">CATransform3DIsAffine (CATransform3D t);</span><br></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//view.transform</span><br><span class="line">self.redView.transform = CGAffineTransformIdentity;</span><br><span class="line">[UIView animateWithDuration:1.0f animations:^&#123;</span><br><span class="line">self.redView.transform = CGAffineTransformMakeScale(2.0f, 2.0f);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">//view.layer.transform</span><br><span class="line">self.redView.layer.transform =  CATransform3DIdentity;</span><br><span class="line">[UIView animateWithDuration:1.0f animations:^&#123;</span><br><span class="line">self.redView.layer.transform = CATransform3DMakeScale(2.0, 2.0, 1.0);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">//view.layer.transform</span><br><span class="line">CABasicAnimation *transformAnimation = [CABasicAnimation animationWithKeyPath:@&quot;transform&quot;];</span><br><span class="line">transformAnimation.toValue = [NSValue valueWithCATransform3D:CATransform3DMakeScale(2.0, 2.0, 1.0)];</span><br><span class="line">transformAnimation.beginTime = CACurrentMediaTime();</span><br><span class="line">transformAnimation.duration = 1.0f;</span><br><span class="line">transformAnimation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</span><br><span class="line">[self.redView.layer addAnimation:transformAnimation forKey:@&quot;transformAnimation&quot;];</span><br></pre></td></tr></table></figure></li></ul><h2 id="UIView动画的实现方式"><a href="#UIView动画的实现方式" class="headerlink" title="UIView动画的实现方式"></a>UIView动画的实现方式</h2><h3 id="begin-commit"><a href="#begin-commit" class="headerlink" title="begin-commit"></a>begin-commit</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[UIView beginAnimations:nil context:nil];</span><br><span class="line">[UIView setAnimationDuration:2.0];</span><br><span class="line">[UIView setAnimationDelay:.5];</span><br><span class="line">[UIView setAnimationRepeatCount:5];</span><br><span class="line">//是否禁用动画效果（对象属性依然会被改变，只是没有动画效果）</span><br><span class="line">[UIView setAnimationsEnabled:(BOOL)];</span><br><span class="line">//设置代理</span><br><span class="line">[UIView setAnimationDelegate:self];</span><br><span class="line">//设置动画将开始时代理对象执行的方法</span><br><span class="line">[UIView setAnimationWillStartSelector:(nullable SEL)];</span><br><span class="line">//设置动画结束后调用的代理方法</span><br><span class="line">[UIView setAnimationDidStopSelector:@selector(animationDidStop:finished:context:)];</span><br><span class="line">/*</span><br><span class="line">UIViewAnimationCurve：</span><br><span class="line">UIViewAnimationCurveEaseInOut,         // 慢进慢出（默认值）</span><br><span class="line">UIViewAnimationCurveEaseIn,            // 慢进</span><br><span class="line">UIViewAnimationCurveEaseOut,           // 慢出</span><br><span class="line">UIViewAnimationCurveLinear             // 匀速</span><br><span class="line">*/</span><br><span class="line">[UIView setAnimationCurve:(UIViewAnimationCurve)];</span><br><span class="line">//设置视图的过渡效果</span><br><span class="line">/* UIViewAnimationTransition:</span><br><span class="line">UIViewAnimationTransitionNone,              //不使用动画</span><br><span class="line">UIViewAnimationTransitionFlipFromLeft,      //从左向右旋转翻页</span><br><span class="line">UIViewAnimationTransitionFlipFromRight,     //从右向左旋转翻页</span><br><span class="line">UIViewAnimationTransitionCurlUp,            //从下往上卷曲翻页</span><br><span class="line">UIViewAnimationTransitionCurlDown,          //从上往下卷曲翻页</span><br><span class="line">cache：是否使用视图缓存，YES：视图在开始和结束时渲染一次；NO：视图在每一帧都渲染</span><br><span class="line">*/</span><br><span class="line">[UIView setAnimationTransition:(UIViewAnimationTransition) forView:(nonnull UIView *) cache:(BOOL)];</span><br></pre></td></tr></table></figure><h3 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">UIViewAnimationOptions:(可组合使用)</span><br><span class="line">UIViewAnimationOptionLayoutSubviews            //进行动画时布局子控件</span><br><span class="line">UIViewAnimationOptionAllowUserInteraction      //进行动画时允许用户交互</span><br><span class="line">UIViewAnimationOptionBeginFromCurrentState     //从当前状态开始动画</span><br><span class="line">UIViewAnimationOptionRepeat                    //无限重复执行动画</span><br><span class="line">UIViewAnimationOptionAutoreverse               //执行动画回路</span><br><span class="line">UIViewAnimationOptionOverrideInheritedDuration //忽略嵌套动画的执行时间设置</span><br><span class="line">UIViewAnimationOptionOverrideInheritedCurve    //忽略嵌套动画的曲线设置</span><br><span class="line">UIViewAnimationOptionAllowAnimatedContent      //转场：进行动画时重绘视图</span><br><span class="line">UIViewAnimationOptionShowHideTransitionViews   //转场：移除（添加和移除图层的）动画效果</span><br><span class="line">UIViewAnimationOptionOverrideInheritedOptions  //不继承父动画设置</span><br><span class="line"></span><br><span class="line">UIViewAnimationOptionCurveEaseInOut            //时间曲线，慢进慢出（默认值）</span><br><span class="line">UIViewAnimationOptionCurveEaseIn               //时间曲线，慢进</span><br><span class="line">UIViewAnimationOptionCurveEaseOut              //时间曲线，慢出</span><br><span class="line">UIViewAnimationOptionCurveLinear               //时间曲线，匀速</span><br><span class="line"></span><br><span class="line">UIViewAnimationOptionTransitionNone            //转场，不使用动画</span><br><span class="line">UIViewAnimationOptionTransitionFlipFromLeft    //转场，从左向右旋转翻页</span><br><span class="line">UIViewAnimationOptionTransitionFlipFromRight   //转场，从右向左旋转翻页</span><br><span class="line">UIViewAnimationOptionTransitionCurlUp          //转场，下往上卷曲翻页</span><br><span class="line">UIViewAnimationOptionTransitionCurlDown        //转场，从上往下卷曲翻页</span><br><span class="line">UIViewAnimationOptionTransitionCrossDissolve   //转场，交叉消失和出现</span><br><span class="line">UIViewAnimationOptionTransitionFlipFromTop     //转场，从上向下旋转翻页</span><br><span class="line">UIViewAnimationOptionTransitionFlipFromBottom  //转场，从下向上旋转翻页</span><br><span class="line">*/</span><br><span class="line">[UIView animateWithDuration:(NSTimeInterval) //动画持续时间</span><br><span class="line">delay:(NSTimeInterval) //动画延迟执行的时间</span><br><span class="line">options:(UIViewAnimationOptions) //动画的过渡效果</span><br><span class="line">animations:^&#123;</span><br><span class="line">//执行的动画</span><br><span class="line">&#125;                completion:^(BOOL finished) &#123;</span><br><span class="line">//动画执行提交后的操作</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><ul><li>过渡动画，主要用于UIView进入或者离开视图<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[UIView transitionWithView:self.view duration:2.f options:UIViewAnimationOptionTransitionFlipFromLeft animations:^&#123;</span><br><span class="line">//动画效果代码</span><br><span class="line">&#125; completion:^(BOOL finished) &#123;</span><br><span class="line">//动画完成代码</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></li></ul><h1 id="Spring-Animation-API"><a href="#Spring-Animation-API" class="headerlink" title="Spring Animation API"></a>Spring Animation API</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[UIView animateWithDuration:(NSTimeInterval)//动画持续时间</span><br><span class="line">delay:(NSTimeInterval)//动画延迟执行的时间</span><br><span class="line">usingSpringWithDamping:(CGFloat)//震动效果，范围0~1，数值越小震动效果越明显</span><br><span class="line">initialSpringVelocity:(CGFloat)//初始速度，数值越大初始速度越快</span><br><span class="line">options:(UIViewAnimationOptions)//动画的过渡效果(注意：初始速度取值越高而时间较短时，也会出现反弹效果)</span><br><span class="line">animations:^&#123;</span><br><span class="line">//执行的动画</span><br><span class="line">&#125;</span><br><span class="line">completion:^(BOOL finished) &#123;</span><br><span class="line">//动画执行提交后的操作</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h1 id="keyframes动画"><a href="#keyframes动画" class="headerlink" title="keyframes动画"></a>keyframes动画</h1><ul><li><p>关键帧动画，支持属性关键帧，不支持路径关键帧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">UIViewAnimationOptionLayoutSubviews           //进行动画时布局子控件</span><br><span class="line">UIViewAnimationOptionAllowUserInteraction     //进行动画时允许用户交互</span><br><span class="line">UIViewAnimationOptionBeginFromCurrentState    //从当前状态开始动画</span><br><span class="line">UIViewAnimationOptionRepeat                   //无限重复执行动画</span><br><span class="line">UIViewAnimationOptionAutoreverse              //执行动画回路</span><br><span class="line">UIViewAnimationOptionOverrideInheritedDuration //忽略嵌套动画的执行时间设置</span><br><span class="line">UIViewAnimationOptionOverrideInheritedOptions //不继承父动画设置</span><br><span class="line"></span><br><span class="line">UIViewKeyframeAnimationOptionCalculationModeLinear     //运算模式 :连续</span><br><span class="line">UIViewKeyframeAnimationOptionCalculationModeDiscrete   //运算模式 :离散</span><br><span class="line">UIViewKeyframeAnimationOptionCalculationModePaced      //运算模式 :均匀执行</span><br><span class="line">UIViewKeyframeAnimationOptionCalculationModeCubic      //运算模式 :平滑</span><br><span class="line">UIViewKeyframeAnimationOptionCalculationModeCubicPaced //运算模式 :平滑均匀</span><br><span class="line">*/</span><br><span class="line">[UIView animateKeyframesWithDuration:(NSTimeInterval)//动画持续时间</span><br><span class="line">delay:(NSTimeInterval)//动画延迟执行的时间</span><br><span class="line">options:(UIViewKeyframeAnimationOptions)//动画的过渡效果</span><br><span class="line">animations:^&#123;</span><br><span class="line">//执行的关键帧动画</span><br><span class="line">&#125;</span><br><span class="line">completion:^(BOOL finished) &#123;</span><br><span class="line">//动画执行提交后的操作</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></li><li><p>增加关键帧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[UIView addKeyframeWithRelativeStartTime:(double)//动画开始的时间（占总时间的比例）</span><br><span class="line">relativeDuration:(double) //动画持续时间（占总时间的比例）</span><br><span class="line">animations:^&#123;</span><br><span class="line">//执行的动画</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></li></ul><h1 id="核心动画（Core-Animation）"><a href="#核心动画（Core-Animation）" class="headerlink" title="核心动画（Core Animation）"></a>核心动画（Core Animation）</h1><h2 id="CALayer"><a href="#CALayer" class="headerlink" title="CALayer"></a>CALayer</h2><h3 id="CALayer的属性"><a href="#CALayer的属性" class="headerlink" title="CALayer的属性"></a>CALayer的属性</h3><ul><li>bounds</li><li>position：设置CALayer在父层中的位置，是以父层的左上角为坐标原点</li><li>anchorPoint：定位点，决定了CALayer身上的哪个点会在position属性所指的位置，x,y的取值范围是0~1。默认值：(0.5,0.5)，所以默认CALayer的中点会在position所指定的位置上。</li><li>RefbackgroundColor(CGColorRef)</li><li>transform(CGTransform3D)</li><li>borderColor(CGColorRef)</li><li>borderWidth</li><li>cornerRadius</li><li>content(id)   //可以给UIView设置背景图片，CGImage格式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 跨框架赋值需要进行桥接</span><br><span class="line">self.view.layer.contents = (__bridge id _Nullable)([UIImage imageNamed:@&quot;123&quot;].CGImage);</span><br></pre></td></tr></table></figure><h3 id="隐式动画"><a href="#隐式动画" class="headerlink" title="隐式动画"></a>隐式动画</h3><ul><li>每个UIView都默认关联着一个CALayer，这个Layer就是RootLayer。所有手动创建的的非RootLayer都存在着隐式动画。</li><li>可动画属性：对非RootLayer的部分属性进行修改，默认会自动产生一些动画效果，这些属性称为可动画属性。常见的可动画属性：<ul><li>bounds：缩放动画</li><li>backgroundColor：渐变动画</li><li>position：平移动画</li></ul></li><li>事务可以关闭隐式动画（变换仍存在）：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[CATransaction begin];</span><br><span class="line">// 关闭隐式动画</span><br><span class="line">[CATransaction setDisableActions:YES];</span><br><span class="line">//动画效果</span><br><span class="line">self.redView.layer.anchorPoint = CGPointMake(0, 0);</span><br><span class="line">[UIView animateWithDuration:3.0 animations:^&#123;</span><br><span class="line">self.redView.transform = CGAffineTransformMakeRotation(M_PI);</span><br><span class="line">&#125; completion:^(BOOL finished) &#123;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[CATransaction commit];</span><br></pre></td></tr></table></figure></li></ul><h2 id="核心动画"><a href="#核心动画" class="headerlink" title="核心动画"></a>核心动画</h2><h3 id="核心动画的特点"><a href="#核心动画的特点" class="headerlink" title="核心动画的特点"></a>核心动画的特点</h3><ul><li>核心动画的执行过程是在后台操作的，不会阻塞主线程</li><li>核心动画直接作用在CALayer上</li><li>属于Quartz Core框架的API</li><li>不支持交互</li></ul><h3 id="核心动画的使用步骤"><a href="#核心动画的使用步骤" class="headerlink" title="核心动画的使用步骤"></a>核心动画的使用步骤</h3><ul><li>初始化一个CAAnimation的对象，并设置一些动画相关属性</li><li>通过调用CALayer的<code>addAnimation:forKey:</code>增加CAAniamtion对象到CALayer中，开始执行动画</li><li>通过调用CALayer的<code>removeAnimation:forKey:</code>停止CALayer的动画</li></ul><h3 id="CAAnimation"><a href="#CAAnimation" class="headerlink" title="CAAnimation"></a>CAAnimation</h3><ul><li>CAAnimation是所有动画对象的父类，是抽象类，不可直接使用，应该使用它具体的子类</li><li><p>CAAnimation继承结构</p><ul><li>CAAnimation-&gt;CAMediaTiming协议<ul><li>CAPropertyAnimation<ul><li>CABasicAnimation</li><li>CAKeyframeAnimation</li></ul></li><li>CAAnimationGroup</li><li>CATransition</li></ul></li></ul></li><li><p>CAAnimation——动画填充模式（fillMode）<br><code>要想fillMode有效，最好设置removedOnCompletion = NO</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//    创建动画</span><br><span class="line">CABasicAnimation *anim = [CABasicAnimation animation];;</span><br><span class="line">//    设置动画对象</span><br><span class="line">//    keyPath决定了执行怎样的动画,调用layer的哪个属性来执行动画</span><br><span class="line">//    position:平移</span><br><span class="line">anim.keyPath = @&quot;position&quot;;</span><br><span class="line">//    包装成对象</span><br><span class="line">anim.fromValue = [NSValue valueWithCGPoint:CGPointMake(0, 0)];;</span><br><span class="line">anim.toValue = [NSValue valueWithCGPoint:CGPointMake(200, 300)];</span><br><span class="line">anim.duration = 2.0;</span><br><span class="line"></span><br><span class="line">//    让图层保持动画执行完毕后的状态</span><br><span class="line">//    执行完毕以后不要删除动画</span><br><span class="line">anim.removedOnCompletion = NO;</span><br><span class="line">//    保持最新的状态</span><br><span class="line">anim.fillMode = kCAFillModeForwards;</span><br><span class="line"></span><br><span class="line">//    添加动画</span><br><span class="line">[self.redView.layer addAnimation:anim forKey:nil];</span><br></pre></td></tr></table></figure></li></ul><p>fillMode属性值：</p><pre><code>- kCAFillModeRemoved 默认值，也就是说当动画开始前和动画结束后，动画对layer都没有影响，动画结束后，layer会恢复到之前的状态- kCAFillModeForwards 当动画结束后，layer会一直保持着动画最后的状态- kCAFillModeBackwards 在动画开始前，只需要将动画加入了一个layer，layer便立即进入动画的初始状态并等待动画开始。- kCAFillModeBoth 动画加入后开始之前，layer便处于动画初始状态，动画结束后layer保持动画最后的状态</code></pre><ul><li>CAAnimation——速度控制函数（timingFunction）<br>CAMediaTimingFunction属性值：<ul><li>kCAMediaTimingFunctionLinear（线性）</li><li>kCAMediaTimingFunctionEaseIn（渐进）</li><li>kCAMediaTimingFunctionEaseOut（渐出）</li><li>kCAMediaTimingFunctionEaseInEaseOut（渐进渐出）</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//设置动画的执行节奏</span><br><span class="line">anim.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear];</span><br></pre></td></tr></table></figure><ul><li><p>CAAnimation——动画代理方法（delegate）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//CAAnimationDelegate</span><br><span class="line">- (void)animationDidStart:(CAAnimation *)anim;</span><br><span class="line">- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag;</span><br></pre></td></tr></table></figure></li><li><p>CALayer上动画的暂停和恢复</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    static NSInteger count = 0;</span><br><span class="line">    if (count++%2 == 0) &#123;</span><br><span class="line">        [self pauseLayer:self.redView.layer];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        [self resumeLayer:self.redView.layer];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//停止</span><br><span class="line">-(void)pauseLayer:(CALayer*)layer</span><br><span class="line">&#123;</span><br><span class="line">    CFTimeInterval pausedTime = [layer convertTime:CACurrentMediaTime() fromLayer:nil];</span><br><span class="line">    //让CALayer的时间停止走动</span><br><span class="line">    layer.speed = 0.0;</span><br><span class="line">    //让CALayer的时间停留在pausedTime这个时刻</span><br><span class="line">    layer.timeOffset = pausedTime;</span><br><span class="line">&#125;</span><br><span class="line">//恢复</span><br><span class="line">-(void)resumeLayer:(CALayer*)layer</span><br><span class="line">&#123;</span><br><span class="line">    CFTimeInterval pausedTime = layer.timeOffset;</span><br><span class="line">    //1. 让CALayer的时间继续行走</span><br><span class="line">    layer.speed = 1.0;</span><br><span class="line">    //2. 取消上次记录的停留时刻</span><br><span class="line">    layer.timeOffset = 0.0;</span><br><span class="line">    //3. 取消上次设置的时间</span><br><span class="line">    layer.beginTime = 0.0;</span><br><span class="line">    //4. 计算暂停的时间(这里也可以用CACurrentMediaTime()-pausedTime)</span><br><span class="line">    CFTimeInterval timeSincePause = [layer convertTime:CACurrentMediaTime() fromLayer:nil] - pausedTime;</span><br><span class="line">    //5. 设置相对于父坐标系的开始时间(往后退timeSincePause)</span><br><span class="line">    layer.beginTime = timeSincePause;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="CAPropertyAnimation-抽象类"><a href="#CAPropertyAnimation-抽象类" class="headerlink" title="CAPropertyAnimation 抽象类"></a>CAPropertyAnimation 抽象类</h4><ul><li>通过指定CALayer的一个属性名称为keyPath（NSString类型），并且对CALayer的这个属性值进行修改，达到响应动画效果。<br><code>keyPath是CALayer的可动画属性</code></li></ul><h4 id="CABasicAnimation"><a href="#CABasicAnimation" class="headerlink" title="CABasicAnimation"></a>CABasicAnimation</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//创建动画对象</span><br><span class="line">CABasicAnimation *anim = [CABasicAnimation animation];</span><br><span class="line"></span><br><span class="line">//设置动画属性</span><br><span class="line">anim.keyPath = @&quot;position.y&quot;;</span><br><span class="line">anim.toValue = @300;</span><br><span class="line"></span><br><span class="line">//动画提交时,会自动删除动画</span><br><span class="line">anim.removedOnCompletion = NO;</span><br><span class="line">//设置动画最后保持状态</span><br><span class="line">anim.fillMode = kCAFillModeForwards;</span><br><span class="line"></span><br><span class="line">//添加动画对象</span><br><span class="line">[self.redView.layer addAnimation:anim forKey:nil];</span><br></pre></td></tr></table></figure><h4 id="CAKeyframeAnimation-关键帧动画"><a href="#CAKeyframeAnimation-关键帧动画" class="headerlink" title="CAKeyframeAnimation 关键帧动画"></a>CAKeyframeAnimation 关键帧动画</h4><ul><li>与CABasicAnimation的区别：<ul><li>CABasicAnimation：只能从fromValue变到toValue（可看做只有2个关键帧的CAKeyframeAnimation）</li><li>CAKeyframeAnimation：会使用NSArray保存这些数值</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//    创建动画</span><br><span class="line">CAKeyframeAnimation *anim = [CAKeyframeAnimation animation];;</span><br><span class="line">//    设置动画对象</span><br><span class="line">//  keyPath决定了执行怎样的动画,调整哪个属性来执行动画</span><br><span class="line">anim.keyPath = @&quot;position&quot;;</span><br><span class="line">NSValue *v1 = [NSValue valueWithCGPoint:CGPointMake(100, 0)];</span><br><span class="line">NSValue *v2 = [NSValue valueWithCGPoint:CGPointMake(200, 0)];</span><br><span class="line">NSValue *v3 = [NSValue valueWithCGPoint:CGPointMake(300, 0)];</span><br><span class="line">NSValue *v4 = [NSValue valueWithCGPoint:CGPointMake(400, 0)];</span><br><span class="line"></span><br><span class="line">anim.values = @[v1,v2,v3,v4];</span><br><span class="line">anim.duration = 2.0;</span><br><span class="line">//    让图层保持动画执行完毕后的状态</span><br><span class="line">//    状态执行完毕后不要删除动画</span><br><span class="line">anim.removedOnCompletion = NO;</span><br><span class="line">//    保持最新的状态</span><br><span class="line">anim.fillMode = kCAFillModeForwards;</span><br><span class="line"></span><br><span class="line">//    添加动画</span><br><span class="line">[self.redView.layer addAnimation:anim forKey:nil];</span><br></pre></td></tr></table></figure><ul><li>根据路径创建动画<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//    创建动画</span><br><span class="line">CAKeyframeAnimation *anim = [CAKeyframeAnimation animation];</span><br><span class="line"></span><br><span class="line">anim.keyPath = @&quot;position&quot;;</span><br><span class="line">anim.removedOnCompletion = NO;</span><br><span class="line">anim.fillMode = kCAFillModeForwards;</span><br><span class="line">anim.duration = 2.0;</span><br><span class="line"></span><br><span class="line">//    创建一个路径</span><br><span class="line">CGMutablePathRef path = CGPathCreateMutable();</span><br><span class="line">//    路径的范围</span><br><span class="line">CGPathAddEllipseInRect(path, NULL, CGRectMake(100, 100, 200, 200));</span><br><span class="line">//    添加路径</span><br><span class="line">anim.path = path;</span><br><span class="line">//    释放路径(带Create的函数创建的对象都需要手动释放,否则会内存泄露)</span><br><span class="line">CGPathRelease(path);</span><br><span class="line">//    添加到View的layer</span><br><span class="line">[self.redView.layer addAnimation:anim forKey:nil];</span><br></pre></td></tr></table></figure></li></ul><h4 id="CAAnimationGroup-动画组"><a href="#CAAnimationGroup-动画组" class="headerlink" title="CAAnimationGroup 动画组"></a>CAAnimationGroup 动画组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">CAAnimationGroup *group = [CAAnimationGroup animation];</span><br><span class="line"></span><br><span class="line">//    创建旋转动画对象</span><br><span class="line">CABasicAnimation *retate = [CABasicAnimation animation];</span><br><span class="line">//    layer的旋转属性</span><br><span class="line">retate.keyPath = @&quot;transform.rotation&quot;;</span><br><span class="line">//    角度</span><br><span class="line">retate.toValue = @(M_PI);</span><br><span class="line"></span><br><span class="line">//    创建缩放动画对象</span><br><span class="line">CABasicAnimation *scale = [CABasicAnimation animation];</span><br><span class="line">//    缩放属性</span><br><span class="line">scale.keyPath = @&quot;transform.scale&quot;;</span><br><span class="line">//    缩放比例</span><br><span class="line">scale.toValue = @(0.0);</span><br><span class="line">//    添加到动画组当中</span><br><span class="line">group.animations = @[retate,scale];</span><br><span class="line">//           执行动画时间</span><br><span class="line">group.duration = 2.0;</span><br><span class="line">//</span><br><span class="line">group.repeatCount = MAXFLOAT;</span><br><span class="line">//</span><br><span class="line">group.autoreverses = YES;</span><br><span class="line">//    执行完以后不要删除动画</span><br><span class="line">group.removedOnCompletion = NO;</span><br><span class="line">//          保持最新的状态</span><br><span class="line">group.fillMode = kCAFillModeForwards;</span><br><span class="line"></span><br><span class="line">[self.redView.layer addAnimation:group forKey:nil];</span><br></pre></td></tr></table></figure><ul><li>播放gif图<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line"></span><br><span class="line">NSArray *imageArray = [self getImageArrayWithGIFNameWit:@&quot;aisi&quot;];</span><br><span class="line">self.imageView.animationImages = imageArray;</span><br><span class="line">self.imageView.animationDuration = 3;</span><br><span class="line">self.imageView.animationRepeatCount = MAXFLOAT;</span><br><span class="line">[self.imageView startAnimating];</span><br><span class="line"></span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line"></span><br><span class="line">[_imageView stopAnimating];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSArray&lt;UIImage *&gt; *)getImageArrayWithGIFNameWit:(NSString *)imageName &#123;</span><br><span class="line"></span><br><span class="line">NSMutableArray *imageArray = [NSMutableArray array];</span><br><span class="line">NSString *path = [[NSBundle mainBundle] pathForResource:imageName ofType:@&quot;gif&quot;];</span><br><span class="line">NSData *data = [NSData dataWithContentsOfFile:path];</span><br><span class="line"></span><br><span class="line">if (!data) &#123;</span><br><span class="line">NSLog(@&quot;图片不存在!&quot;);</span><br><span class="line">return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CGImageSourceRef source = CGImageSourceCreateWithData((__bridge CFDataRef)data, NULL);</span><br><span class="line"></span><br><span class="line">size_t count = CGImageSourceGetCount(source);</span><br><span class="line"></span><br><span class="line">if (count &lt;= 1) &#123;</span><br><span class="line">[imageArray addObject:[[UIImage alloc] initWithData:data]];</span><br><span class="line">&#125;else &#123;</span><br><span class="line"></span><br><span class="line">for (size_t i = 0; i &lt; count; i++) &#123;</span><br><span class="line">CGImageRef image = CGImageSourceCreateImageAtIndex(source, i, NULL);</span><br><span class="line"></span><br><span class="line">[imageArray addObject:[UIImage imageWithCGImage:image scale:[UIScreen mainScreen].scale orientation:UIImageOrientationUp]];</span><br><span class="line"></span><br><span class="line">CGImageRelease(image);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CFRelease(source);</span><br><span class="line"></span><br><span class="line">return imageArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="CATransition-转场动画"><a href="#CATransition-转场动画" class="headerlink" title="CATransition 转场动画"></a>CATransition 转场动画</h4><ul><li><code>作用对象是父视图，过渡效果体现在父视图上</code></li><li>创建转场动画<ul><li>创建动画对象：[CATransition animation];</li><li>设置动画属性值</li><li>添加到需要转场动画的图层上： [ layer addAimation:animation forKer:nil];</li></ul></li><li>动画属性<ul><li>type</li><li>subtype</li><li>startProgress</li><li>endProgress</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">type</span><br><span class="line">fade : 交叉淡化过渡</span><br><span class="line">push : 新视图把旧视图推出去</span><br><span class="line">moveIn: 新视图移到旧视图上面</span><br><span class="line">reveal: 将旧视图移开,显示下面的新视图</span><br><span class="line">cube : 立方体翻滚效果</span><br><span class="line">oglFlip : 上下左右翻转效果</span><br><span class="line">suckEffect : 收缩效果，如一块布被抽走</span><br><span class="line">rippleEffect: 水滴效果</span><br><span class="line">pageCurl : 向上翻页效果</span><br><span class="line">pageUnCurl : 向下翻页效果</span><br><span class="line">cameraIrisHollowOpen : 相机镜头打开效果</span><br><span class="line">cameraIrisHollowClos : 相机镜头关闭效果</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">CATransition *anim = [CATransition animation];</span><br><span class="line">//转场类型</span><br><span class="line">anim.type = @&quot;cube&quot;;</span><br><span class="line">//动画执行时间</span><br><span class="line">anim.duration = 0.5;</span><br><span class="line">//动画执行方向</span><br><span class="line">anim.subtype = kCATransitionFromLeft;</span><br><span class="line">//动画从哪个点开始</span><br><span class="line">//    anim.startProgress = 0.2;</span><br><span class="line">//    anim.endProgress = 0.3;</span><br><span class="line">//添加到View的layer</span><br><span class="line">[self.redView.layer addAnimation:anim forKey:nil];</span><br></pre></td></tr></table></figure><h5 id="使用UIView实现转场动画"><a href="#使用UIView实现转场动画" class="headerlink" title="使用UIView实现转场动画"></a>使用UIView实现转场动画</h5><ul><li><p>单个视图的过渡效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[UIView transitionWithView:(nonnull UIView *)</span><br><span class="line">duration:(NSTimeInterval)</span><br><span class="line">options:(UIViewAnimationOptions)</span><br><span class="line">animations:^&#123;</span><br><span class="line">//执行的动画</span><br><span class="line">&#125;</span><br><span class="line">completion:^(BOOL finished) &#123;</span><br><span class="line">//动画执行提交后的操作</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></li><li><p>双视图的过渡效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[UIView transitionFromView:(nonnull UIView *) toView:(nonnull UIView *) duration:(NSTimeInterval) options:(UIViewAnimationOptions) completion:^(BOOL finished) &#123;</span><br><span class="line">//动画执行提交后的操作</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">//相当于</span><br><span class="line">//[fromView.superview addSubview:toView];</span><br><span class="line">//[fromView removeFromSuperview];</span><br></pre></td></tr></table></figure></li></ul><h5 id="自定义转场动画"><a href="#自定义转场动画" class="headerlink" title="自定义转场动画"></a>自定义转场动画</h5><p><a href="https://www.jianshu.com/p/9fa025c42261" target="_blank" rel="noopener">iOS动画，绝对够分量！</a><br><a href="https://www.jianshu.com/p/3bc427f0dd56" target="_blank" rel="noopener">iOS 动画 —— transform</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动画 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>OC与JS交互的几种方法</title>
      <link href="/2017/07/04/OC%E4%B8%8EJS%E4%BA%A4%E4%BA%92%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
      <url>/2017/07/04/OC%E4%B8%8EJS%E4%BA%A4%E4%BA%92%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>OC与JS交互的几种方法<br>1.JavaScriptCore<br>2.WebViewJavascriptBridge<br>3.WKWebview<br><a id="more"></a></p><h1 id="JavaScriptCore"><a href="#JavaScriptCore" class="headerlink" title="JavaScriptCore"></a>JavaScriptCore</h1><h2 id="通过JSContext实现OC与JS的交互"><a href="#通过JSContext实现OC与JS的交互" class="headerlink" title="通过JSContext实现OC与JS的交互"></a>通过JSContext实现OC与JS的交互</h2><h3 id="1-在webViewDidFinishLoad方法中创建JSContext对象-获取该UIWebview的javascript执行环境"><a href="#1-在webViewDidFinishLoad方法中创建JSContext对象-获取该UIWebview的javascript执行环境" class="headerlink" title="1.在webViewDidFinishLoad方法中创建JSContext对象,获取该UIWebview的javascript执行环境"></a>1.在webViewDidFinishLoad方法中创建JSContext对象,获取该UIWebview的javascript执行环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)webViewDidFinishLoad:(UIWebView *)webView &#123;</span><br><span class="line"></span><br><span class="line">    //通过当前webView的键获取到jscontext</span><br><span class="line">    self.jsContext = [webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];</span><br><span class="line">    //以后JS就可以通过 OCModel 调用OC方法</span><br><span class="line">    self.jsContext[@&quot;OCModel&quot;] = self;</span><br><span class="line">    self.jsContext.exceptionHandler = ^(JSContext *context, JSValue *exceptionValue) &#123;</span><br><span class="line">        context.exception = exceptionValue;</span><br><span class="line">        NSLog(@&quot;异常信息：%@&quot;, exceptionValue);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-OC调用JS方法并传递一个参数"><a href="#2-OC调用JS方法并传递一个参数" class="headerlink" title="2.OC调用JS方法并传递一个参数"></a>2.OC调用JS方法并传递一个参数</h3><p>JS方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function getImg(path)&#123;</span><br><span class="line">    //document.getElementById(&quot;test&quot;).src=path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>OC通过<code>evaluateScript</code>调用JS方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *alertJS=[NSString stringWithFormat:@&quot;getImg(&apos;%@&apos;)&quot;,@&quot;abc&quot;]; //准备执行的js代码</span><br><span class="line">[self.jsContext evaluateScript:alertJS];</span><br></pre></td></tr></table></figure></p><h3 id="3-JS调用OC方法并传递一个参数"><a href="#3-JS调用OC方法并传递一个参数" class="headerlink" title="3.JS调用OC方法并传递一个参数"></a>3.JS调用OC方法并传递一个参数</h3><p>OC方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)getImg:(NSString *)source&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>JS通过<code>OCModel</code>调用OC方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function getGalleryImg()&#123;</span><br><span class="line">    OCModel.getImg(&apos;gallery&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="通过request的URL实现交互"><a href="#通过request的URL实现交互" class="headerlink" title="通过request的URL实现交互"></a>通过request的URL实现交互</h2><p>JS代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">//触发该方法，调用OC中webview的`shouldStartLoadWithRequest`方法实现与OC交互</span><br><span class="line">function goCamera()&#123;</span><br><span class="line">    window.location.href=&quot;js-call://camera/cameraCallback&quot;;</span><br><span class="line">&#125;</span><br><span class="line">//OC回调的JS方法</span><br><span class="line">function cameraCallback(data) &#123;</span><br><span class="line">    //获取到OC传递过来的参数</span><br><span class="line">    alert(data);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>OC代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType</span><br><span class="line">&#123;</span><br><span class="line">    NSString *requestString = [[request URL] absoluteString];</span><br><span class="line">    //jS协议头</span><br><span class="line">    NSString *protocol = @&quot;js-call://&quot;;</span><br><span class="line">    //请求的字符串符合协议头</span><br><span class="line">    if ([requestString hasPrefix:protocol]) &#123;</span><br><span class="line">        //从协议头后的位置截取字符串到最后</span><br><span class="line">        NSString *requestContent = [requestString substringFromIndex:[protocol length]];</span><br><span class="line">        //将/分隔的字符串转换成数组</span><br><span class="line">        NSArray *vals = [requestContent componentsSeparatedByString:@&quot;/&quot;];</span><br><span class="line">        if ([[vals objectAtIndex:0] isEqualToString:@&quot;camera&quot;]) &#123;</span><br><span class="line">            //获取到回调方法：cameraCallback</span><br><span class="line">            callback = [vals objectAtIndex:1];</span><br><span class="line">            //OC回调JS方法，并传递一个参数</span><br><span class="line">            [_webView stringByEvaluatingJavaScriptFromString:[NSString stringWithFormat:@&quot;%@(&apos;%@&apos;);&quot;, callback, @&quot;abc&quot;]];</span><br><span class="line">        &#125; </span><br><span class="line">        else &#123;</span><br><span class="line">            [webView stringByEvaluatingJavaScriptFromString:@&quot;alert(&apos;未定义&apos;);&quot;];</span><br><span class="line">        &#125;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="WebViewJavascriptBridge"><a href="#WebViewJavascriptBridge" class="headerlink" title="WebViewJavascriptBridge"></a>WebViewJavascriptBridge</h1><h2 id="1-通过cocoapods或手动导入WebViewJavascriptBridge框架"><a href="#1-通过cocoapods或手动导入WebViewJavascriptBridge框架" class="headerlink" title="1.通过cocoapods或手动导入WebViewJavascriptBridge框架"></a>1.通过cocoapods或手动导入WebViewJavascriptBridge框架</h2><h2 id="2-OC端-创建webview-与bridge对象建立联系"><a href="#2-OC端-创建webview-与bridge对象建立联系" class="headerlink" title="2.OC端:创建webview,与bridge对象建立联系"></a>2.OC端:创建webview,与bridge对象建立联系</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 开启日志</span><br><span class="line">[WebViewJavascriptBridge enableLogging];</span><br><span class="line"></span><br><span class="line">// 指定webview，建立JS与OjbC的沟通桥梁</span><br><span class="line">self.bridge = [WebViewJavascriptBridge bridgeForWebView:webView];</span><br><span class="line">[self.bridge setWebViewDelegate:self];</span><br></pre></td></tr></table></figure><h2 id="3-JS端：创建setupWebViewJavascriptBridge"><a href="#3-JS端：创建setupWebViewJavascriptBridge" class="headerlink" title="3.JS端：创建setupWebViewJavascriptBridge"></a>3.JS端：创建setupWebViewJavascriptBridge</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">window.onerror = function(err) &#123;</span><br><span class="line">log(&apos;window.onerror: &apos; + err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*这段代码是固定的，必须要放到js中*/</span><br><span class="line">function setupWebViewJavascriptBridge(callback) &#123;</span><br><span class="line">if (window.WebViewJavascriptBridge) &#123; return callback(WebViewJavascriptBridge); &#125;</span><br><span class="line">if (window.WVJBCallbacks) &#123; return window.WVJBCallbacks.push(callback); &#125;</span><br><span class="line">window.WVJBCallbacks = [callback];</span><br><span class="line">var WVJBIframe = document.createElement(&apos;iframe&apos;);</span><br><span class="line">WVJBIframe.style.display = &apos;none&apos;;</span><br><span class="line">WVJBIframe.src = &apos;wvjbscheme://__BRIDGE_LOADED__&apos;;</span><br><span class="line">document.documentElement.appendChild(WVJBIframe);</span><br><span class="line">setTimeout(function() &#123; document.documentElement.removeChild(WVJBIframe) &#125;, 0)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*与OC交互的所有JS方法都要放在此处注册，才能调用通过JS调用OC方法或者让OC调用这里的JS方法*/</span><br><span class="line">setupWebViewJavascriptBridge(function(bridge) &#123;</span><br><span class="line"></span><br><span class="line">    //在这注册OC调用JS的方法，可以接收OC传过来的参数 data ，还可以通过 responseCallback 回调OC</span><br><span class="line">    /*</span><br><span class="line">    bridge.registerHandler(&apos;JSFunction&apos;, function(data, responseCallback) &#123;</span><br><span class="line">        responseCallback(&#123;&apos;&apos;: &apos;&apos;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    //这里可以调用OC方法，OC端在处理完成后，反馈给JS，这样写是在载入页面完成时就先调用</span><br><span class="line">    document.getElementById(&apos;btn&apos;).onclick = function (e) &#123;</span><br><span class="line">    bridge.callHandler(&apos;OCFunction&apos;, &#123;&apos;js&apos;: &apos;abc&apos;&#125;, function(response) &#123;</span><br><span class="line">        alert(response)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="4-JS调用OC方法"><a href="#4-JS调用OC方法" class="headerlink" title="4.JS调用OC方法"></a>4.JS调用OC方法</h2><p>bridge通过<code>registerHandler</code>注册提供给JS调用的方法<br>OC端通过responseCallback回调JS，JS就可以得到所需要的数据<br>OC方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[self.bridge registerHandler:@&quot;JSCallOC&quot; handler:^(id data, WVJBResponseCallback responseCallback) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, data);     //js-oc,abc</span><br><span class="line">    if (responseCallback) &#123;</span><br><span class="line">        // 回调给JS</span><br><span class="line">        responseCallback(@&#123;@&quot;oc-js&quot;: @&quot;123&quot;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><p>JS调用OC方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bridge.callHandler(&apos;JSCallOC&apos;, &#123;&apos;js-oc&apos;: &apos;abc&apos;&#125;, function(responseData) &#123;</span><br><span class="line">    alert(responseData)     //oc-js,123</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="5-OC调用JS方法"><a href="#5-OC调用JS方法" class="headerlink" title="5.OC调用JS方法"></a>5.OC调用JS方法</h2><p>JS方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*JS给ObjC提供公开的API，在ObjC端可以手动调用JS的这个API。接收ObjC传过来的参数，且可以回调ObjC*/</span><br><span class="line">bridge.registerHandler(&apos;OCCallJS&apos;, function(data, responseCallback) &#123;</span><br><span class="line">    alert(data)     //oc-js,123</span><br><span class="line">    responseCallback(&#123;&apos;a&apos;: &apos;1&apos;, &apos;b&apos;: &apos;2&apos;&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>OC调用JS方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[self.bridge callHandler:@&quot;OCCallJS&quot; data:@&#123;@&quot;oc-js&quot;: @&quot;123&quot;&#125; responseCallback:^(id responseData) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, responseData);     //&apos;a&apos;: &apos;1&apos;, &apos;b&apos;: &apos;2&apos;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><h1 id="WKWebview"><a href="#WKWebview" class="headerlink" title="WKWebview"></a>WKWebview</h1><h2 id="1-添加JS交互方法"><a href="#1-添加JS交互方法" class="headerlink" title="1.添加JS交互方法"></a>1.添加JS交互方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//添加JS交互方法</span><br><span class="line">-(void)setupJSmethod&#123;</span><br><span class="line"></span><br><span class="line">// 注入JS对象名称AppModel，当JS通过AppModel来调用时，</span><br><span class="line">// 我们可以在WKScriptMessageHandler代理中接收到</span><br><span class="line">[self.userContentController addScriptMessageHandler:self name:@&quot;AppModel&quot;];</span><br><span class="line">[self.userContentController addScriptMessageHandler:self name:@&quot;userLogin&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-创建WKWebview"><a href="#2-创建WKWebview" class="headerlink" title="2.创建WKWebview"></a>2.创建WKWebview</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init];</span><br><span class="line">/*</span><br><span class="line">NSString *js = @&quot;I am JS Code&quot;;</span><br><span class="line">//初始化WKUserScript对象</span><br><span class="line">//根据生成的WKUserScript对象，初始化WKWebViewConfiguration</span><br><span class="line">//WKUserScriptInjectionTimeAtDocumentEnd为网页加载完成时注入</span><br><span class="line">WKUserScript *script = [[WKUserScript alloc] initWithSource:js injectionTime:WKUserScriptInjectionTimeAtDocumentEnd forMainFrameOnly:YES];</span><br><span class="line">[config.userContentController addUserScript:script];</span><br><span class="line">*/</span><br><span class="line">// 注入JS对象名称AppModel，当JS通过AppModel来调用时，</span><br><span class="line">// 我们可以在WKScriptMessageHandler代理中接收到</span><br><span class="line">[config.userContentController addScriptMessageHandler:self name:@&quot;AppModel&quot;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">self.webView = [[WKWebView alloc] initWithFrame:self.view.bounds configuration:config];</span><br><span class="line">// 导航代理</span><br><span class="line">self.webView.navigationDelegate = self;</span><br><span class="line">// 与webview UI交互代理</span><br><span class="line">self.webView.UIDelegate = self;</span><br><span class="line">[self.view addSubview:self.webView];</span><br><span class="line"></span><br><span class="line">NSURL *path = [[NSBundle mainBundle] URLForResource:@&quot;demo&quot; withExtension:@&quot;html&quot;];</span><br><span class="line">[self.webView loadRequest:[NSURLRequest requestWithURL:path]];</span><br></pre></td></tr></table></figure><h2 id="3-添加WKWebView属性的监听"><a href="#3-添加WKWebView属性的监听" class="headerlink" title="3.添加WKWebView属性的监听"></a>3.添加WKWebView属性的监听</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// 添加KVO监听</span><br><span class="line">[self.webView addObserver:self</span><br><span class="line">forKeyPath:@&quot;loading&quot;</span><br><span class="line">options:NSKeyValueObservingOptionNew</span><br><span class="line">context:nil];</span><br><span class="line">[self.webView addObserver:self</span><br><span class="line">forKeyPath:@&quot;title&quot;</span><br><span class="line">options:NSKeyValueObservingOptionNew</span><br><span class="line">context:nil];</span><br><span class="line">[self.webView addObserver:self</span><br><span class="line">forKeyPath:@&quot;estimatedProgress&quot;</span><br><span class="line">options:NSKeyValueObservingOptionNew</span><br><span class="line">context:nil];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - KVO</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath</span><br><span class="line">ofObject:(id)object</span><br><span class="line">change:(NSDictionary&lt;NSString *,id&gt; *)change</span><br><span class="line">context:(void *)context &#123;</span><br><span class="line">if ([keyPath isEqualToString:@&quot;loading&quot;]) &#123;</span><br><span class="line">NSLog(@&quot;loading&quot;);</span><br><span class="line">&#125; else if ([keyPath isEqualToString:@&quot;title&quot;]) &#123;</span><br><span class="line">self.title = self.webView.title;</span><br><span class="line">&#125; else if ([keyPath isEqualToString:@&quot;estimatedProgress&quot;]) &#123;</span><br><span class="line">NSLog(@&quot;progress: %f&quot;, self.webView.estimatedProgress);</span><br><span class="line">//        self.progressView.progress = self.webView.estimatedProgress;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 加载完成</span><br><span class="line">//    if (!self.webView.loading) &#123;</span><br><span class="line">//        // 手动调用JS代码</span><br><span class="line">//        // 每次页面完成都弹出来，大家可以在测试时再打开</span><br><span class="line">//        NSString *js = @&quot;callJsAlert()&quot;;</span><br><span class="line">//        [self.webView evaluateJavaScript:js completionHandler:^(id _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">//            NSLog(@&quot;response: %@ error: %@&quot;, response, error);</span><br><span class="line">//            NSLog(@&quot;call js alert by native&quot;);</span><br><span class="line">//        &#125;];</span><br><span class="line">//</span><br><span class="line">//        [UIView animateWithDuration:0.5 animations:^&#123;</span><br><span class="line">//            self.progressView.alpha = 0;</span><br><span class="line">//        &#125;];</span><br><span class="line">//    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-WKScriptMessageHandler"><a href="#4-WKScriptMessageHandler" class="headerlink" title="4.WKScriptMessageHandler"></a>4.WKScriptMessageHandler</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - WKScriptMessageHandler</span><br><span class="line">//JS调用iOS</span><br><span class="line">- (void)userContentController:(WKUserContentController *)userContentController</span><br><span class="line">didReceiveScriptMessage:(WKScriptMessage *)message &#123;</span><br><span class="line">if ([message.name isEqualToString:@&quot;AppModel&quot;]) &#123;</span><br><span class="line">// 打印所传过来的参数，只支持NSNumber, NSString, NSDate, NSArray,</span><br><span class="line">// NSDictionary, and NSNull类型</span><br><span class="line">NSLog(@&quot;%@&quot;, message.body);</span><br><span class="line">&#125;else if ([message.name isEqualToString:@&quot;userLogin&quot;])&#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, message.body);</span><br><span class="line"></span><br><span class="line">// 每次页面完成都弹出来，大家可以在测试时再打开</span><br><span class="line">NSString *js = [NSString stringWithFormat:@&quot;callJsUserName(&apos;%@&apos;)&quot;,message.body[@&quot;body&quot;]];</span><br><span class="line">[self.webView evaluateJavaScript:js completionHandler:^(id _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">NSLog(@&quot;response: %@ error: %@&quot;, response, error);</span><br><span class="line">NSLog(@&quot;call js username by native&quot;);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-WKUIDelegate"><a href="#5-WKUIDelegate" class="headerlink" title="5.WKUIDelegate"></a>5.WKUIDelegate</h2><figure class="highlight plain"><figcaption><span>mark - WKUIDelegate</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">- (void)webViewDidClose:(WKWebView *)webView &#123;</span><br><span class="line">NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在JS端调用alert函数时，会触发此代理方法。</span><br><span class="line">// JS端调用alert时所传的数据可以通过message拿到</span><br><span class="line">// 在原生得到结果后，需要回调JS，是通过completionHandler回调</span><br><span class="line">- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler &#123;</span><br><span class="line">NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;alert&quot; message:@&quot;JS调用alert&quot; preferredStyle:UIAlertControllerStyleAlert];</span><br><span class="line">[alert addAction:[UIAlertAction actionWithTitle:@&quot;确定&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">completionHandler();</span><br><span class="line">&#125;]];</span><br><span class="line"></span><br><span class="line">[self presentViewController:alert animated:YES completion:NULL];</span><br><span class="line">NSLog(@&quot;%@&quot;, message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// JS端调用confirm函数时，会触发此方法</span><br><span class="line">// 通过message可以拿到JS端所传的数据</span><br><span class="line">// 在iOS端显示原生alert得到YES/NO后</span><br><span class="line">// 通过completionHandler回调给JS端</span><br><span class="line">- (void)webView:(WKWebView *)webView runJavaScriptConfirmPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(BOOL result))completionHandler &#123;</span><br><span class="line">NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line"></span><br><span class="line">UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;confirm&quot; message:@&quot;JS调用confirm&quot; preferredStyle:UIAlertControllerStyleAlert];</span><br><span class="line">[alert addAction:[UIAlertAction actionWithTitle:@&quot;确定&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">completionHandler(YES);</span><br><span class="line">&#125;]];</span><br><span class="line">[alert addAction:[UIAlertAction actionWithTitle:@&quot;取消&quot; style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">completionHandler(NO);</span><br><span class="line">&#125;]];</span><br><span class="line">[self presentViewController:alert animated:YES completion:NULL];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;, message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// JS端调用prompt函数时，会触发此方法</span><br><span class="line">// 要求输入一段文本</span><br><span class="line">// 在原生输入得到文本内容后，通过completionHandler回调给JS</span><br><span class="line">- (void)webView:(WKWebView *)webView runJavaScriptTextInputPanelWithPrompt:(NSString *)prompt defaultText:(nullable NSString *)defaultText initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(NSString * __nullable result))completionHandler &#123;</span><br><span class="line">NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;, prompt);</span><br><span class="line">UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;textinput&quot; message:@&quot;JS调用输入框&quot; preferredStyle:UIAlertControllerStyleAlert];</span><br><span class="line">[alert addTextFieldWithConfigurationHandler:^(UITextField * _Nonnull textField) &#123;</span><br><span class="line">textField.textColor = [UIColor redColor];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[alert addAction:[UIAlertAction actionWithTitle:@&quot;确定&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">completionHandler([[alert.textFields lastObject] text]);</span><br><span class="line">&#125;]];</span><br><span class="line"></span><br><span class="line">[self presentViewController:alert animated:YES completion:NULL];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-WKNavigationDelegate"><a href="#6-WKNavigationDelegate" class="headerlink" title="6.WKNavigationDelegate"></a>6.WKNavigationDelegate</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - WKNavigationDelegate</span><br><span class="line">// 请求开始前，会先调用此代理方法</span><br><span class="line">// 与UIWebView的</span><br><span class="line">// - (BOOL)webView:(UIWebView *)webView</span><br><span class="line">// shouldStartLoadWithRequest:(NSURLRequest *)request</span><br><span class="line">// navigationType:(UIWebViewNavigationType)navigationType;</span><br><span class="line">// 类型，在请求先判断能不能跳转（请求）</span><br><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler &#123;</span><br><span class="line">NSString *hostname = navigationAction.request.URL.host.lowercaseString;</span><br><span class="line">if (navigationAction.navigationType == WKNavigationTypeLinkActivated</span><br><span class="line">&amp;&amp; ![hostname containsString:@&quot;.baidu.com&quot;]) &#123;</span><br><span class="line">// 对于跨域，需要手动跳转</span><br><span class="line">[[UIApplication sharedApplication] openURL:navigationAction.request.URL];</span><br><span class="line"></span><br><span class="line">// 不允许web内跳转</span><br><span class="line">decisionHandler(WKNavigationActionPolicyCancel);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">self.progressView.alpha = 1.0;</span><br><span class="line">decisionHandler(WKNavigationActionPolicyAllow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在响应完成时，会回调此方法</span><br><span class="line">// 如果设置为不允许响应，web内容就不会传过来</span><br><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler &#123;</span><br><span class="line">decisionHandler(WKNavigationResponsePolicyAllow);</span><br><span class="line">NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 开始导航跳转时会回调</span><br><span class="line">- (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(null_unspecified WKNavigation *)navigation &#123;</span><br><span class="line">NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 接收到重定向时会回调</span><br><span class="line">- (void)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(null_unspecified WKNavigation *)navigation &#123;</span><br><span class="line">NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 导航失败时会回调</span><br><span class="line">- (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(null_unspecified WKNavigation *)navigation withError:(NSError *)error &#123;</span><br><span class="line">NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 页面内容到达main frame时回调</span><br><span class="line">- (void)webView:(WKWebView *)webView didCommitNavigation:(null_unspecified WKNavigation *)navigation &#123;</span><br><span class="line">NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 导航完成时，会回调（也就是页面载入完成了）</span><br><span class="line">- (void)webView:(WKWebView *)webView didFinishNavigation:(null_unspecified WKNavigation *)navigation &#123;</span><br><span class="line">NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 导航失败时会回调</span><br><span class="line">- (void)webView:(WKWebView *)webView didFailNavigation:(null_unspecified WKNavigation *)navigation withError:(NSError *)error &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 对于HTTPS的都会触发此代理，如果不要求验证，传默认就行</span><br><span class="line">// 如果需要证书验证，与使用AFN进行HTTPS证书验证是一样的</span><br><span class="line">- (void)webView:(WKWebView *)webView didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *__nullable credential))completionHandler &#123;</span><br><span class="line">NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">completionHandler(NSURLSessionAuthChallengePerformDefaultHandling, nil);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 9.0才能使用，web内容处理中断时会触发</span><br><span class="line">- (void)webViewWebContentProcessDidTerminate:(WKWebView *)webView &#123;</span><br><span class="line">NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-dealloc"><a href="#7-dealloc" class="headerlink" title="7.dealloc"></a>7.dealloc</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)dealloc &#123;</span><br><span class="line">[[_webView configuration].userContentController removeScriptMessageHandlerForName:@&quot;方法名&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-JS端代码"><a href="#8-JS端代码" class="headerlink" title="8.JS端代码"></a>8.JS端代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;iOS and Js&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">* &#123;</span><br><span class="line">font-size: 40px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div style=&quot;margin-top: 100px&quot;&gt;</span><br><span class="line">&lt;h1&gt;Test how to use objective-c call js&lt;/h1&gt;&lt;br/&gt;</span><br><span class="line">&lt;div&gt;&lt;input type=&quot;button&quot; value=&quot;userLogin&quot; onclick=&quot;callJsUserLogin()&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;div&gt;&lt;input type=&quot;button&quot; value=&quot;call js alert&quot; onclick=&quot;callJsAlert()&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;div&gt;&lt;input type=&quot;button&quot; value=&quot;Call js confirm&quot; onclick=&quot;callJsConfirm()&quot;&gt;&lt;/div&gt;&lt;br/&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;div&gt;&lt;input type=&quot;button&quot; value=&quot;Call Js prompt &quot; onclick=&quot;callJsInput()&quot;&gt;&lt;/div&gt;&lt;br/&gt;</span><br><span class="line">&lt;div&gt;Click me here: &lt;a href=&quot;https://www.baidu.com&quot;&gt;Jump to Baidu&lt;/a&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;div id=&quot;SwiftDiv&quot;&gt;</span><br><span class="line">&lt;span id=&quot;jsParamFuncSpan&quot; style=&quot;color: red; font-size: 50px;&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">function callJsAlert() &#123;</span><br><span class="line">alert(&apos;Objective-C call js to show alert&apos;);</span><br><span class="line"></span><br><span class="line">window.webkit.messageHandlers.AppModel.postMessage(&#123;body: &apos;call js alert in js&apos;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function callJsConfirm() &#123;</span><br><span class="line">if (confirm(&apos;confirm&apos;, &apos;Objective-C call js to show confirm&apos;)) &#123;</span><br><span class="line">document.getElementById(&apos;jsParamFuncSpan&apos;).innerHTML</span><br><span class="line">= &apos;true&apos;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">document.getElementById(&apos;jsParamFuncSpan&apos;).innerHTML</span><br><span class="line">= &apos;false&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// AppModel是我们所注入的对象</span><br><span class="line">window.webkit.messageHandlers.AppModel.postMessage(&#123;body: &apos;call js confirm in js&apos;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function callJsInput() &#123;</span><br><span class="line">var response = prompt(&apos;Hello&apos;, &apos;Please input your name:&apos;);</span><br><span class="line">document.getElementById(&apos;jsParamFuncSpan&apos;).innerHTML = response;</span><br><span class="line"></span><br><span class="line">// AppModel是我们所注入的对象</span><br><span class="line">window.webkit.messageHandlers.AppModel.postMessage(&#123;body: response&#125;);</span><br><span class="line">&#125;</span><br><span class="line">function callJsUserLogin()&#123;</span><br><span class="line">window.webkit.messageHandlers.userLogin.postMessage(&#123;body: &apos;xiaoming&apos;&#125;);</span><br><span class="line">&#125;</span><br><span class="line">function callJsUserName(username)&#123;</span><br><span class="line">document.getElementById(&apos;jsParamFuncSpan&apos;).innerHTML</span><br><span class="line">= username;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="9-总结"><a href="#9-总结" class="headerlink" title="9.总结"></a>9.总结</h2><ul><li>JS调用OC方法：<br>JS端：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.webkit.messageHandlers.userLogin.postMessage(&#123;body: &apos;xiaoming&apos;&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>OC端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)userContentController:(WKUserContentController *)userContentController</span><br><span class="line">didReceiveScriptMessage:(WKScriptMessage *)message &#123;</span><br><span class="line">    if ([message.name isEqualToString:@&quot;userLogin&quot;])&#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, message.body);</span><br><span class="line">    &#125;</span><br><span class="line">    //else if ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>OC调用JS方法：<br>OC端：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSString *username = @&quot;xiaoming&quot;;</span><br><span class="line">NSString *js = [NSString stringWithFormat:@&quot;callJsUserName(&apos;%@&apos;)&quot;,username];</span><br><span class="line">[self.webView evaluateJavaScript:js completionHandler:^(id _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">NSLog(@&quot;response: %@ error: %@&quot;, response, error);</span><br><span class="line">NSLog(@&quot;call js username by native&quot;);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></li></ul><p>JS端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function callJsUserName(username)&#123;</span><br><span class="line">document.getElementById(&apos;jsParamFuncSpan&apos;).innerHTML</span><br><span class="line">= username;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="清除webview缓存"><a href="#清除webview缓存" class="headerlink" title="清除webview缓存"></a>清除webview缓存</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//清除cookies</span><br><span class="line">NSHTTPCookie *cookie;</span><br><span class="line">NSHTTPCookieStorage *storage = [NSHTTPCookieStorage sharedHTTPCookieStorage];</span><br><span class="line">for (cookie in [storage cookies]) &#123;</span><br><span class="line">[storage deleteCookie:cookie];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NSHTTPCookie *cookie = [NSHTTPCookie cookieWithProperties:[NSDictionary dictionaryWithObjectsAndKeys:@&quot;false&quot;,@&quot;HttpOnly&quot;,nil]];</span><br><span class="line">[[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:cookie];</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//清除webView的缓存</span><br><span class="line">[[NSURLCache sharedURLCache] removeAllCachedResponses];</span><br><span class="line"></span><br><span class="line">//清除请求</span><br><span class="line">[[NSURLCache sharedURLCache] removeCachedResponseForRequest:self.request];</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//不加载缓存</span><br><span class="line">[self.webview loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:self.webURL] cachePolicy:NSURLRequestReloadIgnoringLocalCacheData timeoutInterval:10.0]];</span><br></pre></td></tr></table></figure><p>参考文章：<a href="https://www.cnblogs.com/jiang-xiao-yan/p/5345893.html" target="_blank" rel="noopener">WKWebView与Js实战(OC版)</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>OpenGL学习笔记</title>
      <link href="/2017/07/03/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/07/03/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>1.GPUImage底层使用的是OPENGL,操控GPU来实现屏幕展示<br><a id="more"></a></p><p>01-自定义图层类型<br>02-初始化CAEAGLLayer图层属性<br>03-创建EAGLContext<br>04-创建渲染缓冲区<br>05-创建帧缓冲区<br>06-创建着色器<br>07-创建着色器程序<br>08-创建纹理对象<br>09-YUV转RGB绘制纹理<br>10-渲染缓冲区到屏幕<br>11-清理内存</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>OC中的block</title>
      <link href="/2017/07/01/OC%E4%B8%AD%E7%9A%84block/"/>
      <url>/2017/07/01/OC%E4%B8%AD%E7%9A%84block/</url>
      
        <content type="html"><![CDATA[<h2 id="block的定义"><a href="#block的定义" class="headerlink" title="block的定义"></a>block的定义</h2><ul><li>用作本地变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">returnType (^blockName)(parameterTypes) = ^returnType(parameters) &#123;...&#125;;</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><ul><li><p>用作属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, copy, nullability) returnType (^blockName)(parameterTypes);</span><br><span class="line">As a method parameter:</span><br></pre></td></tr></table></figure></li><li><p>用作方法参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)someMethodThatTakesABlock:(returnType (^nullability)(parameterTypes))blockName;</span><br></pre></td></tr></table></figure></li><li><p>调用参数为block的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[someObject someMethodThatTakesABlock:^returnType (parameters) &#123;...&#125;];</span><br></pre></td></tr></table></figure></li><li><p>用作类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef returnType (^TypeName)(parameterTypes);</span><br><span class="line">TypeName blockName = ^returnType(parameters) &#123;...&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="block的使用"><a href="#block的使用" class="headerlink" title="block的使用"></a>block的使用</h2><h3 id="block用copy修饰，delegate用weak修饰，枚举用assign修饰"><a href="#block用copy修饰，delegate用weak修饰，枚举用assign修饰" class="headerlink" title="block用copy修饰，delegate用weak修饰，枚举用assign修饰"></a>block用copy修饰，delegate用weak修饰，枚举用assign修饰</h3><h3 id="MRC环境下："><a href="#MRC环境下：" class="headerlink" title="MRC环境下："></a>MRC环境下：</h3><p>(1)block引用局部变量<br>局部变量a:block代码块中使用局部变量,会自动拷贝一份到常量区,所以不可改变量<br>如果要修改局部变量，需要加__block修饰变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__block int number = 10;</span><br><span class="line">void (^myBlock)(void) = ^(void) &#123;</span><br><span class="line">number = 20;    //不用__block，则不能修改</span><br><span class="line">NSLog(@&quot;%d&quot;,number);;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p> (2)block中引用一个局部OC对象<br>该对象会被retain，如果局部变量使用__block修饰，则不会retain<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__block NSObject *obj = [[NSObject alloc]init];</span><br><span class="line">void (^myBlock)(void) = ^(void) &#123;</span><br><span class="line">NSLog(@&quot;%ld&quot;,obj.retainCount);  //不用__block，则为2</span><br><span class="line">&#125;;</span><br><span class="line">myBlock();</span><br></pre></td></tr></table></figure></p><p>(3)block中引用一个全局变量<br>在block代码块中使用全局变量或方法时,会将这个变量或方法所在的对象self引用计数加1,引起循环引用<br>解决方法:使用__block修饰self<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__block SecondViewController *weakSelf =self;</span><br></pre></td></tr></table></figure></p><h3 id="ARC环境下："><a href="#ARC环境下：" class="headerlink" title="ARC环境下："></a>ARC环境下：</h3><p>(1)在block中引用局部变量，同MRC需要<strong>block修饰<br>(2)在block中引用局部对象，不用加</strong>block<br>(3)在block中引用全局变量，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">_index = 1;</span><br><span class="line">__weak SecondViewController *weakThis = self;</span><br><span class="line">[btn addTapAction:^(UIButton *btn) &#123;</span><br><span class="line"></span><br><span class="line">//可修改值,但控制器不销毁,发生了循环引用</span><br><span class="line">//        _index = 2;</span><br><span class="line">//        NSLog(@&quot;index:%ld&quot;,_index);</span><br><span class="line"></span><br><span class="line">//属性</span><br><span class="line">__strong SecondViewController *strongThis = weakThis;</span><br><span class="line">strongThis-&gt;_index = 2;</span><br><span class="line">NSLog(@&quot;index:%ld&quot;,strongThis-&gt;_index);</span><br><span class="line"></span><br><span class="line">//方法</span><br><span class="line">//[weakThis test];</span><br><span class="line">[strongThis test];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><h3 id="weak与block区别"><a href="#weak与block区别" class="headerlink" title="weak与block区别"></a><strong>weak与</strong>block区别</h3><p>MRC，<strong>block 修饰，可以避免循环引用；ARC，</strong>block 修饰，同样会引起循环引用问题；<br><strong>block不管是ARC还是MRC模式下都可以使用，可以修饰对象，还可以修饰基本数据类型；</strong>weak只能在ARC模式下使用，也只能修饰对象，不能修饰基本数据类型；<br>(1)block下循环引用的问题<br><strong>block本身并不能避免循环引用，避免循环引用需要在block内部把</strong>block修饰的obj置为nil<br><strong>weak可以避免循环引用，但是其会导致外部对象释放了之后，block 内部也访问不到这个对象的问题，我们可以通过在 block 内部声明一个 </strong>strong<br>的变量来指向 weakObj，使外部对象既能在 block 内部保持住，又能避免循环引用的问题<br>(2)<strong>block与</strong>weak功能上的区别。<br><strong>block会持有该对象，即使超出了该对象的作用域，该对象还是会存在的，直到block对象从堆上销毁；而</strong>weak仅仅是将该对象赋值给weak对象，当该对象销毁时，weak对象将指向nil；<br><strong>block可以让block修改局部变量，而</strong>weak不能。<br>另外，MRC中<strong>block是不会引起retain；但在ARC中</strong>block则会引起retain。所以ARC中应该使用__weak。</p><p>参考：<a href="http://fuckingblocksyntax.com" target="_blank" rel="noopener">How Do I Declare A Block in Objective-C?</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> block </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS面试实战总结</title>
      <link href="/2017/06/30/iOS%E9%9D%A2%E8%AF%95%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93/"/>
      <url>/2017/06/30/iOS%E9%9D%A2%E8%AF%95%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="youxin"><a href="#youxin" class="headerlink" title="youxin"></a>youxin</h1><p>1.阐述一下 runtime,runloop，并举几个应用场景。<br>runtime:动态创建类和对象，进行消息发送和转发<br>runloop运行循环:<br>一.保持程序的持续运行。<br>二.处理App中的各类事件（触摸事件、定时器事件、Selector事件）<br>三.节省CPU资源，提高程序性能：没有事件时就进行睡眠状态<br>内部实现：do-while循环。</p><p>2.请列举你知道的设计模式。</p><p>3.请设计一个账号系统，需考虑持久化，登录态等。</p><p>4.请用代码或者伪代码打印输出一个菱形。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void print(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j;</span><br><span class="line">    for(i=1; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(j=1; j&lt;=n-i; j++)&#123; printf(&quot; &quot;); &#125;</span><br><span class="line">        for(j=n-i+1; j&lt;n+i; j++)&#123; printf(&quot;*&quot;); &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(i=n-1; i&gt;=1; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        for(j=1; j&lt;=(n-i); j++)&#123; printf(&quot; &quot;); &#125;</span><br><span class="line">        for(j=n-i+1; j&lt;n+i; j++)&#123; printf(&quot;*&quot;); &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>5.sdwebimage使用到了哪些缓存机制，缓存到什么路径下。<br>Memory 和 Disk 双重 Cache 机制。缓存到tmp的cache文件夹下，NSCachesDirectory。</p><p>6.是否使用或了解过swift，react native，优缺点是什么。</p><p>7.线上crash如何解决。<br>bug严重性分析：确定紧急版本更新，迭代版本中修复，热修复。<br>（1）如果是服务端返回的异常数据没做兼容，就由服务端确保格式正确，客户端看情况是否要做兼容；<br>（2）如果是升级版本后的由于本地数据库或本地存储的数据格式未兼容等问题，一般需要撤下版本重新提交；<br>（3）已经发布的版本集成过热修复模块，否则也要重新发布版本。</p><p>8.请写出你知道的排序算法及其复杂度。<br>（1）冒泡排序<br>（2）插入排序<br>（3）选择排序<br>（4）快速排序<br><img src="assets/demo/sort.png" alt="排序算法比较"><br><img src="assets/demo/sort_desc.png" alt="排序算法图解"></p><p>9.AutoreleasePool是如何实现的。</p><ul><li>AutoreleasePool（自动释放池）：是OC中的一种内存自动回收机制，它可以延迟加入AutoreleasePool中的变量release的时机。</li><li>AutoreleasePool与线程：每一个线程都会维护自己的 autoreleasepool 堆栈，每一个 autoreleasepool 只对应一个线程。Autorelease对象是在当前的runloop迭代结束时释放的。</li><li>autorelease何时释放：在没有使用@autoreleasepool的情况,autorelease对象是在当前的runloop迭代结束时释放。每个runloop中都会创建一个 autoreleasepool 并在runloop迭代结束进行释放。如果是手动创建autoreleasepool,自己创建Pool并释放</li><li>AutoreleasePool是如何实现的：通过声明一个<strong>AtAutoreleasePool类型的局部变量</strong>autoreleasepool实现了@autoreleasepool{}。一个线程的autoreleasepool就是一个指针栈，每个runloop迭代中都加入了自动释放池Push和Pop。</li></ul><p>10.ipa体积如何压缩。<br>（1）配置编译选项 （Levels选项内）Genetate Debug Symbols  设置为NO，这个配置选项应该会让你减去小半的体积。<br>（2）舍弃架构armv7，因为armv7用于支持4s和3gs<br>（3）编译的版本必须是发布版本<br>（4）资源：<br>1）图片：去掉无用的图片；用代码绘制简单的纯色图片；一些对图片要求高的用位图，其他的尽量用矢量图；如果不需要使用透明，可以用jpeg代替PNG<br>2）音视频：不增加编解码的前提下正确选择格式<br>3）文件：检查bundle中的无用文件，不要打包到app或者静态库中。可以点击文件，在右侧的file inspector里面的target membership中取消勾选；或者在build phase里面的Copy Bundle Resources中去掉。<br>4）代码：确定 dead code（代码被定义但从未被调用）被剥离，build setting 里 DEAD_CODE_STRIPPING = YES。 去掉冗余的代码，即使一点冗余代码，编译后体积也是很可观的。<br>5）第三方库：查找内部使用到的第三方库，一方面可以进行删减代码，用不到的类，直接删除，还有第三方库中的图片资源统统删除掉，如果能够自己手写实现的，那费功夫自己写吧<br>注意：把product 里面的文件 使用“显示包内容”方式，按照文件大小排序，查看打完包后具体是哪些图片占用太多的空间，并针对性地优化</p><h2 id="http网络请求过程"><a href="#http网络请求过程" class="headerlink" title="http网络请求过程"></a>http网络请求过程</h2><h2 id="对称加密与非对称加密"><a href="#对称加密与非对称加密" class="headerlink" title="对称加密与非对称加密"></a>对称加密与非对称加密</h2><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>对称加密：加密（encryption）与解密（decryption）使用的是同样的密钥（secret key）。加密和解密算法是公开的，秘钥必须严格保存，如果秘钥泄露，别人就能够用密文+秘钥还原成你的明文。<br>优点：算法公开、计算量小、加密速度快、加密效率高。<br>缺点：秘钥的管理和分发非常困难，不够安全。<br>比如：常见的DES/AES都是属于对称加密算法。</p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>非对称加密：需要两个密钥来进行加密和解密，这两个秘钥是公开密钥（简称公钥）和私有密钥（简称私钥），即常说的“公钥加密，私钥加密”或“私钥加密，公钥加密”。私钥只能由一方安全保管，不能外泄，而公钥则可以发给任何请求它的人。非对称加密使用这对密钥中的一个进行加密，而解密则需要另一个密钥。比如，你向银行请求公钥，银行将公钥发给你，你使用公钥对消息加密，那么只有私钥的持有人–银行才能对你的消息解密。与对称加密不同的是，银行不需要将私钥通过网络发送出去，因此安全性大大提高。<br>优点：安全性更高，公钥是公开的，秘钥是自己保存的，不需要将私钥给别人。<br>缺点：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。<br>比如：RSA就是最常用的非对称加密算法。</p><h1 id="momo"><a href="#momo" class="headerlink" title="momo"></a>momo</h1><h2 id="1-NSString-name，非ARC下重写setter-getter方法"><a href="#1-NSString-name，非ARC下重写setter-getter方法" class="headerlink" title="1.NSString *name，非ARC下重写setter,getter方法"></a>1.NSString *name，非ARC下重写setter,getter方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-(void)setName:(NSString *)name&#123;</span><br><span class="line">    if (_name != name) &#123;</span><br><span class="line">        [_name release];</span><br><span class="line">        _name = [name copy];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (NSString *)name&#123;</span><br><span class="line">    return [[_name retain]autorelease];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!--## 2.简述OC的内存管理模式，包括alloc,retain,copy,release,autorelease,dealloc这些方法的理解。--><h2 id="3-描述autorelease对象释放时机，简述autorelasepool的工作机制"><a href="#3-描述autorelease对象释放时机，简述autorelasepool的工作机制" class="headerlink" title="3.描述autorelease对象释放时机，简述autorelasepool的工作机制"></a>3.描述autorelease对象释放时机，简述autorelasepool的工作机制</h2><h2 id="4-在OC中如何判定两个对象完全相等"><a href="#4-在OC中如何判定两个对象完全相等" class="headerlink" title="4.在OC中如何判定两个对象完全相等"></a>4.在OC中如何判定两个对象完全相等</h2><p>[obj1 isEqual:obj2]</p><h2 id="5-以下作为button的响应方法会有什么问题，能看到log吗"><a href="#5-以下作为button的响应方法会有什么问题，能看到log吗" class="headerlink" title="5.以下作为button的响应方法会有什么问题，能看到log吗"></a>5.以下作为button的响应方法会有什么问题，能看到log吗</h2><ul><li>(void)clickButton{<br>  dispatch_sync(dispatch_get_main_queue(), ^{<br>  NSLog(“log”);<br>  });<br>}<br>线程阻塞，不能，主线程不能使用同步方法</li></ul><h2 id="6-在一个类中retain一个NSTimer类型的成员变量会有问题吗，为什么"><a href="#6-在一个类中retain一个NSTimer类型的成员变量会有问题吗，为什么" class="headerlink" title="6.在一个类中retain一个NSTimer类型的成员变量会有问题吗，为什么"></a>6.在一个类中retain一个NSTimer类型的成员变量会有问题吗，为什么</h2><p>有问题，会retain他的target，target指定为self，会循环引用</p><h2 id="7-简述C的函数调用和OC的消息传递的机制区别"><a href="#7-简述C的函数调用和OC的消息传递的机制区别" class="headerlink" title="7.简述C的函数调用和OC的消息传递的机制区别"></a>7.简述C的函数调用和OC的消息传递的机制区别</h2><p>C函数调用顺序执行<br>OC消息传递，异步执行</p><h2 id="8-OC中category的实现原理和runtime有关吗，什么联系"><a href="#8-OC中category的实现原理和runtime有关吗，什么联系" class="headerlink" title="8.OC中category的实现原理和runtime有关吗，什么联系"></a>8.OC中category的实现原理和runtime有关吗，什么联系</h2><p>有关，再对下的编译之后，运行期动态添加方法。</p><h2 id="9-NSOperationQueue和GCD有什么区别，实现机制有什么不同"><a href="#9-NSOperationQueue和GCD有什么区别，实现机制有什么不同" class="headerlink" title="9.NSOperationQueue和GCD有什么区别，实现机制有什么不同"></a>9.NSOperationQueue和GCD有什么区别，实现机制有什么不同</h2><p>GCD更简洁，底层C语言实现。</p><h2 id="10-列举在iOS开发中擅长的模块和其特点使用时的注意问题（例如：音频录制和播放，mapkit定位等）"><a href="#10-列举在iOS开发中擅长的模块和其特点使用时的注意问题（例如：音频录制和播放，mapkit定位等）" class="headerlink" title="10.列举在iOS开发中擅长的模块和其特点使用时的注意问题（例如：音频录制和播放，mapkit定位等）"></a>10.列举在iOS开发中擅长的模块和其特点使用时的注意问题（例如：音频录制和播放，mapkit定位等）</h2><p>mapkit：always/wheninuse background</p><h2 id="11-简述1-2个自己经常使用的第三方库和其优缺点"><a href="#11-简述1-2个自己经常使用的第三方库和其优缺点" class="headerlink" title="11.简述1.2个自己经常使用的第三方库和其优缺点"></a>11.简述1.2个自己经常使用的第三方库和其优缺点</h2><!--## atomic／lock--><h2 id="使用一种数据结构替代NSNotificationCenter"><a href="#使用一种数据结构替代NSNotificationCenter" class="headerlink" title="使用一种数据结构替代NSNotificationCenter"></a>使用一种数据结构替代NSNotificationCenter</h2><p>dictionary</p><h2 id="NSSet使用场景"><a href="#NSSet使用场景" class="headerlink" title="NSSet使用场景"></a>NSSet使用场景</h2><h1 id="zhihu"><a href="#zhihu" class="headerlink" title="zhihu"></a>zhihu</h1><h2 id="1-rebase"><a href="#1-rebase" class="headerlink" title="1.rebase"></a>1.rebase</h2><h2 id="2-私有库"><a href="#2-私有库" class="headerlink" title="2.私有库"></a>2.私有库</h2><h2 id="4-NSURL-NSURLSession-NSURLConnection-NSURL"><a href="#4-NSURL-NSURLSession-NSURLConnection-NSURL" class="headerlink" title="4.NSURL,NSURLSession,NSURLConnection,NSURL"></a>4.NSURL,NSURLSession,NSURLConnection,NSURL</h2><h1 id="xiaoyezi"><a href="#xiaoyezi" class="headerlink" title="xiaoyezi"></a>xiaoyezi</h1><h2 id="wkwebview交互过程造成内存泄漏"><a href="#wkwebview交互过程造成内存泄漏" class="headerlink" title="wkwebview交互过程造成内存泄漏"></a>wkwebview交互过程造成内存泄漏</h2><h2 id="Safari-怎么调试加载的h5，怎么控制手机页面调试"><a href="#Safari-怎么调试加载的h5，怎么控制手机页面调试" class="headerlink" title="Safari 怎么调试加载的h5，怎么控制手机页面调试"></a>Safari 怎么调试加载的h5，怎么控制手机页面调试</h2><ul><li>1.Safari设置-safari偏好设置-高级菜单-在菜单中显示“开发”菜单，选中复选框，这样就能看到开发菜单了</li><li>2.iPhone设置-safari-高级-打开“javascript”开关和web检查器开关</li><li>3.iPhone接上Mac，运行手机app里的web页面，在开发菜单中选择连接的手机，找到调试的网页，就能在Safari里面调试了，可以打断点，查看cookie，打印cookie或元素，添加alert</li></ul><h2 id="IM消息状态提醒，比如正在输入之类的"><a href="#IM消息状态提醒，比如正在输入之类的" class="headerlink" title="IM消息状态提醒，比如正在输入之类的"></a>IM消息状态提醒，比如正在输入之类的</h2><h2 id="n个台阶，一次走一步或者两步，有多少种走法"><a href="#n个台阶，一次走一步或者两步，有多少种走法" class="headerlink" title="n个台阶，一次走一步或者两步，有多少种走法"></a>n个台阶，一次走一步或者两步，有多少种走法</h2><h2 id="git回退"><a href="#git回退" class="headerlink" title="git回退"></a>git回退</h2><h2 id="view从创建到展示出来都会经历哪些过程"><a href="#view从创建到展示出来都会经历哪些过程" class="headerlink" title="view从创建到展示出来都会经历哪些过程"></a>view从创建到展示出来都会经历哪些过程</h2><p>loadView创建：<br>(1)[super loadView]<br>    1)指定了与控制器相关联的xib文件，通过xib文件创建控制器的view<br>    2)没有明显地传xib文件名，加载与控制器同名的xib文件<br>    3)没有找到相关联的xib文件，创建一个空白的UIView，赋值给控制器的view<br>(2)在loadView方法中，通过代码创建view，不需要调用[super loadView]<br>过程：loadView-&gt;viewDidLoad-&gt;viewWillAppear-&gt;viewWillLayoutSubviews-&gt;viewDidLayoutSubviews-&gt;viewDidAppear-&gt;viewWillDisappear-&gt;viewDidDisappear-&gt;viewDidUnLoad</p><h1 id="dongao"><a href="#dongao" class="headerlink" title="dongao"></a>dongao</h1><!--1.strong，retain，copy，assign，weak，unsafe_unretained--><p>2.远程推送<br><!--3.copy，nsmutablearray--><br>4.layoutsubviews什么时候调用<br>5.内存空间<br>6.内存优化<br>7.创建一个对象过程<br>8.define，const区别<br>9.五张图片合成一张，异步下载<br>10.OC动态语言理解</p><h1 id="高德"><a href="#高德" class="headerlink" title="高德"></a>高德</h1><!--* reatin copy 属性 代码--><ul><li><p>通知 主/子线程</p></li><li><p>setValue/setObject   forKey/forKeyPath 字典 </p></li><li><p>CGRect id NSValue</p></li><li><p>ABC排序</p></li><li><p>nil、Nil、NULL、NSNull<br>nil：定义一个实例为空，指向一个OC对象的空指针，而且我们对于nil的调用方法，是不会产生crash或者抛出异常。<br>NULL：nil是一个对象，而NULL只是一个空值而已。<br>Nil：定义一个空的类，指向一个类的空指针。<br>NSNull：通常标识集合中的空值，定义了一个单例对象用于表示集合对象的空值。集合对象无法包含nil 用来作为其具体的值，譬如NSArray.NSSet和NSDictionary.相应的，nil值用一个特定的对象NSNulll来表示。NSNull只是提供了一个单一实例用力表示对象属性中的nil值。在默认的实现方法中，dictionaryWithValuesForKeys:和setValuesForKeysWith:自动地奖NSNull和nil相互转换，因此我们设置的对象不需要进行NSNulld的测试操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSURL *url = nil;</span><br><span class="line">Class cls = Nil;</span><br><span class="line">int *pointerInt = NULL;</span><br><span class="line">NSArray *arr = [NSArray arrayWithObjects:[[NSObject alloc]init],[NSNull null],[[NSObject alloc]init],[[NSObject alloc]init],nil,nil];</span><br><span class="line">NSLog(@&quot;%@--%ld&quot;,arr,arr.count);</span><br><span class="line">//打印结果</span><br><span class="line">(</span><br><span class="line">&quot;&lt;NSObject: 0x600001de85c0&gt;&quot;,</span><br><span class="line">&quot;&lt;null&gt;&quot;,</span><br><span class="line">&quot;&lt;NSObject: 0x600001de8570&gt;&quot;,</span><br><span class="line">&quot;&lt;NSObject: 0x600001de85f0&gt;&quot;</span><br><span class="line">)--4</span><br></pre></td></tr></table></figure></li><li><p>uibutton hitTest</p></li><li><p>GCD</p></li><li><p>TableView优化</p></li><li><p>block 3种</p></li><li><p>tableView 实现滚动完成加载数据</p></li><li><p>msgSend 消息发送</p></li><li><p>runloop timer</p></li><li><p>OC 高效</p></li></ul><h1 id="sougou"><a href="#sougou" class="headerlink" title="sougou"></a>sougou</h1><p>第一部分：选择题（有多选）<br>1.在OC中类接口声明的关键字为：（ D ）<br>A、@import<br>B、@interface<br>C、@implementation<br>D、@protocal<br>2.不会立刻使引用计数器改变的是（ C ）<br>A、release<br>B、alloc<br>C、autorelease<br>D、retain<br>3.下属代码打印的结果是：（ C ）<br>NSString <em>name = [[NSString alloc]initWithString:@”张三”];<br>NSLog(@”%ld”,[name retainCount]);<br>A、-1<br>B、0<br>C、1<br>D、2<br>4.控制台打印的最后一条信息会是：（ A ）<br>NSDictionary </em>dict = [NSDictionary dictionaryWithObject:@”v” forKey:@”k”];<br>NSLog(@”%@”,[dict objectForKey:@”k”]);<br>[dict release];<br>A、v<br>B、k:v<br>C、崩溃信息<br>D、v:k<br>5.以下说法正确的是：（ B ）<br>A、nonatomic：提供多线程保护，提高性能，在没有使用多线程的编程中可以选择使用<br>B、assign：属性默认值，说明设置器直接进行赋值，针对基础数据类型（NSInteger,CGFloat）和C数据类型（int,float,double,char）等。<br>C、retain：此属性只用于obj-c的对象类型，对参数进行release 旧值，再retain 新值。<br>D、copy：此属性只对实现NSCoping 协议的对象有效（NSString）,拷贝工作由copy方法执行<br>6.下面代码对字符串str进行拼接后，2次打印的地址是否相同：（ A ）<br>NSMutableString *str = [[NSMutableString alloc]initWithFormat:@”123”];<br>NSLog(@”str = %p”,str);<br>[str appendFormat:@”456”];<br>NSLog(@”str = %p”,str);<br>A、相同<br>B、不同<br>C、随机打印<br>D、有时相同，有时不同<br>7.以下说法正确的是：（ B ）<br>A、OC不用”函数调用”，而用互相传递讯息<br>B、OC一个完整的类分为interface和implemention两块<br>C、OC对象使用new分配内存，用delete释放<br>D、OC协议分为非正式协议和正式协议<br>8.OC中包含一个自定义的头文件应该使用：（ C ）<br>A、#include “”<br>B、#include &lt;&gt;<br>C、#import “”<br>D、import &lt;&gt;<br>9.OC中的委托最好声明成：（ B ）<br>A、retain<br>B、assign<br>C、copy<br>D、readonly<br>10.创建对象时，对象的内存和指向对象的指针分别分配在哪里：（ A ）<br>A、堆区，栈区<br>B、常量区，堆区<br>C、全局区，栈区<br>D、栈区，堆区<br>11.关于KVC的描述错误的是:（ A ）<br>A、KVC 是指 “Key-Value Observing”<br>B、是一种间接访问对象属性的机制<br>C、只能访问对象的属性<br>D、当对象的属性值改变时，我们能收到一个通知<br>12.以下说法正确的是:（ C ）<br>A、求数组的内容的个数用length方法<br>B、字典时根据其位置来索引数据的<br>C、协议中定义的方法默认是必须实现的<br>D、定义类目必须要拿到自己类的源代码<br>13.内存管理的关键字描述错误的是:（ D ）<br>A、retainCount是指对象的引用计数<br>B、retain关键字可以增大对象的引用计数<br>C、release可以减小对象的引用计数，但autorelease不可以<br>D、dealloc方法不能直接调用<br>14.下面描述正确的选项是:（ B ）<br>A、当计数器为1时，dealloc方法由系统自动调用<br>B、一个对象在引用计数变为0时，会调用自己的dealloc<br>C、在dealloc方法里，应该在[super dealloc]后释放本类所拥有的对象<br>D、开启ARC后，可以重载dealloc，必须在dealloc里写[super dealloc]方法<br>15.下面哪个选项是正确的（ B ）<br>A、用继承可以扩展一个类，要调用扩展的方法，既可以用父类，也可以用子类<br>B、用类目可以扩展一个类，可以直接用该类或该类的实例对象，去调用该类目扩展的方法<br>C、延展就是类目<br>D、可以在一个类的外部，调用这个类延展的方法</p><p>第二部分：问答题（至少答四题）<br>1.在iOS中实现回调一般有哪几种方法<br>block,delegate<br>2.OC中实现多线程有哪几种方式<br>NSThread,pthread,NSOperation+NSOperationQueue,GCD<br>3.NSMutableDictionary 中的 setObject:forKey 和 setValue:forKey 有什么区别</p><p>4.weak 和 assign 有什么区别</p><p>5.initWithCoder 和 initWithFrame 有什么区别</p><p>6.NSView 的 frame、bounds 和 center 有什么区别<br>frame：相对于父视图<br>bounds：相对于自身<br>center：中心店<br>7.awakeFromNib,initWithCoder,viewDidLoad 的调用顺序和调用时间</p><p>第三部分：编程题<br>1.编程实现字符串拷贝（考虑内存重叠）<br>char <em>strcpy(char </em>src,char *dst);</p><p>2.利用分类给NSString 扩展三个方法：<br>（1）字符串翻转（比如：@”123”，调用方法后，返回@”321”）<br>（2）计算英文字母的个数（比如：@”123abc456”，调用方法后，返回@”3”）<br>（3）去除字符串两端的空格（比如：@”123 456”，调用方法后，返回@”123456”）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@interface NSString(LPY)</span><br><span class="line"></span><br><span class="line">+ (NSString *)stringWithReverse:(NSString *)rString;</span><br><span class="line">- (NSString *)initWithReverse;</span><br><span class="line"></span><br><span class="line">+ (NSString *)stringWithCharacterLength:(NSString *)lString;</span><br><span class="line">- (NSString *)initWithCharacterLength;</span><br><span class="line"></span><br><span class="line">+ (NSString *)stringWithTrim:(NSString *)tString;</span><br><span class="line">- (NSString *)initWithTrim;</span><br><span class="line"></span><br><span class="line">@END</span><br></pre></td></tr></table></figure></p><h1 id="未知"><a href="#未知" class="headerlink" title="未知"></a>未知</h1><p>第一部分：swift技术<br>1.struct Tutorial{<br>var difficulty: Int = 1<br>}<br>var tutorial1 = Tutorial()<br>var tutorial2 = tutorial1<br>tutorial2.difficulty = 2<br>请说明：tutorial1.difficulty和tutoria2.difficulty 的值分别是多少<br>如果Tutorial是一个类会有什么不同，说明原因<br>1.2 2.2 结构体值拷贝，类指针拷贝<br>2.下面code是把数组按字母顺序进行排序，看起来有些复杂，你能用闭包代码简化它吗<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let sortedAnimals = animals.sort&#123;(one: String,two: String) -&gt; Bool in</span><br><span class="line">return one&lt;two</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>sort{&lt;} sort{$0&lt;$1}<br>3.下面代码能否编译通过<br>public struct ThermometerStruct {<br>    private(set) var temperature: Double = 0.0<br>    public mutating func registerTemperature(temperature: Double){<br>        self.temperature = temperature<br>    }<br>}<br>let thermometerStruct = ThermometerStruct()<br>thermometerStruct.registerTemperature(56.0)<br>4.下面代码打印输出是什么？为什么？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var thing = &quot;cars&quot;</span><br><span class="line">let closure = &#123;(thing) in</span><br><span class="line">print(&quot;I love \(thing)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">thing = &quot;airplane&quot;</span><br></pre></td></tr></table></figure></p><p>I love airplane<br>5.下面代码会出什么错误，如何修复<br>struct Kitten{</p><p>}<br>func showKitten(kitten: Kitten?){<br>    guard let k = kitten else {<br>        print (“there is no kitten”)<br>    }<br>    print(k)<br>}<br>6.什么是optional类型，它是用来解决什么问题的，对一个optional变量拆包有多少种方法<br>7.swift中枚举类型中，row values 和associated values有什么区别<br>8.下面代码中，x时什么类型，值是什么<br>let d = [“john”:23,”james”:24,”vincent”:34,”louis”:29]<br>let x = d.sort{$0.1&lt;$1.1}.map{$0.0}</p><p>第二部分：iOS技术<br>1.view 类中，bounds和frame有什么区别<br>2.描述viewcontroller的生命周期事件顺序<br>3.描述iOS APP 应用程序声明周期状态<br>4.列举比较重要的application delegate methods<br>5.iOS中如何进行并发编程开发，请描述各种方式的使用方式和优缺点</p><p>第三部分：编程<br>1.给Array写一个扩展方法，查一下Array中不相同元素的个数（注意需要泛型类型支持，且类型遵循comparable协议），如：[1,2,3].countUniques() //输出结果：3</p><p>第四部分：逻辑题</p><h1 id="zaiyoudao"><a href="#zaiyoudao" class="headerlink" title="zaiyoudao"></a>zaiyoudao</h1><p>1.id 声明的属性有什么特性<br>2.@public,@protect,@private 它们的含义与作用<br>3.深复制和浅复制的区别<br>4.NSArray 和NSMutableArray 的区别<br>6.在iPhone应用中如何保存数据<br>7.view和view之间传值方式<br>8.请简单介绍下APNS发送系统消息的机制<br>9.<strong>block和</strong>weak 修饰符的区别<br>10.define和const常量的区别<br>19.描述下SDWebimage中给UIImageView加载图片的逻辑。</p><h1 id="buchang"><a href="#buchang" class="headerlink" title="buchang"></a>buchang</h1><p>1.iOS设计模式是什么，你知道哪些设计模式，并简要叙述<br>2.#import 和#include 有什么区别，@class呢，#import&lt;&gt;和#import()有什么区别<br>3.category（类别）、extension（扩展）和继承的区别<br>4.什么事KVC和KVO<br>5.ViewController生命周期<br>6.进程和线程的区别，同步异步的区别，并行和并发的区别<br>7.什么时候报 unrecognize selector 错误，iOS有哪些机制来避免走到这一步<br>8.runloop 是来做什么的，runloop 和线程有什么关系，主线程默认开启了runloop吗，子线程呢<br>9.类方法和实例方法有什么区别<br>10.isKindOfClass,isMemberOfClass selector 作用分别是什么<br>11.gGCD和NSOperation 的区别<br>12.Runtime 实现的机制是什么，怎么用，一般用于干嘛<br>13.什么是 method swizzling<br>14.假定输入的字符串中只包含字母和<em>号，编写函数fun，功能是：除了中间和尾部的</em>外，将字符串中其他<em>全部删除。编写时，不用C的其他函数。例：<em>**</em></em>A<em>BC</em>DEF<em>G<em>**</em>，结果为：A</em>BC<em>DEF</em>G<em>**</em></p><h1 id="feienlaisi"><a href="#feienlaisi" class="headerlink" title="feienlaisi"></a>feienlaisi</h1><p>1.NSObject 中 description 属性的意义，它可以重写吗<br>2.懒加载（延时加载）<br>3.UIView和CALayer的区别<br>4.优化UITablebView的性能（比如含有正在加载的网络图片不会卡）<br>5.cocoapods<br>7.进程间的通信方式<br>8.static 的作用<br>9.线程的状态<br>10.AFNetworking 的底层实现<br>11.nil,Nil,NULL,NSNull<br>12.简述 NotificationCenter,KVC,KVO,delegate，并说明它们之间的区别<br>13.drawRect 和 layoutsubviews 的区别<br>14.controllerA调用controllerB后，如何在B中对A进行一些代码操作，请用block和delegate分别实现</p><h1 id="yige"><a href="#yige" class="headerlink" title="yige"></a>yige</h1><p>1.请写一个单例的实现<br>2.简单描述一个MVC,MVP,MVVM的优缺点<br>3.常用的多线程有哪几种，以及使用场景<br>4.简单写出VC的生命周期（执行的方法及顺序）<br><!--5.@property的本质是什么，有哪些属性关键字和关键字的使用情况。--></p><h1 id="fz-apb"><a href="#fz-apb" class="headerlink" title="fz apb"></a>fz apb</h1><p>1.描述一个MVC模式和MVVM模式等具体应用场景和如何应用，以及两种模式的最根本区别</p><h1 id="zili（swift）"><a href="#zili（swift）" class="headerlink" title="zili（swift）"></a>zili（swift）</h1><p>1.用var 声明view1和用let声明view2，在下面的例子中有什么不同，能否编译通过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">var view1 = UIView()</span><br><span class="line">view1.alpha = 0.5</span><br><span class="line">let view2 = UIView()</span><br><span class="line">view2.alpha = 0.5 //will this line compile</span><br></pre></td></tr></table></figure></p><!--3.属性关键字 readwrite，readionly，assign，retain，copy，nonatomic 各有什么作用，在哪种情况下用--><p>4.你是否接触过OC中的反射机制，简单聊一下概念和使用<br>5.开发项目中你怎么检查内存泄露<br>6.下面的代码输出什么<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@implementation Son: Father</span><br><span class="line">- (id)init&#123;</span><br><span class="line">    if(self = [super init])&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,NSStringFromClass([self class]));//Son</span><br><span class="line">    NSLog(@&quot;%@&quot;,NSStringFromClass([super class]));//Son</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>答：结果self和super都是指向当前实例的。不同的是，[self class]会在当前类的方法列表中去找class这个方法，[super class]会直接开始在当前类的父类中去找calss这个方法，两者在找不到的时候，都会继续向祖先类查询class方法，最终到NSObject类。那么问题来了，由于我们在Father和Son中都没有去重写class这个方法，最终自然都会去执行NSObject中的class方法，结果也自然应该是一样的。至于为什么是Son，我们可以看看NSObject中class的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(Class)class &#123; </span><br><span class="line">return object_getClass(self); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这就说的通了，返回的都是self的类型，self此处正好就是Son，因此结果就会输出Son。<br>9.swift2.0引用了一个新关键字能产生递归枚举类型，下面是一个带有Node节点的枚举类型，Node关联值类型，T和List：<br>enum List<t>{<br>    case Node(T,List<t>)<br>}<br>10.swift中struct和class有什么区别，举个应用中的实例<br>class可以继承 值拷贝/指针拷贝<br>12.OC的类可以多重继承吗，可以实现多个接口吗，category 是什么，重写一个类的方式用继承好还是分类好，为什么<br><!--13.什么情况使用weak关键字，相比assign有什么不同--><br>14.设计模式是什么，你知道哪些设计模式，并简要叙述<br>15.MVC和MVVM的区别</t></t></p><h1 id="other"><a href="#other" class="headerlink" title="other"></a>other</h1><ul><li><p>热修复<br>JSPatch ReactNative Lua+Wax</p></li><li><p>列举自己的优点和缺点</p></li></ul><p>参考文章：<a href="https://www.cnblogs.com/dianming/p/6902442.html" target="_blank" rel="noopener">iOS之Safari调试webView/H5页面</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS直播学习笔记</title>
      <link href="/2017/06/29/iOS%E7%9B%B4%E6%92%AD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/06/29/iOS%E7%9B%B4%E6%92%AD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="推流"><a href="#推流" class="headerlink" title="推流"></a>推流</h2><p>//LFLiveKit,librtmp</p><a id="more"></a><p>1.安装Homebrew<br>查看是否已经安装了Homebrew<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man brew</span><br></pre></td></tr></table></figure></p><p>安装Homebrew<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure></p><p>2.安装nginx<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//从github下载Nginx到本地,增加home-brew对nginx的扩展</span><br><span class="line">brew tap homebrew/nginx</span><br><span class="line"></span><br><span class="line">//安装Nginx服务器和rtmp模块</span><br><span class="line">brew install nginx-full --with-rtmp-module</span><br><span class="line"></span><br><span class="line">查看是否安装成功</span><br><span class="line">nginx</span><br></pre></td></tr></table></figure></p><p>在浏览器地址栏输入：<code>http://localhost:8080</code><br>如果出现<code>Welcome to nginx!</code>，则表示安装成功</p><p>3.配置rtmp<br>查看nginx配置文件安装在哪<br>brew info nginx-full</p><p>前往<code>/usr/local/etc/nginx/nginx.conf</code>，在最后添加以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rtmp &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 1990;</span><br><span class="line">        application liveApp &#123;</span><br><span class="line">            live on;</span><br><span class="line">            record off;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重新加载nginx的配置文件<br>nginx -s reload</p><p>4.安装ffmpeg进行推流<br>brew install ffmpeg</p><p>5.使用ffmepg推流测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -i (视频全路径) -vcodec copy -f flv (rtmp路径)</span><br><span class="line">ffmpeg -re -i /Users/xxx/Downloads/4.mp4 -vcodec copy -f flv rtmp://localhost:1990/liveApp/room</span><br></pre></td></tr></table></figure></p><p>出现错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[tcp @ 0x7ffd66e08440] Connection to tcp://localhost:1990 failed (Connection refused), trying next address</span><br><span class="line">[flv @ 0x7ffd68005400] FLV does not support sample rate 48000, choose from (44100, 22050, 11025)</span><br><span class="line">[flv @ 0x7ffd68005400] Audio codec mp3 not compatible with flv</span><br><span class="line">Could not write header for output file #0 (incorrect codec parameters ?): Function not implemented</span><br></pre></td></tr></table></figure></p><p>原因：flv格式不支持音频码率为48000的，只支持44100，22050，11025的，你得找一个音频码率为这三个中的其中一个的视频或者利用ffmpeg修改音频的码率</p><p>6.使用VLC播放rtmp推流<br>VLC</p><p>7.用ffmpeg抓取桌面以及摄像头推流进行直播<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//查看ffmpeg是否支持对应的设备</span><br><span class="line">ffmpeg -f avfoundation -list_devices true -i &quot;&quot;</span><br><span class="line">//抓取桌面和摄像头进行推流</span><br><span class="line">ffmpeg -f avfoundation -framerate 30 -i &quot;1:0&quot; -f avfoundation -framerate 30 -video_size 640x480 -i &quot;0&quot; -c:v libx264 -preset slow -filter_complex &apos;overlay=main_w-overlay_w-10:main_h-overlay_h-10&apos; -acodec libmp3lame -ar 44100 -ac 1  -f flv rtmp://localhost:1990/liveApp/room</span><br></pre></td></tr></table></figure></p><h2 id="搭建WEB服务器"><a href="#搭建WEB服务器" class="headerlink" title="搭建WEB服务器"></a>搭建WEB服务器</h2><p>1.安装node.js,NPM<br>2.利用NPM下载第三方模块（Express和Socket.IO）<br>创建package.json:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line">&quot;express&quot;: &quot;^4.14.0&quot;,</span><br><span class="line">&quot;socket.io&quot;: &quot;^1.4.8&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行<code>npm install</code></p><p>3.http服务器搭建<br>创建xxx.js文件，然后执行<code>node xxx.js</code>即可<br>`<br>// require<br>// 加载http模块<br>var http = require(‘http’);</p><p>// 创建http服务器<br>var server = http.createServer(function(request,response){<br>// response.write(‘Hello world’);<br>// response.end();<br>});</p><p>// 监听服务器<br>server.listen(8080,’192.168.0.101’);</p><p>console.log(‘监听8080’);<br>`</p><p>4.express框架<br>Express框架建立在node.js内置的http模块上，可以快速地搭建一个Web服务器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 引入express模块</span><br><span class="line">var express = require(&apos;express&apos;);</span><br><span class="line"></span><br><span class="line">// 创建express服务器，创建服务器没有对访问服务器进行处理</span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">// 监听get请求，请求根目录，输出Hello world</span><br><span class="line">app.get(&apos;/&apos;,function(request,response)&#123;</span><br><span class="line">response.send(&apos;Hello world&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.post(&apos;/&apos;,function(request,response)&#123;</span><br><span class="line">response.send(&apos;Hello world&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(8080,&quot;192.168.0.101&quot;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;监听8080&quot;);</span><br></pre></td></tr></table></figure></p><p>5.上传下载服务器搭建</p><h2 id="搭建socket即时通讯服务器"><a href="#搭建socket即时通讯服务器" class="headerlink" title="搭建socket即时通讯服务器"></a>搭建socket即时通讯服务器</h2><p>1.WebSocket<br>WebSocket：服务器和 客户端 都能主动的向对方发送或接收数据<br>websocket协议头:ws<br>Socket.IO:是一个完全由JavaScript实现、基于Node.js、支持WebSocket的协议用于实时通信、跨平台的开源框架。<br>2.导入Socket.IO<br>3.创建socket</p><ul><li>（1）面向express框架开发，加载express框架，方便处理get,post请求</li><li>（2）因为socket依赖http,创建http服务器，使用http模块.</li><li>（3）可以通过express创建http服务器http.server(express)</li><li>（4）通过http服务器创建socket</li><li>（5）监听http服务器<br>4.建立socket连接<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 监听socket连接</span><br><span class="line">// function参数必填socket</span><br><span class="line">socket.on(&apos;connection&apos;,function(clientSocket)&#123;</span><br><span class="line">console.log(&apos;建立连接&apos;,clientSocket);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>5.SocketIO发送事件</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 直播 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS获取定位授权</title>
      <link href="/2017/06/28/iOS%E8%8E%B7%E5%8F%96%E5%AE%9A%E4%BD%8D%E6%8E%88%E6%9D%83/"/>
      <url>/2017/06/28/iOS%E8%8E%B7%E5%8F%96%E5%AE%9A%E4%BD%8D%E6%8E%88%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<p>手动调用CLLocationManager对象的requestAlwaysAuthorization方法，会弹出定位授权提示弹框。调用该方法需要在Info.plist中设置NSLocationAlwaysUsageDescription的值，这个值会显示在系统提示框中。 </p><ul><li>仅执行 requestWhenInUseAuthorization，弹框中提示信息：允许”XXX”在您使用该应用时访问您的位置吗？，并且只有允许或不允许选择项。执行requestAlwaysAuthorization或同时requestWhenInUseAuthorization 弹框中提示信息：允许”XXX”访问您的位置？，并且这时会有三个选择项：仅在使用应用期间，始终允许，不允许。</li><li><p>注意：CLLocationManager的实例需要设置为全局变量，否则定位授权提示弹框会出现一闪而过的问题。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if ([CLLocationManager locationServicesEnabled]) &#123;</span><br><span class="line">    // 创建位置管理者对象</span><br><span class="line">    self.lcManager = [[CLLocationManager alloc] init];</span><br><span class="line">    self.lcManager.delegate = self; // 设置代理</span><br><span class="line">    // 设置定位距离过滤参数 (当本次定位和上次定位之间的距离大于或等于这个值时，调用代理方法)</span><br><span class="line">    self.lcManager.distanceFilter = 100;</span><br><span class="line">    self.lcManager.desiredAccuracy = kCLLocationAccuracyBest; // 设置定位精度(精度越高越耗电)</span><br><span class="line">    [self.lcManager requestAlwaysAuthorization];</span><br><span class="line">    [self.lcManager requestWhenInUseAuthorization];</span><br><span class="line">    [self.lcManager startUpdatingLocation]; // 开始更新位置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代理方法监听状态变化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">-(void)locationManager:(CLLocationManager *)manager didChangeAuthorizationStatus:(CLAuthorizationStatus)status&#123;</span><br><span class="line"></span><br><span class="line">    switch (status) &#123;</span><br><span class="line">    case kCLAuthorizationStatusNotDetermined:</span><br><span class="line">    &#123;</span><br><span class="line">        NSLog(@&quot;用户还未决定授权&quot;);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    case kCLAuthorizationStatusRestricted:</span><br><span class="line">    &#123;</span><br><span class="line">        NSLog(@&quot;访问受限&quot;);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    case kCLAuthorizationStatusDenied:</span><br><span class="line">    &#123;</span><br><span class="line">        // 类方法，判断是否开启定位服务</span><br><span class="line">        if ([CLLocationManager locationServicesEnabled]) &#123;</span><br><span class="line">            NSLog(@&quot;定位服务开启，被拒绝&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            NSLog(@&quot;定位服务关闭，不可用&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    case kCLAuthorizationStatusAuthorizedAlways:</span><br><span class="line">    &#123;</span><br><span class="line">        NSLog(@&quot;获得前后台授权&quot;);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    case kCLAuthorizationStatusAuthorizedWhenInUse:</span><br><span class="line">    &#123;</span><br><span class="line">        NSLog(@&quot;获得前台授权&quot;);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    default:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>ReactNative使用学习笔记</title>
      <link href="/2017/06/21/ReactNative%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/06/21/ReactNative%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="直接通过ReactNative方式创建项目"><a href="#直接通过ReactNative方式创建项目" class="headerlink" title="直接通过ReactNative方式创建项目"></a>直接通过ReactNative方式创建项目</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>必须安装：Xcode，Homebrew，node,npm<br>npm其实是Node.js的包管理工具,已经在Node.js安装的时候顺带装好了。<br>可选：React Native的命令行工具,IDE(Atom/Nuclide/Webstorm/Sublime),watchman,Flow<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//brew</span><br><span class="line">ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br><span class="line">brew -v</span><br><span class="line">//node</span><br><span class="line">brew install node</span><br><span class="line">//React Native的命令行工具</span><br><span class="line">npm install -g react-native-cli</span><br><span class="line">//watchman</span><br><span class="line">brew install watchman</span><br><span class="line">//flow</span><br><span class="line">brew install flow</span><br><span class="line">//yarn全局安装</span><br><span class="line">npm install -g yarn</span><br></pre></td></tr></table></figure></p><ul><li>如果安装brew时报错：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xcode-select: error: invalid developer directory &apos;/Library/Developer/CommandLineTools&apos;</span><br><span class="line">Failed during: /usr/bin/sudo /usr/bin/xcode-select --switch /Library/Developer/CommandLineTools</span><br></pre></td></tr></table></figure></li></ul><p>解决：<br>如果<code>/Library/Developer/CommandLineTools</code> 路径不存在，需要手动安装 Command Line Tools：<code>XCode --&gt; Open Developer Tool --&gt; More Developer tools</code> 下载安装系统对应版本的  Command Line Tools 即可。</p><p>否则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ xcodebuild</span><br><span class="line">xcodebuild: error: The directory /Users/jzg does not contain an Xcode project.</span><br><span class="line">xcode-select --install</span><br><span class="line">$ xcode-select -p</span><br><span class="line">/Applications/Xcode.app/Contents/Developer</span><br><span class="line">//xcode的命令行工具不再安装在 /Library/Developer/CommandLineTools 这个位置了，需要重新设置一下路径: </span><br><span class="line">$ sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer</span><br><span class="line">//最后再输入命令这个验证一下： </span><br><span class="line">$ xcode-select -p</span><br><span class="line">//重新执行brew安装命令</span><br></pre></td></tr></table></figure></p><ul><li>brew update 或者 brew install … 时出现卡在updating状态问题，解决：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//先卸载已安装的homebrew</span><br><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot;</span><br><span class="line">//然后重新安装</span><br><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br><span class="line">//通过该方法直接获取最新的homebrew执行安装其他插件等操作即可。</span><br></pre></td></tr></table></figure></li></ul><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ react-native init RNDemo</span><br></pre></td></tr></table></figure><h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><ul><li>启功服务器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm run start </span><br><span class="line">//或者</span><br><span class="line">yarn start</span><br></pre></td></tr></table></figure></li></ul><p>1.使用命令行或Xcode<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ react-native run-ios</span><br><span class="line">$ react-native run-android</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">React packager ready.</span><br><span class="line">Loading dependency graph, done.</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><ul><li>run-ios指定模拟器<br>1.react-native run-ios –simulator “iPhone 7”<br>2.敲过一次就之后就可以直接react-native run-ios了</li></ul><p>运行项目时如果遇到<code>&lt;React/RCTBundleURLProvider.h&gt;” file not found</code>问题，可按如下方法试着解决：</p><ul><li>把项目里面的 node_modules 文件夹删除掉</li><li>npm install</li><li>react-native upgrade</li><li>clean,run</li></ul><p>2.在Xcode中运行原生iOS项目（对于Android则是在Android Studio中运行原生Android项目），然后在对应的React Native根目录下运行npm start(开启nodejs服务，开启JS Server)。</p><h3 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h3><p>运行 <code>react-native run-android</code> 时如果提示缺少JDK，同时在终端运行<code>java -version</code>获取不到JAVA版本，则需要安装JDK。<br>1.访问<a href="http://www.oracle.com" target="_blank" rel="noopener">http://www.oracle.com</a> ，底部点击<code>Java for Developers</code>，JDK DOWNLOAD，根据环境选择安装包下载，根据提示完成安装。<br>3.配置JDK的环境变量。<code>/Library/Java/JavaVirtualMachines/jdk-x.x.x.jdk/Contents/Home</code> (注意版本号)是该JDK的根目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi .bash_profile</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk-x.x.x.jdk/Contents/Home</span><br><span class="line">PATH=$JAVA_HOME/bin:$PATH:.</span><br><span class="line">CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:.</span><br><span class="line">export JAVA_HOME</span><br><span class="line">export PATH</span><br><span class="line">export CLASSPATH</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source .bash_profile</span><br></pre></td></tr></table></figure><p>再次运行 <code>java -version</code> 应该就能获取到版本了。<br>如果报错 <code>Could not determine java version from &#39;x.x.x&#39;</code>，需要执行以下命令或直接到上面的安装目录删除 jdk，安装低版本即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf /Library/Java/JavaVirtualMachines/jdk-x.x.x.jdk</span><br></pre></td></tr></table></figure></p><h1 id="RN与原生项目"><a href="#RN与原生项目" class="headerlink" title="RN与原生项目"></a>RN与原生项目</h1><h2 id="先创建iOS项目，再集成React-Native到原生项目"><a href="#先创建iOS项目，再集成React-Native到原生项目" class="headerlink" title="先创建iOS项目，再集成React Native到原生项目"></a>先创建iOS项目，再集成React Native到原生项目</h2><p>(1) 先通过Xcode创建项目<br>(2) 将iOS原生项目代码放到ios文件夹中，ios文件夹与package.json、index.ios.js放在根目录下。<br>在根目录创建一个package.json文件，用于初始化react-native.<br>package.json内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;name&quot;: &quot;RNDemo&quot;,</span><br><span class="line">&quot;version&quot;: &quot;0.0.1&quot;,</span><br><span class="line">&quot;private&quot;: true,</span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">&quot;start&quot;: &quot;node node_modules/react-native/local-cli/cli.js start&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line">&quot;react&quot;: &quot;15.4.1&quot;,</span><br><span class="line">&quot;react-native&quot;: &quot;0.39.2&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>dependencies中的react和react-native的版本取决于你的具体需求。一般来说我们推荐使用最新版本。你可以使用<code>npm info react</code>和<code>npm info react-native</code>来查看当前的最新版本。另外，react-native对react的版本有严格要求，高于或低于某个范围都不可以。可以先尝试执行<code>npm install</code>，然后注意观察安装过程中的报错信息，例如<code>require react@某.某.某版本, but none was installed</code>，然后根据这样的提示，执行<code>npm i -S react@某.某.某版本</code>。</p><p>(3) 安装依赖包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure></p><p>或者安装指定版本的react/react-native<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save react-native@0.45.1</span><br><span class="line">$ npm install --save react@15.6.1</span><br></pre></td></tr></table></figure></p><p>(4)集成cocoaPods<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod init</span><br></pre></td></tr></table></figure></p><p>Podfile文件内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, &quot;8.0&quot;</span><br><span class="line">target &quot;HelloRN&quot; do</span><br><span class="line">use_frameworks! </span><br><span class="line"># &apos;node_modules&apos;目录一般位于根目录中，但是如果你的结构不同，那你就要根据实际路径修改下面的`:path`</span><br><span class="line">pod &apos;React&apos;, :path =&gt; &apos;../node_modules/react-native&apos;, :subspecs =&gt;</span><br><span class="line">[</span><br><span class="line">&apos;Core&apos;,</span><br><span class="line">&apos;DevSupport&apos;, # 如果RN版本 &gt;= 0.43，则需要加入此行才能开启开发者菜单</span><br><span class="line">&apos;RCTText&apos;,</span><br><span class="line">&apos;RCTNetwork&apos;,</span><br><span class="line">&apos;RCTWebSocket&apos;, # 这个模块是用于调试功能的</span><br><span class="line"># 在这里继续添加需要的模块</span><br><span class="line">]</span><br><span class="line"># 如果你的RN版本 &gt;= 0.42.0，请加入下面这行</span><br><span class="line">pod &quot;Yoga&quot;, :path =&gt; &quot;../node_modules/react-native/ReactCommon/yoga&quot;</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>修改完Podfile文件内容执行<code>pod install</code></p><p>(4) 创建index.ios.js文件<br>注意当前项目名称为<code>RNDemo</code>，修改为实际项目名称。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import &#123;</span><br><span class="line">AppRegistry,</span><br><span class="line">StyleSheet,</span><br><span class="line">Text,</span><br><span class="line">View</span><br><span class="line">&#125; from &apos;react-native&apos;;</span><br><span class="line"></span><br><span class="line">class RNDemo extends React.Component &#123;  </span><br><span class="line">render() &#123;</span><br><span class="line">return (</span><br><span class="line">&lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">&lt;Text&gt;This is a simple application.&lt;/Text&gt;</span><br><span class="line">&lt;/View&gt;</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const styles = StyleSheet.create(&#123;</span><br><span class="line">container: &#123;</span><br><span class="line">flex: 1,</span><br><span class="line">justifyContent: &apos;center&apos;,</span><br><span class="line">alignItems: &apos;center&apos;,</span><br><span class="line">backgroundColor: &apos;#FFFFFF&apos;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">React.AppRegistry.registerComponent(&apos;RNDemo&apos;, () =&gt; RNDemo);</span><br></pre></td></tr></table></figure></p><p>(5) Cocoapods集成react-native<br>在工程目录下创建Podfile文件，内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 请将:path后面的内容为node_modules文件夹路径。</span><br><span class="line">plateform :ios, &apos;8.0&apos;</span><br><span class="line">target &quot;RNDemo&quot; do</span><br><span class="line">pod &apos;React&apos;, :path =&gt; &apos;../node_modules/react-native&apos;, :subspecs =&gt; [</span><br><span class="line">&apos;Core&apos;,</span><br><span class="line">&apos;RCTImage&apos;,</span><br><span class="line">&apos;RCTNetwork&apos;,</span><br><span class="line">&apos;RCTText&apos;,</span><br><span class="line">&apos;RCTWebSocket&apos;,</span><br><span class="line"># 添加其他你想在工程中使用的依赖。</span><br><span class="line">]</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>执行<code>pod install</code>即可<br>如果出现如下问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The dependency `React/Core (from `./node_modules/react-native`)` is not used in any concrete target.</span><br></pre></td></tr></table></figure></p><p>在项目首尾请添加上target即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target &quot;RNDemo&quot; do </span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>(6)添加react native应用<br>创建一个ReactView视图文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithFrame:(CGRect)frame</span><br><span class="line">&#123;</span><br><span class="line">if (self = [super initWithFrame:frame]) &#123;</span><br><span class="line">NSString * strUrl = @&quot;http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true&quot;;</span><br><span class="line">NSURL * jsCodeLocation = [NSURL URLWithString:strUrl];</span><br><span class="line"></span><br><span class="line">RCTRootView * rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation</span><br><span class="line">moduleName:@&quot;SimpleApp&quot;</span><br><span class="line">initialProperties:nil</span><br><span class="line">launchOptions:nil];</span><br><span class="line"></span><br><span class="line">[self addSubview:rootView];</span><br><span class="line"></span><br><span class="line">rootView.frame = self.bounds;</span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ReactView.m 中通过 <a href="http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true" target="_blank" rel="noopener">http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true</a> 加载bundle文件</p><p>在ViewController中加载这个视图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReactView * reactView = [[ReactView alloc] initWithFrame:CGRectMake(0, 40, CGRectGetWidth(self.view.bounds), 100)];</span><br><span class="line">[self.view addSubview:reactView];</span><br></pre></td></tr></table></figure></p><p>(7)启动开发服务器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ react-native start</span><br></pre></td></tr></table></figure></p><p>(8)Info.list中修改NSAppTransportSecurity配置<br>(9)在Xcode中运行项目，完成</p><h3 id="升级Xcode8后遇到的错误"><a href="#升级Xcode8后遇到的错误" class="headerlink" title="升级Xcode8后遇到的错误"></a>升级Xcode8后遇到的错误</h3><p>Q1:’React/RCTBundleURLProvider.h’ file not found<br>A1:将node_modules文件夹删除，执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install</span><br><span class="line">$ react-native upgrade</span><br></pre></td></tr></table></figure></p><p>clean，重新运行</p><p>Q2:RCTSCrollView.m 中_refreshControl找不到<br>A2:在@implementation RCTCustomScrollView下添加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@implementation RCTCustomScrollView</span><br><span class="line">&#123;</span><br><span class="line">RCTRefreshControl *_refreshControl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Q3:’React/JavaScriptCore.h’ file not found<br>A3:cocoapods升级到1.2.0</p><p>Q4:控制台不断输出<code>[] nw_connection_get_connected_socket_block_invoke 710 Connection has no connected handler</code><br>A4:edit scheme-&gt;arguments-&gt;Environment Variables-&gt;添加Name: “OS_ACTIVITY_MODE”, Value:”disable”</p><h1 id="JavaScript基础"><a href="#JavaScript基础" class="headerlink" title="JavaScript基础"></a>JavaScript基础</h1><p>(1){}表示定义一个对象<br>(2)var,let,function,弱类型,typeof(),isNaN()<br>数据类型：Boolean,null,undefined,Number,String,Symbol,Object<br>false:false,undefined,NaN,null,””,0<br>显式类型转换：parseInt()<br>隐式类型转换：==,-,*,/<br>数组：var a = [“1”,”2”,”3”]<br>     var a = new Array(“1”,”2”,”3”)<br>     var a = Array(“1”,”2”,”3”)<br>字典：{}</p><blockquote><p>JS:基于原型(所有对象均为实例,通过构造器函数来定义和创建一组对象)<br>OC：基于类<br>(3)Promises(ES6)<br>JS本身是单线程的语言，它要实现异步都是通过回调函数来实现的，JS中引入了Promises来处理异步和延迟操作。<br>    promise有以下几种状态：</p><pre><code>* pending，最初的状态* fulfilled，执行成功* rejected，执行出错* settled，执行结束了，失败(rejected)或者成功(fulfilled)</code></pre><p>(4)箭头函数(ES6)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(s) =&gt; s.length 等同于 function(s)&#123; return s.length &#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>普通函数.bind(this) 来把内部函数中的this绑定到了外部函数去。<br>箭头函数里的this还是原来的this，不需要额外绑定。<br>(5)模板字符串(ES6)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var html = `公司名：$&#123;name&#125;   </span><br><span class="line">简介：$&#123;desc&#125;`;</span><br><span class="line"></span><br><span class="line">等同于</span><br><span class="line"></span><br><span class="line">var tpl = &apos;公司名：&apos; + name + &apos;\n&apos;+</span><br><span class="line">&apos;简介：&apos;+ desc;</span><br></pre></td></tr></table></figure></p><h1 id="React基础"><a href="#React基础" class="headerlink" title="React基础"></a>React基础</h1><h2 id="组件（component）"><a href="#组件（component）" class="headerlink" title="组件（component）"></a>组件（component）</h2><p>是React类的基类，进行视图展示。</p><ul><li>组件的属性(prop)：组件之前通过标签的属性来传递数据，由父组件传递给子组件(单向的属性传递)</li><li>组件的状态(state)<ul><li>每次调用setState时都会更新组件的状态，触发render函数进行渲染更新界面（render方法是被异步调用的，这可以保证同步的多个setState方法只会触发一次render）</li><li>组件自己不可以自己修改props（即：props可认为是只读的），只可由其他组件调用它时在外部修改</li></ul></li><li>createClass：创建一个component</li><li>render()：返回的的 JSX 模板需要一个根元素包裹起来<br>返回一个根的视图，用来渲染实际的Component可视部分</li><li>getInitialState()：只能在用React.createClass创建的时候使用<br>在Component被加载之前调用一次，这个方法的返回值会被设置为this.state</li><li>getDefaultProps()：在Class 创建的时候，调用一次，这个方法在调用的时候，任何实例还没有被创建<br>返回的任何Object 对象，在各个实例中是共享的</li></ul><h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><p><img src="/assets/20170621_react/componentLifeCycle.png" alt="组件生命周期"></p><p>(1)创建：getDefaultProps(ES6:defaultProps)-&gt;<br>(2)实例化：getInitialState(ES6:constructor)-&gt;componentWillMount-&gt;render-&gt;componentDidMount-&gt;<br>(3)运行更新阶段：</p><pre><code>+ 运行中-&gt;props改变-&gt;componentWillReceiveProps-&gt;+ 运行中-&gt;state改变-&gt;</code></pre><p>shouldComponentUpdate-&gt;</p><pre><code>+ false-&gt;运行中+ true-&gt;componentWillUpdate-&gt;render-&gt;componentDidUpdate-&gt;运行中</code></pre><p>(4)销毁阶段：Unmount(卸载)-&gt;componentWillUnmount</p><table><thead><tr><th>生命周期</th><th>调用次数</th><th>能否使用 setSate()</th></tr></thead><tbody><tr><td>defaultProps / getDefaultProps</td><td>1(全局调用一次)</td><td>否</td></tr><tr><td>constructor / getInitialState</td><td>1</td><td>否</td></tr><tr><td>componentWillMount</td><td>1</td><td>是</td></tr><tr><td>render</td><td>&gt;=1</td><td>否</td></tr><tr><td>componentDidMount</td><td>1</td><td>是</td></tr><tr><td>componentWillReceiveProps</td><td>&gt;=0</td><td>是</td></tr><tr><td>shouldComponentUpdate</td><td>&gt;=0</td><td>否</td></tr><tr><td>componentWillUpdate</td><td>&gt;=0</td><td>否</td></tr><tr><td>componentDidUpdate</td><td>&gt;=0</td><td>否</td></tr><tr><td>componentWillUnmount</td><td>1</td><td>否</td></tr></tbody></table><p>(1)getDefaultProps(ES6:defaultProps):初始化一些默认的属性，一个控件可以利用this.props获取并初始化它的属性</p><pre><code>+ ES5:getDefaultProps:function(){},propTypes:{},+ ES6:static defaultProps={};static propTypes={};</code></pre><p>(2)constructor(props) / getInitialState():状态初始化</p><pre><code>+ ES5:getInitialState: function(){}+ ES6:constructor(props){}</code></pre><p>(3)componentWillMount():准备加载组件，业务初始化操作，也可以设置组件状态<br>(4)render():渲染界面，返回JSX或其它组件来构成DOM，只能返回一个顶级元素<br>(5)componentDidMount():组件加载成功并被成功渲染，一般会做一些网络请求等加载数据的操作</p><p>(6)componentWillReceiveProps():组件接收到新的props会触发，可以调用setState()来完成对state的修改，nextProps 是即将被设置的属性，旧的属性还是可以通过 this.props 来获取<br>(7)shouldComponentUpdate():返回布尔值（决定是否需要更新组件）<br>(8)componentWillUpdate():shouldComponentUpdate返回true或者调用forceUpdate之后触发此方法，会把 nextProps 和 nextState 分别设置到 this.props 和 this.state 中，开始准备更新组件。不能使用 this.setState 来修改状态。<br>(9)render()：再确定需要更新组件时，调用render，根据diff算法，渲染界面，生成需要更新的虚拟DOM数据。<br>(10)componentDidUpdate():可以在这个方法中做DOM操作，首次render之后调用componentDidMount，其它render结束之后都是调用componentDidUpdate。<br>(11)componentWillUnmount():组件从DOM中移除，可以做一些组件相关的清理工作，例如取消计时器、网络请求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：绝对不要在componentWillUpdate和componentDidUpdate中调用this.setState方法，否则将导致无限循环调用。</span><br></pre></td></tr></table></figure></p><h2 id="组件更新的四种方式"><a href="#组件更新的四种方式" class="headerlink" title="组件更新的四种方式"></a>组件更新的四种方式</h2><p>(1)首次Initial Render，即首次加载组件<br>(2)调用this.setState<br>(3)父组件发生更新<br>(4)调用this.forceUpdate强制更新</p><h2 id="statics"><a href="#statics" class="headerlink" title="statics"></a>statics</h2><p>定义Components可以调用的静态方法</p><h2 id="原生和React-Native之间的通信方式"><a href="#原生和React-Native之间的通信方式" class="headerlink" title="原生和React Native之间的通信方式"></a>原生和React Native之间的通信方式</h2><p>主要包括三部分：</p><ul><li>属性</li><li>原生模块</li><li>原生UI组件封装</li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>原生给JS传数据，主要依靠属性。<br>(1)原生-&gt;React Native </p><ul><li>传递属性<br>initialProperties：必须是NSDictionary的一个实例。这一字典参数会在内部被转化为一个可供JS组件调用的JSON对象。</li><li>更新属性<br>appProperties：可以通过componentWillMount访问新的属性值。</li><li>更新必须在主线程中进行，读取则可以在任何线程中进行。</li><li>更新属性时并不能做到只更新一部分属性。建议自己封装一个函数来构造属性。<br>(2)React Native-&gt;原生<br>宏RCT_CUSTOM_VIEW_PROPERTY</li></ul><h3 id="原生模块"><a href="#原生模块" class="headerlink" title="原生模块"></a>原生模块</h3><p>原生模块是JS中也可以使用的Objective-C类。一个“原生模块”就是一个实现了“RCTBridgeModule”协议的Objective-C类。</p><h3 id="原生UI组件封装"><a href="#原生UI组件封装" class="headerlink" title="原生UI组件封装"></a>原生UI组件封装</h3><p>参考链接：<a href="http://www.lcode.org/【react-native开发】react-native-for-android环境配置以及第一个实例/" target="_blank" rel="noopener">React Native开发</a><br><a href="http://www.jianshu.com/p/5b185df2d11a" target="_blank" rel="noopener">React Native 简介与入门</a><br><a href="https://www.cnblogs.com/qiangxia/p/5584622.html" target="_blank" rel="noopener">学习React Native必看的几个开源项目</a><br><a href="http://react-china.org/t/react-native/10141/3" target="_blank" rel="noopener">总结一下今年的react native 填坑之旅，已双端上线</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JSP学习笔记</title>
      <link href="/2017/06/12/JSP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/06/12/JSP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>cookies 存储在浏览器。而会话存储在服务器端<br><a id="more"></a><br>待补充</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常见算法总结</title>
      <link href="/2017/06/09/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2017/06/09/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>1、插入排序<br>在要排序的一组数中，假设前面(n-1) [n&gt;=2] 个数已经是排好顺序的，现在要把第n个数插到前面的有序数中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">if(arr == null || arr.length &lt; 2)&#123;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;arr.length;i++)&#123;</span><br><span class="line">    for(intj=i;j&gt;0;j--)&#123;</span><br><span class="line">        if(arr[j]&lt;arr[j-1])&#123;</span><br><span class="line">            int temp=arr[j];</span><br><span class="line">            arr[j]=arr[j-1];</span><br><span class="line">            arr[j-1]=temp;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //接下来是无用功</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return arr;</span><br></pre></td></tr></table></figure></p><p>2、冒泡排序<br>在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int temp = 0;</span><br><span class="line">for (int i = a.length - 1; i &gt; 0; --i)</span><br><span class="line">&#123;</span><br><span class="line">    for (int j = 0; j &lt; i; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        if (a[j + 1] &lt; a[j])</span><br><span class="line">        &#123;</span><br><span class="line">            temp = a[j];</span><br><span class="line">            a[j] = a[j + 1];</span><br><span class="line">            a[j + 1] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3、快速排序<br>快速排序是对冒泡排序的一种本质改进。它的基本思想是通过一趟扫描后，使得排序序列的长度能大幅度地减少。在冒泡排序中，一次扫描只能确保最大数值的数移到正确位置，而待排序序列的长度可能只减少1。快速排序通过一趟扫描，就能确保以某个数为基准点的左边各数都比它小，右边各数都比它大。然后又用同样的方法处理它左右两边的数，直到基准点的左右只有一个元素为止。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    if(left &gt;= right)/*如果左边索引大于或者等于右边的索引就代表已经整理完成一个组了*/</span><br><span class="line">    &#123;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    int i = left;</span><br><span class="line">    int j = right;</span><br><span class="line">    int key = a[left];</span><br><span class="line"></span><br><span class="line">    while(i &lt; j)                               /*控制在当组内寻找一遍*/</span><br><span class="line">    &#123;</span><br><span class="line">        while(i &lt; j &amp;&amp; key &lt;= a[j])</span><br><span class="line">        /*而寻找结束的条件就是，1，找到一个小于或者大于key的数（大于或小于取决于你想升</span><br><span class="line">        序还是降序）2，没有符合条件1的，并且i与j的大小没有反转*/ </span><br><span class="line">        &#123;</span><br><span class="line">            j--;/*向前寻找*/</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        /*找到一个这样的数后就把它赋给前面的被拿走的i的值（如果第一次循环且key是</span><br><span class="line">        a[left]，那么就是给key）*/</span><br><span class="line"></span><br><span class="line">        while(i &lt; j &amp;&amp; key &gt;= a[i])</span><br><span class="line">        /*这是i在当组内向前寻找，同上，不过注意与key的大小关系停止循环和上面相反，</span><br><span class="line">        因为排序思想是把数往两边扔，所以左右两边的数大小与key的关系相反*/</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        a[j] = a[i];        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    a[i] = key;/*当在当组内找完一遍以后就把中间数key回归*/</span><br><span class="line">    sort(a, left, i - 1);/*最后用同样的方式对分出来的左边的小组进行同上的做法*/</span><br><span class="line">    sort(a, i + 1, right);/*用同样的方式对分出来的右边的小组进行同上的做法*/</span><br><span class="line">    /*当然最后可能会出现很多分左右，直到每一组的i = j 为止*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4、选择排序<br>在要排序的一组数中，选出最小的一个数与第一个位置的数交换；然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">int i,j,min,t;</span><br><span class="line">for(i=0;i&lt;n-1;i++)</span><br><span class="line">&#123;</span><br><span class="line">    min=i;//查找最小值</span><br><span class="line">    for(j=i+1;j&lt;n;j++)</span><br><span class="line">        if(a[min]&gt;a[j])</span><br><span class="line">        min=j;//交换</span><br><span class="line"></span><br><span class="line">        if(min!=i)</span><br><span class="line">        &#123;</span><br><span class="line">            t=a[min];</span><br><span class="line">            a[min]=a[i];</span><br><span class="line">            a[i]=t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>升序排序（选择排序）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">void sort(int a[],int n)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">int i, j, index;</span><br><span class="line"></span><br><span class="line">for(i = 0; i &lt; n - 1; i++) &#123;</span><br><span class="line"></span><br><span class="line">index = i;</span><br><span class="line"></span><br><span class="line">for(j = i + 1; j &lt; n; j++) &#123;</span><br><span class="line"></span><br><span class="line">if(a[index] &gt; a[j]) &#123;</span><br><span class="line"></span><br><span class="line">index = j;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(index != i) &#123;</span><br><span class="line"></span><br><span class="line">int temp = a[i];</span><br><span class="line"></span><br><span class="line">a[i] = a[index];</span><br><span class="line"></span><br><span class="line">a[index] = temp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line"></span><br><span class="line">int numArr[10] = &#123;86, 37, 56, 29, 92, 73, 15, 63, 30, 8&#125;;</span><br><span class="line"></span><br><span class="line">sort(numArr, 10);</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line"></span><br><span class="line">printf(&quot;%d, &quot;, numArr[i]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>降序排序（冒泡排序）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line"></span><br><span class="line">    int array[10] = &#123;24, 17, 85, 13, 9, 54, 76, 45, 5, 63&#125;;</span><br><span class="line"></span><br><span class="line">    int num = sizeof(array)/sizeof(int);</span><br><span class="line"></span><br><span class="line">    for(int i = 0; i &lt; num-1; i++) &#123;</span><br><span class="line"></span><br><span class="line">        for(int j = 0; j &lt; num - 1 - i; j++) &#123;</span><br><span class="line"></span><br><span class="line">            if(array[j] &lt; array[j+1]) &#123;</span><br><span class="line"></span><br><span class="line">                int tmp = array[j];</span><br><span class="line">                array[j] = array[j+1];</span><br><span class="line">                array[j+1] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i = 0; i &lt; num; i++) &#123;</span><br><span class="line"></span><br><span class="line">        printf(&quot;%d&quot;, array[i]);</span><br><span class="line">        if(i == num-1) &#123;</span><br><span class="line">            printf(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            printf(&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><p>二分法查找只适用与已排序的数列。<br>思路：首先将值 x 与数组 v 的中间元素比较，如果 x 小于中间的元素，则将 end 值设为 中间元素-1，同理，若 x 大于中间元素，则将中间元素 + 1作为 start，再在 start 与 end 之间进行查找。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int start = 0;</span><br><span class="line">int end = data.length-1;</span><br><span class="line">int mid = (start+end)/2;//a</span><br><span class="line">while(data[mid]!=aim&amp;&amp;end&gt;start)&#123;</span><br><span class="line">    if(data[mid]&gt;aim)&#123;</span><br><span class="line">        end = mid-1;</span><br><span class="line">    &#125;else if(data[mid]&lt;aim)&#123;</span><br><span class="line">        start = mid+1;</span><br><span class="line">    &#125;</span><br><span class="line">    mid = (start+end)/2;</span><br><span class="line">&#125;</span><br><span class="line">return (data[mid]!=aim)?-1:mid;</span><br></pre></td></tr></table></figure></p><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>数列：1,1,2,3,5,8,13,21…  求第n项的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int f1,f2,f,i,n;    </span><br><span class="line">f1=f2=1;</span><br><span class="line">if(n&lt;=2)    </span><br><span class="line">    printf(&quot;%d&quot;,1);    </span><br><span class="line">else </span><br><span class="line">&#123;                        //加上括号</span><br><span class="line">    for(i=3;i&lt;=n;i++)      </span><br><span class="line">&#123;   </span><br><span class="line">f=f1+f2;         </span><br><span class="line">f1=f2;   </span><br><span class="line">f2=f;</span><br></pre></td></tr></table></figure></p><h2 id="请用代码或者伪代码打印输出一个菱形"><a href="#请用代码或者伪代码打印输出一个菱形" class="headerlink" title="请用代码或者伪代码打印输出一个菱形"></a>请用代码或者伪代码打印输出一个菱形</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void print(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j;</span><br><span class="line">    for(i=1; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(j=1; j&lt;=n-i; j++)&#123; printf(&quot; &quot;); &#125;</span><br><span class="line">        for(j=n-i+1; j&lt;n+i; j++)&#123; printf(&quot;*&quot;); &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=n-1; i&gt;=1; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        for(j=1; j&lt;=(n-i); j++)&#123; printf(&quot; &quot;); &#125;</span><br><span class="line">        for(j=n-i+1; j&lt;n+i; j++)&#123; printf(&quot;*&quot;); &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打印0-100之间的素数"><a href="#打印0-100之间的素数" class="headerlink" title="打印0-100之间的素数"></a>打印0-100之间的素数</h2><p>思路：与小于根号n的数取余，结果为0则是合数，否则就是素数（质数）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1;i&lt;100;i++)&#123;</span><br><span class="line">    int r = [self isPrime:i];</span><br><span class="line">    if(r==1)&#123;</span><br><span class="line">        NSLog(@&quot;%d&quot;,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(int)isPrime:(int)number&#123;</span><br><span class="line">    for(int i=0;i&lt;=sqrt(number);i++)&#123;</span><br><span class="line">        if(number%i==0)  return0;  </span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="求两个整数的最大公约数"><a href="#求两个整数的最大公约数" class="headerlink" title="求两个整数的最大公约数"></a>求两个整数的最大公约数</h2><p>思路：如果较大数与较小数取余为0，则最大公约数为较小数，否则，拿较小数与上一步取余结果取余，直到结果为0，最后的较小数为最大公约数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int gcd(int a,int b)&#123;</span><br><span class="line">    int temp = 0;</span><br><span class="line">    if(a&lt;b)&#123;</span><br><span class="line">        temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (b!=0) &#123;</span><br><span class="line">        temp = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">        NSLog(@&quot;a:%d b:%d&quot;,a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="给定一个字符串，输出本字符串中只出现一次并且最靠前的那个字符的位置？如“abaccddeeef”-字符是b-输出应该是2"><a href="#给定一个字符串，输出本字符串中只出现一次并且最靠前的那个字符的位置？如“abaccddeeef”-字符是b-输出应该是2" class="headerlink" title="给定一个字符串，输出本字符串中只出现一次并且最靠前的那个字符的位置？如“abaccddeeef”,字符是b,输出应该是2"></a>给定一个字符串，输出本字符串中只出现一次并且最靠前的那个字符的位置？如“abaccddeeef”,字符是b,输出应该是2</h2><p>思路：创建一个空数组，默认元素都为-1，遍历字符串一遍，存下每个字母的位置，如果存过一次，就把位置设置为-2，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include     &lt;stdio.h&gt;</span><br><span class="line">#include     &lt;stdlib.h&gt;</span><br><span class="line">#include     &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int find_char(const char* str)</span><br><span class="line">&#123;</span><br><span class="line">    static int pos[256];</span><br><span class="line">    const unsigned char* p = (const unsigned char*)str;</span><br><span class="line">    int i = 0;</span><br><span class="line">    if( (!str) || (!(*str)) ) return -1;</span><br><span class="line">    memset(pos,-1,sizeof(pos));</span><br><span class="line">    while(*p)&#123;</span><br><span class="line">        if(pos[*p] == -1)&#123;</span><br><span class="line">            pos[*p] = p-(const unsigned char*)str;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            pos[*p] = -2;</span><br><span class="line">        &#125;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0;i&lt;sizeof(pos)/sizeof(pos[0]);i++)&#123;</span><br><span class="line">        if(pos[i]&gt;=0)return pos[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const char* p = &quot;abaccddeeef&quot;;</span><br><span class="line">    int pos = find_char(p);</span><br><span class="line">    printf(&quot;index:%d, it is &apos;%c&apos;\n&quot;,pos,pos!=-1?p[pos]:&apos; &apos;);</span><br><span class="line"></span><br><span class="line">    p = &quot;abcdefghijklmnopqrstuvwxyz abcdefghijklmnopqrstu wxyz &quot;;</span><br><span class="line">    pos = find_char(p);</span><br><span class="line">    printf(&quot;index:%d, it is &apos;%c&apos;\n&quot;,pos,pos!=-1?p[pos]:&apos; &apos;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="给定一个整数，问这个整数转成2进制后，里面包含有多少个1？比如：10，二进制表示为，1010则，输出2"><a href="#给定一个整数，问这个整数转成2进制后，里面包含有多少个1？比如：10，二进制表示为，1010则，输出2" class="headerlink" title="给定一个整数，问这个整数转成2进制后，里面包含有多少个1？比如：10，二进制表示为，1010则，输出2"></a>给定一个整数，问这个整数转成2进制后，里面包含有多少个1？比如：10，二进制表示为，1010则，输出2</h2><p>思路：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int howmany(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    while (x)</span><br><span class="line">    &#123;</span><br><span class="line">        if ((x&amp;1) == 1)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        x = x&gt;&gt;1;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="计算阶乘"><a href="#计算阶乘" class="headerlink" title="计算阶乘"></a>计算阶乘</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int f(int i)</span><br><span class="line">&#123;</span><br><span class="line">    int t=1,j;</span><br><span class="line"></span><br><span class="line">    for(j=1;j&lt;=i;j++)</span><br><span class="line">    t=t*j;</span><br><span class="line"></span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="现有一个M行N列的数组-要求安装反向斜对角线-右上-gt-左下-的方式-打印该数组"><a href="#现有一个M行N列的数组-要求安装反向斜对角线-右上-gt-左下-的方式-打印该数组" class="headerlink" title="现有一个M行N列的数组,要求安装反向斜对角线(右上-&gt;左下)的方式,打印该数组."></a>现有一个M行N列的数组,要求安装反向斜对角线(右上-&gt;左下)的方式,打印该数组.</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//    int m = 5,n = 4;</span><br><span class="line">int m ,n;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;m,&amp;n);</span><br><span class="line">int a[m][n];</span><br><span class="line">int count=0;</span><br><span class="line">for (int i=0; i&lt;m; i++) &#123;</span><br><span class="line">    for (int j=0; j&lt;n; j++) &#123;</span><br><span class="line">        a[i][j]=count++;</span><br><span class="line">        printf(&quot;%d &quot;,a[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (int k = 0; k&lt;m+n-1; k++) &#123;</span><br><span class="line">    for (int i=0; i&lt;m; i++) &#123;</span><br><span class="line">        for (int j=0; j&lt;n; j++) &#123;</span><br><span class="line">            if (i+j==k) &#123;</span><br><span class="line">                printf(&quot;%d &quot;,a[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printf(&quot;*****优化后的算法*****\n&quot;);</span><br><span class="line">int low=0;   //i的下限</span><br><span class="line">while (num&lt;(m+n-1)) &#123;//i+j=5，3*4的数组循环6次</span><br><span class="line"></span><br><span class="line">    if(num&gt;=n)&#123; //打印下半部分的时候i的下标开始+1</span><br><span class="line">        low++;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i=low;i&lt;m; i++) &#123;</span><br><span class="line">        printf(&quot;%d &quot;,a[i][num-i]);</span><br><span class="line">        if (num==i) &#123; //列的下标等于0的时候，跳出。</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);//加一个换行可以看得更加明了</span><br><span class="line">    num++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java语言学习笔记</title>
      <link href="/2017/06/09/Java%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/06/09/Java%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>##JAVA基础</p><h3 id="1-public类"><a href="#1-public类" class="headerlink" title="1.public类"></a>1.public类</h3><ul><li>一个源文件中只能有一个public类</li><li>一个源文件可以有多个非public类<a id="more"></a><h3 id="2-package-import"><a href="#2-package-import" class="headerlink" title="2.package/import"></a>2.package/import</h3>编译java包：<blockquote><p>$ javac -d directory javafilename</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">E:\sources&gt; javac -d c:\classes Simple.java</span><br><span class="line">//运行</span><br><span class="line">e:\sources&gt; set classpath=c:\classes;.;</span><br><span class="line">e:\sources&gt; java mypack.Simple</span><br></pre></td></tr></table></figure></blockquote></li></ul><p>OR<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e:\sources&gt; java -classpath c:\classes mypack.Simple</span><br></pre></td></tr></table></figure></p><p>加载类文件或jar文件的方式:</p><ul><li>加载临时类文件<ul><li>通过在命令提示符中设置类路径</li><li>通过 -classpath 开关选项</li></ul></li><li>永久加载类文件<ul><li>通过在环境变量中设置类路径</li><li>通过创建jar文件，其中包含所有类文件，并将jar文件复制到JDK安装目录的jre/lib/ext文件夹中。</li></ul></li></ul><h3 id="3-引用类型"><a href="#3-引用类型" class="headerlink" title="3.引用类型"></a>3.引用类型</h3><p>对象、数组都是引用数据类型。<br>所有引用类型的默认值都是null。</p><h3 id="4-JAVA常量"><a href="#4-JAVA常量" class="headerlink" title="4.JAVA常量"></a>4.JAVA常量</h3><p>在 Java 中使用 final 关键字来修饰常量，通常使用大写字母表示常量</p><h3 id="5-基本数据类型"><a href="#5-基本数据类型" class="headerlink" title="5. 基本数据类型"></a>5. 基本数据类型</h3><ul><li>不能对boolean类型进行类型转换。</li><li>在把容量大的类型转换为容量小的类型时必须使用强制类型转换 double-&gt;float</li></ul><p>6.自动类型转换<br>转换前的数据类型的位数要低于转换后的数据类型。Float-&gt;double</p><ol start="7"><li>Java语言支持的变量类型<h4 id="类变量：独立于方法之外的变量，用-static-修饰。"><a href="#类变量：独立于方法之外的变量，用-static-修饰。" class="headerlink" title="类变量：独立于方法之外的变量，用 static 修饰。"></a>类变量：独立于方法之外的变量，用 static 修饰。</h4></li></ol><ul><li>在类中以static关键字声明，但必须在方法构造方法和语句块之外</li><li>静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。</li><li>静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。</li><li>为了对类的使用者可见，大多数静态变量声明为public类型</li><li>默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。</li><li>类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。</li><li>静态块在类加载时main之前执行<h4 id="实例变量：独立于方法之外的变量，不过没有-static-修饰。"><a href="#实例变量：独立于方法之外的变量，不过没有-static-修饰。" class="headerlink" title="实例变量：独立于方法之外的变量，不过没有 static 修饰。"></a>实例变量：独立于方法之外的变量，不过没有 static 修饰。</h4></li><li>当一个对象被实例化之后，每个实例变量的值就跟着确定；</li><li>实例变量可以声明在使用前或者使用后；</li><li>一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；</li><li>实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；</li><li>实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名<h4 id="局部变量：类的方法中的变量。"><a href="#局部变量：类的方法中的变量。" class="headerlink" title="局部变量：类的方法中的变量。"></a>局部变量：类的方法中的变量。</h4></li><li>访问修饰符不能用于局部变量；</li><li>局部变量是在栈上分配的。</li><li>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。</li></ul><h4 id="实例初始化块"><a href="#实例初始化块" class="headerlink" title="实例初始化块"></a>实例初始化块</h4><p>主要有三个规则。 它们如下：</p><ul><li>在创建类的实例时创建实例初始化程序块。</li><li>在父类构造函数被调用之后(即在super()构造函数调用之后)调用实例初始化块。</li><li>实例初始化程序块按它们显示的顺序排列。</li></ul><h3 id="8．修饰符：访问修饰符、非访问修饰符"><a href="#8．修饰符：访问修饰符、非访问修饰符" class="headerlink" title="8．修饰符：访问修饰符、非访问修饰符"></a>8．修饰符：访问修饰符、非访问修饰符</h3><ul><li>修饰符用来定义类、方法或者变量，通常放在语句的最前端，默认default<h4 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h4>（1） public/protected/default/private<br>（2） private: 只能通过类中公共的 getter 方法被外部类访问<br>（3） protected: 同一个包中的任何其他类访问，也能够被不同包中的子类访问</li><li>public: 如果几个相互访问的 public 类分布在不同的包中，则需要导入相应 public 类所在的包</li><li>注意：父类中声明为 public 的方法在子类中也必须为 public。</li><li>父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。</li><li>父类中声明为 private 的方法，不能够被继承。</li></ul><h4 id="非访问修饰符"><a href="#非访问修饰符" class="headerlink" title="非访问修饰符"></a>非访问修饰符</h4><p>static,abstract,final,synchronized,volatile<br>（1）final：用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。</p><ul><li>final 变量：能被显式地初始化并且只能初始化一次。被声明为 final 的对象的引用不能指向不同的对象。但是 final 对象里的数据可以被改变。也就是说 final 对象的引用不能改变，但是里面的值可以改变。final 修饰符通常和 static 修饰符一起使用来创建类常量。</li><li>final 方法：类中的 final 方法可以被子类继承，但是不能被子类修改。</li><li>final 类：final 类不能被继承，没有类能够继承 final 类的任何特性。</li><li>被声明为 final 类的方法自动地声明为 final，但是实例变量并不是 final</li><li>在声明时未初始化的静态final变量称为静态空白final变量。 它只能在静态块中初始化。<br>（2）abstract: 抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充<br>一个类不能同时被 abstract 和 final 修饰。<br>抽象方法:是一种没有任何实现的方法，该方法的的具体实现由子类提供。</li><li>抽象方法不能被声明成 final 和 static。</li><li>任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。</li><li>如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。抽象类可以包含抽象方法和非抽象方法。</li><li>抽象方法的声明以分号结尾，例如：public abstract sample()。<br>在java中有两种实现抽象的方法，它们分别是：</li><li>抽象类(部分)</li><li>接口 (完全)<br>抽象类实现了部分抽象(0到100％)，而接口实现了完全抽象(100％)。<br><img src="/assets/20170609_java/acAndIfa.png" alt="抽象类与接口"></li></ul><h3 id="9-instanceof-name-instanceof-String"><a href="#9-instanceof-name-instanceof-String" class="headerlink" title="9.instanceof: name instanceof String"></a>9.instanceof: name instanceof String</h3><p>增强for循环：for(声明语句 : 表达式)<br>switch支持字符串，直到break退出</p><h3 id="10-装箱-拆箱"><a href="#10-装箱-拆箱" class="headerlink" title="10.装箱/拆箱"></a>10.装箱/拆箱</h3><p>装箱：int-&gt;number  拆箱：number-&gt;int<br>intValue() valueOf() compareo() equals() parseInt()(string-&gt;int) ceil() floor() random()</p><h3 id="11-Character-char的包装类"><a href="#11-Character-char的包装类" class="headerlink" title="11.Character char的包装类"></a>11.Character char的包装类</h3><p>isLetter() isDigit() isUpperCase() isWhitespace() toUpperCase() toString()</p><h3 id="12-String"><a href="#12-String" class="headerlink" title="12.String"></a>12.String</h3><p>length() s1.concat(s2)  s = format(”—%f %d %s”,floatVar,.,.) charAt(index) int compareo()(对象，字符串)<br>boolean contentEquals(StringBuffer)  endsWith() equals()  indexOf(ch) split substring</p><h3 id="13-StringBuffer-StringBuilder"><a href="#13-StringBuffer-StringBuilder" class="headerlink" title="13. StringBuffer/StringBuilder"></a>13. StringBuffer/StringBuilder</h3><p>当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。<br>StringBuffer(线程安全) StringBuilder(速度优势,不是线程安全的,不能同步访问)  多数情况下建议使用 StringBuilder 类<br>StringBuffer：append(s) reverse dekete(start,end) replace(start,end,str) capacity() charAt() indexOf() toString substring</p><h3 id="14-Arrays数组"><a href="#14-Arrays数组" class="headerlink" title="14.Arrays数组"></a>14.Arrays数组</h3><p>double[] list = new double[10];  参数：(int[] array)  返回值：int[]<br>fill sort equals binarySearch</p><h3 id="15-Date"><a href="#15-Date" class="headerlink" title="15.Date"></a>15.Date</h3><p>date.toString() getime() after before equals compareo   format parse<br>SimpleDateFormat(E yyyy-MM-dd HH:mm:ss a zzz) PM<br>Sleep(1000*3)  Calender.getInstance()</p><h3 id="16-正则表达式"><a href="#16-正则表达式" class="headerlink" title="16.正则表达式"></a>16.正则表达式</h3><p>Pattern Matcher<br>\s+ 多个空格  ^$ 以什么开始  \d+多个数字  ()? 0/1 可选  * 0/n  +1\n   {n} (n,) &gt;=n  . 除\n\r之外的任何单个字符<br>[xyz] [^xyz] [a-z]  \b字符边界</p><h3 id="17-function"><a href="#17-function" class="headerlink" title="17.function"></a>17.function</h3><p>重载：方法名相同，参数列表不同<br>构造方法：方法名与类名相同，没有返回值，自定义则默认构造方法失效<br>可变参数：一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明<br>（double… numbers）<br>protected void finalize()</p><h3 id="18-BufferReader"><a href="#18-BufferReader" class="headerlink" title="18.BufferReader"></a>18.BufferReader</h3><p>read() write() scanner() print() println()</p><h3 id="19-I-O"><a href="#19-I-O" class="headerlink" title="19.I/O"></a>19.I/O</h3><p>FileInputStream FileOutputStream File FileReader FileWrite mkdir mkdirs isDirectory delete()</p><p>20.Scanner(System.in)<br>next nextLine</p><p>21.Exception<br>java.lang.Exception Error  Throwable<br>IOException RuntimeException</p><h3 id="22-面向对象"><a href="#22-面向对象" class="headerlink" title="22.面向对象"></a>22.面向对象</h3><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>extends final修饰的类不能被集成，方法不能被重写  单继承</p><h4 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h4><p>Override(返回值和形参都不能改变) Overload(方法名字相同，而参数不同。返回类型可以相同也可以不同)<br>构造方法不能被重写<br>最常用的地方就是构造器的重载</p><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>父类指向子类对象  Animal a = new Cat()   实现方式：重写，接口，抽象类和抽象方法  变量不能被重写</p><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。</p><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>修改属性的可见性来限制对属性的访问（一般限制为private）<br>对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问</p><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>是抽象方法的集合。<br>有静态、final变量和抽象方法（JAVA8还可以有默认方法，静态方法），接口字段默认是public，static和final，方法默认是public和abstract<br>类描述对象的属性和方法。接口则包含类要实现的方法。<br>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。<br>一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。<br>接口中的方法会被隐式的指定为 public abstract，接口中的变量会被隐式的指定为 public static final<br>类的多重继承是不合法，但接口允许多重继承</p><h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><p>小写开头<br>使用类全名描述 或 import(import 声明必须在包声明之后，类声明之前)</p><h2 id="java高级"><a href="#java高级" class="headerlink" title="java高级"></a>java高级</h2><h3 id="1-一些概念理解"><a href="#1-一些概念理解" class="headerlink" title="1.一些概念理解"></a>1.一些概念理解</h3><h4 id="JVM-Java虚拟机"><a href="#JVM-Java虚拟机" class="headerlink" title="JVM(Java虚拟机)"></a>JVM(Java虚拟机)</h4><p>一个抽象机器。它是一个提供可以执行Java字节码的运行时环境的规范。<br>JVM执行以下主要任务：</p><ul><li>加载代码</li><li>验证代码</li><li>执行代码</li><li>提供运行时环境<h4 id="JRE（Java-Runtime-Environment）"><a href="#JRE（Java-Runtime-Environment）" class="headerlink" title="JRE（Java Runtime Environment）"></a>JRE（Java Runtime Environment）</h4>用于提供Java运行时环境。它是JVM的实现。它是实际存在的。它包含一组库和JVM在运行时使用的其他文件。<h4 id="JDK（Java-Development-Kit）"><a href="#JDK（Java-Development-Kit）" class="headerlink" title="JDK（Java Development Kit）"></a>JDK（Java Development Kit）</h4>它是实际上存在的。它包含JRE+开发工具。</li></ul><p>JDK(JRE(JVM+LIB+OTHER)+IDE)</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MyEclipse快捷键</title>
      <link href="/2017/06/09/MyEclipse%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2017/06/09/MyEclipse%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<p>1.补全：alt+/<br>2.修复：ctrl+1<br><a id="more"></a><br>3.删除当前行：ctrl+d<br>4.复制当前行到上一行/下一行：ctrl+alt+上/下方向键<br>5.互换位置：alt+上/下方向键<br>6.上/下一个编辑的页面：alt+左/右方向键<br>7.显示工程文件目录：alt+enter<br>8.当前行插入空行：shift+enter(+ctrl 下一行插入)<br>9.格式化：ctrl+shift+f<br>10.重命名：alt+shift+r<br>11.抽取方法：alt+shift+m<br>12.组织导入（自动加入引用）：ctrl+shift+o<br>13.添加导入：Ctrl+Shift+M<br>14.单步返回 F7<br>15.单步跳过 F6<br>16.单步跳入 F5<br>17.单步跳入选择 Ctrl+F5<br>18.调试上次启动 F11<br>19.继续 F8 </p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mysql学习笔记</title>
      <link href="/2017/06/08/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/06/08/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database db;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop database db;</span><br></pre></td></tr></table></figure><h3 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure><h3 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use db;</span><br></pre></td></tr></table></figure><h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE db.tb (</span><br><span class="line">`id` INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">`name` VARCHAR(45) NOT NULL,</span><br><span class="line">PRIMARY KEY (`cid`));</span><br></pre></td></tr></table></figure><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table tb</span><br></pre></td></tr></table></figure><h3 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RENAME TABLE tb TO new_tbname;</span><br><span class="line">ALTER TABLE tb RENAME TO new_tbname;</span><br></pre></td></tr></table></figure><h3 id="初始化表-清空"><a href="#初始化表-清空" class="headerlink" title="初始化表(清空)"></a>初始化表(清空)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRUNCATE TABLE tb</span><br></pre></td></tr></table></figure><h3 id="复制表："><a href="#复制表：" class="headerlink" title="复制表："></a>复制表：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tb_name2 SELECT * FROM tb_name;</span><br></pre></td></tr></table></figure><p>或者部分复制：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tb_name2 SELECT id,name FROM tb_name;</span><br></pre></td></tr></table></figure></p><h3 id="查看数据库中可用的表："><a href="#查看数据库中可用的表：" class="headerlink" title="查看数据库中可用的表："></a>查看数据库中可用的表：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure><h3 id="查看表的结构："><a href="#查看表的结构：" class="headerlink" title="查看表的结构："></a>查看表的结构：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DESCRIBE tb_name;</span><br><span class="line">SHOW COLUMNS in tb_name; 　　//from也可以</span><br></pre></td></tr></table></figure><h2 id="列-约束"><a href="#列-约束" class="headerlink" title="列/约束"></a>列/约束</h2><p>ALTER TABLE tb ADD[CHANGE,RENAME,DROP]</p><h3 id="增加列-约束"><a href="#增加列-约束" class="headerlink" title="增加列/约束"></a>增加列/约束</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table tb add column name VARCHAR(45) not null after id,add primary key(id);</span><br></pre></td></tr></table></figure><h3 id="删除列-约束"><a href="#删除列-约束" class="headerlink" title="删除列/约束"></a>删除列/约束</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table tb drop col2 drop primary key(id);</span><br></pre></td></tr></table></figure><h3 id="修改列-约束"><a href="#修改列-约束" class="headerlink" title="修改列/约束"></a>修改列/约束</h3><p>ALTER TABLE tb MODIFY col2 int NOT NULL DEFAULT 100 add col1 int identity(1,1);<br>ALTER TABLE tb ALTER col2 SET DEFAULT 1000;<br>ALTER TABLE tb ALTER col2 DROP DEFAULT;</p><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>primary key,not null,unique,asc/desc/default 0/AUTO_INCREMENT/zerofill</p><h2 id="单表操作"><a href="#单表操作" class="headerlink" title="单表操作"></a>单表操作</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into tb(col1,col2) values(value1,value2)</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from tb [WHERE Clause]</span><br></pre></td></tr></table></figure><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update tb set col1=value1 [WHERE Clause]</span><br></pre></td></tr></table></figure><p>使用MySQL执行update的时候报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error Code: 1175. You are using safe update mode and you tried to update a table without a WHERE that uses a KEY column To disable safe mode, toggle the option in Preferences -&gt; SQL Queries and reconnect.</span><br></pre></td></tr></table></figure></p><p>解决方法：<br>执行命令 SET SQL_SAFE_UPDATES = 0;  //修改下数据库模式<br>如果想要提高数据库安全等级，可以在恢复回原有的设置，执行命令：SET SQL_SAFE_UPDATES = 1;</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tb [WHERE Clause]</span><br></pre></td></tr></table></figure><h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><ul><li>=、&gt;、&lt;、&lt;&gt; and/not and  or  is null/is not null</li><li><p>分组查询：order by/group by/having</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tb order by col1,col2 asc/desc</span><br></pre></td></tr></table></figure></li><li><p>like</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT field1, field2,...fieldN </span><br><span class="line">FROM tb</span><br><span class="line">WHERE field1 LIKE condition1 [AND [OR]] filed2 = &apos;somevalue&apos;</span><br></pre></td></tr></table></figure></li><li><p>in/not in</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tb1 where a [not] in (value1,value2,value3)</span><br></pre></td></tr></table></figure></li><li><p>between/not between</p></li><li><p>exists/not exists</p></li><li><p>全选/全不选<br>where 1=1 表示选择全部<br>where 1=2 表示全部不选，</p></li><li><p>分页</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">declare @start int,@end int</span><br><span class="line">@sql  nvarchar(600)</span><br><span class="line">set @sql=’select top’+str(@end-@start+1)+’+from T where rid not in(select top’+str(@str-1)+’Rid from T where Rid&gt;-1)’</span><br><span class="line">exec sp_executesql @sql</span><br></pre></td></tr></table></figure></li><li><p>删除重复记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1),delete from tablename where id not in (select max(id) from tablename group by col1,col2,...)</span><br><span class="line">2),select distinct * into temp from tablename</span><br><span class="line">delete from tablename</span><br><span class="line">insert into tablename select * from temp</span><br></pre></td></tr></table></figure></li><li><p>列出数据库里所有的表名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name from sysobjects where type=&apos;U&apos; // U代表用户</span><br></pre></td></tr></table></figure></li><li><p>列出表里的所有的列名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select name from syscolumns where id=object_id(&apos;TableName&apos;)</span><br><span class="line">select column_name,data_type from information_schema.columns</span><br><span class="line">where table_name = &apos;表名&apos;   //查询某一个表的字段和数据类型</span><br></pre></td></tr></table></figure></li><li><p>获取当前数据库中的所有用户表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select Name from sysobjects where xtype=&apos;u&apos; and status&gt;=0</span><br></pre></td></tr></table></figure></li></ul><h2 id="多表操作"><a href="#多表操作" class="headerlink" title="多表操作"></a>多表操作</h2><h3 id="union"><a href="#union" class="headerlink" title="union"></a>union</h3><p>通过组合其他两个结果表（例如 TABLE1 和 TABLE2）并消去表中任何重复行而派生出一个结果表。当 ALL 随 UNION 一起使用时（即 UNION ALL），不消除重复行。两种情况下，派生表的每一行不是来自 TABLE1 就是来自 TABLE2。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT expression1, expression2, ... expression_n</span><br><span class="line">FROM tb1</span><br><span class="line">[WHERE conditions]</span><br><span class="line">UNION [ALL | DISTINCT]</span><br><span class="line">SELECT expression1, expression2, ... expression_n</span><br><span class="line">FROM tb2</span><br><span class="line">[WHERE conditions];</span><br><span class="line"></span><br><span class="line">DISTINCT: 可选，删除结果集中重复的数据。默认情况下 UNION 操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没啥影响。</span><br><span class="line">ALL: 可选，返回所有结果集，包含重复数据。</span><br></pre></td></tr></table></figure></p><h3 id="EXCEPT"><a href="#EXCEPT" class="headerlink" title="EXCEPT"></a>EXCEPT</h3><p>通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个结果表。当 ALL 随 EXCEPT 一起使用时 (EXCEPT ALL)，不消除重复行。</p><h3 id="INTERSECT"><a href="#INTERSECT" class="headerlink" title="INTERSECT"></a>INTERSECT</h3><p>通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表。当 ALL 随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。</p><p>注：使用运算词的几个查询结果行必须是一致的。 </p><h3 id="分组：group-by"><a href="#分组：group-by" class="headerlink" title="分组：group by"></a>分组：group by</h3><p>count,sum,max,min,avg</p><h3 id="连接：join"><a href="#连接：join" class="headerlink" title="连接：join"></a>连接：join</h3><ul><li><p>INNER JOIN（内连接,或等值连接）：获取两个表中字段匹配关系的记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT a.col1, a.col2, b.col3 FROM tb1 a INNER JOIN tb2 b</span><br><span class="line">ON a.col1 = b.col1;</span><br><span class="line">等价于</span><br><span class="line">SELECT a.col1, a.col2, b.col3 FROM tb1 a, tb2 b </span><br><span class="line">WHERE a.col1 = b.col1;</span><br></pre></td></tr></table></figure></li><li><p>LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT a.col1, a.col2, b.col3 FROM tb1 a LEFT JOIN tb2 b </span><br><span class="line">ON a.col1 = b.col1;</span><br></pre></td></tr></table></figure></li><li><p>RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT a.col1, a.col2, b.col3 FROM tb1 a RIGHT JOIN tb2 b </span><br><span class="line">ON a.col1 = b.col1;</span><br></pre></td></tr></table></figure></li></ul><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h3 id="临时表"><a href="#临时表" class="headerlink" title="临时表"></a>临时表</h3><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java搭建springMVC项目笔记</title>
      <link href="/2017/06/08/Java%E6%90%AD%E5%BB%BAspringMVC%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/06/08/Java%E6%90%AD%E5%BB%BAspringMVC%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="MyEclipse搭建项目"><a href="#MyEclipse搭建项目" class="headerlink" title="MyEclipse搭建项目"></a>MyEclipse搭建项目</h1><ul><li>创建命名空间namespace</li><li>新建项目 new -&gt; project</li><li>添加tomcat,jdk</li><li>运行</li><li>访问：<a href="http://localhost:8080/project_name/" target="_blank" rel="noopener">http://localhost:8080/project_name/</a><a id="more"></a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">nested exception is org.springframework.core.NestedIOException: ASM ClassReader failed to parse class file - probably due to a new Java class file version that isn&apos;t supported yet</span><br><span class="line">...</span><br><span class="line">nested exception is java.lang.IllegalArgumentException</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>解决方法：<br>在项目上右键–properties–java Compile–compiler compliance level</p><p>在工程目录下添加config文件夹，下面添加文件：jdbc.properties,spring-mvc.xml,spring-mybatis.xml<br><img src="/assets/20170609_java/java_config.png" alt="spring-config"></p><ul><li>jdbc.properties：mysql配置</li><li>spring-mvc.xml<ul><li>context -&gt; base-package: 包的跟路径</li><li>bean -&gt; prefix: /WEB-INF/page/下放.jsp文件<br>  mvc -&gt; bean: utl 的根路径</li><li>spring-mybatis.xml: <ul><li>context -&gt; base-package: 包的根路径</li><li>bean -&gt; base-package: dao的根路径</li><li>aop -&gt; expression: service的根路径</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java开发环境配置</title>
      <link href="/2017/06/06/java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2017/06/06/java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>Java开发需要：<br>1.JDK (Java Deverlopment Kit)<br>Java开发工具包(JDK)是一个用于开发Java应用程序和小程序的软件开发环境。<br>它包括Java运行时环境(JRE)，编译器/加载程序(JAVA)，编译器(javac)，归档器(jar)，文档生成(Javadoc)以及 Java 开发的其他工具。<br><a id="more"></a><br>2.IDE (Integrated Development Environment)<br>集成开发环境：MyEclipse,IDEA</p><h1 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h1><h2 id="1-下载：http-tomcat-apache-org"><a href="#1-下载：http-tomcat-apache-org" class="headerlink" title="1.下载：http://tomcat.apache.org"></a>1.下载：<a href="http://tomcat.apache.org" target="_blank" rel="noopener">http://tomcat.apache.org</a></h2><h2 id="2-修改权限，否则会提示permission-denny错误："><a href="#2-修改权限，否则会提示permission-denny错误：" class="headerlink" title="2.修改权限，否则会提示permission denny错误："></a>2.修改权限，否则会提示<code>permission denny</code>错误：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 755 xxx/bin/*.sh  (xxx表示你tomcat放至的路径)</span><br></pre></td></tr></table></figure><h2 id="3-将Tomcat写入系统的环境变量PATH中。"><a href="#3-将Tomcat写入系统的环境变量PATH中。" class="headerlink" title="3.将Tomcat写入系统的环境变量PATH中。"></a>3.将Tomcat写入系统的环境变量PATH中。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pico .bash_profile</span><br></pre></td></tr></table></figure><p>在打开的页面中，输入以下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:tomcat_dir/bin;  </span><br><span class="line">export PATH=$PATH:tomcat_dir/logs;</span><br></pre></td></tr></table></figure></p><p>其中tomcat_dir为tomcat根目录<br>接着按下 control+x，再按 y 表示确定修改，最后回车。</p><p>验证是否成功</p><blockquote><p>$ echo $PATH<br>显示如下:<br>$ -bash: /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Users/fuhua/Documents/Tomcat/apache-tomcat-8.0.30/bin: No such file or directory<br>需要重新启动计算机，以便完成系统环境变量的配置。</p></blockquote><h2 id="4-启动Tomcat"><a href="#4-启动Tomcat" class="headerlink" title="4.启动Tomcat."></a>4.启动Tomcat.</h2><ul><li>如果你完成将Tomcat写入系统的环境变量PATH中，你可以直接在终端输入 startup.sh ；</li><li><p>如果你没有完成，那么就要定位到Tomcat的bin目录中，如在终端输入 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd tomcat_dir/bin</span><br><span class="line">$ startup.sh</span><br><span class="line">Tomcat started.</span><br></pre></td></tr></table></figure></li><li><p>在浏览器中输入<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a><br>如果出现Apache Tomcat界面，代表 tomcat 启动成功。</p></li></ul><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><ul><li>下载：<a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">MySQL官网</a></li><li>安装完成时记得保存弹出框中的密码，这是mysql root账号和密码</li><li>系统偏好设置中，点击MySQL开启MySQL Server服务<h2 id="修改root账户密码"><a href="#修改root账户密码" class="headerlink" title="修改root账户密码"></a>修改root账户密码</h2></li><li>关闭MySQL Server服务</li><li>终端输入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 苹果系统下 mysql server 的安装地址</span><br><span class="line">$ cd /usr/local/mysql/bin/</span><br><span class="line">// 登录管理员权限</span><br><span class="line">$ sudo su</span><br><span class="line">// 禁止 mysql 验证功能</span><br><span class="line">sh-3.2# ./mysqld_safe --skip-grant-tables &amp;</span><br><span class="line">//终端输出</span><br><span class="line">[1] 2487</span><br><span class="line">sh-3.2# Logging to &apos;/usr/local/mysql-5.7.18-macos10.12-x86_64/data/192.168.1.143.err&apos;.</span><br><span class="line">2017-06-06T06:35:36.6NZ mysqld_safe Starting mysqld daemon with databases from /usr/local/mysql-5.7.18-macos10.12-x86_64/data</span><br><span class="line">sh-3.2# ./mysql</span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 3</span><br><span class="line">Server version: 5.7.18 MySQL Community Server (GPL)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.</span><br><span class="line"></span><br><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos; = PASSWORD(&apos;123456&apos;);</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure></li></ul><h2 id="安装MySQL-Workbench"><a href="#安装MySQL-Workbench" class="headerlink" title="安装MySQL Workbench"></a>安装MySQL Workbench</h2><p><a href="https://dev.mysql.com/downloads/workbench/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/workbench/</a><br>MySQL connections + ：输入connection name创建新链接</p><h2 id="加入系统环境变量"><a href="#加入系统环境变量" class="headerlink" title="加入系统环境变量"></a>加入系统环境变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ cd /usr/local/mysql/bin</span><br><span class="line">$ ls</span><br><span class="line">//查看目录中是否有mysql</span><br><span class="line">$ vim ~/.bash_profile</span><br><span class="line">//在该文件中添加 PATH=$PATH:/usr/local/mysql/bin</span><br><span class="line">$ source ~/.bash_profile</span><br><span class="line">$ mysql -uroot -p   //登录mysql</span><br><span class="line">//输入密码后，登录成功会显示：</span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 22</span><br><span class="line">Server version: 5.7.18 MySQL Community Server (GPL)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.</span><br></pre></td></tr></table></figure><p>可以通过以下名录修改密码：</p><blockquote><p>$ $ SET PASSWORD FOR ‘root‘@’localhost’ = PASSWORD(‘newpass’);</p></blockquote><h1 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h1><h2 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h2><h3 id="下载：JDK官网"><a href="#下载：JDK官网" class="headerlink" title="下载：JDK官网"></a>下载：<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">JDK官网</a></h3><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li>mac自带jdk，安装目录：/System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home</li><li>自己安装目录：/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home<h3 id="配置jdk环境变量"><a href="#配置jdk环境变量" class="headerlink" title="配置jdk环境变量"></a>配置jdk环境变量</h3>（1）只针对当前用户<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ touch ~/.bash_profile  </span><br><span class="line">$ vim ~/.bash_profile</span><br></pre></td></tr></table></figure></li></ul><p>在编辑器中添加如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home</span><br><span class="line">CLASSPAHT=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">PATH=$JAVA_HOME/bin:$PATH:</span><br><span class="line">export JAVA_HOME</span><br><span class="line">export CLASSPATH</span><br><span class="line">export PATH</span><br></pre></td></tr></table></figure></p><p>使系统变量生效，使用以下命令或重启电脑：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ source .bash_profile</span><br></pre></td></tr></table></figure></p><p>查看java版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -version</span><br></pre></td></tr></table></figure></p><p>检查系统变量是否生效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo $JAVA_HOME</span><br></pre></td></tr></table></figure></p><p>（2）针对所有用户<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /etc</span><br><span class="line">$ sudo vi profile</span><br></pre></td></tr></table></figure></p><p>在编辑器最下面添加如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home</span><br><span class="line">CLASSPAHT=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">PATH=$JAVA_HOME/bin:$PATH:</span><br></pre></td></tr></table></figure></p><p>接下来同上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ source .bash_profile</span><br><span class="line">$ java -version</span><br><span class="line">$ echo $JAVA_HOME</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS调试与优化技巧</title>
      <link href="/2017/06/05/iOS%E8%B0%83%E8%AF%95%E4%B8%8E%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7/"/>
      <url>/2017/06/05/iOS%E8%B0%83%E8%AF%95%E4%B8%8E%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><h3 id="全局断点（Global-BreakPoint）"><a href="#全局断点（Global-BreakPoint）" class="headerlink" title="全局断点（Global BreakPoint）"></a>全局断点（Global BreakPoint）</h3><h3 id="异常断点（Exception-Breakpoint）"><a href="#异常断点（Exception-Breakpoint）" class="headerlink" title="异常断点（Exception Breakpoint）"></a>异常断点（Exception Breakpoint）</h3><p>项目crash时，添加异常断点运行，会定位到出错的代码行</p><h3 id="条件断点（Condational-Breakpoint）"><a href="#条件断点（Condational-Breakpoint）" class="headerlink" title="条件断点（Condational Breakpoint）"></a>条件断点（Condational Breakpoint）</h3><p>右击断点，condition中添加触发断点的条件，比如循环中使用</p><h3 id="符号断点（Symbolic-Breakpoint）"><a href="#符号断点（Symbolic-Breakpoint）" class="headerlink" title="符号断点（Symbolic Breakpoint）"></a>符号断点（Symbolic Breakpoint）</h3><ul><li>Symbol中输入 viewDidLoad，则在程序中所有的 viewDidLoad 方法被调用时都会触发断点。</li><li>我们也可以仅仅为特定的某个类的方法添加断点。在 Symbol 一栏输入 [ClassName viewDidLoad] (Objective-C) 或 ClassName.viewDidLoad (Swift) 即可。</li><li>unrecognized selector sent to instance 0xaxxxx 这种错误，这个instance可以这样快速定位：-[NSObject(NSObject) doesNotRecognizeSelector:]</li></ul><h2 id="打印日志-NSLog"><a href="#打印日志-NSLog" class="headerlink" title="打印日志 NSLog"></a>打印日志 NSLog</h2><p>NSLog的打印是非常低效的，甚至比print低100倍，以下NSLog更高效，并且可以获取更多信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//A better version of NSLog</span><br><span class="line">#define NSLog(format, ...) do &#123; \</span><br><span class="line">fprintf(stderr, &quot;&lt;%s : %d&gt; %s\n&quot;, \</span><br><span class="line">[[[NSString stringWithUTF8String:__FILE__] lastPathComponent] UTF8String], \</span><br><span class="line">__LINE__, __func__); \</span><br><span class="line">(NSLog)((format), ##__VA_ARGS__); \</span><br><span class="line">fprintf(stderr, &quot;-------\n&quot;); \</span><br><span class="line">&#125; while (0)</span><br></pre></td></tr></table></figure></p><p><code>使用do-while是为了避免吃掉分号问题</code></p><ul><li>不知道%@，%d的时候可以使用全局方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSStringFromClass</span><br><span class="line">NSStringFromCGRect</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><h2 id="僵尸对象"><a href="#僵尸对象" class="headerlink" title="僵尸对象"></a>僵尸对象</h2><p>开启：edit scheme-&gt;Diagnostics-&gt;Zombie Objects，当访问已经被释放的对象时将会获取到更多的信息。</p><h2 id="LLVM-lldb"><a href="#LLVM-lldb" class="headerlink" title="LLVM lldb"></a>LLVM lldb</h2><p>LLVM：编译器<br>lldb：LLVM的调试器</p><h3 id="expression"><a href="#expression" class="headerlink" title="expression"></a>expression</h3><p>可以在调试时动态执行指定表达式，并将结果打印出来。常用于在调试过程中修改变量的值。<br>expression的完整语法是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expression &lt;cmd-options&gt; -- &lt;expr&gt;&lt;/expr&gt;</span><br></pre></td></tr></table></figure></p><h3 id="p-amp-print-amp-call"><a href="#p-amp-print-amp-call" class="headerlink" title="p &amp; print &amp; call"></a>p &amp; print &amp; call</h3><p>一般情况下，我们直接用expression还是用得比较少的，更多时候我们用的是p、print、call。这三个命令其实都是expression –的别名（–表示不再接受命令选项，详情见前面原始(raw）命令这一节）</p><ol><li>print: 打印某个东西，可以是变量和表达式</li><li>p: 可以看做是print的简写</li><li>call: 调用某个方法。一般只在不需要显示输出，或是方法无返回值时使用</li></ol><h3 id="po"><a href="#po" class="headerlink" title="po"></a>po</h3><p>一般打印的时候，打印出来的是对象的指针，而不是对象本身。如果我们想打印对象。我们需要使用命令选项:-O。为了更方便的使用，LLDB为expression -O –定义了一个别名：po</p><h3 id="frame（帧）"><a href="#frame（帧）" class="headerlink" title="frame（帧）"></a>frame（帧）</h3><p>输入命令<code>bt</code>，可以打印出来所有的frame。如果仔细观察，这些frame和左边红框里的堆栈是一致的。平时我们看到的左边的堆栈就是frame。</p><h3 id="c-amp-n-amp-s-amp-finish"><a href="#c-amp-n-amp-s-amp-finish" class="headerlink" title="c &amp; n &amp; s &amp; finish"></a>c &amp; n &amp; s &amp; finish</h3><ol><li>c/ continue/ thread continue: 这三个命令效果都等同于上图中第一个按钮的。表示程序继续运行</li><li>n/ next/ thread step-over: 这三个命令效果等同于上图第二个按钮。表示单步运行</li><li>s/ step/ thread step-in: 这三个命令效果等同于上图第三个按钮。表示进入某个方法</li><li>finish/ step-out: 这两个命令效果等同于第四个按钮。表示直接走完当前方法，返回到上层frame</li></ol><h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><p>image 命令可用于寻址，有多个组合命令。比较实用的用法是用于寻找栈地址对应的代码位置。</p><ul><li><p>image lookup –address<br>当发生崩溃时，想寻找栈地址对应的代码位置，简写为image lookup -a。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image lookup --address 0x0000000100004af8</span><br></pre></td></tr></table></figure></li><li><p>image lookup –name<br>当我们想查找一个方法或者符号的信息，比如所在文件位置等，尤其当文件被封装为.a库时，简写为image lookup -n。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) image lookup -n dictionaryWithXMLString:</span><br></pre></td></tr></table></figure></li><li><p>image lookup –type<br>当我们想查看一个类型的时候，可以使用image lookup –type，简写为image lookup -t</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) image lookup -t Model</span><br></pre></td></tr></table></figure></li></ul><h2 id="预编译指令"><a href="#预编译指令" class="headerlink" title="预编译指令"></a>预编译指令</h2><h3 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h3><h4 id="include"><a href="#include" class="headerlink" title="#include"></a>#include</h4><p>#include &lt;&gt;：预处理器会搜索C函数库头文件路径下的文件</p><p>#include “”：首先搜索程序所在目录，其次搜索系统Path定义目录，如果还是找不到才会搜索C函数库头文件所在目录。</p><ul><li>使用#include的时候包含文件的时候是不能递归包含，重复包含。替代：1、使用#import替代include 2、使用宏判断<h4 id="import"><a href="#import" class="headerlink" title="#import"></a>#import</h4>OC特有的就是一个智能的#include，解决了#include的重复包含的问题。</li></ul><h3 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h3><p>C中的宏分为两类，对象宏(object-like macro)和函数宏(function-like macro)。<br>可以使用<code>\</code>将宏分成了好几行来写。</p><h4 id="define"><a href="#define" class="headerlink" title="#define"></a>#define</h4><h4 id="undef"><a href="#undef" class="headerlink" title="#undef"></a>#undef</h4><p>当你使用了#define宏定义后，则在整个程序的运行周期内这个宏都是有效的，但有时候我们在某个逻辑里希望这个宏失效不想使用，则会使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define NetworkOn //定义一个宏，如果该宏定义了，则在应用里使用网络</span><br><span class="line">-(void)closeNetwork&#123;//突然发生意外的情况，网络无法使用了，调用该方法，取消NetworkOn的宏定义</span><br><span class="line">#undef NetworkOn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><h4 id="if-else-endif"><a href="#if-else-endif" class="headerlink" title="#if #else #endif"></a>#if #else #endif</h4><p>判断是否开启ARC<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#if !__has_feature(objc_arc)</span><br><span class="line">//如果没有开启ARC这里可以做一些错误处理</span><br><span class="line">#error &quot;没有开启ARC&quot;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><p>判断系统版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#if __IPHONE_OS_VERSION_MIN_REQUIRED &lt; __IPHONE_7_0</span><br><span class="line">//如果iOS版本低于7.0</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><p>判断设备信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define IS_IPAD (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad)</span><br><span class="line">#if IS_IPAD</span><br><span class="line">//这台设备是IPAD</span><br><span class="line">#else</span><br><span class="line">//不是</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><h4 id="if-define-ifdef-ifndef-elif"><a href="#if-define-ifdef-ifndef-elif" class="headerlink" title="#if define #ifdef #ifndef #elif"></a>#if define #ifdef #ifndef #elif</h4><p>#if define = #ifdef</p><p>#if !define = #ifndef</p><p>#elif = “else if”</p><h3 id="错误、警告处理"><a href="#错误、警告处理" class="headerlink" title="错误、警告处理"></a>错误、警告处理</h3><h4 id="error"><a href="#error" class="headerlink" title="#error"></a>#error</h4><h4 id="warning"><a href="#warning" class="headerlink" title="#warning"></a>#warning</h4><p>Build Settings-&gt;Treat Warning as Errors，如果你设置成Yes，那么你的waring就等于error，编译不了。</p><ul><li><p>创建一个警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//Generate a warning</span><br><span class="line">#pragma message &quot;Warning 1&quot;</span><br><span class="line"></span><br><span class="line">//Another way to generate a warning</span><br><span class="line">#warning &quot;Warning 2&quot;</span><br></pre></td></tr></table></figure></li><li><p>关闭警告<br>如果需要全局关闭的话，直接在Other C Flags里写-Wno-…就行了，比如-Wextra -Wno-sign-compare就是一个常见的组合。<br>如果相对某几个文件开启或禁用警告，在Build Phases的Compile Source相应的文件中加入对应的编译标识即可。<br>如果只是想在某几行关闭某个警告的话，可以通过临时改变诊断编译标记来抑制指定类型的警告，具体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wunused-variable&quot;</span><br><span class="line"></span><br><span class="line">int a;</span><br><span class="line"></span><br><span class="line">#pragma clang diagnostic pop</span><br></pre></td></tr></table></figure></li></ul><h3 id="编译器控制"><a href="#编译器控制" class="headerlink" title="编译器控制"></a>编译器控制</h3><h4 id="pragma"><a href="#pragma" class="headerlink" title="#pragma"></a>#pragma</h4><p>#pragma mark</p><p>#pragma mark -<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;clang的参数&quot;</span><br><span class="line">#pragma clang diagnostic pop</span><br></pre></td></tr></table></figure></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h3 id="line"><a href="#line" class="headerlink" title="#line"></a>#line</h3><p>改变当前行的行号在编译器中的表示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#line 100  //指定下一行的__LINE__为100</span><br><span class="line">printf(&quot;%d\n&quot;,__LINE__);</span><br></pre></td></tr></table></figure></p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><h2 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h2><ul><li>静态内存分析：指在程序未运行时，通过工具对代码直接进行分析，根据代码的上下文语法结构，让编译器分析内存情况，检查是否有内存泄露。<h3 id="Analyze主要分析四种问题"><a href="#Analyze主要分析四种问题" class="headerlink" title="Analyze主要分析四种问题"></a>Analyze主要分析四种问题</h3></li><li>1.逻辑错误：访问空指针或未初始化的变量等，建议在声明变量时，同时进行初始化。（len is a garbage value。）</li><li>2.内存管理错误：如内存泄露等（Potential leak of an object stored into ‘XXX’。）</li><li>3.声明错误：创建了对象但未使用（Unused、Never read….）</li><li>4.API调用错误：未包含使用的库或框架</li></ul><h2 id="Instruments"><a href="#Instruments" class="headerlink" title="Instruments"></a>Instruments</h2><h3 id="Activity-Monitor（活动监视器）：监控进程的CPU-内存-磁盘"><a href="#Activity-Monitor（活动监视器）：监控进程的CPU-内存-磁盘" class="headerlink" title="Activity Monitor（活动监视器）：监控进程的CPU,内存,磁盘"></a>Activity Monitor（活动监视器）：监控进程的CPU,内存,磁盘</h3><h3 id="Time-Profile"><a href="#Time-Profile" class="headerlink" title="Time Profile"></a>Time Profile</h3><p>注意：<br>1.使用真机调试<br>2.使用发布配置</p><p>1在底部的Call Tree中勾选：<br><a id="more"></a></p><ul><li>Seperate by state：</li><li>Separate by Thread（建议选择）：每个线程被单独考虑。这能让你知道哪一个线程占用CPU最多。</li><li>Invert Call Tree（不建议选择）：选中该选项后，调用栈会自上至下显示。这通常是你需要的，因为你想知道CPU花费时间的那个最深的方法。</li><li>Hide system Libraries（建议选择）：隐藏系统库文件。过滤掉各种系统调用，只显示自己的代码调用。</li><li>Flatten Recursion（一般不选）：拼合递归，将每一个调用栈中的递归函数（调用它们自身的函数）视作单一入口，而不是多入口。</li><li>Top Functions（可选）：将花费在一个函数中的总时间视作在该函数中直接花费的时间加上调用的其他函数花费的时间。找到最耗时的函数或方法，选上后会将最耗时的函数降序排列，比如A调用了B，A的耗时时间是会包含B的耗时。</li></ul><p>2.配置项目<br>scheme-&gt;profile-&gt;Build Configuration：Debug<br>project-&gt;debug information format-&gt;debug：DWARF with dSYM File</p><p>3 运行项目<br>在time profiler中，选择对应的device和process，点击红色按钮运行APP。</p><ul><li>可以拖动时间轴查看其中一段时间的CPU使用情况</li><li>可以点击weight，按照时间消耗进行排序<br>选择真机运行APP，模拟器使用的是电脑的CPU</li></ul><h3 id="内存泄露-Leaks"><a href="#内存泄露-Leaks" class="headerlink" title="内存泄露 Leaks"></a>内存泄露 Leaks</h3><p>leaks:自动加载Allocations，监控程序运行过程中的内存变化<br><strong> 内存溢出/内存泄露 </strong></p><ul><li>内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。</li><li>内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。memory leak会最终会导致out of memory！</li></ul><p>如果出现红色的叉，说明有内存泄露问题。<br>修复：暂停-&gt;leak checks-&gt;点击红色的叉-&gt;call tree-&gt;hide system libraries-&gt;点击展开到最后不能展开的代码为止-&gt;双击定位到具体代码</p><p>一般检测内存泄露：（1）Instruments－Leaked （2）Analyze</p><h3 id="Allocations"><a href="#Allocations" class="headerlink" title="Allocations"></a>Allocations</h3><p>内存泄漏分两种：</p><ul><li>Leaked Memory：为对象A申请了内存空间，之后再也没用到A，也没有释放A导致内存泄漏。</li><li>Abandoned Memory（被遗弃的内存）：类似于递归，不断的申请内存导致的内存泄漏。</li></ul><h3 id="Core-Animation"><a href="#Core-Animation" class="headerlink" title="Core Animation"></a>Core Animation</h3><p>一般FPS是60左右，低于45的话需要进行优化。<br>调试选项：真机，run，Xcode-&gt;debug-&gt;View Debugging-&gt;Rendering-&gt;</p><ul><li>Color Blended Layers（图层混合）<br>这个选项基于渲染程度对屏幕中的混合区域进行绿到红的高亮显示。由于重绘的原因，混合对GPU性能有影响，同时也是滑动和动画帧率下降的罪魁祸首之一。<br>可以这样做：<br>1.给视图的backgroundColor属性设置一个固定的，不透明的颜色<br>2.设置opaque属性为YES</li><li>Color Hits Green and MissesRed（光栅化）<br>光栅化是将一个layer预先渲染成位图(bitmap)，然后加入缓存中。如果对于阴影效果这样比较消耗资源的静态内容进行缓存，可以得到一定幅度的性能提升。demo中的这一行代码表示将label的layer光栅化：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label.layer.shouldRasterize = YES;</span><br></pre></td></tr></table></figure></li></ul><p>图层的以下属性将会触发屏幕外绘制：<br>1.圆角（当和maskToBounds一起使用时）<br>2.图层蒙板<br>3.阴影</p><p>有时候我们可以把那些需要屏幕外绘制的图层开启光栅化以作为一个优化方式，前提是这些图层并不会被频繁地重绘。<br>对于那些需要动画而且要在屏幕外渲染的图层来说，你可以用CAShapeLayer，contentsCenter或者shadowPath来获得同样的表现而且较少地影响到性能。</p><ul><li>Color Copied Images （颜色格式）<br>有时候寄宿图片的生成意味着Core Animtaion 被强制生成一些图片，然后发送到渲染服务器，而不是简单的指向原始指针。这个选项把这些图片渲染成蓝色。复制图片对内存和CPU使用来说，是一项非常昂贵的操作，所以应该尽可能避免。</li><li>Color Non-Standard Surface Formats</li><li>Color immediately<br>通常 Core Animation Instrument 以每秒以每秒十次的频率更新图层调试颜色。对某些效果来说，这显然太慢了，这个选项就可以设置每帧都更新（可能会影响到渲染性能，而且会导致帧率测量不准，所以不要一直都设置它）。</li><li>Color misaligned Images （图片大小）<br>这里会高亮那些被缩放或者拉伸，以及没有正确对起到像素边界的图片。这些中大多数通常会导致图片的不正常缩放，如果把一张大图当缩略图显示，或者不正确的模糊图像。那么这个选项会帮你识别出问题所在。</li><li>Color Offscreen-Rendered Yellow （离屏渲染）<br>这里会把那些需要离屏渲染的图层高亮成黄色。这些图层很可能需要用shadowPath或者shouldRasterize来优化。</li><li>Color Compositing Fast Path Blue （快速路径）<br>这个选项会对任何使用OpenGL绘制的图层进行高亮。如果仅仅使用UIKit或者Core Animtaion的API，那么不会有任何效果。</li><li>Flash Updated Regions （变化区域）<br>这个选项会对重绘的内容高亮成黄色（也就是任何现在软件层面使用Core Animtaion绘制的图层）。这种绘图的速度很慢，如果频繁发生这种情况的话，这意味着有一个隐藏的bug，或者说通过增加缓存，或使用替代方案会有提示的空间。</li></ul><p><strong> 总结 </strong></p><p>1、避免图层混合<br>①、确保控件的opaque属性设置为true，确保backgroundColor和父视图颜色一致且不透明；<br>②、如无特殊需要，不要设置低于1的alpha值；<br>③、确保UIImage没有alpha通道；</p><p>2、避免临时转换<br>①、确保图片大小和frame一致，不要在滑动时缩放图片；<br>②、确保图片颜色格式被GPU支持，避免劳烦CPU转换；</p><p>3、慎用离屏渲染<br>①、绝大多数时候离屏渲染会影响性能；<br>②、重写drawRect方法，设置圆角、阴影、模糊效果，光栅化都会导致离屏渲染；<br>③、设置阴影效果是加上阴影路径；<br>④、滑动时若需要圆角效果，开启光栅化；</p><h3 id="僵尸对象-Zoombies"><a href="#僵尸对象-Zoombies" class="headerlink" title="僵尸对象 Zoombies"></a>僵尸对象 Zoombies</h3><p>在项目中经常见到的“EXC_BAD_ACCESS”就是访问了被释放的内存地址造成的。<br>在用Zombies模版时使用iOS模拟器比真机要好。</p><p>另外XCode也提供了手动设置NSZombieEnabled环境变量的方法：Edit Scheme-&gt;勾选Enable Zombie Objects。<br>不过设置NSZombieEnabled为True后，会导致内存占用的增长，同时会影响Leaks工具的调试，这是因为设置NSZombieEnabled会用僵尸对象来代替已释放对象。</p><ul><li>重要概念：<br>1、内存泄漏：对象使用完没有释放，导致内存浪费。<br>2、僵尸对象：已经被销毁的对象(不能再使用的对象)<br>3、野指针：指向僵尸对象(不可用内存)的指针。给野指针发消息会报EXC_BAD_ACCECC错误。<br>4、空指针：没有指向储存空间的指针(里面存的是nil,也就是0)。在oc中使用空指针调中方法不会报错。<br>注意:为了避免野指针错误的常见方法:在对象被销毁之后,将指向对象的指针变为空指针。</li></ul><p>学习资料：<br><a href="https://www.raywenderlich.com/97886/instruments-tutorial-with-swift-getting-started" target="_blank" rel="noopener">《How to Use Instruments in Xcode》</a><br><a href="https://objccn.io/issue-19-2/" target="_blank" rel="noopener">《与调试器共舞 - LLDB 的华尔兹》</a><br><a href="http://www.starfelix.com/blog/2014/03/17/lldbdiao-shi-ming-ling-chu-tan/" target="_blank" rel="noopener">《LLDB调试命令初探》</a><br><a href="http://lldb.llvm.org/tutorial.html" target="_blank" rel="noopener">《The LLDB Debugger》</a><br><a href="https://developer.apple.com/library/mac/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/Introduction.html" target="_blank" rel="noopener">《About LLDB and Xcode》</a><br><a href="https://www.cnblogs.com/lxlx1798/p/6652821.html" target="_blank" rel="noopener">浅谈LLDB调试器</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>798艺术区</title>
      <link href="/2017/06/04/798%E8%89%BA%E6%9C%AF%E5%8C%BA/"/>
      <url>/2017/06/04/798%E8%89%BA%E6%9C%AF%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="2017-06-04-北京798艺术区"><a href="#2017-06-04-北京798艺术区" class="headerlink" title="2017-06-04 北京798艺术区"></a>2017-06-04 北京798艺术区</h2><center><img src="/assets/20170640_798/line.jpeg" alt="“抽象画”"></center><br><a id="more"></a><br><center>抽象画</center><br><center><img src="/assets/20170640_798/chinese.jpeg" alt="“陶瓷”"></center><br><center>各种小陶瓷</center><center><img src="/assets/20170640_798/cat.jpeg" alt="“卡哇伊”"> </center><br><center>猫咪，卡哇伊</center><center><img src="/assets/20170640_798/brain.jpeg" alt="“brain”"> </center><br><center>brain</center><center><img src="/assets/20170640_798/redpeople.jpeg" alt="“red people”"></center><br><center>red people</center><center><img src="/assets/20170640_798/unknown.jpeg" alt="“未名”"> </center><br><center>未名</center><center><img src="/assets/20170640_798/child.jpeg" alt="“孤独的小孩”"> </center><br><center>孤独的小孩</center><center><img src="/assets/20170640_798/lover.jpeg" alt="“恋人”"> </center><br><center>恋人</center><center><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28476557&auto=1&height=66"></iframe></center>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>MVVM学习笔记</title>
      <link href="/2017/05/20/MVVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/05/20/MVVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="MVVM（Model-View-View-Mode）的四个组件："><a href="#MVVM（Model-View-View-Mode）的四个组件：" class="headerlink" title="MVVM（Model View View-Mode）的四个组件："></a>MVVM（Model View View-Mode）的四个组件：</h2><ul><li>view ：由 MVC 中的 view 和 controller 组成，负责 UI 的展示，绑定 viewModel 中的属性，触发 viewModel 中的命令；在MVVM中，Controller可以当作一个重量级的View（负责界面切换和处理各类系统事件）。</li><li>viewModel ：从 MVC 的 controller 中抽取出来的展示逻辑，负责从 model 中获取 view 所需的数据，转换成 view 可以展示的数据，并暴露公开的属性和命令供 view 进行绑定；</li><li>model ：与 MVC 中的 model 一致，包括数据模型、访问数据库的操作和网络请求等；<a id="more"></a></li><li>binder ：在 MVVM 中，声明式的数据和命令绑定是一个隐含的约定，它可以让开发者非常方便地实现 view 和 viewModel 的同步，避免编写大量繁杂的样板化代码。</li><li>viewModel之间可以有依赖<br>总结：在 iOS 的 MVVM 实现中，我们可以使用 RAC 来在 view 和 viewModel 之间充当 binder 的角色，优雅地实现两者之间的同步。此外，我们还可以把 RAC 用在 model 层，使用 Signal 来代表异步的数据获取操作，比如读取文件、访问数据库和网络请求等。</li></ul><h3 id="引用规则"><a href="#引用规则" class="headerlink" title="引用规则"></a>引用规则</h3><ul><li>view 引用viewModel ，反之没有（viewModel 绝对不能包含视图 view（UIKit.h），不然就跟 view 产生了耦合，不方便复用和测试）</li><li>viewModel 引用model，反之没有</li></ul><h2 id="实现MVC到MVVM的转变"><a href="#实现MVC到MVVM的转变" class="headerlink" title="实现MVC到MVVM的转变"></a>实现MVC到MVVM的转变</h2><blockquote><p>将 MVC 中的 controller 中的展示逻辑抽取出来，放置到 viewModel 中，然后通过一定的技术手段，比如 RAC 来同步 view 和 viewModel。</p></blockquote><h2 id="MVVM相较于MVM的优势"><a href="#MVVM相较于MVM的优势" class="headerlink" title="MVVM相较于MVM的优势"></a>MVVM相较于MVM的优势</h2><ul><li>由于展示逻辑被抽取到了 viewModel 中，所以 view 中的代码将会变得非常轻量级；</li><li>由于 viewModel 中的代码是与 UI 无关的，所以它具有良好的可测试性；</li><li>使用MVVM会轻微的增加代码量，但总体上减少了代码的复杂性</li></ul><p>参考链接：<a href="http://blog.leichunfeng.com/blog/2016/02/27/mvvm-with-reactivecocoa/" target="_blank" rel="noopener">MVVM With ReactiveCocoa</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ReactiveCocoa学习笔记</title>
      <link href="/2017/05/20/ReactiveCocoa%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/05/20/ReactiveCocoa%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>ReactiveCocoa(RAC):是函数响应式编程(Functional Reactive Programming:FRP)框架，高聚合、低耦合思想。<br>使用cocoapods导入时加上<code>use_frameworks!</code><br><a id="more"></a></p><h2 id="ReactiveCocoa常见类"><a href="#ReactiveCocoa常见类" class="headerlink" title="ReactiveCocoa常见类"></a>ReactiveCocoa常见类</h2><h3 id="RACSiganl-信号类-核心"><a href="#RACSiganl-信号类-核心" class="headerlink" title="RACSiganl:信号类(核心)"></a>RACSiganl:信号类(核心)</h3><p>一般表示将来有数据传递，只要有数据改变，信号内部接收到数据，就会马上发出数据。</p><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ul><li>信号类(RACSiganl)，只是表示当数据改变时，信号内部会发出数据，它本身不具备发送信号的能力，而是交给内部一个订阅者去发出。</li><li>默认一个信号都是冷信号，也就是值改变了，也不会触发，只有订阅了这个信号，这个信号才会变为热信号，值改变了才会触发。</li><li>如何订阅信号：调用信号RACSignal的subscribeNext就能订阅。</li></ul><h4 id="RACSiganl简单使用"><a href="#RACSiganl简单使用" class="headerlink" title="RACSiganl简单使用"></a>RACSiganl简单使用</h4><ul><li><p>1.创建信号 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ + (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe</span><br></pre></td></tr></table></figure></li><li><p>2.订阅信号,才会激活信号. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock</span><br></pre></td></tr></table></figure></li><li><p>3.发送信号 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ - (void)sendNext:(id)value</span><br></pre></td></tr></table></figure></li></ul><h4 id="RACSignal底层实现"><a href="#RACSignal底层实现" class="headerlink" title="RACSignal底层实现"></a>RACSignal底层实现</h4><ul><li>1.创建信号，首先把didSubscribe保存到信号中，还不会触发。</li><li>2.当信号被订阅，也就是调用signal的subscribeNext:nextBlock<ul><li>2.1 subscribeNext内部会创建订阅者subscriber，并且把nextBlock保存到subscriber中。</li><li>2.2 subscribeNext内部会调用signal的didSubscribe</li></ul></li><li>3.siganl的didSubscribe中调用[subscriber sendNext:@1];<ul><li>3.1 sendNext底层其实就是执行subscriber的nextBlock<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 1.创建信号</span><br><span class="line">RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line"></span><br><span class="line">    // block调用时刻：每当有订阅者订阅信号，就会调用block。</span><br><span class="line">    // 2.发送信号</span><br><span class="line">    [subscriber sendNext:@1];</span><br><span class="line">    // 如果不在发送数据，最好发送信号完成，内部会自动调用[RACDisposable disposable]取消订阅信号。</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">        // block调用时刻：当信号发送完成或者发送错误，就会自动执行这个block,取消订阅信号。</span><br><span class="line">        // 执行完Block后，当前信号就不在被订阅了。</span><br><span class="line">        NSLog(@&quot;信号被销毁&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 3.订阅信号,才会激活信号.</span><br><span class="line">[siganl subscribeNext:^(id x) &#123;</span><br><span class="line">    // block调用时刻：每当有信号发出数据，就会调用block.</span><br><span class="line">    NSLog(@&quot;接收到数据:%@&quot;,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="RACSubscriber"><a href="#RACSubscriber" class="headerlink" title="RACSubscriber"></a>RACSubscriber</h3><p>表示订阅者的意思，用于发送信号，这是一个协议，不是一个类，只要遵守这个协议，并且实现方法才能成为订阅者。通过create创建的信号，都有一个订阅者，帮助他发送数据。</p><h3 id="RACDisposable"><a href="#RACDisposable" class="headerlink" title="RACDisposable"></a>RACDisposable</h3><ul><li>用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。</li><li>使用场景:不想监听某个信号时，可以通过它主动取消订阅信号。</li></ul><h3 id="RACSubject"><a href="#RACSubject" class="headerlink" title="RACSubject"></a>RACSubject</h3><ul><li>信号提供者，自己可以充当信号，又能发送信号。</li><li>使用场景:通常用来代替代理，有了它，就不必要定义代理了。</li><li>RACSubject:底层实现和RACSignal不一样。<ul><li>1.调用subscribeNext订阅信号，只是把订阅者保存起来，并且订阅者的nextBlock已经赋值了。</li><li>2.调用sendNext发送信号，遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。</li></ul></li><li>RACSubject使用步骤:<ul><li>1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。</li><li>2.订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock</li><li>3.发送信号 sendNext:(id)value<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 1.创建信号</span><br><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line"></span><br><span class="line">// 2.订阅信号</span><br><span class="line">[subject subscribeNext:^(id x) &#123;</span><br><span class="line">// block调用时刻：当信号发出新值，就会调用.</span><br><span class="line">NSLog(@&quot;第一个订阅者%@&quot;,x);</span><br><span class="line">&#125;];</span><br><span class="line">[subject subscribeNext:^(id x) &#123;</span><br><span class="line">// block调用时刻：当信号发出新值，就会调用.</span><br><span class="line">NSLog(@&quot;第二个订阅者%@&quot;,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 3.发送信号</span><br><span class="line">[subject sendNext:@&quot;1&quot;];</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong><em>RACSubject替换代理</em></strong><br>需求:<br>1.给当前控制器添加一个按钮，modal到另一个控制器界面<br>2.另一个控制器view中有个按钮，点击按钮，通知当前控制器</p><ul><li><p>步骤一：在第二个控制器.h，添加一个RACSubject代替代理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface TwoViewController : UIViewController</span><br><span class="line">@property (nonatomic, strong) RACSubject *delegateSignal;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li><li><p>步骤二：监听第二个控制器按钮点击</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@implementation TwoViewController</span><br><span class="line">- (IBAction)notice:(id)sender &#123;</span><br><span class="line">// 通知第一个控制器，告诉它，按钮被点了</span><br><span class="line"></span><br><span class="line">// 通知代理</span><br><span class="line">// 判断代理信号是否有值</span><br><span class="line">if (self.delegateSignal) &#123;</span><br><span class="line">    // 有值，才需要通知</span><br><span class="line">    [self.delegateSignal sendNext:nil];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li><li><p>步骤三：在第一个控制器中，监听跳转按钮，给第二个控制器的代理信号赋值，并且监听.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@implementation OneViewController </span><br><span class="line">- (IBAction)btnClick:(id)sender &#123;</span><br><span class="line">    // 创建第二个控制器</span><br><span class="line">    TwoViewController *twoVc = [[TwoViewController alloc] init];</span><br><span class="line">    // 设置代理信号</span><br><span class="line">    twoVc.delegateSignal = [RACSubject subject];</span><br><span class="line">    // 订阅代理信号</span><br><span class="line">    [twoVc.delegateSignal subscribeNext:^(id x) &#123;</span><br><span class="line">        NSLog(@&quot;点击了通知按钮&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    // 跳转到第二个控制器</span><br><span class="line">    [self presentViewController:twoVc animated:YES completion:nil];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li></ul><h3 id="RACReplaySubject"><a href="#RACReplaySubject" class="headerlink" title="RACReplaySubject"></a>RACReplaySubject</h3><p>重复提供信号类，是RACSubject的子类。<br>RACReplaySubject与RACSubject区别:</p><ul><li>RACReplaySubject可以先发送信号，在订阅信号，RACSubject就不可以。</li><li>使用场景一:如果一个信号每被订阅一次，就需要把之前的值重复发送一遍，使用重复提供信号类。</li><li>使用场景二:可以设置capacity数量来限制缓存的value的数量,即只缓充最新的几个值。<br>RACReplaySubject:底层实现和RACSubject不一样。</li><li>1.调用sendNext发送信号，把值保存起来，然后遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。</li><li>2.调用subscribeNext订阅信号，遍历保存的所有值，一个一个调用订阅者的nextBlock<br>注意：如果想当一个信号被订阅，就重复播放之前所有值，需要先发送信号，在订阅信号。也就是先保存值，在订阅值。<br>RACReplaySubject使用步骤:</li><li>1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。</li><li>2.可以先订阅信号，也可以先发送信号。<ul><li>2.1 订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock</li><li>2.2 发送信号 sendNext:(id)value<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 1.创建信号</span><br><span class="line">RACReplaySubject *replaySubject = [RACReplaySubject subject];</span><br><span class="line"></span><br><span class="line">// 2.发送信号</span><br><span class="line">[replaySubject sendNext:@1];</span><br><span class="line">[replaySubject sendNext:@2];</span><br><span class="line"></span><br><span class="line">// 3.订阅信号</span><br><span class="line">[replaySubject subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;第一个订阅者接收到的数据%@&quot;,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 订阅信号</span><br><span class="line">[replaySubject subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;第二个订阅者接收到的数据%@&quot;,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="RACTuple"><a href="#RACTuple" class="headerlink" title="RACTuple"></a>RACTuple</h3><p>元组类,类似NSArray,用来包装值.</p><h3 id="RACSequence"><a href="#RACSequence" class="headerlink" title="RACSequence"></a>RACSequence</h3><p>RAC中的集合类，用于代替NSArray,NSDictionary,可以使用它来快速遍历数组和字典。<br>使用场景：字典转模型<br>RACSequence和RACTuple简单使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// 1.遍历数组</span><br><span class="line">NSArray *numbers = @[@1,@2,@3,@4];</span><br><span class="line"></span><br><span class="line">// 第一步: 把数组转换成集合RACSequence numbers.rac_sequence</span><br><span class="line">// 第二步: 把集合RACSequence转换RACSignal信号类,numbers.rac_sequence.signal</span><br><span class="line">// 第三步: 订阅信号，激活信号，会自动把集合中的所有值，遍历出来。</span><br><span class="line">[numbers.rac_sequence.signal subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 2.遍历字典,遍历出来的键值对会包装成RACTuple(元组对象)</span><br><span class="line">NSDictionary *dict = @&#123;@&quot;name&quot;:@&quot;zs&quot;,@&quot;age&quot;:@18&#125;;</span><br><span class="line">[dict.rac_sequence.signal subscribeNext:^(RACTuple *x) &#123;</span><br><span class="line"></span><br><span class="line">// 解包元组，会把元组的值，按顺序给参数里面的变量赋值</span><br><span class="line">RACTupleUnpack(NSString *key,NSString *value) = x;</span><br><span class="line">    // 相当于以下写法</span><br><span class="line">    // NSString *key = x[0];</span><br><span class="line">    // NSString *value = x[1];</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;%@ %@&quot;,key,value);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 3.字典转模型</span><br><span class="line">// 3.1 OC写法</span><br><span class="line">NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;flags.plist&quot; ofType:nil];</span><br><span class="line">NSArray *dictArr = [NSArray arrayWithContentsOfFile:filePath];</span><br><span class="line">NSMutableArray *items = [NSMutableArray array];</span><br><span class="line">for (NSDictionary *dict in dictArr) &#123;</span><br><span class="line">    FlagItem *item = [FlagItem flagWithDict:dict];</span><br><span class="line">    [items addObject:item];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3.2 RAC写法</span><br><span class="line">NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;flags.plist&quot; ofType:nil];</span><br><span class="line">NSArray *dictArr = [NSArray arrayWithContentsOfFile:filePath];</span><br><span class="line">NSMutableArray *flags = [NSMutableArray array];</span><br><span class="line">_flags = flags;</span><br><span class="line">// rac_sequence注意点：调用subscribeNext，并不会马上执行nextBlock，而是会等一会。</span><br><span class="line">[dictArr.rac_sequence.signal subscribeNext:^(id x) &#123;</span><br><span class="line">    // 运用RAC遍历字典，x：字典</span><br><span class="line">    FlagItem *item = [FlagItem flagWithDict:x];</span><br><span class="line">    [flags addObject:item];</span><br><span class="line">&#125;];</span><br><span class="line">NSLog(@&quot;%@&quot;,  NSStringFromCGRect([UIScreen mainScreen].bounds));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 3.3 RAC高级写法:</span><br><span class="line">NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;flags.plist&quot; ofType:nil];</span><br><span class="line">NSArray *dictArr = [NSArray arrayWithContentsOfFile:filePath];</span><br><span class="line">// map:映射的意思，目的：把原始值value映射成一个新值</span><br><span class="line">// array: 把集合转换成数组</span><br><span class="line">// 底层实现：当信号被订阅，会遍历集合中的原始值，映射成新值，并且保存到新的数组里。</span><br><span class="line">NSArray *flags = [[dictArr.rac_sequence map:^id(id value) &#123;</span><br><span class="line">    return [FlagItem flagWithDict:value];</span><br><span class="line">&#125;] array];</span><br></pre></td></tr></table></figure></p><h3 id="RACCommand"><a href="#RACCommand" class="headerlink" title="RACCommand"></a>RACCommand</h3><p>RAC中用于处理事件的类，可以把事件如何处理,事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。<br>使用场景:监听按钮点击，网络请求</p><ul><li><p>RACCommand使用步骤:</p><ul><li>1.创建命令 initWithSignalBlock:(RACSignal * (^)(id input))signalBlock</li><li>2.在signalBlock中，创建RACSignal，并且作为signalBlock的返回值</li><li>3.执行命令 - (RACSignal *)execute:(id)input</li></ul></li><li><p>RACCommand使用注意</p><ul><li>1.signalBlock必须要返回一个信号，不能传nil.</li><li>2.如果不想要传递信号，直接创建空的信号[RACSignal empty];</li><li>3.RACCommand中信号如果数据传递完，必须调用[subscriber sendCompleted]，这时命令才会执行完毕，否则永远处于执行中。</li><li>4.RACCommand需要被强引用，否则接收不到RACCommand中的信号，因此RACCommand中的信号是延迟发送的。</li></ul></li><li><p>RACCommand设计思想：内部signalBlock为什么要返回一个信号，这个信号有什么用。</p><ul><li>1.在RAC开发中，通常会把网络请求封装到RACCommand，直接执行某个RACCommand就能发送请求。</li><li>2.当RACCommand内部请求到数据的时候，需要把请求的数据传递给外界，这时候就需要通过signalBlock返回的信号传递了。</li></ul></li><li><p>如何拿到RACCommand中返回信号发出的数据。</p><ul><li>1.RACCommand有个执行信号源executionSignals，这个是signal of signals(信号的信号),意思是信号发出的数据是信号，不是普通的类型。</li><li>2.订阅executionSignals就能拿到RACCommand中返回的信号，然后订阅signalBlock返回的信号，就能获取发出的值。</li></ul></li><li><p>五、监听当前命令是否正在执行executing</p></li><li><p>六、使用场景,监听按钮点击，网络请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// 1.创建命令</span><br><span class="line">RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) &#123;</span><br><span class="line">    NSLog(@&quot;执行命令&quot;);</span><br><span class="line">    // 创建空信号,必须返回信号</span><br><span class="line">    // return [RACSignal empty];</span><br><span class="line"></span><br><span class="line">    // 2.创建信号,用来传递数据</span><br><span class="line">    return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@&quot;请求数据&quot;];</span><br><span class="line">        // 注意：数据传递完，最好调用sendCompleted，这时命令才执行完毕。</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 强引用命令，不要被销毁，否则接收不到数据</span><br><span class="line">_conmmand = command;</span><br><span class="line"></span><br><span class="line">// 3.订阅RACCommand中的信号</span><br><span class="line">[command.executionSignals subscribeNext:^(id x) &#123;</span><br><span class="line">    [x subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// RAC高级用法</span><br><span class="line">// switchToLatest:用于signal of signals，获取signal of signals发出的最新信号,也就是可以直接拿到RACCommand中的信号</span><br><span class="line">[command.executionSignals.switchToLatest subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 4.监听命令是否执行完毕,默认会来一次，可以直接跳过，skip表示跳过第一次信号。</span><br><span class="line">[[command.executing skip:1] subscribeNext:^(id x) &#123;</span><br><span class="line"></span><br><span class="line">    if ([x boolValue] == YES) &#123;</span><br><span class="line">    // 正在执行</span><br><span class="line">    NSLog(@&quot;正在执行&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">    // 执行完成</span><br><span class="line">    NSLog(@&quot;执行完成&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 5.执行命令</span><br><span class="line">[self.conmmand execute:@1];</span><br></pre></td></tr></table></figure></li></ul><h3 id="RACMulticastConnection"><a href="#RACMulticastConnection" class="headerlink" title="RACMulticastConnection"></a>RACMulticastConnection</h3><p>用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。<br>注意:RACMulticastConnection通过RACSignal的-publish或者-muticast:方法创建.</p><ul><li><p>RACMulticastConnection使用步骤:</p><ul><li>1.创建信号 + (RACSignal <em>)createSignal:(RACDisposable </em> (^)(id<racsubscriber> subscriber))didSubscribe</racsubscriber></li><li>2.创建连接 RACMulticastConnection *connect = [signal publish];</li><li>3.订阅信号,注意：订阅的不在是之前的信号，而是连接的信号。 [connect.signal subscribeNext:nextBlock]</li><li>4.连接 [connect connect]</li></ul></li><li><p>RACMulticastConnection底层原理:</p><ul><li>1.创建connect，connect.sourceSignal -&gt; RACSignal(原始信号)  connect.signal -&gt; RACSubject</li><li>2.订阅connect.signal，会调用RACSubject的subscribeNext，创建订阅者，而且把订阅者保存起来，不会执行block。</li><li>3.[connect connect]内部会订阅RACSignal(原始信号)，并且订阅者是RACSubject<ul><li>3.1.订阅原始信号，就会调用原始信号中的didSubscribe</li><li>3.2 didSubscribe，拿到订阅者调用sendNext，其实是调用RACSubject的sendNext</li></ul></li><li>4.RACSubject的sendNext,会遍历RACSubject所有订阅者发送信号。<ul><li>4.1 因为刚刚第二步，都是在订阅RACSubject，因此会拿到第二步所有的订阅者，调用他们的nextBlock</li></ul></li></ul></li><li><p>需求：假设在一个信号中发送请求，每次订阅一次都会发送请求，这样就会导致多次请求。<br>解决：使用RACMulticastConnection就能解决.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 1.创建请求信号</span><br><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    NSLog(@&quot;发送请求&quot;);</span><br><span class="line">    return nil;</span><br><span class="line">&#125;];</span><br><span class="line">// 2.订阅信号</span><br><span class="line">[signal subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;接收数据&quot;);</span><br><span class="line">&#125;];</span><br><span class="line">// 2.订阅信号</span><br><span class="line">[signal subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;接收数据&quot;);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 3.运行结果，会执行两遍发送请求，也就是每次订阅都会发送一次请求</span><br></pre></td></tr></table></figure></li><li><p>RACMulticastConnection:解决重复请求问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 1.创建信号</span><br><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    NSLog(@&quot;发送请求&quot;);</span><br><span class="line">    [subscriber sendNext:@1];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 2.创建连接</span><br><span class="line">RACMulticastConnection *connect = [signal publish];</span><br><span class="line"></span><br><span class="line">// 3.订阅信号，</span><br><span class="line">// 注意：订阅信号，也不能激活信号，只是保存订阅者到数组，必须通过连接,当调用连接，就会一次性调用所有订阅者的sendNext:</span><br><span class="line">[connect.signal subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;订阅者一信号&quot;);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[connect.signal subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;订阅者二信号&quot;);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 4.连接,激活信号</span><br><span class="line">[connect connect];</span><br></pre></td></tr></table></figure></li></ul><h3 id="RACScheduler"><a href="#RACScheduler" class="headerlink" title="RACScheduler"></a>RACScheduler</h3><p>RAC中的队列，用GCD封装的。</p><h3 id="RACUnit"><a href="#RACUnit" class="headerlink" title="RACUnit"></a>RACUnit</h3><p>表⽰stream不包含有意义的值,也就是看到这个，可以直接理解为nil.</p><h3 id="RACEvent"><a href="#RACEvent" class="headerlink" title="RACEvent"></a>RACEvent</h3><p>把数据包装成信号事件(signal event)。它主要通过RACSignal的-materialize来使用，然并卵。</p><h2 id="ReactiveCocoa开发中常见用法。"><a href="#ReactiveCocoa开发中常见用法。" class="headerlink" title="ReactiveCocoa开发中常见用法。"></a>ReactiveCocoa开发中常见用法。</h2><h3 id="代替代理"><a href="#代替代理" class="headerlink" title="代替代理"></a>代替代理</h3><p>rac_signalForSelector：用于替代代理。</p><h3 id="代替KVO"><a href="#代替KVO" class="headerlink" title="代替KVO"></a>代替KVO</h3><p>rac_valuesAndChangesForKeyPath：用于监听某个对象的属性改变。</p><h3 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h3><p>rac_signalForControlEvents：用于监听某个事件。</p><h3 id="代替通知"><a href="#代替通知" class="headerlink" title="代替通知"></a>代替通知</h3><p>rac_addObserverForName:用于监听某个通知。</p><h3 id="监听文本框文字改变"><a href="#监听文本框文字改变" class="headerlink" title="监听文本框文字改变"></a>监听文本框文字改变</h3><p>rac_textSignal:只要文本框发出改变就会发出这个信号。</p><h3 id="处理当界面有多次请求时，需要都获取到数据时，才能展示界面"><a href="#处理当界面有多次请求时，需要都获取到数据时，才能展示界面" class="headerlink" title="处理当界面有多次请求时，需要都获取到数据时，才能展示界面"></a>处理当界面有多次请求时，需要都获取到数据时，才能展示界面</h3><p>rac_liftSelector:withSignalsFromArray:Signals:当传入的Signals(信号数组)，每一个signal都至少sendNext过一次，就会去触发第一个selector参数的方法。<br>使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据。<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// 1.代替代理</span><br><span class="line">// 需求：自定义redView,监听红色view中按钮点击</span><br><span class="line">// 之前都是需要通过代理监听，给红色View添加一个代理属性，点击按钮的时候，通知代理做事情</span><br><span class="line">// rac_signalForSelector:把调用某个对象的方法的信息转换成信号，就要调用这个方法，就会发送信号。</span><br><span class="line">// 这里表示只要redV调用btnClick:,就会发出信号，订阅就好了。</span><br><span class="line">[[redV rac_signalForSelector:@selector(btnClick:)] subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;点击红色按钮&quot;);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 2.KVO</span><br><span class="line">// 把监听redV的center属性改变转换成信号，只要值改变就会发送信号</span><br><span class="line">// observer:可以传入nil</span><br><span class="line">[[redV rac_valuesAndChangesForKeyPath:@&quot;center&quot; options:NSKeyValueObservingOptionNew observer:nil] subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 3.监听事件</span><br><span class="line">// 把按钮点击事件转换为信号，点击按钮，就会发送信号</span><br><span class="line">[[self.btn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;按钮被点击了&quot;);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 4.代替通知</span><br><span class="line">// 把监听到的通知转换信号</span><br><span class="line">[[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIKeyboardWillShowNotification object:nil] subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;键盘弹出&quot;);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 5.监听文本框的文字改变</span><br><span class="line">[_textField.rac_textSignal subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;文字改变了%@&quot;,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 6.处理多个请求，都返回结果的时候，统一做处理.</span><br><span class="line">RACSignal *request1 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line"></span><br><span class="line">// 发送请求1</span><br><span class="line">[subscriber sendNext:@&quot;发送请求1&quot;];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *request2 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    // 发送请求2</span><br><span class="line">    [subscriber sendNext:@&quot;发送请求2&quot;];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据。</span><br><span class="line">[self rac_liftSelector:@selector(updateUIWithR1:r2:) withSignalsFromArray:@[request1,request2]];</span><br><span class="line">&#125;</span><br><span class="line">// 更新UI</span><br><span class="line">- (void)updateUIWithR1:(id)data r2:(id)data1</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;更新UI%@  %@&quot;,data,data1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="ReactiveCocoa常见宏"><a href="#ReactiveCocoa常见宏" class="headerlink" title="ReactiveCocoa常见宏"></a>ReactiveCocoa常见宏</h2><h3 id="RAC-TARGET-KEYPATH-NIL-VALUE"><a href="#RAC-TARGET-KEYPATH-NIL-VALUE" class="headerlink" title="RAC(TARGET, [KEYPATH, [NIL_VALUE]])"></a>RAC(TARGET, [KEYPATH, [NIL_VALUE]])</h3><p>用于给某个对象的某个属性绑定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 只要文本框文字改变，就会修改label的文字</span><br><span class="line">RAC(self.labelView,text) = _textField.rac_textSignal;</span><br></pre></td></tr></table></figure></p><h3 id="RACObserve-self-name"><a href="#RACObserve-self-name" class="headerlink" title="RACObserve(self, name)"></a>RACObserve(self, name)</h3><p>监听某个对象的某个属性,返回的是信号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[RACObserve(self.view, center) subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><h3 id="weakify-Obj-和-strongify-Obj"><a href="#weakify-Obj-和-strongify-Obj" class="headerlink" title="@weakify(Obj)和@strongify(Obj)"></a>@weakify(Obj)和@strongify(Obj)</h3><p>一般两个都是配套使用,在主头文件(ReactiveCocoa.h)中并没有导入，需要自己手动导入，RACEXTScope.h才可以使用。但是每次导入都非常麻烦，只需要在主头文件自己导入就好了。</p><h3 id="RACTuplePack"><a href="#RACTuplePack" class="headerlink" title="RACTuplePack"></a>RACTuplePack</h3><p>把数据包装成RACTuple（元组类）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 把参数中的数据包装成元组</span><br><span class="line">RACTuple *tuple = RACTuplePack(@10,@20);</span><br></pre></td></tr></table></figure></p><h3 id="RACTupleUnpack：把RACTuple（元组类）解包成对应的数据。"><a href="#RACTupleUnpack：把RACTuple（元组类）解包成对应的数据。" class="headerlink" title="RACTupleUnpack：把RACTuple（元组类）解包成对应的数据。"></a>RACTupleUnpack：把RACTuple（元组类）解包成对应的数据。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 把参数中的数据包装成元组</span><br><span class="line">RACTuple *tuple = RACTuplePack(@&quot;abc&quot;,@20);</span><br><span class="line"></span><br><span class="line">// 解包元组，会把元组的值，按顺序给参数里面的变量赋值</span><br><span class="line">// name = @&quot;abc&quot; age = @20</span><br><span class="line">RACTupleUnpack(NSString *name,NSNumber *age) = tuple;</span><br></pre></td></tr></table></figure><p>原文链接：<a href="http://www.jianshu.com/p/87ef6720a096#" target="_blank" rel="noopener">最快让你上手ReactiveCocoa之基础篇</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReactNative </tag>
            
            <tag> RAC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS多媒体学习笔记</title>
      <link href="/2017/05/06/iOS%E5%A4%9A%E5%AA%92%E4%BD%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/05/06/iOS%E5%A4%9A%E5%AA%92%E4%BD%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h2><h3 id="音效-AudioToolbox-framework"><a href="#音效-AudioToolbox-framework" class="headerlink" title="音效 AudioToolbox.framework"></a>音效 AudioToolbox.framework</h3><p>限制：</p><ul><li>音频播放时间不能超过30s</li><li>数据必须是PCM或者IMA4格式</li><li>音频文件必须打包成.caf、.aif、.wav中的一种（注意这是官方文档的说法，实际测试发现一些.mp3也可以播放）<a id="more"></a></li></ul><h3 id="音乐-AVAudioPlayer"><a href="#音乐-AVAudioPlayer" class="headerlink" title="音乐 AVAudioPlayer"></a>音乐 AVAudioPlayer</h3><p>AVFoundation.framework中的AVAudioPlayer<br>AVAudioPlayer可以看成一个播放器，它支持多种音频格式，而且能够进行进度、音量、播放速度等控制。<br>AVAudioPlayer使用：</p><ul><li>初始化AVAudioPlayer对象，此时通常指定本地文件路径。</li><li>设置播放器属性，例如重复次数、音量大小等。</li><li>调用play方法播放。</li></ul><h3 id="MPMusicPlayerController"><a href="#MPMusicPlayerController" class="headerlink" title="MPMusicPlayerController"></a>MPMusicPlayerController</h3><h3 id="音频会话-AVAudioSession"><a href="#音频会话-AVAudioSession" class="headerlink" title="音频会话 AVAudioSession"></a>音频会话 AVAudioSession</h3><p>支持后台播放：</p><ul><li>1.设置后台运行模式：在plist文件中添加Required background modes，并且设置item 0=App plays audio or streams audio/video using AirPlay（其实可以直接通过Xcode在Project Targets-Capabilities-Background Modes中设置）</li><li><p>2.设置AVAudioSession的类型为AVAudioSessionCategoryPlayback并且调用setActive::方法启动会话。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AVAudioSession *audioSession=[AVAudioSession sharedInstance];</span><br><span class="line">[audioSession setCategory:AVAudioSessionCategoryPlayback error:nil];</span><br><span class="line">[audioSession setActive:YES error:nil];</span><br></pre></td></tr></table></figure></li><li><p>3.为了能够让应用退到后台之后支持耳机控制，建议添加远程控制事件（这一步不是后台播放必须的）<br>在iOS中每个应用都有一个音频会话，这个会话就通过AVAudioSession来表示。AVAudioSession同样存在于AVFoundation框架中，它是单例模式设计，通过sharedInstance进行访问。在使用Apple设备时大家会发现有些应用只要打开其他音频播放就会终止，而有些应用却可以和其他应用同时播放，在多种音频环境中如何去控制播放的方式就是通过音频会话来完成的。</p></li></ul><h3 id="音频队列服务（Audio-Queue-Services）"><a href="#音频队列服务（Audio-Queue-Services）" class="headerlink" title="音频队列服务（Audio Queue Services）"></a>音频队列服务（Audio Queue Services）</h3><ul><li>AVAudioPlayer只能播放本地文件，并且是一次性加载所以音频数据，初始化AVAudioPlayer时指定的URL也只能是File URL而不能是HTTP URL。</li><li>AudioToolbox框架中的音频队列服务Audio Queue Services，支持网络流媒体播放。</li></ul><h3 id="FSAudioStream"><a href="#FSAudioStream" class="headerlink" title="FSAudioStream"></a>FSAudioStream</h3><h2 id="录音"><a href="#录音" class="headerlink" title="录音"></a>录音</h2><h3 id="AVAudioRecorder"><a href="#AVAudioRecorder" class="headerlink" title="AVAudioRecorder"></a>AVAudioRecorder</h3><p>AVFoundation框架中的AVAudioRecorder类<br>info.plist 添加 <code>NSMicrophoneUsageDescription</code></p><h3 id="音频队列服务（Audio-Queue-Services）-1"><a href="#音频队列服务（Audio-Queue-Services）-1" class="headerlink" title="音频队列服务（Audio Queue Services）"></a>音频队列服务（Audio Queue Services）</h3><h2 id="视频播放"><a href="#视频播放" class="headerlink" title="视频播放"></a>视频播放</h2><h3 id="MPMoviePlayerController"><a href="#MPMoviePlayerController" class="headerlink" title="MPMoviePlayerController"></a>MPMoviePlayerController</h3><p>MediaPlayer.framework种的MPMoviePlayerController类，它支持本地视频和网络视频播放，如果要在UI中展示视频需要将view属性添加到界面中。</p><h3 id="MPMoviePlayerViewController"><a href="#MPMoviePlayerViewController" class="headerlink" title="MPMoviePlayerViewController"></a>MPMoviePlayerViewController</h3><p>默认全屏播放，开发者在开发的时候直接使用这个视图控制器。<br>注意：由于MPMoviePlayerViewController的初始化方法做了大量工作（例如设置URL、自动播放、添加点击Done完成的监控等），所以当再次点击播放弹出新的模态窗口的时如果不销毁之前的MPMoviePlayerViewController，那么新的对象就无法完成初始化，这样也就不能再次进行播放。</p><h3 id="AVPlayer"><a href="#AVPlayer" class="headerlink" title="AVPlayer"></a>AVPlayer</h3><p>AVPlayer存在于AVFoundation中，它更加接近于底层，所以灵活性也更强。<br>AVPlayer本身并不能显示视频，而且它也不像MPMoviePlayerController有一个view属性。如果AVPlayer要显示必须创建一个播放器层AVPlayerLayer用于展示，播放器层继承于CALayer，有了AVPlayerLayer之添加到控制器视图的layer中即可。<br>几个相关类：</p><ul><li>AVAsset：主要用于获取多媒体信息，是一个抽象类，不能直接使用。</li><li>AVURLAsset：AVAsset的子类，可以根据一个URL路径创建一个包含媒体信息的AVURLAsset对象。</li><li>AVPlayerItem：一个媒体资源管理对象，管理者视频的一些基本信息和状态，一个AVPlayerItem对应着一个视频资源。</li></ul><h2 id="视频截图"><a href="#视频截图" class="headerlink" title="视频截图"></a>视频截图</h2><h3 id="MPMoviePlayerController-1"><a href="#MPMoviePlayerController-1" class="headerlink" title="MPMoviePlayerController"></a>MPMoviePlayerController</h3><h3 id="AVAssetImageGenerator"><a href="#AVAssetImageGenerator" class="headerlink" title="AVAssetImageGenerator"></a>AVAssetImageGenerator</h3><p>AVFundation框架中的AVAssetImageGenerator<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*  截取指定时间的视频缩略图</span><br><span class="line">*</span><br><span class="line">*  @param timeBySecond 时间点</span><br><span class="line">*/</span><br><span class="line">-(void)thumbnailImageRequest:(CGFloat )timeBySecond&#123;</span><br><span class="line">    //创建URL</span><br><span class="line">    NSURL *url=[self getNetworkUrl];</span><br><span class="line">    //根据url创建AVURLAsset</span><br><span class="line">    AVURLAsset *urlAsset=[AVURLAsset assetWithURL:url];</span><br><span class="line">    //根据AVURLAsset创建AVAssetImageGenerator</span><br><span class="line">    AVAssetImageGenerator *imageGenerator=[AVAssetImageGenerator assetImageGeneratorWithAsset:urlAsset];</span><br><span class="line">    /*截图</span><br><span class="line">    * requestTime:缩略图创建时间</span><br><span class="line">    * actualTime:缩略图实际生成的时间</span><br><span class="line">    */</span><br><span class="line">    NSError *error=nil;</span><br><span class="line">    CMTime time=CMTimeMakeWithSeconds(timeBySecond, 10);//CMTime是表示电影时间信息的结构体，第一个参数表示是视频第几秒，第二个参数表示每秒帧数.(如果要活的某一秒的第几帧可以使用CMTimeMake方法)</span><br><span class="line">    CMTime actualTime;</span><br><span class="line">    CGImageRef cgImage= [imageGenerator copyCGImageAtTime:time actualTime:&amp;actualTime error:&amp;error];</span><br><span class="line">    if(error)&#123;</span><br><span class="line">    NSLog(@&quot;截取视频缩略图时发生错误，错误信息：%@&quot;,error.localizedDescription);</span><br><span class="line">    return;</span><br><span class="line">    &#125;</span><br><span class="line">    CMTimeShow(actualTime);</span><br><span class="line">    UIImage *image=[UIImage imageWithCGImage:cgImage];//转化为UIImage</span><br><span class="line">    //保存到相册</span><br><span class="line">    UIImageWriteToSavedPhotosAlbum(image,nil, nil, nil);</span><br><span class="line">    CGImageRelease(cgImage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="第三方"><a href="#第三方" class="headerlink" title="第三方"></a>第三方</h3><p>iOS上常用的视频编码、解码框架有：VLC、ffmpeg</p><h2 id="摄像头（拍照和视频录制）"><a href="#摄像头（拍照和视频录制）" class="headerlink" title="摄像头（拍照和视频录制）"></a>摄像头（拍照和视频录制）</h2><h3 id="UIImagePickerController"><a href="#UIImagePickerController" class="headerlink" title="UIImagePickerController"></a>UIImagePickerController</h3><p>UIImagePickerController继承于UINavigationController</p><h3 id="AVFoundation（AVCaptureSession-AVCaptureDevice）"><a href="#AVFoundation（AVCaptureSession-AVCaptureDevice）" class="headerlink" title="AVFoundation（AVCaptureSession/AVCaptureDevice）"></a>AVFoundation（AVCaptureSession/AVCaptureDevice）</h3><p>灵活性强。</p><p><img src="/assets/20170506_media/media.png" alt="优缺点比较"></p><p>参考原文：<a href="http://www.cnblogs.com/kenshincui/p/4186022.html" target="_blank" rel="noopener">iOS开发系列–音频播放、录音、视频播放、拍照、视频录制</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多媒体 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RAC与Target-Action、通知、代理、KVO</title>
      <link href="/2017/04/23/RAC%E4%B8%8ETarget-Action%E3%80%81%E9%80%9A%E7%9F%A5%E3%80%81%E4%BB%A3%E7%90%86%E3%80%81KVO/"/>
      <url>/2017/04/23/RAC%E4%B8%8ETarget-Action%E3%80%81%E9%80%9A%E7%9F%A5%E3%80%81%E4%BB%A3%E7%90%86%E3%80%81KVO/</url>
      
        <content type="html"><![CDATA[<p>ReactiveCocoa作用<br>1.target-action:rac_signalForControlEvents<br>rac_textSignal rac_gestureSignal<br>2.代理 rac_signalForSelector:@selector() fromProtocol:()<br><a id="more"></a><br>3.通知 rac_addObserverForName<br>4.KVO RACObserve(object, value)</p><p>代码示例：<br>1.target-action<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//1.1 监听textfield文字更改</span><br><span class="line">[[self.textfiled rac_signalForControlEvents:UIControlEventEditingChanged] subscribeNext:^(id x)&#123;</span><br><span class="line">    NSLog(@&quot;change&quot;);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">//简写</span><br><span class="line">[[self.textfiled rac_textSignal] subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">//1.2</span><br><span class="line">UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] init];</span><br><span class="line">    [[tap rac_gestureSignal] subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;tap&quot;);</span><br><span class="line">&#125;];</span><br><span class="line">//注意：如果给label添加手势，需要打开userInteractionEnabled</span><br><span class="line">self.lab.userInteractionEnabled = YES;</span><br><span class="line">[self.lab addGestureRecognizer:tap];</span><br></pre></td></tr></table></figure></p><p>2.代理：rac_signalForSelector:@selector() fromProtocol:()<br>*** 注意：只能实现返回值为void的代理方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@&quot;title&quot; message:@&quot;rac test&quot; delegate:self cancelButtonTitle:@&quot;no&quot; otherButtonTitles:@&quot;yes&quot;, nil];</span><br><span class="line">    [[self rac_signalForSelector:@selector(alertView:clickedButtonAtIndex:) fromProtocol:@protocol(UIAlertViewDelegate)] subscribeNext:^(RACTuple *tuple) &#123;</span><br><span class="line">        //tuple为点击按钮的各个参数</span><br><span class="line">        NSLog(@&quot;%ld&quot;,tuple.count);    //参数个数 2 </span><br><span class="line">        NSLog(@&quot;%@&quot;,tuple.first);     //alertView</span><br><span class="line">        NSLog(@&quot;%@&quot;,tuple.second);    //buttonIndex</span><br><span class="line">        NSLog(@&quot;%@&quot;,tuple.third);     //null</span><br><span class="line">    &#125;];</span><br><span class="line">//简写</span><br><span class="line">[[alertView rac_buttonClickedSignal] subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,x);     //buttonIndex</span><br><span class="line">&#125;];</span><br><span class="line">[alertView show];</span><br></pre></td></tr></table></figure></p><p>3.通知 rac_addObserverForName<br>点击一个页面可以更新另一个页面数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[[[NSNotificationCenter defaultCenter] rac_addObserverForName:@&quot;postData&quot; object:nil] subscribeNext:^(NSNotification *notification) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, notification.name);</span><br><span class="line">    NSLog(@&quot;%@&quot;, notification.object);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[self presentViewController:[[SecondViewController alloc]init] animated:YES completion:nil];</span><br></pre></td></tr></table></figure></p><p>SecondViewController代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *dataArray = [[NSMutableArray alloc] initWithObjects:@&quot;1&quot;, @&quot;2&quot;, @&quot;3&quot;, nil];</span><br><span class="line">[[NSNotificationCenter defaultCenter] postNotificationName:@&quot;postData&quot; object:dataArray];</span><br><span class="line">[self dismissViewControllerAnimated:YES completion:nil];</span><br></pre></td></tr></table></figure></p><p>4.KVO RACObserve(object, value)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UIScrollView *scrolView = [[UIScrollView alloc] initWithFrame:CGRectMake(0, 300, 200, 400)];</span><br><span class="line">scrolView.contentSize = CGSizeMake(200, 800);</span><br><span class="line">scrolView.backgroundColor = [UIColor greenColor];</span><br><span class="line">[self.view addSubview:scrolView];</span><br><span class="line">[RACObserve(scrolView, contentOffset) subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;success&quot;);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><p>原文链接：<a href="http://www.jianshu.com/p/ff79a5ae0353" target="_blank" rel="noopener">学习RAC小记-适合给新手看的RAC用法总结</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RAC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS IM学习笔记</title>
      <link href="/2017/04/22/iOS-IM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/04/22/iOS-IM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>客户端需要做如下4件事：</p><ul><li>1.客户端调用 socket(…) 创建socket；</li><li>2.客户端调用 connect(…) 向服务器发起连接请求以建立连接；<a id="more"></a></li><li>3.客户端与服务器建立连接之后，就可以通过send(…)/receive(…)向客户端发送或从客户端接收数据；</li><li>4.客户端调用 close 关闭 socket；</li></ul><p>服务端需要做如下5件事：</p><ul><li>1.服务器调用 socket(…) 创建socket；</li><li>2.服务器调用 listen(…) 设置缓冲区；</li><li>3.服务器通过 accept(…)接受客户端请求建立连接；</li><li>4.服务器与客户端建立连接之后，就可以通过 send(…)/receive(…)向客户端发送或从客户端接收数据；</li><li>5.服务器调用 close 关闭 socket；</li></ul><p>可以通过以下几种方式实现：</p><ul><li>1.系统socket</li><li>2.基于Scoket原生：代表框架 CocoaAsyncSocket</li><li>3.基于WebScoket：代表框架 SocketRocket。(npm install ws)</li><li>4.MQTTKit：MQTTClient(npm install mosca)</li><li>5.XMPP</li><li>6.私有协议：基于WebScoket或者Scoket原生进行封装（高效，省流量，安全性高）<br>其中MQTT和XMPP为聊天协议，它们是最上层的协议，而WebScoket是传输通讯协议。</li></ul><p>XMPP常用对象：<br>XMPPStream：xmpp基础服务类<br>XMPPRoster：好友列表类<br>XMPPRosterCoreDataStorage：好友列表（用户账号）在core data中的操作类<br>XMPPvCardCoreDataStorage：好友名片（昵称，签名，性别，年龄等信息）在core data中的操作类<br>XMPPvCardTemp：好友名片实体类，从数据库里取出来的都是它<br>xmppvCardAvatarModule：好友头像<br>XMPPReconnect：如果失去连接,自动重连<br>XMPPRoom：提供多用户聊天支持<br>XMPPPubSub：发布订阅</p><p>代码传送门：<a href="https://github.com/guchunli/IMWithSocket" target="_blank" rel="noopener">IMWithSocket</a></p><p>参考原文：<a href="http://www.cocoachina.com/ios/20170110/18544.html" target="_blank" rel="noopener">iOS即时通讯，从入门到“放弃”？</a><br><a href="http://www.cnblogs.com/QianChia/p/6411914.html#_label3" target="_blank" rel="noopener">iOS - XMPP 的使用</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>北京十渡</title>
      <link href="/2017/04/16/%E5%8C%97%E4%BA%AC%E5%8D%81%E6%B8%A1/"/>
      <url>/2017/04/16/%E5%8C%97%E4%BA%AC%E5%8D%81%E6%B8%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="2017-04-16-北京十渡飞拉达、蹦极"><a href="#2017-04-16-北京十渡飞拉达、蹦极" class="headerlink" title="2017-04-16 北京十渡飞拉达、蹦极"></a>2017-04-16 北京十渡飞拉达、蹦极</h3><center><img src="/assets/20170416_shidu/bengji.jpeg" alt="蹦极"></center><a id="more"></a><p>　　今天真是玩嗨了<br>　　早上六点起床，准备好之后早早出了门，乘地铁赶往公主坟与大家集合。到了集合地，坐着租的面包车开始前往目的地————十渡。<br>　　十渡景区位于北京房山，到了景区之后，带队的队长确定参加飞拉达的人数开始买票。之前了解了一下飞拉达就是攀岩（岩壁探险或铁道式攀登），因为之前从来没参与过类似冒险运动，心里有点小紧张。因为人还比较多，所以一块请了一位教练。刚开始教练教授装备的穿戴，之后带领我们来到了攀岩的山脚下，教练说这座山大概有70多米，之后告诉了我们扣锁的使用，然后开始攀爬演示，小伙伴们也开始一个个紧随其后开始了攀爬之路。</p><center><img src="/assets/20170416_shidu/feilada.jpeg" alt="飞拉达"></center><br>　　飞拉达历经大约三个小时，穿越了ABCD区，终于到达了终点。教练帮我们把所有锁扣都挂到绳索上，下面是湖水，随着绳索划过去才算再次到达了地面。<br><br>　　之后和大家一起腐败吃午餐，吃午餐的餐厅对面正好就是蹦极的跳台，时不时看着一个个挑战者坠落、弹起，再坠落…　由于某些原因（吃的有点多了，惭愧…），本来打算不参加蹦极了，但是一想如果不参加，回去之后一定会捶胸顿足，后悔不跌，而且同行的小伙伴们除了一对情侣之外都参加了，狠了狠心还是买了票。<br>　　来到蹦极门口，工作人员给每个人测量了身高和体重，并把数据写到了手背上。由于蹦极的人很多，等了大约有两三个小时，期间目睹一个一个从跳台自由落体，还有情侣相拥跳下，他们调侃这肯定是他们这辈子抱得最紧的一次了吧~~轮到我们的时候，不知怎么安排的被调到了最后一个，轮到我的时候，工作人员开始给我腿上绑绳，把眼镜粘到了胳膊上，为了避免女生走光把上衣和裤子的连接处也用胶带粘上了，说实话，自从买了票心有一直还挺紧张的，但真到了马上就要跳下去的时候，心里反而没有那么紧张了，还算比较平静。起跳之前冲着镜头挥挥手，然后只要张开双臂就可以了，看着50米下宽阔的湖水，心里还真是怂了，嗯，怂了（幸亏自己还是近视眼，并且还没戴眼镜）…接着工作人员扶着胳膊向前推去，从未有过的自由落体的失重感觉瞬间侵占了大脑，一片空白，只得紧闭双眼，只感觉到达最低点之后又弹跳到了下降高度的三分之二，然后又开始降落，才敢睁开眼睛环顾四周，之后又弹了大概两三次，高度就不是很高了，才开始享受蹦极的乐趣，然后就被放了下来，湖面上有专业人员把我接了下去，整个过程也就是一两分钟的样子，算是真切的感受了一次蹦极的刺激！<br>　　今天认识了一个很说的来的朋友，我俩基本上叽叽喳喳聊了一天，感觉很是投缘，遇到很聊得来的人总是感觉心情很舒畅！同行的小伙伴中了有一个四川的男生，还在上大学，曾经自己骑行去过云南，还有一个广州的女孩（就是下图中的女孩），刚辞了工作专门出来游玩的，很佩服这种勇气！<br><br><center><img src="/assets/20170416_shidu/braveGirl.jpeg" alt="brave girl"></center><p>　　最后用鹿晗的《某时某刻 Catch me when I fall》结个尾~~~</p><!--<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=29771231&auto=1&height=66"></iframe>--><center><iframe height="498" width="510" src="http://player.youku.com/embed/XMTc3MjI5NTk3Mg" frameborder="0" allowfullscreen><br></iframe></center>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>iOS-APP打包/提审/被拒等注意事项</title>
      <link href="/2017/04/13/iOS-APP%E6%89%93%E5%8C%85:%E6%8F%90%E5%AE%A1:%E8%A2%AB%E6%8B%92%E7%AD%89%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/2017/04/13/iOS-APP%E6%89%93%E5%8C%85:%E6%8F%90%E5%AE%A1:%E8%A2%AB%E6%8B%92%E7%AD%89%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="打包前注意点"><a href="#打包前注意点" class="headerlink" title="打包前注意点"></a>打包前注意点</h2><p>1.改为正式环境</p><ul><li>接口改成线上服务器</li><li>极光推送环境改为生产环境等</li></ul><a id="more"></a><p>2.版本号<br>target -&gt; general：<code>Version</code>和<code>Build</code>版本号</p><p>3.签名<br>target -&gt; general -&gt; signing</p><p>4.删除断点，log</p><p>5.本地化，语言包</p><p>6.Capabilities -&gt; background modes<br>如果后台使用了位置，提交信息中应用描述添加免责声明</p><blockquote><p>温馨提示：GPS在后台持续运行，会大大降低电池的寿命。</p></blockquote><p>7.设备选择<code>Generic iOS Device</code>，注意不要选择真机或模拟器。</p><p>8.edit scheme: run,archive -&gt; <code>debug</code> 改为 <code>release</code></p><p>9.打包ad-hoc，进行内测：clean -&gt; build -&gt; archive</p><p>最后，打正式包，提交APP Store。</p><h2 id="archive注意点"><a href="#archive注意点" class="headerlink" title="archive注意点"></a>archive注意点</h2><ul><li>上传app store的1024*1024尺寸的icon和屏幕截图不能加圆角，透明度，通道</li><li>version，build版本号不能低于上次上传过的APP版本号</li><li>info.plist 中获取权限的key对应的value必须要加说明，不能为空</li></ul><h2 id="审核被拒-修改回复"><a href="#审核被拒-修改回复" class="headerlink" title="审核被拒-修改回复"></a>审核被拒-修改回复</h2><h3 id="Background-location"><a href="#Background-location" class="headerlink" title="Background-location"></a>Background-location</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Please revise your app to include features that require the persistent use of real-time location updates while the app is in the background. Please also add the following battery use disclaimer in your Application Description:</span><br><span class="line">&quot;Continued use of GPS running in the background can dramatically decrease battery life.&quot;</span><br><span class="line"></span><br><span class="line">If your app does not require persistent real-time location updates, please remove the &quot;location&quot; setting from the UIBackgroundModes key. You may wish to use the significant-change location service or the region monitoring location service if persistent real-time location updates are not required for your app features.</span><br></pre></td></tr></table></figure><p>翻译：请修改您的应用程序，以包括功能，需要持续使用的实时位置更新，而应用程序的背景。请在应用程序描述中添加以下电池使用免责声明：“继续使用在后台运行的全球定位系统，可以大大降低电池寿命。”<br>如果你的应用程序不需要持续的实时位置更新，请清除“位置”从uibackgroundmodes键设置。如果你的应用程序功能不需要持久的实时位置更新，您可能希望使用显着的更改位置服务或区域监测位置服务。</p><h3 id="Guideline-2-3-3-Performance-Accurate-Metadata"><a href="#Guideline-2-3-3-Performance-Accurate-Metadata" class="headerlink" title="Guideline 2.3.3 - Performance - Accurate Metadata"></a>Guideline 2.3.3 - Performance - Accurate Metadata</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">We noticed that your screenshots for iPhone 5.8” do not sufficiently reflect your app in use on the relevant device.</span><br><span class="line"></span><br><span class="line">Please see attached screenshots for details.</span><br><span class="line"></span><br><span class="line">Next Steps</span><br><span class="line"></span><br><span class="line">To resolve this issue, please revise your screenshots to ensure that they accurately reflect the app in use on the supported devices. For iPhone, you need a set of 5.5-inch display screenshots and for iPad, you need a set for 12.9-inch display. This set will be scaled appropriately down to other device sizes when viewed on the App Store in each territory.</span><br><span class="line"></span><br><span class="line">Resources</span><br><span class="line"></span><br><span class="line">For resources on creating great screenshots for the App Store, you may want to review the App Store Product Page information available on the Apple developer portal.</span><br><span class="line"></span><br><span class="line">Please ensure you have made any screenshot modifications using Media Manager. You should confirm your app looks and behaves identically in all languages and on all supported devices. Learn how to use Media Manager to add custom screenshots for each display size and localization.</span><br><span class="line"></span><br><span class="line">Since your iTunes Connect status is Rejected, a new binary will be required. Make the desired metadata changes when you upload the new binary.</span><br><span class="line"></span><br><span class="line">NOTE: Please be sure to make any metadata changes to all app localizations by selecting each specific localization and making appropriate changes.</span><br></pre></td></tr></table></figure><p>回复模板如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">尊敬的苹果审核委员会， 你好。</span><br><span class="line">谢谢你的耐心和认真审核， 我们认真排查了你提到的7个审核条款， 我们对此回应如下：</span><br><span class="line">1.1.6：我们App并没有包含误导用户的功能和虚假信息，全都是真实的。</span><br><span class="line">2.3.0：我们App没有在通过苹果审核后修改任何的概念和功能。</span><br><span class="line">2.3.1：我们App没有切换到任何赌博或彩票的网站，我们是原生App。</span><br><span class="line">3.1.1：我们App内需要使用第三方支付来XXX。</span><br><span class="line">4.3.0：我们App内容都是我们自己开发的， 并不存在抄袭或者大量相似。</span><br><span class="line">5.2.1：我们App并没有法人实体和版权的风险。</span><br><span class="line">5.3.4：我们App需要在XXX、XXX等服务中访问用户的位置信息。</span><br><span class="line">这是我们经过认真自查之后，得到的结论， 我们的App需要尽快上线，因为我们有大量推广活动在做。</span><br><span class="line">希望苹果审核团队能继续审核，感谢。</span><br></pre></td></tr></table></figure></p><h3 id="Guideline-2-3-3-Performance-Accurate-Metadata-1"><a href="#Guideline-2-3-3-Performance-Accurate-Metadata-1" class="headerlink" title="Guideline 2.3.3 - Performance - Accurate Metadata"></a>Guideline 2.3.3 - Performance - Accurate Metadata</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">We noticed that your screenshots for iPhone 5.8” do not sufficiently reflect your app in use on the relevant device.</span><br><span class="line"></span><br><span class="line">Please see attached screenshots for details.</span><br><span class="line"></span><br><span class="line">Next Steps</span><br><span class="line"></span><br><span class="line">To resolve this issue, please revise your screenshots to ensure that they accurately reflect the app in use on the supported devices. For iPhone, you need a set of 5.5-inch display screenshots and for iPad, you need a set for 12.9-inch display. This set will be scaled appropriately down to other device sizes when viewed on the App Store in each territory.</span><br><span class="line"></span><br><span class="line">Resources</span><br><span class="line"></span><br><span class="line">For resources on creating great screenshots for the App Store, you may want to review the App Store Product Page information available on the Apple developer portal.</span><br><span class="line"></span><br><span class="line">Please ensure you have made any screenshot modifications using Media Manager. You should confirm your app looks and behaves identically in all languages and on all supported devices. Learn how to use Media Manager to add custom screenshots for each display size and localization.</span><br><span class="line"></span><br><span class="line">Since your iTunes Connect status is Rejected, a new binary will be required. Make the desired metadata changes when you upload the new binary.</span><br><span class="line"></span><br><span class="line">NOTE: Please be sure to make any metadata changes to all app localizations by selecting each specific localization and making appropriate changes.</span><br></pre></td></tr></table></figure><p><code>2.3 准确的元数据问题主要是应用标题、描述、截图等与应用功能严重不符</code></p><ul><li>原因：虽然针对iPhone X上传的设计图尺寸大小符合规定，但在设计图内容中出现的手机屏幕样式不是iPhoneX的样式。</li><li>解决：让设计修改设计图内容中手机屏幕的样式，修改成iPhoneX带刘海的样式，或者5.8寸预览图属于可选而非必选，所以，如果没有新的是配图可以忽略5.8寸不上传。</li></ul><h3 id="Guideline-3-2-1-Business-Other-Business-Model-Issues-Acceptable"><a href="#Guideline-3-2-1-Business-Other-Business-Model-Issues-Acceptable" class="headerlink" title="Guideline 3.2.1 - Business - Other Business Model Issues - Acceptable"></a>Guideline 3.2.1 - Business - Other Business Model Issues - Acceptable</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">The seller and company names associated with your app do not reflect the financial institute name in the app or its metadata, as required by Guideline 3.2.1(viii) of the App Store Review Guidelines.</span><br><span class="line"></span><br><span class="line">Next Steps</span><br><span class="line"></span><br><span class="line">Your app must be published under a seller name and company name that reflects the financial institution. If you have developed this app on behalf of a client, please advise your client to add you to the development team of their Apple Developer account.</span><br><span class="line"></span><br><span class="line">Please note that submitting documentation showing permission to publish this app on behalf of the financial institution will not resolve this issue. This app must be submitted under the financial institution’s own Apple Developer account.</span><br><span class="line"></span><br><span class="line">Once created, you cannot change your seller name or company name in App Store Connect. For assistance with changing your company name or seller name, you will need to contact us. Select Membership and Account to request an update to your Apple Developer account information.</span><br><span class="line"></span><br><span class="line">Please see attached screenshot for details.</span><br><span class="line"></span><br><span class="line">Since your App Store Connect status is Rejected, a new binary will be required.</span><br></pre></td></tr></table></figure><p>原因：</p><ol><li>APP名称跟公司名字差距较大，APP没有表现出APP与公司的关系。</li><li>开发者账号不是企业开发账号</li><li>开发者申请的邮箱不是公司名字的邮箱（比如自己的QQ号码邮箱）</li><li>iTunes Connect中填写的技术支持网址不是跟公司有关的网址。<br>5.电商和金融理财类被拒的风险很大</li></ol><p>解决：</p><ol><li>提供APP是其公司合法App的相关文件，向苹果提供公司营业执照和软著之类证明。在itunes connect中,app描述里面加上: “app名字”属于你们公司的。</li><li>用公司帐号而非个人帐号提交应用。</li><li>确认开发账号申请邮箱是否是公司邮箱</li><li>技术支持是公司网站主页</li><li>提供金融资质证明。审核期间app内部不能出现任何第三方的名字，屏蔽敏感页面和敏感词等审核通过后再打开。</li></ol><h3 id="解决方案中心回复提交附件注意事项（重要）"><a href="#解决方案中心回复提交附件注意事项（重要）" class="headerlink" title="解决方案中心回复提交附件注意事项（重要）"></a>解决方案中心回复提交附件注意事项（重要）</h3><ol><li>上传的文件必须是png格式（直接修改后缀名不可以）</li><li>并且文件大小限制在5M内</li><li>上传文件的命名不要有汉字，要用字母</li></ol><h3 id="Guideline-3-2-2-Business-Other-Business-Model-Issues-Unacceptable"><a href="#Guideline-3-2-2-Business-Other-Business-Model-Issues-Unacceptable" class="headerlink" title="Guideline 3.2.2 - Business - Other Business Model Issues - Unacceptable"></a>Guideline 3.2.2 - Business - Other Business Model Issues - Unacceptable</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The primary purpose of your app is to encourage users to watch ads or perform marketing-oriented tasks, which is not appropriate for the App Store.</span><br><span class="line"></span><br><span class="line">Next Steps</span><br><span class="line"></span><br><span class="line">We encourage you to review your app concept and incorporate different content and features that are in compliance with the App Store Review Guidelines.</span><br></pre></td></tr></table></figure><h3 id="Guideline-5-1-1-Legal-Privacy-Data-Collection-and-Storage"><a href="#Guideline-5-1-1-Legal-Privacy-Data-Collection-and-Storage" class="headerlink" title="Guideline 5.1.1 - Legal - Privacy - Data Collection and Storage"></a>Guideline 5.1.1 - Legal - Privacy - Data Collection and Storage</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">We noticed that your app requests the user’s consent to access their camera but does not clarify the use of this feature in the permission modal alert.</span><br><span class="line"></span><br><span class="line">Please see attached screenshot for details.</span><br><span class="line"></span><br><span class="line">Next Steps</span><br><span class="line"></span><br><span class="line">To resolve this issue, please revise the permission modal alert to specify why the app is requesting access to the user&apos;s camera.</span><br><span class="line"></span><br><span class="line">Resources</span><br><span class="line"></span><br><span class="line">To learn more about requesting the user’s permission to access app features, visit the iOS Human Interface Guidelines. You may also want to review the Technical Q&amp;A QA1937: Resolving the Privacy-Sensitive Data App Rejection page for details on how to provide a usage description for permission request alerts.</span><br></pre></td></tr></table></figure><ul><li>原因：相机使用场景提示文本不够明确，需提示用户为何打开此功能。</li><li>解决：info.plist文件中，对应key为NSCameraUsageDescription的value说明在哪些地方要用到定位服务，用户的位置信息，例如：”App会在XXX、XXX等服务中访问您的相机”。</li></ul><h3 id="Guideline-5-1-1-Legal-Privacy-Data-Collection-and-Storage-1"><a href="#Guideline-5-1-1-Legal-Privacy-Data-Collection-and-Storage-1" class="headerlink" title="Guideline 5.1.1 - Legal - Privacy - Data Collection and Storage"></a>Guideline 5.1.1 - Legal - Privacy - Data Collection and Storage</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Specific issue: We noticed that your app requires users to register with personal information to access non-account-based features.</span><br><span class="line"></span><br><span class="line">Action required: To resolve this issue, please revise your app to let users freely access your app’s non account-based features. To protect users’ privacy, any registration feature that requires users to disclose personal information must be optional or tied to account-specific functionality. Additionally, the requested information must be relevant to the features.</span><br><span class="line"></span><br><span class="line">More information: Apps cannot require user registration prior to allowing access to app content and features that are not associated specifically to the user. You should allow users to freely access your app’s non account-based features. For example, an e-commerce app should let users browse store offerings and other features that are not account-based before being asked to register, or a restaurant app should allow users to explore the menu before placing an order. Registration must then only be required for account-specific features, such as saving items for future reference or placing an order.</span><br></pre></td></tr></table></figure><ul><li>原因：在没有进行与用户信息相关的操作时，却强行让用户登录，甚至不登录就无法看到任何内容。</li><li>解决：增加游客模式。</li></ul><h3 id="Guideline-5-1-5-Legal-Privacy-Location-Services"><a href="#Guideline-5-1-5-Legal-Privacy-Location-Services" class="headerlink" title="Guideline 5.1.5 - Legal - Privacy - Location Services"></a>Guideline 5.1.5 - Legal - Privacy - Location Services</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Your app uses location services but does not clarify the purpose of its use in the location modal alert. Apps that collect, transmit, or use location data must notify and obtain the user’s consent prior to accessing this data.</span><br><span class="line"></span><br><span class="line">Please see attached screenshot for details.</span><br><span class="line"></span><br><span class="line">Next Steps</span><br><span class="line"></span><br><span class="line">To resolve this issue, please specify why the app is requesting the user&apos;s location in the location permission modal alert.</span><br><span class="line"></span><br><span class="line">Resources</span><br><span class="line"></span><br><span class="line">For additional information and instructions on configuring and presenting an alert, please review the Requesting Permission section of the iOS Human Interface Guidelines and the Information Property List Key Reference. You may also want to review the Technical Q&amp;A QA1937: Resolving the Privacy-Sensitive Data App Rejection page for details on how to provide a usage description for permission request alerts.</span><br></pre></td></tr></table></figure><ul><li>原因：定位使用场景提示文本不够明确，需提示用户为何打开此功能。</li><li>解决：info.plist文件中，对应key为NSLocationWhenInUseUsageDescription的value说明在哪些地方要用到定位服务，用户的位置信息，例如：”App会在XXX、XXX等服务中访问您的位置信息”。</li></ul><h2 id="iOS的各种结果文件："><a href="#iOS的各种结果文件：" class="headerlink" title="iOS的各种结果文件："></a>iOS的各种结果文件：</h2><p>（1）app<br>iOS编译以后生成的原始文件，实际是一个文件夹，里面包含各种资源文件（图片，第三方bundle，plist等文件），程序的可执行文件(二进制格式)以及对所有文件的签名记录（_CodeSignature）<br>不能上传AppStore</p><p>（2）dSYM<br>生成.app时的附属产物。本质是一个文件夹，其中只有一个最大的文件，作用是对iOS程序闪退后产生的log文件进行符号化（desymbolicate）；通俗的说，就是把无意义的内存地址变成可读的程序中的类和方法以及代码行数<br>不能上传AppStore</p><p>（3）ipa<br>实际上就是把.app放到Payload文件夹后，对Payload进行了zip操作，最后改了下扩展名。<br>可通过Application Loader上传AppStore</p><p>（4）xcarchive<br>实际上也是一个文件夹，包含.ipa和.dSYM文件<br>可通过Xcode上传AppStore</p><h2 id="获取APP在APP-Store的最新版本号"><a href="#获取APP在APP-Store的最新版本号" class="headerlink" title="获取APP在APP Store的最新版本号"></a>获取APP在APP Store的最新版本号</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//版本更新方法实现</span><br><span class="line">- (NSComparisonResult)shouldUpdateOnlineVersion &#123;</span><br><span class="line">    //获取app地址</span><br><span class="line">    NSURL *appURLPath = [NSURL URLWithString:[NSString stringWithFormat:@&quot;http://itunes.apple.com/lookup?id=%@&quot;,ITUNESAPPID]];</span><br><span class="line">    //获取发布版本的Version</span><br><span class="line">    NSString *string = [NSString stringWithContentsOfURL:appURLPath encoding:NSUTF8StringEncoding error:nil];</span><br><span class="line"></span><br><span class="line">    NSString *onlineVersion;</span><br><span class="line"></span><br><span class="line">    if (!([string isEqualToString:@&quot;&quot;] || string == nil)) &#123;</span><br><span class="line">    NSDictionary *dic = [JsonUtil dictionaryWithJsonString:string];</span><br><span class="line"></span><br><span class="line">        NSInteger resultCount = [[dic objectForKey:@&quot;resultCount&quot;] integerValue];</span><br><span class="line">        if (resultCount == 1) &#123;</span><br><span class="line">            NSArray *result = [dic objectForKey:@&quot;results&quot;];</span><br><span class="line">            NSDictionary *first = [result firstObject];</span><br><span class="line">            onlineVersion = [first objectForKey:@&quot;version&quot;];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return NSOrderedDescending;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NSString *nowVersion = [[[NSBundle mainBundle] infoDictionary] objectForKey:@&quot;CFBundleShortVersionString&quot;];</span><br><span class="line"></span><br><span class="line">    NSComparisonResult result = [nowVersion compare:onlineVersion];</span><br><span class="line">    return result;</span><br><span class="line">    //    NSOrderedAscending 当前版本低于(伪)线上版本</span><br><span class="line">    //    NSOrderedSame 等于</span><br><span class="line">    //    NSOrderedDescending 当前版本高于(伪)线上版本</span><br><span class="line">    //  ！！该接口不一定能获取到最新appstore上的版本信息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 审核 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS单元测试学习笔记</title>
      <link href="/2017/04/09/iOS%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/04/09/iOS%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>1.新建项目时注意勾选<code>Unit Tests</code>,<code>UI Tests</code><br>如果忘记勾选，File–&gt;new–&gt;target–&gt;iOS–&gt;Cocoa Unit Testing Bundle/Cocoa UI Testing Bundle 添加<br><a id="more"></a><br>2.setUp是每个测试方法调用前执行，tearDown是每个测试方法调用后执行<br>3.测试方法必须testXXX的格式，且不能有参数<br>4.测试方法的执行顺序是字典序排序,cmd + U进行单元测试，这个快捷键是全部测试，在代码左侧就是平常打断点的地方，有个菱形按钮是单独测试这个方法<br>5.iOS9的http安全问题：现在进行异步请求的网络测试，由于测试方法主线程执行完就会结束，所以需要设置一下，否则没法查看异步返回结果。在方法结束前设置等待，调回回来的时候再让它继续执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//waitForExpectationsWithTimeout是等待时间，超过了就不再等待往下执行。</span><br><span class="line">#define WAIT do &#123;\</span><br><span class="line">[self expectationForNotification:@&quot;RSBaseTest&quot; object:nil handler:nil];\</span><br><span class="line">[self waitForExpectationsWithTimeout:30 handler:nil];\</span><br><span class="line">&#125; while (0);</span><br><span class="line"></span><br><span class="line">#define NOTIFY \</span><br><span class="line">[[NSNotificationCenter defaultCenter]postNotificationName:@&quot;RSBaseTest&quot; object:nil];</span><br></pre></td></tr></table></figure></p><h2 id="常用的断言测试函数"><a href="#常用的断言测试函数" class="headerlink" title="常用的断言测试函数"></a>常用的断言测试函数</h2><p>XCTFail(format…)  //生成一个失败的测试；<br>XCTAssertNil(a1, format…)  //为空判断，a1为空时通过，反之不通过；<br>XCTAssertNotNil(a1, format…) //不为空判断，a1不为空时通过，反之不通过；<br>XCTAssert(expression, format…) //当expression求值为TRUE时通过；<br>XCTAssertTrue(expression, format…) //当expression求值为TRUE时通过；<br>XCTAssertFalse(expression, format…)  //当expression求值为False时通过；<br>XCTAssertEqualObjects(a1, a2, format…)  //判断相等，[a1 isEqual:a2]值为TRUE时通过，其中一个不为空时，不通过；<br>XCTAssertNotEqualObjects(a1, a2, format…)  //判断不等，[a1 isEqual:a2]值为False时通过；<br>XCTAssertEqual(a1, a2, format…)  //判断相等（当a1和a2是 C语言标量、结构体或联合体时使用,实际测试发现NSString也可以）；<br>XCTAssertNotEqual(a1, a2, format…)  //判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；<br>XCTAssertEqualWithAccuracy(a1, a2, accuracy, format…)  //判断相等，（double或float类型）提供一个误差范围，当在误差范围（+/-accuracy）以内相等时通过测试；<br>XCTAssertNotEqualWithAccuracy(a1, a2, accuracy, format…)   //判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试；<br>XCTAssertThrows(expression, format…)  //异常测试，当expression发生异常时通过；反之不通过；<br>XCTAssertThrowsSpecific(expression, specificException, format…)  //异常测试，当expression发生specificException异常时通过；反之发生其他异常或不发生异常均不通过；<br>XCTAssertThrowsSpecificNamed(expression, specificException, exception_name, format…)  //异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过；<br>XCTAssertNoThrow(expression, format…)  //异常测试，当expression没有发生异常时通过测试；<br>XCTAssertNoThrowSpecific(expression, specificException, format…)  //异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过；<br>XCTAssertNoThrowSpecificNamed(expression, specificException, exception_name, format…)  //异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过</p><p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">// XCTFail(format…)  //生成一个失败的测试；</span><br><span class="line">//        XCTFail(@&quot;Fail&quot;);</span><br><span class="line"></span><br><span class="line">// XCTAssertNil(a1, format...) 为空判断， a1 为空时通过，反之不通过；</span><br><span class="line">//        XCTAssertNil(@&quot;not nil string&quot;, @&quot;string must be nil&quot;);</span><br><span class="line"></span><br><span class="line">// XCTAssertNotNil(a1, format…) 不为空判断，a1不为空时通过，反之不通过；</span><br><span class="line">XCTAssertNotNil(@&quot;not nil string&quot;, @&quot;string can not be nil&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// XCTAssert(expression, format...) 当expression求值为TRUE时通过；</span><br><span class="line">//        XCTAssert((2 &gt; 2), @&quot;expression must be true&quot;);</span><br><span class="line"></span><br><span class="line">// XCTAssertTrue(expression, format...) 当expression求值为TRUE时通过；</span><br><span class="line">XCTAssertTrue(1, @&quot;Can not be zero&quot;);</span><br><span class="line"></span><br><span class="line">// XCTAssertFalse(expression, format...) 当expression求值为False时通过；</span><br><span class="line">XCTAssertFalse((2 &lt; 2), @&quot;expression must be false&quot;);</span><br><span class="line"></span><br><span class="line">// XCTAssertEqualObjects(a1, a2, format...) 判断相等， [a1 isEqual:a2] 值为TRUE时通过，其中一个不为空时，不通过；</span><br><span class="line">//    XCTAssertEqualObjects(@&quot;1&quot;, @&quot;1&quot;, @&quot;[a1 isEqual:a2] should return YES&quot;);</span><br><span class="line">//    XCTAssertEqualObjects(@&quot;1&quot;, @&quot;2&quot;, @&quot;[a1 isEqual:a2] should return YES&quot;);</span><br><span class="line"></span><br><span class="line">//     XCTAssertNotEqualObjects(a1, a2, format...) 判断不等， [a1 isEqual:a2] 值为False时通过，</span><br><span class="line">//    XCTAssertNotEqualObjects(@&quot;1&quot;, @&quot;1&quot;, @&quot;[a1 isEqual:a2] should return NO&quot;);</span><br><span class="line">//    XCTAssertNotEqualObjects(@&quot;1&quot;, @&quot;2&quot;, @&quot;[a1 isEqual:a2] should return NO&quot;);</span><br><span class="line"></span><br><span class="line">// XCTAssertEqual(a1, a2, format...) 判断相等（当a1和a2是 C语言标量、结构体或联合体时使用,实际测试发现NSString也可以）；</span><br><span class="line">// 1.比较基本数据类型变量</span><br><span class="line">//    XCTAssertEqual(1, 2, @&quot;a1 = a2 shoud be true&quot;); // 无法通过测试</span><br><span class="line">//    XCTAssertEqual(1, 1, @&quot;a1 = a2 shoud be true&quot;); // 通过测试</span><br><span class="line"></span><br><span class="line">// 2.比较NSString对象</span><br><span class="line">//    NSString *str1 = @&quot;1&quot;;</span><br><span class="line">//    NSString *str2 = @&quot;1&quot;;</span><br><span class="line">//    NSString *str3 = str1;</span><br><span class="line">//    XCTAssertEqual(str1, str2, @&quot;a1 and a2 should point to the same object&quot;); // 通过测试</span><br><span class="line">//    XCTAssertEqual(str1, str3, @&quot;a1 and a2 should point to the same object&quot;); // 通过测试</span><br><span class="line"></span><br><span class="line">// 3.比较NSArray对象</span><br><span class="line">//    NSArray *array1 = @[@1];</span><br><span class="line">//    NSArray *array2 = @[@1];</span><br><span class="line">//    NSArray *array3 = array1;</span><br><span class="line">//    XCTAssertEqual(array1, array2, @&quot;a1 and a2 should point to the same object&quot;); // 无法通过测试</span><br><span class="line">//    XCTAssertEqual(array1, array3, @&quot;a1 and a2 should point to the same object&quot;); // 通过测试</span><br><span class="line"></span><br><span class="line">// XCTAssertNotEqual(a1, a2, format...) 判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；</span><br><span class="line"></span><br><span class="line">// XCTAssertEqualWithAccuracy(a1, a2, accuracy, format...) 判断相等，（double或float类型）提供一个误差范围，当在误差范围（+/- accuracy ）以内相等时通过测试；</span><br><span class="line">//    XCTAssertEqualWithAccuracy(1.0f, 1.5f, 0.25f, @&quot;a1 = a2 in accuracy should return YES&quot;);</span><br><span class="line"></span><br><span class="line">// XCTAssertNotEqualWithAccuracy(a1, a2, accuracy, format...) 判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试；</span><br><span class="line">//    XCTAssertNotEqualWithAccuracy(1.0f, 1.5f, 0.25f, @&quot;a1 = a2 in accuracy should return NO&quot;);</span><br><span class="line"></span><br><span class="line">// XCTAssertThrows(expression, format...) 异常测试，当expression发生异常时通过；反之不通过；（很变态）</span><br><span class="line"></span><br><span class="line">// XCTAssertThrowsSpecific(expression, specificException, format...) 异常测试，当expression发生 specificException 异常时通过；反之发生其他异常或不发生异常均不通过；</span><br><span class="line"></span><br><span class="line">// XCTAssertThrowsSpecificNamed(expression, specificException, exception_name, format...) 异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过；</span><br><span class="line"></span><br><span class="line">// XCTAssertNoThrow(expression, format…) 异常测试，当expression没有发生异常时通过测试；</span><br><span class="line"></span><br><span class="line">// XCTAssertNoThrowSpecific(expression, specificException, format...)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过；</span><br><span class="line"></span><br><span class="line">// XCTAssertNoThrowSpecificNamed(expression, specificException, exception_name, format...) 异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过</span><br></pre></td></tr></table></figure></p><p>转自：<a href="http://www.jianshu.com/p/8bbec078cabe" target="_blank" rel="noopener">iOS单元测试(作用及入门提升)</a><br>(<a href="http://www.jianshu.com/p/009844a0b9ed" target="_blank" rel="noopener">http://www.jianshu.com/p/009844a0b9ed</a>)</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2017玉渊潭樱花节</title>
      <link href="/2017/04/08/2017%E7%8E%89%E6%B8%8A%E6%BD%AD%E6%A8%B1%E8%8A%B1%E8%8A%82/"/>
      <url>/2017/04/08/2017%E7%8E%89%E6%B8%8A%E6%BD%AD%E6%A8%B1%E8%8A%B1%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<h3 id="2017-04-08-玉渊潭樱花节"><a href="#2017-04-08-玉渊潭樱花节" class="headerlink" title="2017-04-08 玉渊潭樱花节"></a>2017-04-08 玉渊潭樱花节</h3><center><img src="/assets/20170418_yuyuantan/yuyuantan04.JPG" alt=""></center><br><a id="more"></a><br><br><center><br>去年就打算去玉渊潭看花的<br>忘了是什么原因错过了花期，没能去成<br>心里总觉得遗憾<br>今年决定不能再错过一定要去看看的<br>虽然今天天气不太好，但是花开尤盛，自以为很是不错<br>也算是了了一个小小心愿<br><br>最重要的是去了，并且看到了<br>不是么~~<br></center><center><img src="/assets/20170418_yuyuantan/yuyuantan02.JPG" alt=""></center><p><br></p><center><img src="/assets/20170418_yuyuantan/yuyuantan03.JPG" alt=""></center>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>iOS runtime与runloop学习笔记</title>
      <link href="/2017/03/22/iOS%20runtime%E4%B8%8Erunloop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/03/22/iOS%20runtime%E4%B8%8Erunloop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h1><p>Objective-C 是一门动态语言，它把很多静态语言在编译和链接时做的事情放到了运行时去处理，它在运行时实现了对类、方法、成员变量、属性等信息的管理机制。</p><ul><li><p>需要<code>#import &lt;objc/runtime.h&gt;</code></p></li><li><p>基于C，为C添加类面向对象的特性。<br>对象方法：保存到类对象的方法列表。<br>类方法：保存到元类(Meta Class)的方法列表。</p></li></ul><a id="more"></a><h2 id="运行时的类与对象"><a href="#运行时的类与对象" class="headerlink" title="运行时的类与对象"></a>运行时的类与对象</h2><p>类与对象相关的函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">const char *class_getName(Class cls)，获取指定类的类名。</span><br><span class="line">BOOL class_isMetaClass(Class cls)，判断指定类是否是一个元类。</span><br><span class="line">Class class_getSuperclass(Class cls)，获取指定类的父类。</span><br><span class="line">Class class_setSuperclass(Class cls, Class newSuper)，设定指定类的父类。</span><br><span class="line">int class_getVersion(Class cls)，获取指定类的版本信息。</span><br><span class="line">void class_setVersion(Class cls, int version)，设定指定类的版本信息。</span><br><span class="line">size_t class_getInstanceSize(Class cls)，获取实例大小。</span><br><span class="line">Ivar class_getInstanceVariable(Class cls, const char *name)，获取指定名字的实例变量。</span><br><span class="line">Ivar class_getClassVariable(Class cls, const char *name)，获取指定名字的类变量。</span><br><span class="line">Ivar *class_copyIvarList(Class cls, unsigned int *outCount)，获取类的成员变量列表的拷贝。调用后需要自己 free()。</span><br><span class="line">Method class_getInstanceMethod(Class cls, SEL name)，获取指定名字的实例方法。</span><br><span class="line">Method class_getClassMethod(Class cls, SEL name)，获取指定名字的类方法。</span><br><span class="line">IMP class_getMethodImplementation(Class cls, SEL name)，获取指定名字的方法实现。</span><br><span class="line">BOOL class_respondsToSelector(Class cls, SEL sel)，类是否响应指定的方法。</span><br><span class="line">Method *class_copyMethodList(Class cls, unsigned int *outCount)，获取方法列表的拷贝。调用后需要自己 free()。</span><br><span class="line">BOOL class_conformsToProtocol(Class cls, Protocol *protocol)，类是否遵循指定的协议。</span><br><span class="line">Protocol * __unsafe_unretained *class_copyProtocolList(Class cls, unsigned int *outCount)，获取协议列表的拷贝。调用后需要自己 free()。</span><br><span class="line">objc_property_t class_getProperty(Class cls, const char *name)，获取指定名字的属性。</span><br><span class="line">objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)，获取类的属性列表。调用后需要自己 free()。</span><br><span class="line">BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)，为类添加方法。</span><br><span class="line">IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types)，替代类的方法。</span><br><span class="line">BOOL class_addIvar(Class cls, const char *name, size_t size, uint8_t alignment, const char *types)，给指定的类添加成员变量。这个函数只能在 objc_allocateClassPair() 和 objc_registerClassPair() 之间调用，并且不能为一个已经存在的类添加成员变量。</span><br><span class="line">BOOL class_addProtocol(Class cls, Protocol *protocol)，为类添加协议。</span><br><span class="line">BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)，为类添加属性。</span><br><span class="line">void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)，替代类的属性。</span><br><span class="line">id class_createInstance(Class cls, size_t extraBytes)，创建指定类的实例。</span><br><span class="line">id objc_constructInstance(Class cls, void *bytes)，在指定的位置创建类的实例。</span><br><span class="line">void *objc_destructInstance(id obj)，销毁实例。</span><br><span class="line">Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)，创建类和元类。</span><br><span class="line">void objc_registerClassPair(Class cls)，注册类到 Runtime。</span><br><span class="line">void objc_disposeClassPair(Class cls)，销毁类和对应的元类。</span><br></pre></td></tr></table></figure></p><ul><li>类是元类的实例。</li><li>isa，在大多面向对象的语言中，都有类和对象的概念，其中，对象是类的实例，是通过类定义的结构生成出来的。而在 Objective-C 中，类本身也是一个对象，类作为对象时的 isa 指针指向的是元类(Meta Class)。</li><li><p>object_getClass() 可以获得当前对象 isa</p></li><li><p><code>#pragma clang diagnostic...</code>代码，可用于忽略编译器对于未声明的 @selector 的 warning。因为我们的代码中我们需要动态的为一个类创建方法，所以必然不会事先声明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wundeclared-selector&quot;</span><br><span class="line">//调用未声明的 @selector</span><br><span class="line">#pragma clang diagnostic pop</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>objc_registerClassPair()</code> 函数需要注意，不能注册已经注册过的类。</p></li><li>使用 <code>objc_disposeClassPair()</code> 函数需要注意，如果一个类的实例和子类还存在时，不要去销毁一个类。</li></ul><h2 id="运行时的成员变量与属性"><a href="#运行时的成员变量与属性" class="headerlink" title="运行时的成员变量与属性"></a>运行时的成员变量与属性</h2><ul><li>我们不能用 class_addIvar() 函数为一个已经存在的类添加 Ivar。并且 class_addIvar() 只能在 objc_allocateClassPair() 和 objc_registerClassPair() 之间调用。</li><li>添加一个属性及对应的成员变量后，我们还能通过 [obj valueForKey:@”propertyName”]; 获得属性值。</li></ul><h2 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h2><p>可用于在类别中添加属性，创建一个category，然后添加property，并且实现setter,gertter。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)setName:(NSString *)name&#123;</span><br><span class="line">objc_setAssociatedObject(self, &quot;name&quot;, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)name&#123;</span><br><span class="line">return objc_getAssociatedObject(self, &quot;name&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>相关方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void objc_setAssociatedObject(id object, const void *key, id value, objc _AssociationPolicy policy)</span><br><span class="line">id objc_getAssociatedObject(id object, const void *key)</span><br><span class="line">void objc_removeAssociatedObjects(id object)</span><br></pre></td></tr></table></figure></p><h2 id="方法与消息"><a href="#方法与消息" class="headerlink" title="方法与消息"></a>方法与消息</h2><ul><li>需要<code>#import &lt;objc/message.h&gt;</code></li></ul><ol><li>IMP 其实就是 implementation 的缩写，表示方法实现的代码块地址<blockquote><p>IMP定义：<code>id (*IMP)(id, SEL,...)</code></p></blockquote></li></ol><p>2.SEL用于唯一标识一个方法名,因此一个类中是不能存在两个同名的方法的，即使参数类型不同也不行。<br>获取SEL的三种方法：<br>(1)sel_registerName函数<br>(2)Objective-C编译器提供的@selector()<br>(3)NSSelectorFromString()方法</p><p>3.Method<br>将[receiver message]转化为一个消息函数的调用</p><blockquote><p>定义：<code>objc_msgSend(receiver, selector, arg1, arg2,...)</code></p></blockquote><h2 id="消息机制"><a href="#消息机制" class="headerlink" title="消息机制"></a>消息机制</h2><blockquote><p>注意：使用objc_msgSend，需要<code>#import &lt;objc/runtime.h&gt;</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 通过类名获取类</span><br><span class="line">Class catClass = objc_getClass(&quot;Cat&quot;); </span><br><span class="line"></span><br><span class="line">//注意Class实际上也是对象，所以同样能够接受消息，向Class发送alloc消息</span><br><span class="line">Cat *cat = objc_msgSend(catClass, @selector(alloc)); </span><br><span class="line"></span><br><span class="line">//发送init消息给Cat实例cat</span><br><span class="line">cat = objc_msgSend(cat, @selector(init)); </span><br><span class="line"></span><br><span class="line">//发送eat消息给cat，即调用eat方法</span><br><span class="line">objc_msgSend(cat, @selector(eat));</span><br><span class="line"></span><br><span class="line">//汇总消息传递过程</span><br><span class="line">objc_msgSend(objc_msgSend(objc_msgSend(objc_getClass(&quot;Cat&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;)), sel_registerName(&quot;eat&quot;));</span><br></pre></td></tr></table></figure></p></blockquote><ul><li>objc_msgSend()报错<code>Too many arguments to function call ,expected 0,have3</code><blockquote><p>Build Setting–&gt; Apple LLVM 6.0 - Preprocessing–&gt; Enable Strict Checking of objc_msgSend Calls  改为 NO</p></blockquote></li></ul><h2 id="方法交换"><a href="#方法交换" class="headerlink" title="方法交换"></a>方法交换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load&#123;</span><br><span class="line">Method eatMethod = class_getInstanceMethod(self, @selector(eat));</span><br><span class="line">Method playMethod = class_getInstanceMethod(self, @selector(play));</span><br><span class="line">method_exchangeImplementations(eatMethod, playMethod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态加载方法"><a href="#动态加载方法" class="headerlink" title="动态加载方法"></a>动态加载方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void run(id self, SEL _cmd, NSNumber *number)&#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//收到run:消息时候，为该类添加一个方法实现</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel&#123;</span><br><span class="line">if(sel == NSSelectorFromString(@&quot;run:&quot;))&#123;</span><br><span class="line">class_addMethod(self, @selector(run:), run, &quot;v@:@&quot;);</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line">return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line">//另外针对类方法的为 resolveClassMethod</span><br></pre></td></tr></table></figure><h2 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h2><p>Method Swizzling（俗称黑魔法）就是在运行时将一个方法的实现代替为另一个方法的实现。Runtime提供三种方式来将原来的方法实现代替掉，那该怎样选择它们呢？<br>1.Method Resolution：由于Method Resolution不能像消息转发那样可以交给其他对象来处理，所以只适用于在原来的类中代替掉。<br>2.Fast Forwarding：它可以将消息处理转发给其他对象，使用范围更广，不只是限于原来的对象。<br>3.Normal Forwarding：它跟Fast Forwarding一样可以消息转发，但它能通过NSInvocation对象获取更多消息发送的信息，例如：target、selector、arguments和返回值等信息。</p><p>消息转发机制基本上分为三个步骤：<br>第一步：动态方法解析。<br>第二步：备用接收者。<br>第三步：完整转发。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">//  第一步，消息接收者没有找到对应的方法时候，会先调用此方法，可在此方法实现中动态添加新的方法</span><br><span class="line">//  返回YES表示相应selector的实现已经被找到，或者添加新方法到了类中，否则返回NO</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  第二步， 如果第一步的返回NO或者直接返回了YES而没有添加方法，该方法被调用</span><br><span class="line">//  在这个方法中，我们可以指定一个可以返回一个可以响应该方法的对象， 注意如果返回self就会死循环</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">//    if ([NSStringFromSelector(aSelector) isEqualToString:@&quot;run:&quot;]) &#123;</span><br><span class="line">//        return [[RuntimeMethodHelper alloc] init];</span><br><span class="line">//    &#125;</span><br><span class="line">//    return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  第三步， 如果forwardingTargetForSelector:返回了nil，则该方法会被调用，系统会询问我们要一个合法的『类型编码(Type Encoding)』</span><br><span class="line">//  函数的最后一个参数 types 是描述方法返回值和参数列表的字符串，我们的代码中的用到的 i@:@ 四个字符分别对应着：返回值 int32_t、参数 id self、参数 SEL _cmd、参数 NSDictionary *dic,即类型编码。</span><br><span class="line">//  若返回 nil，则不会进入下一步，而是无法处理消息</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    NSMethodSignature *signature = [super methodSignatureForSelector:aSelector];</span><br><span class="line">    if (!signature) &#123;</span><br><span class="line">        if ([NSStringFromSelector(aSelector) isEqualToString:@&quot;run:&quot;])&#123;</span><br><span class="line">            return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];</span><br><span class="line">        &#125;</span><br><span class="line">        return [super methodSignatureForSelector: aSelector];</span><br><span class="line">    &#125;</span><br><span class="line">    return signature;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 当实现了此方法后，-doesNotRecognizeSelector: 将不会被调用</span><br><span class="line">// 在这里进行消息转发</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line"></span><br><span class="line">if ([RuntimeMethodHelper instancesRespondToSelector:anInvocation.selector]) &#123;</span><br><span class="line">[anInvocation invokeWithTarget:[[RuntimeMethodHelper alloc] init]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//    // 在这里可以改变方法选择器</span><br><span class="line">//    [anInvocation setSelector:@selector(run:)];</span><br><span class="line">//    // 改变方法选择器后，需要指定消息的接收者</span><br><span class="line">//    [anInvocation invokeWithTarget:self];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//- (void)run:(NSNumber *)num &#123;</span><br><span class="line">//    NSLog(@&quot;---%@&quot;, num); // Print: &lt;RuntimeMethodHelper: 0x7f814b498ee0&gt;, 0x102d79929</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">// 如果没有实现消息转发 forwardInvocation  则调用此方法</span><br><span class="line">- (void)doesNotRecognizeSelector:(SEL)aSelector &#123;</span><br><span class="line">NSLog(@&quot;unresolved method ：%@&quot;, NSStringFromSelector(aSelector));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="深入理解黑魔法"><a href="#深入理解黑魔法" class="headerlink" title="深入理解黑魔法"></a>深入理解黑魔法</h3><p>当项目规模比较大，各个控制器功能都已经实现，突然增加每个页面都需要修改的需求，实现方式有以下几种：<br>1.每个页面进行修改<br>2.继承<br>3.category<br>4.Method Swizzling<br>Method Swizzling本质上就是对IMP和SEL进行交换。Method Swizzling也是iOS中AOP(面相切面编程)的一种实现方式。<br>在OC语言的runtime特性中，调用一个对象的方法就是给这个对象发送消息。是通过查找接收消息对象的方法列表，从方法列表中查找对应的SEL，这个SEL对应着一个IMP(一个IMP可以对应多个SEL)，通过这个IMP找到对应的方法调用。<br>在每个类中都有一个Dispatch Table，这个Dispatch Table本质是将类中的SEL和IMP(可以理解为函数指针)进行对应。而我们的Method Swizzling就是对这个table进行了操作，让SEL对应另一个IMP。<br>在实现Method Swizzling时，核心代码主要就是一个runtime的C语言API：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT void method_exchangeImplementations(Method m1, Method m2) </span><br><span class="line">__OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);</span><br></pre></td></tr></table></figure></p><h2 id="字典转模型应用"><a href="#字典转模型应用" class="headerlink" title="字典转模型应用"></a>字典转模型应用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)modelWithDict:(NSDictionary *)dict&#123;</span><br><span class="line">    id model = [[self alloc] init];</span><br><span class="line">    unsigned int count = 0;</span><br><span class="line"></span><br><span class="line">    Ivar *ivars = class_copyIvarList(self, &amp;count);</span><br><span class="line">    for (int i = 0 ; i &lt; count; i++) &#123;</span><br><span class="line">        Ivar ivar = ivars[i];</span><br><span class="line"></span><br><span class="line">        NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(ivar)];</span><br><span class="line"></span><br><span class="line">        //这里注意，拿到的成员变量名为_cid,_age</span><br><span class="line">        ivarName = [ivarName substringFromIndex:1];</span><br><span class="line">        id value = dict[ivarName];</span><br><span class="line"></span><br><span class="line">        [model setValue:value forKeyPath:ivarName];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return model;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/guchunli/RuntimeDemo" target="_blank" rel="noopener">demo传送门</a></p><h1 id="runloop运行循环"><a href="#runloop运行循环" class="headerlink" title="runloop运行循环"></a>runloop运行循环</h1><ul><li>保持程序的持续运行。</li><li>处理App中的各类事件（触摸事件、定时器事件、Selector事件）</li><li>节省CPU资源，提高程序性能：没有事件时就进行睡眠状态</li></ul><h2 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h2><p>do-while循环，在这个循环内部不断地处理各种任务（Source\Timeer\Observer）,Source和Timer这两个是主动向RunLoop发送消息的，Observer是被动接收消息的。CDRunLoopRunSpecific具体处理runloop的运行情况。</p><h2 id="runloop与线程"><a href="#runloop与线程" class="headerlink" title="runloop与线程"></a>runloop与线程</h2><h3 id="线程与RunLoop一一对应，其关系是保存在一个全局的-Dictionary-里，key-是-pthread-t，-value-是-CFRunLoopRef，RunLoop在第一次获取时创建，在线程结束时销毁"><a href="#线程与RunLoop一一对应，其关系是保存在一个全局的-Dictionary-里，key-是-pthread-t，-value-是-CFRunLoopRef，RunLoop在第一次获取时创建，在线程结束时销毁" class="headerlink" title="线程与RunLoop一一对应，其关系是保存在一个全局的 Dictionary 里，key 是 pthread_t， value 是 CFRunLoopRef，RunLoop在第一次获取时创建，在线程结束时销毁"></a>线程与RunLoop一一对应，其关系是保存在一个全局的 Dictionary 里，key 是 pthread_t， value 是 CFRunLoopRef，RunLoop在第一次获取时创建，在线程结束时销毁</h3><h3 id="主线程的RunLoop默认已经启动，子线程的RunLoop需要手动启动"><a href="#主线程的RunLoop默认已经启动，子线程的RunLoop需要手动启动" class="headerlink" title="主线程的RunLoop默认已经启动，子线程的RunLoop需要手动启动"></a>主线程的RunLoop默认已经启动，子线程的RunLoop需要手动启动</h3><h3 id="RunLoop只能选择一个Mode启动，如果当前Mode没有任何Source、Timer、Observer，那么就不会进入RunLoop"><a href="#RunLoop只能选择一个Mode启动，如果当前Mode没有任何Source、Timer、Observer，那么就不会进入RunLoop" class="headerlink" title="RunLoop只能选择一个Mode启动，如果当前Mode没有任何Source、Timer、Observer，那么就不会进入RunLoop"></a>RunLoop只能选择一个Mode启动，如果当前Mode没有任何Source、Timer、Observer，那么就不会进入RunLoop</h3><ul><li>runloop生命周期：第一次获取时创建（currentRunloop），每条线程对应唯一的runloop，线程结束runloop销毁</li><li>主runloop：在applicationMain中自动创建runloop，主runloop与主线程相关，主线程中runloop自动启动运行，子线程中需要手动创建</li><li>获取runloop：mainRunloop,currentRunloop（懒加载）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];</span><br><span class="line">NSRunLoop *currentRunloop = [NSRunLoop currentRunLoop];</span><br><span class="line">[NSTimer scheduledTimerWithTimeInterval:1.f target:self selector:@selector(run) userInfo:nil repeats:YES];</span><br><span class="line">[currentRunloop run];</span><br></pre></td></tr></table></figure></li></ul><h2 id="iOS中访问和使用RunLoop的API"><a href="#iOS中访问和使用RunLoop的API" class="headerlink" title="iOS中访问和使用RunLoop的API"></a>iOS中访问和使用RunLoop的API</h2><ul><li>Foundation–NSRunLoop</li><li>Core Foundation–CFRunLoopRef(开源)<br>因为后者是开源的，且前者是在后者上针对OC的封装，所以一般是对CFRunLoopRef进行研究。</li></ul><h3 id="两套API对应获取RunLoop对象的方式："><a href="#两套API对应获取RunLoop对象的方式：" class="headerlink" title="两套API对应获取RunLoop对象的方式："></a>两套API对应获取RunLoop对象的方式：</h3><blockquote><p>值得注意的是，获取当前RunLoop都是进行懒加载的，也就是调用时自动创建线程对应的RunLoop。</p><ul><li>Foundation<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[NSRunLoop currentRunLoop]; // 当前runloop</span><br><span class="line">[NSRunLoop mainRunLoop];// 主线程runloop</span><br></pre></td></tr></table></figure></li></ul></blockquote><ul><li>Core Foundation<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopGetCurrent();// 当前runloop</span><br><span class="line">CFRunLoopGetMain();// 主线程runloop</span><br></pre></td></tr></table></figure></li></ul><p>NSRunLoop转化为CFRunLoop：runloop.getCFRunloop</p><h3 id="相关类"><a href="#相关类" class="headerlink" title="相关类"></a>相关类</h3><p>CFRunLoopRef,mode,source（set）,timer（array）,observer（array），每个runloop中至少要有一个source或timer<br>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。</p><h2 id="runloop的运行模式"><a href="#runloop的运行模式" class="headerlink" title="runloop的运行模式"></a>runloop的运行模式</h2><ul><li>CFRunLoopModeRef代表RunLoop的运行模式，一个RunLoop可以包含多个Mode，每个Mode可以包含多个Source、Timer、Observer。</li><li>每次RunLoop启动时，只能指定其中一个Mode，这个Mode就变成了CurrentMode</li><li>当启动RunLoop时，如果所在Mode中没有Source、Timer、Observer，那么将不会进入RunLoop，会直接结束</li><li>如果要切换Mode，只能退出Loop，再重新制定一个Mode进入</li></ul><p>CFRunLoopSourceRef 是事件产生的地方<br>CFRunLoopTimerRef 是基于时间的触发器<br>CFRunLoopObserverRef 是观察者</p><h3 id="系统默认注册了5个Mode"><a href="#系统默认注册了5个Mode" class="headerlink" title="系统默认注册了5个Mode"></a>系统默认注册了5个Mode</h3><ul><li>NSDefaultRunLoopMode：App的默认Mode，通常主线程是在这个Mode下运行</li><li>NSRunLoopCommonModes: 这是一个占位用的Mode，不是一种真正的Mode，mode集合</li><li>UITrackingRunLoopMode：界面跟踪 Mode，追踪触摸滑动，保证界面滑动时不受其他 Mode 影响</li><li>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用</li><li>GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到</li></ul><h3 id="NSRunLoopCommonModes"><a href="#NSRunLoopCommonModes" class="headerlink" title="NSRunLoopCommonModes"></a>NSRunLoopCommonModes</h3><ul><li>一个Mode可以将自己标记为“Common”属性，每当 RunLoop 的内容发生变化时，RunLoop会对标记有“Common”属性的Mode进行相适应的切换，并同步Source/Observer/Timer</li><li>在主线程中，kCFRunLoopDefaultMode 和 UITrackingRunLoopMode这两个Mode都是被默认标记为“Common”属性的，从输出的主线程RunLoop可以查看。</li></ul><h3 id="source（timer-input）"><a href="#source（timer-input）" class="headerlink" title="source（timer,input）"></a>source（timer,input）</h3><ul><li>根据函数调用栈分为：<br>source0：不基于port，用户主动触发的<br>source1：基于Port，系统的</li></ul><h3 id="observer"><a href="#observer" class="headerlink" title="observer"></a>observer</h3><ul><li>监听runloop的状态改变<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">第一个参数：分配空间</span><br><span class="line">第一个参数：监听哪个状态</span><br><span class="line">第一个参数：是否持续监听</span><br><span class="line">第一个参数：优先级</span><br><span class="line">第一个参数：回调</span><br><span class="line">*/</span><br><span class="line">CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), kCFRunLoopAfterWaiting, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">kCFRunLoopEntry = (1UL &lt;&lt; 0),</span><br><span class="line">kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),</span><br><span class="line">kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),</span><br><span class="line">kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),</span><br><span class="line">kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),</span><br><span class="line">kCFRunLoopExit = (1UL &lt;&lt; 7),</span><br><span class="line">kCFRunLoopAllActivities = 0x0FFFFFFFU</span><br><span class="line">*/</span><br><span class="line">switch (activity) &#123;</span><br><span class="line">case kCFRunLoopAfterWaiting:</span><br><span class="line">NSLog(@&quot;即将进入休眠&quot;);</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="runloop的应用"><a href="#runloop的应用" class="headerlink" title="runloop的应用"></a>runloop的应用</h3><p>1.timer<br>2.imageView的显示<br>3.performSelector<br>4.常驻线程：线程完成任务自动挂掉，如果在完成任务后保持runloop，则不会挂掉。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[NSRunLoop currentRunLoop]addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</span><br></pre></td></tr></table></figure></p><p>5.自动释放池<br>什么时候创建：启动runloop<br>最后一次销毁：退出runloop<br>其他时候的创建和销毁：runloop即将进入休眠时会销毁之前的，重新创建一个新的</p><p>事件响应<br>手势识别<br>界面更新<br>定时器<br>PerformSelecter<br>关于GCD<br>关于网络请求</p><p>参考：<a href="https://www.jianshu.com/p/19f280afcb24" target="_blank" rel="noopener">iOS 模块详解—「Runtime面试、工作」</a><br><a href="http://www.samirchen.com/objective-c-runtime/" target="_blank" rel="noopener">Objective-C 的 Runtime</a><br><a href="http://www.jianshu.com/p/99af00237cb8" target="_blank" rel="noopener">iOS Runtime 几种基本用法简记</a><br><a href="http://www.jianshu.com/p/adf0d566c887" target="_blank" rel="noopener">iOS运行时(Runtime)详解+Demo</a><br><a href="https://www.jianshu.com/p/ed65518ec8db" target="_blank" rel="noopener">https://www.jianshu.com/p/ed65518ec8db</a></p><p><a href="https://www.jianshu.com/p/ebc6e20b84cf" target="_blank" rel="noopener">iOS runtime和runloop</a><br><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">深入理解RunLoop</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> runtime </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Apple Pay学习笔记</title>
      <link href="/2017/03/15/Apple%20Pay%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/03/15/Apple%20Pay%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="1-支付方式：Touch-ID-Passcode"><a href="#1-支付方式：Touch-ID-Passcode" class="headerlink" title="1.支付方式：Touch ID/ Passcode"></a>1.支付方式：Touch ID/ Passcode</h3><h3 id="2-设备要求：iPhone6以上（iphone-线上-线下-ipad-线上-watch-线下）"><a href="#2-设备要求：iPhone6以上（iphone-线上-线下-ipad-线上-watch-线下）" class="headerlink" title="2.设备要求：iPhone6以上（iphone:线上/线下 ipad:线上 watch:线下）"></a>2.设备要求：iPhone6以上（iphone:线上/线下 ipad:线上 watch:线下）</h3><h3 id="3-系统要求：iOS8-0以上，银联（中国）：9-2"><a href="#3-系统要求：iOS8-0以上，银联（中国）：9-2" class="headerlink" title="3.系统要求：iOS8.0以上，银联（中国）：9.2"></a>3.系统要求：iOS8.0以上，银联（中国）：9.2</h3><a id="more"></a><h3 id="4-基于NFC"><a href="#4-基于NFC" class="headerlink" title="4.基于NFC"></a>4.基于NFC</h3><h3 id="5-2014年10月20日在美国正式上线，2016年2月18日凌晨5：00，-Apple-Pay-业务在中国上线。"><a href="#5-2014年10月20日在美国正式上线，2016年2月18日凌晨5：00，-Apple-Pay-业务在中国上线。" class="headerlink" title="5.2014年10月20日在美国正式上线，2016年2月18日凌晨5：00， Apple Pay 业务在中国上线。"></a>5.2014年10月20日在美国正式上线，2016年2月18日凌晨5：00， Apple Pay 业务在中国上线。</h3><h3 id="6-与微信支付以及支付宝等第三方支付平台的区别："><a href="#6-与微信支付以及支付宝等第三方支付平台的区别：" class="headerlink" title="6.与微信支付以及支付宝等第三方支付平台的区别："></a>6.与微信支付以及支付宝等第三方支付平台的区别：</h3><ul><li>硬件方面<ul><li>Apple Pay：必须是iOS设备， 而且是按照线上支付和线下支付区分不同的真机设备</li><li>微信、支付宝： 基本跟硬件设备无关， 支持大多数的智能手机</li></ul></li><li>网络环境要求<ul><li>Apple Pay：线上支付需要联网， 线下支付无需联网就可以支付</li><li>微信、支付宝： 无论是线上还是线下支付， 都需要联网使用</li></ul></li><li>使用技术<ul><li>Apple Pay：线下支付使用的是 基于NFC的近场通讯技术</li><li>微信、支付宝： 线下支付使用的是 扫码支付（条形码、二维码）</li></ul></li><li>主要功能<ul><li>Apple Pay：线上支付、线下支付、部分升级后的ATM机可以取款</li><li>微信、支付宝： 线上支付、线下支付、转账、理财等  </li></ul></li><li>安全性能<ul><li>Apple Pay：不保留银行卡信息，并且不会暴漏给外界、不分流银行存款（不需要从银行卡转钱到另外一个平台）、不能充值  安全性较高</li><li>微信、支付宝： 密码保护，身份验证等手段保护账户  安全性相对稍差</li></ul></li><li>支付时长<ul><li>Apple Pay：无论是线上支付，还是线下支付， 只需要验证指纹即可支付。非常迅速</li><li>微信、支付宝： 需要扫码支付， 流程相对繁琐，所以时长较长</li></ul></li><li>各自弊端<ul><li>Apple Pay：只适用于苹果设备， 支付场景单一，无转账理财等业务</li><li>微信、支付宝： 安全性较差， 必须联网操作，需要充值到对应平台</li></ul></li></ul><h2 id="注册并配置一个商业标示符"><a href="#注册并配置一个商业标示符" class="headerlink" title="注册并配置一个商业标示符"></a>注册并配置一个商业标示符</h2><p>1.添加一个App ID<br>2.配置Merchant ID<br>3.为Merchant ID 配置证书, 并下载证书安装到钥匙串<br>4.检查安装到钥匙串中的证书是否有效<br>5.绑定Merchant ID 到 APP ID</p><p>证书失效，请到以下地址下载重新安装：<a href="https://www.apple.com/certificateauthority/" target="_blank" rel="noopener">https://www.apple.com/certificateauthority/</a><br><img src="/assets/20170315_ApplePay/applepay.png" alt="证书"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br></pre></td><td class="code"><pre><span class="line">//一.判断当前设备是否支持支付</span><br><span class="line"></span><br><span class="line">if (![PKPaymentAuthorizationViewController canMakePayments]) &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;该设备不支持ApplePay&quot;);</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//二.判断Wallet有没有添加该支付网络的储蓄卡/信用卡</span><br><span class="line"></span><br><span class="line">&#125;else if ([PKPaymentAuthorizationViewController canMakePaymentsUsingNetworks:@[PKPaymentNetworkChinaUnionPay,PKPaymentNetworkVisa]])&#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;Wallet没有添加该支付网络的储蓄卡/信用卡&quot;);</span><br><span class="line"></span><br><span class="line">//创建一个添加卡的按钮</span><br><span class="line"></span><br><span class="line">PKPaymentButton *btn = [PKPaymentButton buttonWithType:PKPaymentButtonTypeSetUp style:PKPaymentButtonStyleBlack];</span><br><span class="line"></span><br><span class="line">[btn addTarget:self action:@selector(jumpToSetup) forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line"></span><br><span class="line">[self.payView addSubview:btn];        </span><br><span class="line"></span><br><span class="line">&#125;else&#123;</span><br><span class="line"></span><br><span class="line">//创建一个支付按钮</span><br><span class="line"></span><br><span class="line">PKPaymentButton *btn = [PKPaymentButton buttonWithType:PKPaymentButtonTypeBuy style:PKPaymentButtonStyleWhiteOutline];</span><br><span class="line"></span><br><span class="line">[btn addTarget:self action:@selector(jumpToPay) forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line"></span><br><span class="line">[self.payView addSubview:btn];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)jumpToSetup&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NSLog(@&quot;跳转到添加银行卡页面&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PKPassLibrary * pk = [[PKPassLibrary alloc]init];</span><br><span class="line"></span><br><span class="line">[pk openPaymentSetup];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)jumpToPay&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//三.创建支付请求并配置各项信息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//1.创建支付请求</span><br><span class="line"></span><br><span class="line">PKPaymentRequest *request = [[PKPaymentRequest alloc]init];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//2.配置参数</span><br><span class="line"></span><br><span class="line">//2.1 商店标识</span><br><span class="line"></span><br><span class="line">request.merchantIdentifier = @&quot;&quot;;</span><br><span class="line"></span><br><span class="line">//2.2 国家代码</span><br><span class="line"></span><br><span class="line">request.countryCode = @&quot;CN&quot;;</span><br><span class="line"></span><br><span class="line">//2.3 货币代码</span><br><span class="line"></span><br><span class="line">request.currencyCode = @&quot;CNY&quot;;</span><br><span class="line"></span><br><span class="line">//2.4 支持的支付网络</span><br><span class="line"></span><br><span class="line">request.supportedNetworks = @[PKPaymentNetworkChinaUnionPay,PKPaymentNetworkVisa];</span><br><span class="line"></span><br><span class="line">//2.5 支付请求包含一个支付摘要项目的列表</span><br><span class="line"></span><br><span class="line">NSDecimalNumber *price1 = [NSDecimalNumber decimalNumberWithString:@&quot;10.0&quot;];</span><br><span class="line"></span><br><span class="line">PKPaymentSummaryItem *item1 = [PKPaymentSummaryItem summaryItemWithLabel:@&quot;iPhone&quot; amount:price1];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NSDecimalNumber *price2 = [NSDecimalNumber decimalNumberWithString:@&quot;20.0&quot;];</span><br><span class="line"></span><br><span class="line">PKPaymentSummaryItem *item2 = [PKPaymentSummaryItem summaryItemWithLabel:@&quot;iPad&quot; amount:price2 type:PKPaymentSummaryItemTypePending];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NSDecimalNumber *totalPrice = [NSDecimalNumber zero];</span><br><span class="line"></span><br><span class="line">totalPrice = [totalPrice decimalNumberByAdding:price1];</span><br><span class="line"></span><br><span class="line">totalPrice = [totalPrice decimalNumberByAdding:price2];</span><br><span class="line"></span><br><span class="line">PKPaymentSummaryItem *total = [PKPaymentSummaryItem summaryItemWithLabel:@&quot;财务中心&quot; amount:totalPrice type:PKPaymentSummaryItemTypePending];</span><br><span class="line"></span><br><span class="line">//注意：数组最后一个是总价格</span><br><span class="line"></span><br><span class="line">request.paymentSummaryItems = @[item1,item2,total];</span><br><span class="line"></span><br><span class="line">//2.6运输方式</span><br><span class="line"></span><br><span class="line">NSDecimalNumber *shippingPrice = [NSDecimalNumber decimalNumberWithString:@&quot;18.0&quot;];</span><br><span class="line"></span><br><span class="line">PKShippingMethod *method = [PKShippingMethod summaryItemWithLabel:@&quot;顺风快递&quot; amount:shippingPrice];</span><br><span class="line"></span><br><span class="line">method.identifier = @&quot;shunfeng&quot;;</span><br><span class="line"></span><br><span class="line">method.detail = @&quot;24小时内送到&quot;;</span><br><span class="line"></span><br><span class="line">request.shippingMethods = @[method];</span><br><span class="line"></span><br><span class="line">request.shippingType = PKShippingTypeServicePickup;</span><br><span class="line"></span><br><span class="line">//2.7通过指定merchantCapabilities属性来指定你支持的支付处理标准，3DS支付方式是必须支持的，EMV方式是可选的</span><br><span class="line"></span><br><span class="line">request.merchantCapabilities = PKMerchantCapability3DS | PKMerchantCapabilityEMV | PKMerchantCapabilityCredit | PKMerchantCapabilityDebit;</span><br><span class="line"></span><br><span class="line">//2.8需要的配送信息和账单信息</span><br><span class="line"></span><br><span class="line">request.requiredBillingAddressFields = PKAddressFieldAll;</span><br><span class="line"></span><br><span class="line">request.requiredShippingAddressFields = PKAddressFieldAll;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//2.9 存储额外信息</span><br><span class="line"></span><br><span class="line">request.applicationData = [@&quot;购物车ID：123456&quot; dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//四.弹出授权控制器，让用户给支付授权</span><br><span class="line"></span><br><span class="line">//开始支付</span><br><span class="line"></span><br><span class="line">PKPaymentAuthorizationViewController *pkCtrl = [[PKPaymentAuthorizationViewController alloc]initWithPaymentRequest:request];</span><br><span class="line"></span><br><span class="line">if (pkCtrl == nil) &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;授权控制器创建失败&quot;);</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pkCtrl.delegate = self;</span><br><span class="line"></span><br><span class="line">[self presentViewController:pkCtrl animated:YES completion:nil];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - PKPaymentAuthorizationViewControllerDelegate</span><br><span class="line"></span><br><span class="line">//五.处理支付凭证</span><br><span class="line"></span><br><span class="line">//授权成功</span><br><span class="line"></span><br><span class="line">- (void)paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)controller</span><br><span class="line"></span><br><span class="line">didAuthorizePayment:(PKPayment *)payment</span><br><span class="line"></span><br><span class="line">completion:(void (^)(PKPaymentAuthorizationStatus status))completion&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line">服务器接收到token后的一般处理流程:</span><br><span class="line"></span><br><span class="line">1.验证支付数据的哈希表和签名</span><br><span class="line"></span><br><span class="line">2.为加密过的支付数据解码</span><br><span class="line"></span><br><span class="line">3.向支付处理系统提交支付数据</span><br><span class="line"></span><br><span class="line">4.向订单追踪系统提交订单</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;验证授权---%@&quot;,payment.token);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line">处理支付请求时，你有两个选择:</span><br><span class="line"></span><br><span class="line">1.你既可以利用支付平台处理支付请求，</span><br><span class="line"></span><br><span class="line">2.也可以自己实现支付请求处理流程。</span><br><span class="line"></span><br><span class="line">一个常用的支付平台可以完成上述大部分操作。</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;验证通过后，需要开发中继续完成交易&quot;);</span><br><span class="line"></span><br><span class="line">BOOL isSuccess = YES;</span><br><span class="line"></span><br><span class="line">if (isSuccess) &#123;</span><br><span class="line"></span><br><span class="line">completion(PKPaymentAuthorizationStatusSuccess);</span><br><span class="line"></span><br><span class="line">&#125;else&#123;</span><br><span class="line"></span><br><span class="line">completion(PKPaymentAuthorizationStatusFailure);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//六.关闭授权控制器</span><br><span class="line"></span><br><span class="line">//授权成功或者取消授权之后会调用此方法</span><br><span class="line"></span><br><span class="line">- (void)paymentAuthorizationViewControllerDidFinish:(PKPaymentAuthorizationViewController *)controller&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NSLog(@&quot;取消或者交易完成&quot;);</span><br><span class="line"></span><br><span class="line">[self dismissViewControllerAnimated:YES completion:nil];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文章：<br><a href="http://www.cnblogs.com/dashunzi/archive/2016/02/23/ApplePay.html#undefined" target="_blank" rel="noopener">Apple Pay–iOS开发</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>将.c文件打包成库文件</title>
      <link href="/2017/03/06/%E5%B0%86-c%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E6%88%90%E5%BA%93%E6%96%87%E4%BB%B6/"/>
      <url>/2017/03/06/%E5%B0%86-c%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E6%88%90%E5%BA%93%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="打包-a"><a href="#打包-a" class="headerlink" title="打包.a"></a>打包.a</h2><p>1.Cocoa Touch Static Library<br>2.添加要打包的文件:.c，.h<br>3.将头文件添加到Build Phases -&gt; Copy Files中去<br><a id="more"></a><br>4.需要修改Build Settings中的 Build Active Architecture Only 以满足运行不同CPU环境的模拟器。 将此设置为NO。<br>　选择Edit Scheme–&gt; Buid Configuration设置为release<br>5.分别选择模拟器和真机编译，生成.a文件，在不同编译环境下编译会生成四种静态库，debug模拟器，debug真机，release模拟器，release真机<br>6.查看静态库所支持的CPU环境：lipo -info 静态库文件<br>7.合并静态库：lipo -create 静态库1 静态库2 -output 新静态库名称.a</p><p>注意：<br>1.如果直接拖拽的是一个项目，并将项目当做一个静态库引用需要这样处理：在 Build Phases 中的 Target Dependencies 和 Link Binary With Libraries 中分别添加项目。<br>如果仅仅是一个静态库的话，那么Link Binary WithLibraries 是必须添加的。<br>2.如果编译的静态库中有分类的话必须在 Build Settings –&gt; Other Linker Flags 中加 -Objc 如果还崩溃，还得加上 -all_load</p><h2 id="打包-so"><a href="#打包-so" class="headerlink" title="打包.so"></a>打包.so</h2><p>1.编译<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -fPIC -o myfile.o myfile.c</span><br></pre></td></tr></table></figure></p><p>2.生成.so文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -o libname.so myfile.o</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 打包 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>github上使用SSH和gitignore</title>
      <link href="/2017/03/03/github%E4%B8%8A%E4%BD%BF%E7%94%A8SSH%E5%92%8Cgitignore/"/>
      <url>/2017/03/03/github%E4%B8%8A%E4%BD%BF%E7%94%A8SSH%E5%92%8Cgitignore/</url>
      
        <content type="html"><![CDATA[<h2 id="使用SSH"><a href="#使用SSH" class="headerlink" title="使用SSH"></a>使用SSH</h2><h3 id="来到以下路径"><a href="#来到以下路径" class="headerlink" title="来到以下路径"></a>来到以下路径</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.ssh</span><br></pre></td></tr></table></figure><a id="more"></a><p>//如果.ssh文件夹不存在，执行<code>mkdir ~/.ssh</code> 进行创建</p><h3 id="生成RSA密钥对"><a href="#生成RSA密钥对" class="headerlink" title="生成RSA密钥对"></a>生成RSA密钥对</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;your email address&quot;</span><br></pre></td></tr></table></figure><h3 id="查看公钥内容"><a href="#查看公钥内容" class="headerlink" title="查看公钥内容"></a>查看公钥内容</h3><p>复制粘贴公钥，注意：公钥内容以ssh-rsa开头，你的邮箱结尾：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure></p><h3 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com  （github） </span><br><span class="line">$ ssh -T git@git.oschina.net  (oschina)</span><br><span class="line">$ Welcome to Git@OSC, nickname!</span><br></pre></td></tr></table></figure><h2 id="gitignore"><a href="#gitignore" class="headerlink" title="gitignore"></a>gitignore</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /Users/apple/Desktop/code</span><br><span class="line">git clone git地址</span><br><span class="line">cp gitignore路径 .gitignore</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;添加 gitignore&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>注意：”cp gitignore路径 .gitignore”一定要加”.gitignore”。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git学习笔记</title>
      <link href="/2017/03/03/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/03/03/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h2><blockquote><p>$ git init</p></blockquote><a id="more"></a><h2 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h2><blockquote><p>$ git add .<br>$ git commit -m “”</p></blockquote><h2 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h2><blockquote><p>$ git status</p></blockquote><h2 id="查看修改"><a href="#查看修改" class="headerlink" title="查看修改"></a>查看修改</h2><blockquote><p>$ git diff<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-change something</span><br><span class="line">+change</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>$ git diff &gt; 1.diff<br>将diff修改写到1.diff文件中</p></blockquote><h2 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h2><blockquote><p>$ git log</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">commit acbcfcfa48c89deb725aae9e03a68a2f5abaa1d4</span><br><span class="line">Author: gcl &lt;155@163.com&gt;</span><br><span class="line">Date:   Tue Feb 7 14:30:11 2017 +0800</span><br><span class="line"></span><br><span class="line">change 2</span><br><span class="line"></span><br><span class="line">commit 99f733644454644d90b8ee39c6737dc283c78cec</span><br><span class="line">Author: gcl &lt;155@163.com&gt;</span><br><span class="line">Date:   Tue Feb 7 14:27:55 2017 +0800</span><br><span class="line"></span><br><span class="line">change readme.txt</span><br><span class="line"></span><br><span class="line">commit 58110376e350d36c8df095b17ff2ecb44906eae2</span><br><span class="line">Author: gcl &lt;155@163.com&gt;</span><br><span class="line">Date:   Tue Feb 7 14:25:17 2017 +0800</span><br><span class="line"></span><br><span class="line">add readme.txt</span><br></pre></td></tr></table></figure><h3 id="简化版本信息"><a href="#简化版本信息" class="headerlink" title="简化版本信息"></a>简化版本信息</h3><blockquote><p>$ git log –pretty=oneline<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">acbcfcfa48c89deb725aae9e03a68a2f5abaa1d4 change 2</span><br><span class="line">99f733644454644d90b8ee39c6737dc283c78cec change readme.txt</span><br><span class="line">58110376e350d36c8df095b17ff2ecb44906eae2 add readme.txt</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="查看命令历史"><a href="#查看命令历史" class="headerlink" title="查看命令历史"></a>查看命令历史</h3><blockquote><p>$ git reflog<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">acbcfcf HEAD@&#123;0&#125;: reset: moving to acbcfcfa4</span><br><span class="line">99f7336 HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">acbcfcf HEAD@&#123;2&#125;: commit: change 2</span><br><span class="line">99f7336 HEAD@&#123;3&#125;: commit: change readme.txt</span><br><span class="line">5811037 HEAD@&#123;4&#125;: commit (initial): add readme.txt</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="回退版本"><a href="#回退版本" class="headerlink" title="回退版本"></a>回退版本</h2><p>HEAD指向当前版本，<code>HEAD^</code>是上一版本，<code>HEAD^^</code>是上上版本，<code>HEAD~100</code>是上100个版本<br><code>--hard</code>是强制抹除修改，未提交的修改会丢失。<br>git reset –hard <strong><em>慎重使用</em></strong><br><code>--mixed</code>是保存修改，相当于重新提交。</p><h3 id="回到上一版本"><a href="#回到上一版本" class="headerlink" title="回到上一版本"></a>回到上一版本</h3><blockquote><p>$ git reset –hard HEAD^  </p></blockquote><h3 id="回到某一历史"><a href="#回到某一历史" class="headerlink" title="回到某一历史"></a>回到某一历史</h3><blockquote><p>$ git reset –hard commitid</p></blockquote><h2 id="工作区与暂存区"><a href="#工作区与暂存区" class="headerlink" title="工作区与暂存区"></a>工作区与暂存区</h2><ul><li><code>respository文件夹</code>：工作区</li><li><code>.git</code>：版本库，包含了stage（暂存区），分支master，指针HEAD</li><li><code>git add</code>是把文件修改放到了暂存区，<code>git commit</code>把暂存区的内容提交到了分支，没有提交到暂存区的修改是不会被提交到分支的<br>提交的事件线：<code>工作区-&gt;git add-&gt;暂存区-&gt;git commit-&gt;分支</code></li></ul><h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><p><code>git管理的是修改，而不是文件</code></p><ul><li>清空工作区的修改，回到最近一次git commit或git add时的状态（用版本库的版本替换工作区的版本）：git checkout – readme.txt （注意：git checkout 是切换分支命令）</li><li>撤销add后，commit前在暂存区的修改，将暂存区的修改放回工作区：git reset HEAD readme.txt（注意：reset可以回退版本，还可以撤销add到暂存区的内容，回退到工作区，如果要撤销在工作区的修改，可以再次checkout – file）</li><li>撤销commit之后，push之前：版本回退，git reset</li><li>git push：无法撤销</li></ul><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><h3 id="确定删除"><a href="#确定删除" class="headerlink" title="确定删除"></a>确定删除</h3><blockquote><p>git rm filename<br>git commit</p></blockquote><h3 id="撤销删除，找回文件"><a href="#撤销删除，找回文件" class="headerlink" title="撤销删除，找回文件"></a>撤销删除，找回文件</h3><blockquote><p>git checkout – filename<br>注意：<code>git checkout</code>是使用版本库中的最新版本替换工作区的版本，即撤销git add/rm之前的修改</p></blockquote><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><ul><li>本地库master与远程库origin关联，origin为远程库的默认叫法<blockquote><p>$ git remote add origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:XXX/learngit.git（XXX为你的github账户名）</p></blockquote></li><li>将本地库中的所有内容推送到远程库中，加上-u将本地master分支和远程origin分支关联起来，以后推送就可以直接使用git push简化命令<blockquote><p>$ git push -u origin master</p></blockquote></li><li>以后推送使用以下命令<blockquote><p>$ git push origin master</p></blockquote></li><li>把远程库克隆到本地,使用https速度慢，而且每次都要输入口令<blockquote><p>$ git clone ssh或https</p></blockquote></li><li>push与pull<ul><li>push：本地 –&gt; 远程，如果本地超前远程，需要push</li><li>pull：本地 &lt;– 远程，如果本地落后远程，需要pull </li></ul></li></ul><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p><code>HEAD指向当前分支--master分支，master指向最新提交</code></p><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><ul><li>创建分支<br>将当前分支中的所有文件拷贝到新分支<blockquote><p>$ git branch second</p></blockquote></li><li>切换到分支  <blockquote><p>$ git checkout second</p></blockquote></li><li>创建+切换到分支  <blockquote><p>$ git checkout -b second</p></blockquote></li><li>查看当前分支  <blockquote><p>$ git branch</p></blockquote></li></ul><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><ul><li>合并指定分支到当前分支(主分支)  <blockquote><p>$ git branch master<br>$ git merge second</p></blockquote></li><li>撤销合并操作  <blockquote><p>$ git reset</p></blockquote></li><li>合并模式  <ul><li>”fast forward”模式：合并分支默认使用”fast forward”模式，删除分支会丢掉分支信息，合并后看不出做过合并</li><li>普通模式：禁用”fast forward” 使用普通模式，合并后的历史可以看出曾经做过合并，在merge时生成一个新的commit。<br>禁用”fast forward”并且加上了commit描述：<blockquote><p>$ git merge –no-ff -m “merge with no-ff” second</p></blockquote></li></ul></li><li><p>如果出现冲突:git status-&gt;修改冲突-&gt;git add-&gt;git commit</p></li><li><p>git rebase origin master<br>如果出现冲突:git status-&gt;修改冲突-&gt;git add-&gt;<code>git rebase --continue</code></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git merge：用于合并分支</span><br><span class="line">git rebase：用于合并commit</span><br><span class="line">git fetch：用于更新所有分支状态，如远程仓库已添加一个分支，可通过git fetch -p将新分支拉取下来</span><br><span class="line">git pull：用于取回远程主机分支的更新</span><br><span class="line">git pull = git fetch ＋ git merge</span><br></pre></td></tr></table></figure><p>git rebase：会把本分支的commits顶到最顶端，比如合并feature分支到master上，会把整个 feature 分支移动到 master 分支的后面，有效地把所有 master 分支上新的提交并入过来。但是，rebase 为原分支上每一个提交创建一个新的提交，重写了项目历史，并且不会带来合并提交。<br>rebase最大的好处是你的项目历史会非常整洁。首先，它不像 git merge 那样引入不必要的合并提交。其次，如上图所示，rebase 导致最后的项目历史呈现出完美的线性——你可以从项目终点到起点浏览而不需要任何的 fork。这让你更容易使用 git log、git bisect 和 gitk 来查看项目历史。</p><h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><blockquote><p>$ git log  </p><ul><li>查看分支合并图<br>$ git log –graph<br>$ git log –graph –pretty=oneline –abbrev-commit</li></ul></blockquote><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><blockquote><p>$ git branch -d second<br>$ git branch -D second：强行删除一个没有合并过的分支<br>$ git push origin –delete second 删除远程分支</p></blockquote><h3 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h3><p>本地分支：master，dev，bug，feature<br>远程分支：origin，dev<br><img src="/assets/20170303_git/branch.png" alt="“插入图片”"> </p><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><ul><li>查看冲突<blockquote><p>$ git status</p></blockquote></li><li>查看分支合并图 git log –graph<blockquote><p>$ git log –graph –pretty=oneline –abbrev-commit</p></blockquote></li><li>解决冲突<br>合并分支发生冲突后，解决冲突步骤：查看冲突-&gt;修改-&gt;提交-&gt;合并完成</li></ul><h3 id="bug分支"><a href="#bug分支" class="headerlink" title="bug分支"></a>bug分支</h3><p>将当前无法提交到现场先保存起来，使工作区恢复clean状态，修复bug后，再将保存的东西解开</p><ul><li>将工作现场先保存起来：git stash</li><li>查看保存现场记录：git stash list</li><li>恢复工作线程<ul><li>git stash apply ：stash内容不删除，需要使用git stash drop手动删除</li><li>git stash pop：恢复的同时将stash的内容删除</li><li>git stash apply stash@{0}：有多个stah时，指定恢复到某个stash</li></ul></li></ul><h3 id="feature分支"><a href="#feature分支" class="headerlink" title="feature分支"></a>feature分支</h3><p>新添加功能时创建feature分支，开发完成合并到主分支，最好在开发新功能时为每一个新功能创建一个分支</p><h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><h4 id="查看远程库"><a href="#查看远程库" class="headerlink" title="查看远程库"></a>查看远程库</h4><ul><li>查看远程库的信息<blockquote><p>$ git remote</p></blockquote></li><li>查看远程分支详细信息<blockquote><p>$ git remote -v</p></blockquote></li></ul><h4 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h4><p>将本地某个分支中的所有提交推送到远程库</p><blockquote><p>$ git push origin master<br>一般只推送master和dev分支，其他可以在本地放着</p></blockquote><h4 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h4><p>创建本地dev分支：</p><blockquote><p>$ git checkout -b dev origin/dev</p><ul><li>git pull提示“no tracking information”,设置dev和origin/dev的链接：<br>$ git branch –set-upstream dev origin/dev<br>$ git pull<br>$ git add/commit/push</li></ul></blockquote><ul><li>注意：如果git pull时提示“no tracking information”，则需要指定本地master/dev分支与远程origin/dev分支的链接后，才能pull<blockquote><p>$ git branch –set-upstream dev origin/dev  已弃用<br>$ git branch –set-upstream-to=origin/dev dev  最新用法</p></blockquote></li></ul><h4 id="多⼈人协作的⼯工作模式"><a href="#多⼈人协作的⼯工作模式" class="headerlink" title="多⼈人协作的⼯工作模式:"></a>多⼈人协作的⼯工作模式:</h4><p>（1）git push origin branch-name<br>（2）如果推送失败,则因为远程分⽀支⽐比你的本地更新,需要先⽤用git pull试图合并;<br>（3）如果合并有冲突,则解决冲突,并在本地提交;<br>（4）没有冲突或者解决掉冲突后,再⽤用git push origin branch-name推送就能成功! </p><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><h3 id="添加标签"><a href="#添加标签" class="headerlink" title="添加标签"></a>添加标签</h3><ul><li>添加标签<blockquote><p>$ git tag v1.0</p></blockquote></li><li>补加标签<blockquote><p>$ git log –pretty=oneline –abbrev-commit<br>$ git tag v0.9 commitid</p></blockquote></li><li>添加说明<br>用<code>-a</code>指定标签名，<code>-m</code>指定说明文字：<blockquote><p>$ git tag -a v0.1 -m “version 0.1 released” 3628164</p></blockquote></li><li>私钥签名标签<blockquote><p>$ git tag -s v0.2 -m “signed version 0.2 released” fec145a</p></blockquote></li></ul><h3 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a>查看标签</h3><ul><li>查看所有标签<blockquote><p>$ git tag</p></blockquote></li><li>查看标签信息<blockquote><p>$ git show v0.9<br><code>注意，标签不是按时间顺序列出，而是按字母排序的。</code></p></blockquote></li></ul><h3 id="推送标签"><a href="#推送标签" class="headerlink" title="推送标签"></a>推送标签</h3><ul><li>推送某一标签<blockquote><p>$ git push origin v1.0</p></blockquote></li><li>推送本地所有未推送标签<blockquote><p>$ git push origin –tags</p></blockquote></li></ul><h3 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h3><ul><li>删除本地标签<blockquote><p>$ git tag -d v1.0</p></blockquote></li><li>删除远程标签<ul><li>需要先删除本地标签：<blockquote><p>$ git tag -d v1.0</p></blockquote></li><li>推送到远程：<blockquote><p>$ git push origin :refs/tags/v1.0</p></blockquote></li></ul></li></ul><h2 id="github使用"><a href="#github使用" class="headerlink" title="github使用"></a>github使用</h2><h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;xxxxx@xxxxx.com&quot;</span><br><span class="line"># Creates a new ssh key using the provided email</span><br><span class="line"># Generating public/private rsa key pair...</span><br><span class="line">$ cat ~/.ssh/id_rsa.pub</span><br><span class="line"># ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC6eNtGpNGwstc.... </span><br><span class="line">将public key添加</span><br><span class="line">$ ssh -T git@github.com （github）</span><br><span class="line">ssh -T git@git.oschina.net (oschina)</span><br><span class="line">Welcome to Git@OSC, yourname!</span><br></pre></td></tr></table></figure><h3 id="为开源仓库贡献代码"><a href="#为开源仓库贡献代码" class="headerlink" title="为开源仓库贡献代码"></a>为开源仓库贡献代码</h3><h4 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h4><p>在GitHub上，可以任意Fork开源仓库</p><h4 id="提交修改"><a href="#提交修改" class="headerlink" title="提交修改"></a>提交修改</h4><p>自己拥有Fork后的仓库的读写权限，从自己帐号克隆仓库，然后提交到自己的仓库</p><h4 id="pull-request"><a href="#pull-request" class="headerlink" title="pull request"></a>pull request</h4><p>请求官方接受修改</p><h2 id="自定义git"><a href="#自定义git" class="headerlink" title="自定义git"></a>自定义git</h2><h3 id="配置用户名和email"><a href="#配置用户名和email" class="headerlink" title="配置用户名和email"></a>配置用户名和email</h3><p>如果遇到以下问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*** Please tell me who you are.</span><br><span class="line"></span><br><span class="line">Run</span><br><span class="line"></span><br><span class="line">git config --global user.email &quot;you@example.com&quot;</span><br><span class="line">git config --global user.name &quot;Your Name&quot;</span><br><span class="line"></span><br><span class="line">to set your account&apos;s default identity.</span><br><span class="line">Omit --global to set the identity only in this repository.</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;fatal: unable to auto-detect email address (got &apos;xxx@xxx.(none)&apos;)</span><br></pre></td></tr></table></figure></p><p>需要配置<code>用户名</code>和<code>邮箱</code>：</p><blockquote><p>$ git config –global user.name “Your Name”<br>$ git config –global user.email “<a href="mailto:email@example.com" target="_blank" rel="noopener">email@example.com</a>“</p></blockquote><h3 id="给git命令添加颜色"><a href="#给git命令添加颜色" class="headerlink" title="给git命令添加颜色"></a>给git命令添加颜色</h3><blockquote><p>$ git config –global color.ui true</p></blockquote><h3 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h3><ul><li>忽略文件的原则<ul><li>忽略操作系统自动生成的文件，比如缩略图等；</li><li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；</li><li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li></ul></li><li>强制添加被忽略的文件<blockquote><p>$ git add -f App.class </p></blockquote></li></ul><p>查看想添加的文件被.gitignore中的哪条规则忽略了  </p><blockquote><p>$ git check-ignore -v App.class </p></blockquote><p>注意：.gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理</p><h3 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h3><blockquote><p>$ git config –global alias.st status<br>$ git config –global alias.co checkout<br>$ git config –global alias.ci commit<br>$ git config –global alias.br branch<br>$ git config –global alias.unstage ‘reset HEAD’<br>$ git config –global alias.last ‘log -1’<br>$ git config –global alias.lg “log –color –graph –</p></blockquote><p>注意：<code>--global</code>是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>每个仓库的Git配置文件都放在.git/config文件中，查看配置文件</p><blockquote><p>$ cat .git/config<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">repositoryformatversion = 0</span><br><span class="line">filemode = false</span><br><span class="line">bare = false</span><br><span class="line">logallrefupdates = true</span><br><span class="line">symlinks = false</span><br><span class="line">ignorecase = true</span><br><span class="line">hideDotFiles = dotGitOnly</span><br><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">url = git@xxx</span><br><span class="line">fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[branch &quot;master&quot;]</span><br><span class="line">remote = origin</span><br><span class="line">merge = refs/heads/master</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>$ cat ~/gitconfig<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">email = xxx</span><br><span class="line">name = xxx</span><br><span class="line">[color]</span><br><span class="line">ui = true</span><br><span class="line">[alias]</span><br><span class="line">st = status</span><br><span class="line">co = checkout</span><br><span class="line">br = branch</span><br><span class="line">[gui]</span><br><span class="line">encoding = gbk</span><br></pre></td></tr></table></figure></p></blockquote><p>要删除别名，直接把对应的行删掉即可<br>改错了，可以删掉文件重新通过命令配置</p><h2 id="自己搭建git服务器"><a href="#自己搭建git服务器" class="headerlink" title="自己搭建git服务器"></a>自己搭建git服务器</h2><p>（1）安装git<br>sudo apt-get install git<br>（2）创建一个git用户，用来运行git服务<br>sudo adduser git<br>（3）创建证书登录<br>收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个<br>（4）初始化Git仓库<br>sudo chown -R git:git sample.git<br>（5）禁用shell登录<br>出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：<br>git:x:1001:1001:,,,:/home/git:/bin/bash<br>改为：<br>　git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell<br>这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。<br>（6）克隆远程仓库<br>git clone git@server:/srv/sample.git<br>（7）要方便管理公钥，用Gitosis；<br>　　要像SVN那样变态地控制权限，用Gitolite。</p><h2 id="安装可视化工具gitk"><a href="#安装可视化工具gitk" class="headerlink" title="安装可视化工具gitk"></a>安装可视化工具gitk</h2><p>gitk是需要tcl/tk支持的，所以安装gitk之前必须安装tcl/tk。<br>tcl/tk下载：<a href="http://www.tcl.tk/software/tcltk/download.html" target="_blank" rel="noopener">http://www.tcl.tk/software/tcltk/download.html</a></p><h2 id="git命令汇总"><a href="#git命令汇总" class="headerlink" title="git命令汇总"></a>git命令汇总</h2><p>git init </p><p>git add<br>git commit<br>git rm<br>git status</p><p>git diff<br>git log (–pretty=oneling)<br>git reflog</p><p>git checkout – filename<br>git reset HEAD filename<br>git reset –hard HEAD^(commitid)</p><p>git add remote origin git/https<br>git push/pull/clone</p><p>git branch second<br>git checkout second<br>git checkout -b second<br>git branch<br>git branch -d second<br>git log –graph –pretty=oneline –abbrev-commit</p><p>git stash<br>git stash list<br>git stash apply<br>git stash drop<br>git stash pop<br>git stash apply stash@{0}</p><p>git remote -v<br>git checkout -b dev origin/dev<br>git branch –set-upstream-to=origin/dev dev<br>git pull</p><p>git tag name<br>git tag tagname commitid<br>git tag -a tagname -m “description”<br>git tag<br>git show tagname<br>git push origin tagname<br>git push origin –tags<br>git tag -d tagname<br>git push origin :refs/tags/tagname</p><p>ssh-keygen -t rsa -C “<a href="mailto:xxxxx@xxxxx.com" target="_blank" rel="noopener">xxxxx@xxxxx.com</a>“<br>cat ~/.ssh/id_rsa.pub<br>ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a> （github）</p><p>git add -f App.class</p><p>git config user.name “username”<br>git config user.email “email”<br>git config –global alias.st status</p><p><a href="http://git-scm.com" target="_blank" rel="noopener">Git的官方网站</a></p><p>本文为阅读廖雪峰的官方网站中的git教程的学习笔记，仅为自己的一点学习记录，原文写的非常好，作者很厉害，有兴趣的朋友可以阅读原文：<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" title="廖雪峰的官方网站的git教程" target="_blank" rel="noopener">廖雪峰的官方网站的git教程</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Markdown学习笔记</title>
      <link href="/2017/02/19/Markdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/02/19/Markdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="1-换行符：-一行结束时输入两个空格"><a href="#1-换行符：-一行结束时输入两个空格" class="headerlink" title="1.换行符： 一行结束时输入两个空格"></a>1.换行符： 一行结束时输入两个空格</h3><blockquote><p>line1<br>line2  </p></blockquote><a id="more"></a><h3 id="2-段落：-段落之间空一行"><a href="#2-段落：-段落之间空一行" class="headerlink" title="2.段落： 段落之间空一行"></a>2.段落： 段落之间空一行</h3><blockquote><p>p1</p></blockquote><blockquote><p>p2<br>p3  </p></blockquote><h3 id="3-标题："><a href="#3-标题：" class="headerlink" title="3.标题："></a>3.标题：</h3><ul><li>（1）Setext形式：= 大标题 - 中标题  </li><li>（2）atx形式：#  <blockquote><h1 id="大标题"><a href="#大标题" class="headerlink" title="大标题"></a>大标题</h1><h2 id="中标题"><a href="#中标题" class="headerlink" title="中标题"></a>中标题</h2><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3></blockquote></li></ul><blockquote><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6></blockquote><blockquote><p><strong>（1）A</strong><br><strong>（2）B</strong><br><strong>（3）C</strong></p></blockquote><h3 id="4-区块引用："><a href="#4-区块引用：" class="headerlink" title="4.区块引用：>"></a>4.区块引用：></h3><blockquote><p>区块1</p><blockquote><p>区块2</p><blockquote><p>区块3  </p></blockquote></blockquote></blockquote><h3 id="5-列表：-前后加空格，tab键或四个空格可分级"><a href="#5-列表：-前后加空格，tab键或四个空格可分级" class="headerlink" title="5.列表：*/+/-  前后加空格，tab键或四个空格可分级"></a>5.列表：*/+/-  前后加空格，tab键或四个空格可分级</h3><blockquote><ul><li>列表1<ul><li>列表2<ul><li>列表3  </li></ul></li></ul></li></ul></blockquote><h3 id="6-斜体、粗体、删除线"><a href="#6-斜体、粗体、删除线" class="headerlink" title="6.斜体、粗体、删除线"></a>6.斜体、粗体、删除线</h3><p>斜体：<code>*斜体*</code>   <em>斜体</em><br>粗体：<code>**斜体**</code>   <strong>粗体</strong><br>粗斜体：<code>***斜体***</code>   <strong><em>粗斜体</em></strong><br>删除线：<code>~~删除线~~</code>   <del>删除线</del></p><h3 id="7-内嵌代码：-内嵌代码-内嵌代码"><a href="#7-内嵌代码：-内嵌代码-内嵌代码" class="headerlink" title="7.内嵌代码：` 内嵌代码 `  内嵌代码"></a>7.内嵌代码：` 内嵌代码 `  <code>内嵌代码</code></h3><h3 id="8-水平线：——"><a href="#8-水平线：——" class="headerlink" title="8.水平线：——"></a>8.水平线：——</h3><blockquote><hr></blockquote><h3 id="9-链接："><a href="#9-链接：" class="headerlink" title="9.链接："></a>9.链接：</h3><ul><li>[文字]（url title）</li><li>![]（图片 title）<blockquote><p><a href="http://www.baidu.com" title="百度一下" target="_blank" rel="noopener">百度一下-你就知道</a><br><img src="baidu.png" alt="百度" title="百度图片"></p></blockquote></li></ul><h3 id="10-注意：反斜杠-实现转义效果"><a href="#10-注意：反斜杠-实现转义效果" class="headerlink" title="10.注意：反斜杠\实现转义效果"></a>10.注意：反斜杠\实现转义效果</h3><h3 id="11-表格"><a href="#11-表格" class="headerlink" title="11.表格"></a>11.表格</h3><ul><li>第一行为表头，第二行分割表头和主体，第三行开始每一行代表一个表格行</li><li>列与列之间用管道符号 “|” 隔开</li><li>居中对齐，<code>-</code>两边加<code>:</code> ； 居右对齐，<code>-</code>右侧加<code>:</code></li><li><code>注意：</code>如果表格不显示，表格的第一行与上面的内容之间要隔开，换行试试。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| title1 | title2 |   title3  |</span><br><span class="line">|--------|:------:|----------:|</span><br><span class="line">|   a    |   aa   |    aaa    |</span><br><span class="line">|   b    |   bb   |    bbb    |</span><br><span class="line">|   c    |   cc   |    ccc    |</span><br></pre></td></tr></table></figure><table><thead><tr><th>title1</th><th style="text-align:center">title2</th><th style="text-align:right">title3</th></tr></thead><tbody><tr><td>a</td><td style="text-align:center">aa</td><td style="text-align:right">aaa</td></tr><tr><td>b</td><td style="text-align:center">bb</td><td style="text-align:right">bbb</td></tr><tr><td>c</td><td style="text-align:center">cc</td><td style="text-align:right">ccc</td></tr></tbody></table><h2 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h2><ul><li>文档的文件名不得含有空格。</li><li>文件名必须使用半角字符，不得使用全角字符。这也意味着，中文不能用于文件名。</li><li>文件名建议只使用小写字母，不使用大写字母。</li><li>为了醒目，某些说明文件的文件名，可以使用大写字母，比如README、LICENSE。</li><li>文件名包含多个单词时，单词之间建议使用半角的连词线（-）分隔。</li></ul><p>参考文章：<a href="https://www.appinn.com/markdown/basic.html" target="_blank" rel="noopener">Markdown: Basics （快速入门）</a><br><a href="中文技术文档规范">https://github.com/Luis-X/Blog/issues/2</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo创建个人博客记录</title>
      <link href="/2017/02/18/hexo%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/"/>
      <url>/2017/02/18/hexo%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h2><h3 id="1-安装hexo"><a href="#1-安装hexo" class="headerlink" title="1.安装hexo"></a>1.安装hexo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo npm install -g hexo</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2.初始化"></a>2.初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure><h3 id="3-生成静态页面"><a href="#3-生成静态页面" class="headerlink" title="3.生成静态页面"></a>3.生成静态页面</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate（hexo g也可以）</span><br></pre></td></tr></table></figure><h3 id="4-启动本地服务，进行文章预览调试-浏览器输入http-localhost-4000即可"><a href="#4-启动本地服务，进行文章预览调试-浏览器输入http-localhost-4000即可" class="headerlink" title="4.启动本地服务，进行文章预览调试,浏览器输入http://localhost:4000即可"></a>4.启动本地服务，进行文章预览调试,浏览器输入<a href="http://localhost:4000即可" target="_blank" rel="noopener">http://localhost:4000即可</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server（hexo s也可以）</span><br></pre></td></tr></table></figure><h3 id="5-发布配置"><a href="#5-发布配置" class="headerlink" title="5.发布配置"></a>5.发布配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy（hexo d也可以）</span><br></pre></td></tr></table></figure><p><code>deploy</code>之前进行<code>build</code>，可以对博客进行优化，提高网站访问速度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gulp build     //压缩js、css、img文件</span><br></pre></td></tr></table></figure></p><p>每次部署的步骤，可按以下三步来进行: <code>hexo clean</code>，<code>hexo generate</code>，<code>hexo deploy</code>，或者 <code>hexo d -g</code></p><h3 id="6-新建文章"><a href="#6-新建文章" class="headerlink" title="6.新建文章"></a>6.新建文章</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new &quot;postName&quot;</span><br></pre></td></tr></table></figure><h3 id="7-新建页面"><a href="#7-新建页面" class="headerlink" title="7.新建页面"></a>7.新建页面</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page &quot;pageName&quot;</span><br></pre></td></tr></table></figure><h3 id="8-添加统计数据"><a href="#8-添加统计数据" class="headerlink" title="8.添加统计数据"></a>8.添加统计数据</h3><p>在themes/yilia/layout/_partial/footer.ejs文件<code>&lt;style&gt;</code>上添加以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;</span><br></pre></td></tr></table></figure></p><p><code>&lt;style&gt;</code>下添加以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次</span><br><span class="line">本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次</span><br><span class="line">本文总阅读量&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次</span><br></pre></td></tr></table></figure></p><h2 id="hexo填坑历程"><a href="#hexo填坑历程" class="headerlink" title="hexo填坑历程"></a>hexo填坑历程</h2><p>(1)坑一：hexo命令找不到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR Local hexo not found in E:\blog</span><br><span class="line">ERROR Try running: &apos;npm install hexo --save&apos;</span><br></pre></td></tr></table></figure></p><p>解决：按照提示输入<code>npm install hexo --save</code>，如果不可以，可能是：<br>因为安装包中有些内容在墙外，所以可以换淘宝源，或者用</p><blockquote><p>$ npm install -g hexo-cli –no-optional(<strong>很重要</strong>)<br>有时候只写<code>npm install --no-optional</code>也不行，只能以上命令</p></blockquote><p>如果还是不可以，可能是由于：<br>.gitignore文件里面忽略了node_modules文件夹，所以这个文件夹没有更新上去。所以用npm重新安装即可，输入以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ...\blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure></p><p>(2)坑二：ERROR Deployer not found: git</p><blockquote><p>$ npm install hexo-deployer-git –save<br>然后重新 deploy 即可</p></blockquote><p>(3)坑三：hexo deploy成功，但是页面不显示<br>解决：<br>到仓库下的settings下修改GitHub Pages，source选择master分支，显示 <code>Your site is published at https://XXX.github.io/</code>即可</p><p>(4)坑四：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fatal: Not a git repository (or any of the parent directories): .git</span><br><span class="line">FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span><br><span class="line">Error: fatal: Not a git repository (or any of the parent directories): .git</span><br></pre></td></tr></table></figure></p><p>解决：<br>检查_config.yml文件deploy的配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type: git</span><br><span class="line">repo: https://github.com/XXX/XXX.github.io.git</span><br></pre></td></tr></table></figure></p><p>如果还是不可以，请看下一解决方案。</p><p>(5)坑五：Permission to  XXX.github.io.git denied<br>解决：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;yourname&quot;</span><br><span class="line">$ git config --global user.email &quot;youremail&quot;</span><br></pre></td></tr></table></figure></p><p>如果以上做完还是出不来，删掉根目录下的文件夹：.deploy_git，重新deploy就可以了。</p><ul><li>添加动态背景效果代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;</span><br><span class="line">color=&quot;0,0,255&quot; opacity=&apos;0.7&apos; zIndex=&quot;-2&quot; count=&quot;99&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><p>(6)inunpopulatedsubmodule’.deploy_git’<br>解决：<br>先安装下相关的依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git –save</span><br></pre></td></tr></table></figure></p><p>实在不行，就把它删掉，然后重新生成和部署。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls -a</span><br><span class="line">rm -rf .deploy_git</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></p><p><a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html#fn:2" target="_blank" rel="noopener">打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS国际化学习笔记</title>
      <link href="/2016/12/19/iOS%E5%9B%BD%E9%99%85%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2016/12/19/iOS%E5%9B%BD%E9%99%85%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="配置需要国际化的语言"><a href="#配置需要国际化的语言" class="headerlink" title="配置需要国际化的语言"></a>配置需要国际化的语言</h2><p>project-&gt;Info-&gt;Localizations 添加本地化语言包<br><a id="more"></a></p><h2 id="App名称本地化"><a href="#App名称本地化" class="headerlink" title="App名称本地化"></a>App名称本地化</h2><p>(1)创建<code>InfoPlist.string</code>文件，Xcode的<code>File inspection</code>中<code>Localize</code>选择需要本地化的语言<br>(2)在不同语言InfoPlist.strings对应文件中添加应用名称</p><ul><li><p>InfoPlist.strings(English)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//App在英语环境下显示的名称</span><br><span class="line">CFBundleDisplayName = &quot;AppName&quot;;</span><br></pre></td></tr></table></figure></li><li><p>InfoPlist.strings(Chinese)<br>CFBundleDisplayName = “应用名称”;</p></li></ul><p>(3)info.plist添加<code>Application has localized display name</code>，值为YES</p><h2 id="代码中字符串本地化"><a href="#代码中字符串本地化" class="headerlink" title="代码中字符串本地化"></a>代码中字符串本地化</h2><p>(1)创建<code>Localizable.strings</code>文件，Xcode的<code>File inspection</code>中<code>Localize</code>选择需要本地化的语言<br>(2)以KeyValue的形式，为代码中每一个需要本地化的字符串赋值</p><ul><li><p>Localizable.strings(English)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;hello&quot; = &quot;Hello!&quot;;</span><br></pre></td></tr></table></figure></li><li><p>Localizable.strings(Chinese)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;hello&quot; = &quot;你好&quot;;</span><br></pre></td></tr></table></figure></li></ul><p>(3)使用Foundation框架自带的NSLocalizedString(key, comment)这个宏根据Key获取对应字符串<br>NSlocalizeString 第一个参数key是内容,根据key去对应语言的文件中获取对应的字符串，如果没有找到，那么就会以key作为value返回，第二个参数将会转化为字符串文件里的注释。</p><p>#define NSLocalizedString(key, comment) [[NSBundle mainBundle] localizedStringForKey:(key) value:@”” table:nil]</p><h2 id="多人开发情况下的字符串本地化"><a href="#多人开发情况下的字符串本地化" class="headerlink" title="多人开发情况下的字符串本地化"></a>多人开发情况下的字符串本地化</h2><p>不在系统默认的本地化文件<code>Localizable.strings</code>中定义字符串，自定义strings文件储存本地化字符串，然后通过<code>NSLocalizedStringFromTable(\&lt;#key#\&gt;, &lt;#tbl#&gt;, &lt;#comment#&gt;)</code>获取。</p><ul><li>tbl：自定义strings文件的名称<h2 id="图片本地化（两种方式两种方式）"><a href="#图片本地化（两种方式两种方式）" class="headerlink" title="图片本地化（两种方式两种方式）"></a>图片本地化（两种方式两种方式）</h2>第一张方式：同获取本地化字符串方式获取图片名称进行加载<br>第二种方式：将图片本地化，选中图片，在Xcode的<code>File inspection</code>中<code>Localize</code>选择需要本地化的语言，项目目录中显示<code>service(English)</code>和<code>service(Chinese)</code>两张图片，分别替换为不同语言的两张图片，实际是存储在<code>en.lproj</code>和<code>zh-Hans.lproj</code>中同为<code>service.png</code>名称的两张图片。<br>两种方式同获取本地化字符串相同获取图片名称：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *imgName = NSLocalizedString(@&quot;service&quot;, nil);</span><br></pre></td></tr></table></figure></li></ul><h2 id="查看-切换本地语言"><a href="#查看-切换本地语言" class="headerlink" title="查看/切换本地语言"></a>查看/切换本地语言</h2><p>查看本地语言环境：从NSUserDefaults中获取key为<code>AppleLanguages</code>的value即为当前语言环境。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSArray *languages = [[NSUserDefaults standardUserDefaults] valueForKey:@&quot;AppleLanguages&quot;];</span><br><span class="line">NSString *currentLanguage = languages.firstObject;</span><br></pre></td></tr></table></figure></p><p>切换当前语言环境：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSArray *lans = @[@&quot;zh-Hans&quot;];</span><br><span class="line">[[NSUserDefaults standardUserDefaults] setObject:lans forKey:@&quot;AppleLanguages&quot;];</span><br></pre></td></tr></table></figure></p><blockquote><p>也可通过Edit Scheme-&gt;Run-&gt;Arguments Passed On Launch -&gt;-AppleLanguages (语言)改变语言环境</p></blockquote><p>原文链接：<a href="http://www.jianshu.com/p/88c1b65e3ddb" target="_blank" rel="noopener">3分钟实现iOS语言本地化/国际化（图文详解）</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 国际化 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
